(function () {
    'use strict';
    angular
        .module('HCTRAModule', [
        'ngFileUpload', 'ngRoute', 'ngAnimate',
        'infinite-scroll', 'ngMessages', 'ui.bootstrap', 'ngAria',
        'ngSanitize'
    ])
        .factory('sniffrjs', ['thirdPartyDowngrades', function (thirdPartyDowngrades) { return thirdPartyDowngrades.Sniffr; }])
        .factory('bowserjs', ['thirdPartyDowngrades', function (thirdPartyDowngrades) { return thirdPartyDowngrades.Bowser; }])
        .factory('momentjs', ['thirdPartyDowngrades', function (thirdPartyDowngrades) { return thirdPartyDowngrades.Moment; }])
        .factory('vimeoPlayer', ['thirdPartyDowngrades', function (thirdPartyDowngrades) { return thirdPartyDowngrades.Vimeo; }]);
})();
hctraMocks = {
    stringUtilsService: function () {
        return {
            getUrlParameter: function () { return ''; },
            getParameterArray: function (queryString) { return []; }
        };
    },
    broadcastSubmissionService: function () {
        return {
            broadcast: function () {
                return {
                    then: function (cb) {
                        cb();
                        return {
                            catch: function () { }
                        };
                    }
                };
            }
        };
    },
    dollarq: function () {
        return {
            defer: function () {
                return {
                    promise: "promise"
                };
            },
        };
    },
    rxjsService: function () {
        return {
            Rx: {
                Subject: function () { }
            }
        };
    },
    eprotectIframeClientService: function () {
        return {
            EprotectIframeClient: function (config) { }
        };
    },
    siteVerbiage: function () {
        return {
            genericErrorMsg: "generic error message"
        };
    },
    stateStackMemoryService: function () {
        return '';
    },
    $rootScope: function (previousState) {
        return {
            previousState: previousState
        };
    },
    fake$location: function (inLocation) {
        return inLocation;
    },
    $location: function (setUrl) {
        setUrl = setUrl || { value: "http://localhost" };
        return {
            protocol: function () {
                return "http";
            },
            port: function () {
                return 80;
            },
            url: function (inUrl) {
                setUrl.value = inUrl;
                if (setUrl.testUrl)
                    return setUrl.testUrl;
            },
            absUrl: function () {
                return "https://wdev-m.hctra.pri/Home";
            },
            search: function (parameter, value) {
                if (parameter) {
                    if (value === "") {
                        setUrl.deleteSuccess = true;
                    }
                }
                return {
                    id: "45DSGFTG7876GHH456HDWRS2",
                    categoryPath: setUrl.categoryPath,
                    articlePath: setUrl.articlePath,
                    token: setUrl.token
                };
            },
            host: function () {
                return "localhost";
            },
            hash: function () {
                if (setUrl.fromRates) {
                    return "Hardy Toll Road";
                }
                return "hashValue";
            },
            path: function () {
                if (setUrl.testPath)
                    return setUrl.testPath;
            },
            replace: function () {
                return '';
            },
            state: function () {
            }
        };
    },
    objectUtilService: function () {
        return {
            areEqual: function () {
                return;
            },
            deepCompare: function () {
                return;
            },
            clearShallowObject: function () {
                return;
            },
            toLowerCaseKeys: function (objIn) {
                return objIn;
            },
            toCapitalizedCaseKeys: function (objIn) {
                return objIn;
            },
            hasAnyOfKeysInList: function () {
                return;
            }
        };
    },
    javaObjectUtilService: function () {
        return {
            isEmpty: function () {
                return false;
            }
        };
    },
    fake$state: function (inState) {
        var state = inState;
        return state;
    },
    $state: function (inState) {
        var state = {
            go: function (toState, urlParams) {
                inState.value = toState;
                inState.params = urlParams;
            },
            is: function (currentState) {
                return true;
            },
            get: function (toState) {
                return [
                    {
                        url: '/Home',
                        name: 'Home',
                    }, {
                        url: '/AccountSummary',
                        name: 'AccountSummary',
                    }, {
                        url: '/ManageVehicles',
                        name: 'ManageVehicles',
                    }, {
                        url: '/TagReceipt',
                        name: 'TagReceipt',
                    }, {
                        url: '/Agreement',
                        name: 'CloseAccount.Agreement',
                    }, {
                        url: '/Refund',
                        name: 'CloseAccount.Refund',
                    }, {
                        url: '/CloseAccount/CheckInformation',
                        name: 'AccountInformationParent.CloseAccountCheck',
                    }, {
                        url: '/CloseAccount/CreditInformation',
                        name: 'AccountInformationParent.CloseAccountCredit',
                    }, {
                        url: '/CloseAccount/SaveBillingInformation',
                        name: 'AccountInformationParent.CloseAccountSaveBillingInformation',
                    }, {
                        url: '/Review',
                        name: 'CloseAccount.PendingReview',
                    },
                ];
            },
            $current: {
                name: "",
                settings: {}
            },
            current: {
                cms: {
                    path: '',
                    fields: '',
                    helpSupportTitlePath: '/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage'
                },
                name: inState ? inState.name : ""
            }
            //var stateList = [];
            //var mockStateNames = hctraMocks.stateNames();
            //var mockUrls = hctraMocks.routes();
            //angular.forEach(mockUrls, function (mu) {
            //	angular.forEach(mockStateNames, function (msn) {
            //		if (mu == msn) {
            //			var state = {};
            //			state.name = msn;
            //			state.url = mu;
            //			stateList.push(state);
            //		};
            //	});
            //});
            //return stateList;			
        };
        if (inState.statePath === 'ratesController') {
            state.current.cms.path = '/sitecore/content/HCTRA/TravelTools/RatesPage/TollRoadsSection';
        }
        return state;
    },
    countryConversionService: function () {
        return {
            countryNameToCode: function () {
                return;
            },
            countryCodeToName: function () {
                return;
            }
        };
    },
    authChannel: function (loginTouched) {
        return {
            logIn: function (response) {
                loginTouched.value = true;
                loginTouched.response = response;
            },
            onLogIn: function () { },
            logOut: function () {
                loginTouched.logout = true;
            },
            onlogOut: function () { }
        };
    },
    //    stateChangeStartChannel: function () {
    //        return {
    //            onStateChangeStart: function () { }
    //        };
    //    },
    operatingSystemSnifferService: function (osSnifferConfig) {
        return {
            getOs: function () { },
            getOS: function () { },
            isDesktopOs: function () { if (osSnifferConfig) {
                return osSnifferConfig.isDesktop;
            }
            else {
                return true;
            } },
            getOsFull: function () { return osSnifferConfig.osName; },
            getDeviceFull: function () { return osSnifferConfig.deviceName; }
        };
    },
    missedATollService: function () {
        return {
            destroyViolationInformation: function () {
                return;
            },
            saveStep: function (b) {
                return b;
            },
            saveViolationInformation: function (b) {
                return b;
            }
        };
    },
    stringCheckService: function () {
        return {
            isFloat: function (numberString) {
                if (numberString && !isNaN(parseFloat(numberString)) && isFinite(numberString)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        };
    },
    stringUtilsService: function () {
        return {
            getUrlParameter: function () { return ''; },
            getParameterObject: function (queryString) {
                //spyon
                return;
            },
            getParameterArray: function (queryString) { return []; }
        };
    },
    linkLookupService: function (linkLookupServiceObject) {
        return {
            cmsIdDictionary: linkLookupServiceObject,
            articleLookup: function (article) {
                linkLookupServiceObject.article = article;
                return linkLookupServiceObject.url;
            },
            articleLookupById: function () {
                if (linkLookupServiceObject) {
                    return linkLookupServiceObject.id;
                }
            }
        };
    },
    CurrentUser: function () {
        var user = { acctId: 0 };
        var fakeWebStorage = {};
        return {
            setCurrentUser: function () { angular.copy(fakeWebStorage, user); },
            getCurrentUser: function () { return angular.copy(fakeWebStorage); },
            updateCurrentUser: function (response) {
                if (response) {
                    angular.copy(response, fakeWebStorage);
                    angular.copy(fakeWebStorage, user);
                }
            },
            destroyCurrentUser: function () {
                user = { acctId: 0 };
                fakeWebStorage = { acctId: 0 };
            }
        };
    },
    cmsUtilService: function () {
        return {
            addDisplayDates: function () {
                return;
            },
            parseMediaId: function () {
                return;
            },
            generateFileSrc: function (b) {
                return b;
            },
            processItemId: function () {
                return;
            },
            getFileSrcPromise: function () {
                return;
            },
            generateFileSrcFromPromiseResponse: function () {
                return;
            },
            parseAltText: function (b) {
                return b;
            },
            parseCmsDate: function (b) {
                return new Date(Date.UTC(2016, 7, 10));
            },
            convertStartEndDates: function (b) {
                return b;
            },
            formatDisplayDates: function (b) {
                return "formatted string";
            },
            processArticleArray: function (b) {
                return b;
            }
        };
    },
    suspendedAccountService: function (inObject) {
        return {
            getFirstSuspendedAccountState: function () {
                return {
                    then: function (cb) {
                        cb("suspendedState");
                    }
                };
            },
            getBillingAmount: function () {
                return inObject.totalPayment;
            },
            saveStep: function () {
                return;
            },
            isEmpty: function () {
                return false;
            },
            destroySuspendedWizardInformation: function () { },
            saveBillingAmount: function () { },
            onPaymentCancel: function () { },
            onFirstFormEdit: function (scope, cb) {
                cb();
            },
            destroyPciInfo: function () { },
            setPciInfo: function () { }
        };
    },
    vehicleWizardDirectorService: function () {
        return {
            saveStepAndContinueToNextStep: function (currentState, action) {
                if (action === "DeleteCurrentVehicleWithNoVehiclesRemaining") {
                    return "DeleteCurrentVehicleWithNoVehiclesRemaining";
                }
                else if (action === "DeleteCurrentVehicleWithVehiclesRemaining") {
                    return "DeleteCurrentVehicleWithVehiclesRemaining";
                }
                else if ("DeleteVehicleWithNoVehiclesRemaining") {
                    return ("DeleteVehicleWithNoVehiclesRemaining");
                }
                else {
                    return ("");
                }
            },
            destroyVehicleWizardInformation: function () {
                return;
            },
            redirectToCorrectState: function (currentState) {
                return false;
            }
        };
    },
    responsiveService: function (setMobile) {
        return {
            isMobile: function () {
                return setMobile;
            },
            isDesktop: function () {
                return !setMobile;
            }
        };
    },
    environmentConfig: function () {
        return {
            accountActivityMaxDaysInSearch: 365,
            accountActivityTransactonsDefaultVehicleValue: "L",
            arcGisMapLink: 'http://google.com',
            rssConfig: {
                news: {
                    Path: "/content/HCTRA/Home/HomePage/NewsSection/NewsFeed",
                    Locations: ["inHomeNews", "inLatestNews"]
                },
                closures: {
                    Path: "/content/HCTRA/Home/HomePage/MajorClosuresSection/ClosuresFeed",
                    NeedsDate: true,
                    Locations: ["inHomeClosures"]
                },
                customClosures: {
                    Path: "/content/HCTRA/Home/HomePage/MajorClosuresSection/ClosuresFeed",
                    NeedsDate: true,
                    Locations: ["inMajorClosures"]
                }
            },
            vantivConfig: {
                PayPageID: 'payPageId',
                ReportGroup: 'reportGroup',
                TimeoutMilliSeconds: 'timeoutMilliSeconds',
                IFrameUrl: 'iframeUrl',
                IframeEnabled: true
            }
        };
    },
    loggingService: function () {
        return {
            logMessage: function (errorMessage, stackTrace, cause) {
                return {
                    errorMessage: errorMessage,
                    stackTrace: stackTrace,
                    cause: cause
                };
            }
        };
    },
    errorInterceptorService: function (errorMessageDictionary) {
        var _loggingEnabled = true;
        if (errorMessageDictionary == null) {
            errorMessageDictionary = {};
        }
        return {
            toggleFeature: function (messagesToSilence, loggingEnabled) {
                _loggingEnabled = loggingEnabled;
                messagesToSilence.forEach(function (element) { errorMessageDictionary[element] = false; });
                return errorMessageDictionary;
            },
            shouldMessageTriggerLogging: function (message) {
                return errorMessageDictionary[message] ? true : false;
            },
            shouldLoggingBeEnabled: function () {
                return _loggingEnabled ? true : false;
            }
        };
    },
    perfToggle: function () {
        return {};
    },
    serverConstants: function () {
        return {
            maintenanceKey: "",
            currentlyDownloadedWebUiVersion: "",
            appNameHeaderKey: "",
            appNameWebsiteMobileHeaderValue: "",
            appNameWebsiteDesktopHeaderValue: "",
            appNameWebsiteStorefrontHeaderValue: "",
            versionHeaderKey: "",
            latestWebUiVersionHeaderKey: ""
        };
    },
    hctraGlobalFromIndexCshtml: function () {
        return {
        //omnitureEnv: omnitureEnv
        };
    },
    $stateParams: function () {
        return {
            secq: 'What is your favorite color?'
        };
    },
    $timeout: function (inTimer) {
        return function (func, length) {
            inTimer.func = func;
            //console.log(typeof (length));
            if (typeof (length) === 'undefined') {
                inTimer.value = 0;
            }
            else {
                inTimer.value = length;
            }
            func();
        };
    },
    $anchorScroll: function (scrollTo) {
        return function (inScroll) {
            scrollTo.value = inScroll;
        };
    },
    $sce: function (inSce) {
        return {
            trustAsHtml: function (trustedHtml) {
                inSce.value = trustedHtml;
            }
        };
    },
    genericRepo: function (inData) {
        return {
            dataFactory: {
                eftValidateRouting: function () { },
                saveBillingInformation: function () {
                    return {
                        then: function (cb) {
                            cb(inData.value);
                        }
                    };
                },
                LogVantivRequest: function () { },
                LogVantivResponse: function () { },
                StartStorefrontDBSession: function () {
                    return {
                        then: function (cb) {
                            cb({
                                dbResponse: 12,
                                errors: [],
                            });
                        }
                    };
                },
                EndStorefrontDBSession: function () {
                    return {
                        then: function (cb) {
                            cb({
                                dbResponse: 12,
                                errors: [],
                            });
                        }
                    };
                },
                confirmAddTags: function () {
                    return {
                        then: function (cb) {
                            cb({ errors: [], alerts: [] });
                        }
                    };
                },
                getLandingData: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                                alerts: [],
                                states: [],
                                cmsResponse: '{"Title":"test","Children":[{"Title":"test","LongDescription":"test"},{"Title":"test","LongDescription":"test","Image":"test"}]}'
                            });
                        }
                    };
                },
                submitAccount: function () {
                    return {
                        then: function (cb) {
                            cb({
                                securityQuestionID: 4,
                                dbSessionId: "DFNHSETH356SRHSDRH",
                                loginId: "hellome",
                                securityQuestion: "What is life?",
                                acctId: 51651681,
                                emailAddress: "j@j.com",
                                errors: []
                            });
                        }
                    };
                },
                executeCmsPaging: function () {
                    return {
                        then: function (cb) {
                            cb({
                                numberOfPages: 5,
                                numberOfArticles: 500,
                                articles: [1, 2, 3, 6, 5, 4, 7],
                                errors: []
                            });
                        }
                    };
                },
                saveInformation: function (data) {
                    return {
                        then: function (cb) {
                            cb({
                                accountId: '12324',
                                accountActivity: 'A',
                                newAccountStep: {
                                    accountComplete: true
                                },
                                errors: [],
                                alerts: []
                            });
                        }
                    };
                },
                loadArchivePage: function () {
                    return {
                        then: function (cb) {
                            cb(inData.loadArchivePageData);
                        }
                    };
                },
                setupInvoicePage: function () {
                    return {
                        then: function (cb) {
                            cb({ invoiceDates: ["September 2015", "October 2015", "January 2016"], errors: [], alerts: [] });
                        }
                    };
                },
                checkMatEligibility: function () {
                    return {
                        then: function (cb) {
                            cb({
                                isUserEligible: true, listOfViolations: [
                                    {
                                        agency: "TEST",
                                        violationId: 123456,
                                        eventDateTime: new Date(),
                                        balance: 258,
                                        eventLocation: "test",
                                    }
                                ], serviceFee: 12.3, errors: [], alerts: [], lastMatPerformed: "10/10/2000"
                            });
                        }
                    };
                },
                getCmsPageById: function () {
                    return {
                        then: function (cb) {
                            cb({ cmsResponse: '{"test":"value","LongDescription":"test","ShortDescription":"ouch", "Children": "[1,2,3]", "Parameters": ""}', errors: [], alerts: [] });
                            return {
                                then: function (cb) { },
                                finally: function (cb) { cb; }
                            };
                        }
                    };
                },
                getCmsPagesByIds: function (req) {
                    return {
                        then: function (cb) {
                            cb({ responses: req.requests.map(function (x) { return ({ cmsResponse: '{"test":"value","LongDescription":"test","ShortDescription":"ouch", "Children": "[1,2,3]", "Parameters": ""}' }); }), errors: [], alerts: [] });
                            return {
                                then: function (cb) { },
                                finally: function (cb) { cb; }
                            };
                        }
                    };
                },
                getCmsPages: function (request) {
                    return {
                        then: function (cb) {
                            cb({ cmsResponse: '{"test":"value"}', errors: [], alerts: [] });
                        }
                    };
                },
                getMonthlyInvoice: function () {
                    return {
                        then: function (cb) {
                            cb({
                                records: [],
                                errors: []
                            });
                        }
                    };
                },
                getInvoice: function (inData) {
                    return {
                        then: function (cb) {
                            cb({
                                invoiceNumber: "2344928",
                                outstandingInvoices: [{ description: "Beginning Balance", amount: 34.78 }],
                                balSumBalanceRequirement: 344.21,
                                balSumCurrentBalance: 19.42,
                                balSumReplenishmentAmt: 476.47,
                                invoiceSummary: [],
                                address: {
                                    name: "Marc Harris"
                                },
                                phoneNumber: {
                                    homePhoneNumber: "423-336-7701"
                                },
                                errors: [],
                                alerts: []
                            });
                        }
                    };
                },
                oneTimePaymentGetBillingInfo: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                                balanceAmt: -125.36,
                                rebillAmt: 0.00
                            });
                        }
                    };
                },
                getSuspendedAccountData: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                                balanceAmt: -125.00,
                                rebillAmt: 20.00,
                                acctActivity: "S",
                                suspensionFlag: true,
                                violationFlag: false
                            });
                        }
                    };
                },
                setupReceipts: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                                receiptHeaders: [
                                    { date: "2015" },
                                    { date: "2016" },
                                    { date: "2017" }
                                ]
                            });
                        }
                    };
                },
                getAccountFromEzTag: function () {
                    return {
                        then: function (cb) {
                            cb({
                                acctId: 80051,
                                currentBalance: 50.50
                            });
                        }
                    };
                },
                calculateActivationFee: function () {
                    return {
                        then: function (cb) {
                            cb({
                                tagAmount: 20
                            });
                        }
                    };
                },
                submitEmail: function (data) {
                    data = JSON.parse(data);
                    if (data.test === "correct") {
                        return {
                            then: function (cb) {
                                cb({ emailAddress: 'somebody@gmasil.com', errors: [] });
                            }
                        };
                    }
                    else {
                        return {
                            then: function (cb) {
                                cb({ emailAddress: '', errors: ['Some error'] });
                            }
                        };
                    }
                },
                resetPassword: function (rpKey) {
                    if (rpKey === 'acctActivity') {
                        return {
                            then: function (cb) {
                                cb({ acctId: 999999, acctActivity: 'P', newAccountStep: { currentStep: 2 }, errors: [] });
                            }
                        };
                    }
                    else {
                        if (inData) {
                            inData.requestData = rpKey;
                        }
                        return {
                            then: function (cb) {
                                cb({ acctId: 999999, acctActivity: 'P', newAccountStep: { currentStep: 2 }, errors: [] });
                            }
                        };
                    }
                },
                getStates: function () {
                    return {
                        then: function (cb) {
                            cb({ states: ["TX", "OK", "LA"], errors: [] });
                        }
                    };
                },
                getTagAuthorities: function () {
                    return {
                        then: function (cb) {
                            cb({ authorities: ["HCTRA", "TEX"], errors: [] });
                        }
                    };
                },
                setupFpAccount: function () {
                    return {
                        then: function (cb) {
                            cb({ authorities: ["HCTRA", "TEX"], states: ["TX", "OK", "LA"], errors: [] });
                        }
                    };
                },
                getSecurityQuestions: function () {
                    return {
                        then: function (cb) {
                            cb({
                                securityQuestions: [{ securityQuestion: "What is your favorite color?", securityQuestionID: 1 },
                                    { securityQuestion: "What is your mother's middle name?", securityQuestionID: 2 },
                                    { securityQuestion: "Who is your doctor?", securityQuestionID: 3 }],
                                errors: []
                            });
                        }
                    };
                },
                submitSecurityAnswer: function (data) {
                    data = JSON.parse(data);
                    if (data.answer === "black") {
                        return {
                            then: function (cb) {
                                cb({ userId: 'TTC123', securityAnswer: 'whatupdude', errors: [] });
                            }
                        };
                    }
                    else {
                        return {
                            then: function (cb) {
                                cb({ userId: '', errors: ['Some error'] });
                            }
                        };
                    }
                },
                emailSecurityQuestion: function (inId) {
                    inId = JSON.parse(inId);
                    return {
                        then: function (cb) {
                            inData.value = inId.sentId;
                            cb({ securityQuestion: "What is your favorite color", acctId: 999999, securityQuestionId: 4, dbSessionId: '68168ARHARFHB64684', emailAddress: 'j@j.com', loginId: 'tset03', errors: [] });
                        }
                    };
                },
                submitAnswer: function (data) {
                    data = JSON.parse(data);
                    if (data.answer === "black") {
                        return {
                            then: function (cb) {
                                cb({ userId: 'TTC123', errors: [] });
                            }
                        };
                    }
                    else {
                        return {
                            then: function (cb) {
                                cb({ userId: '', errors: ['Some error'] });
                            }
                        };
                    }
                },
                getAccountInformation: function () {
                    return {
                        then: function (cb) {
                            cb({
                                billingInfo: {
                                    address: null,
                                    billingInfoExists: true,
                                    billingType: 0,
                                    billingTypeCode: "C",
                                    billingTypeDisplay: "CREDIT",
                                    cards: [{
                                            address1: "1208 Oak Creek",
                                            address2: null,
                                            cardCode: "V",
                                            cardExpires: "01/2017",
                                            cardExpiresDate: "2017-01-01T13:09:13.369-06:00",
                                            cardNbr: "************-0013",
                                            cardType: 0,
                                            city: "CONROE",
                                            country: "USA",
                                            name: "AnotherTest",
                                            nameOnCard: "AnotherTest",
                                            paymentAmount: 0,
                                            paymentType: 0,
                                            plus4: "2124",
                                            state: "TX",
                                            zip: "77301",
                                            zipCode: "77301"
                                        }],
                                    creditCard: true,
                                    eft: null
                                },
                                personalInfo: {},
                                errors: []
                            });
                        }
                    };
                },
                getManagePaymentInformation: function () {
                    return {
                        then: function (cb) {
                            cb({
                                billingInfo: {
                                    address: null,
                                    billingInfoExists: true,
                                    billingType: 0,
                                    billingTypeCode: "C",
                                    billingTypeDisplay: "CREDIT",
                                    cards: [{
                                            address1: "1208 Oak Creek",
                                            address2: null,
                                            cardCode: "V",
                                            cardExpires: "01/2017",
                                            cardExpiresDate: "2017-01-01T13:09:13.369-06:00",
                                            cardNbr: "************-0013",
                                            cardType: 0,
                                            city: "CONROE",
                                            country: "USA",
                                            name: "AnotherTest",
                                            nameOnCard: "AnotherTest",
                                            paymentAmount: 0,
                                            paymentType: 0,
                                            plus4: "2124",
                                            state: "TX",
                                            zip: "77301",
                                            zipCode: "77301"
                                        }],
                                    creditCard: true,
                                    eft: null,
                                },
                                errors: []
                            });
                        }
                    };
                },
                getCreateAccountSummary: function () {
                    return {
                        then: function (cb) {
                            cb({
                                billingInfo: {
                                    address: null,
                                    billingInfoExists: true,
                                    billingType: 0,
                                    billingTypeCode: "C",
                                    billingTypeDisplay: "credit card",
                                    cards: [{
                                            address1: "1208 Oak Creek",
                                            address2: null,
                                            cardCode: "V",
                                            cardExpires: "01/2017",
                                            cardExpiresDate: "2017-01-01T13:09:13.369-06:00",
                                            cardNbr: "************-0013",
                                            cardType: 0,
                                            city: "CONROE",
                                            country: "USA",
                                            name: "AnotherTest",
                                            nameOnCard: "AnotherTest",
                                            paymentAmount: 0,
                                            paymentType: 0,
                                            plus4: "2124",
                                            state: "TX",
                                            zip: "77301",
                                            zipCode: "77301"
                                        }],
                                    creditCard: true,
                                    eft: null
                                }, personalInfo: {
                                    personalInfoExists: true,
                                    firstName: "FirstName"
                                }, accountTags: {
                                    vehicleListExists: true
                                },
                                errors: []
                            });
                        }
                    };
                },
                getBillingInfo: function () {
                    return {
                        then: function (cb) {
                            cb({
                                address: null,
                                billingInfoExists: true,
                                billingType: 0,
                                billingTypeCode: "C",
                                billingTypeDisplay: "credit card",
                                cards: [{
                                        address1: "1208 Oak Creek",
                                        address2: null,
                                        cardCode: "V",
                                        cardExpires: "01/2017",
                                        cardExpiresDate: "2017-01-01T13:09:13.369-06:00",
                                        cardNbr: "************-0013",
                                        cardType: 0,
                                        city: "CONROE",
                                        country: "USA",
                                        name: "AnotherTest",
                                        nameOnCard: "AnotherTest",
                                        paymentAmount: 0,
                                        paymentType: 0,
                                        plus4: "2124",
                                        state: "TX",
                                        zip: "77301",
                                        zipCode: "77301"
                                    }],
                                creditCard: true,
                                eft: null
                            });
                        }
                    };
                },
                getPersonalInfo: function () {
                    return {
                        then: function (cb) {
                            cb({
                                personalInfoExists: true,
                                accountInfoExists: true,
                                firstName: "FirstName",
                                mailingAddress: {},
                                errors: [],
                                authorizedContactList: [],
                            });
                        }
                    };
                },
                updatePersonalInfo: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                            });
                        }
                    };
                },
                getAccountTags: function () {
                    return {
                        then: function (cb) {
                            cb({ accountTags: { vehicleListExists: true } });
                        }
                    };
                },
                getAccountActivityVM: function () {
                    return {
                        then: function (cb) {
                            var tranactionListItem = { key: 0, value: "All Transactions" };
                            var transactionListItems = [tranactionListItem];
                            var vehicleNickNameItem = 'test';
                            var vehicleNickName = [vehicleNickNameItem];
                            cb({
                                currentBalance: 100,
                                vehicleNickName: 'Bernie',
                                transactionListItems: transactionListItems,
                                vehicleNickName: vehicleNickName,
                                errors: []
                            });
                        }
                    };
                },
                searchAccountActivity: function () {
                    return {
                        then: function (cb) {
                            cb({
                                totalRecordsCount: 30,
                                recordsShownCount: 10,
                                endOfRecords: true,
                                records: [
                                    {
                                        amount: -0.9,
                                        licensePlate: "GFH2407",
                                        licenseState: "TX",
                                        licenseStateAndPlate: "TX-GFH2407",
                                        locationName: "SAM HOUSTON TOLL ROAD-SAM HOUSTON SOUTH PLAZA-SHT-BELR-61 SOUTH",
                                        postedDate: "2018-05-25T12:52:43-05:00",
                                        transType: "AVI Transaction",
                                        trxnDate: "2018-04-29T16:53:38-05:00",
                                        vehicleClassCode: "2",
                                        vehicleNickName: "TX-GFH2407"
                                    },
                                    {
                                        amount: -1.5,
                                        licensePlate: "GFH2407",
                                        licenseState: "TX",
                                        licenseStateAndPlate: "TX-GFH2407",
                                        locationName: "SAM HOUSTON TOLL ROAD-SAM HOUSTON CENTRAL PLAZA-SHT-SAMC-12 NORTH",
                                        postedDate: "2018-05-24T23:42:19-05:00",
                                        transType: "AVI Transaction",
                                        trxnDate: "2018-04-27T09:38:06-05:00",
                                        vehicleClassCode: "2",
                                        vehicleNickName: "TX-GFH2407"
                                    }
                                ],
                                errors: [],
                                hasTollWaivers: true
                            });
                        }
                    };
                },
                getPdfReport: function () {
                    return {
                        then: function (cb) {
                            cb('test');
                        }
                    };
                },
                getCreateAccountReceipt: function () {
                    return {
                        then: function (cb) {
                            cb({
                                billingInfo: { billingInfoExists: true },
                                personalInfo: { personalInfoExists: true },
                                accountTags: { accountTagsExists: true },
                                orderShippingTime: "5-10 business days",
                                errors: [],
                                alerts: []
                            });
                        }
                    };
                },
                checkoutPayment: function (transactionObj) {
                    return {
                        then: function (cb) {
                            cb({
                                transactionId: transactionObj.transactionId,
                                ezTagTransaction: {
                                    tagSalesAmt: 30,
                                    depositAmt: 80,
                                    totalAmt: 80,
                                    tagCostExists: true,
                                    transactionId: transactionObj.transactionId
                                },
                                errors: []
                            });
                        }
                    };
                },
                setupStatementPage: function () {
                    return {
                        then: function (cb) {
                            cb({
                                dates: ["January, 2014", "March, 2014", "April, 2015"],
                                errors: [],
                                alerts: []
                            });
                        }
                    };
                },
                makePayment: function (payment) {
                    return {
                        then: function (cb) {
                            cb({
                                tagSalesAmt: payment.tagSalesAmt,
                                depositAmt: payment.depositAmt,
                                totalAmt: payment.totalAmt,
                                transactionId: payment.transactionId,
                                deliveryMethod: payment.deliveryMethod,
                                errors: []
                            });
                        }
                    };
                },
                addPaymentBankAccount: function (payment) {
                    return {
                        then: function (cb) {
                            cb({
                                tagSalesAmt: payment.tagSalesAmt,
                                depositAmt: payment.depositAmt,
                                totalAmt: payment.totalAmt,
                                transactionId: payment.transactionId,
                                deliveryMethod: payment.deliveryMethod,
                                errors: []
                            });
                        }
                    };
                },
                addPaymentCreditCard: function (payment) {
                    return {
                        then: function (cb) {
                            cb({
                                tagSalesAmt: payment.tagSalesAmt,
                                depositAmt: payment.depositAmt,
                                totalAmt: payment.totalAmt,
                                transactionId: payment.transactionId,
                                deliveryMethod: payment.deliveryMethod,
                                errors: []
                            });
                        }
                    };
                },
                creditCardType: function () {
                    return {
                        then: function (cb) {
                            cb({
                                creditCardTypes: [
                                    { cardCode: "A", cardName: "American Express" },
                                    { cardCode: "D", cardName: "Discover" },
                                    { cardCode: "M", cardName: "MasterCard" },
                                    { cardCode: "V", cardName: "Visa" },
                                ],
                                errors: []
                            });
                        }
                    };
                },
                getVehicleMakes: function () {
                    return {
                        then: function (cb) {
                            cb({
                                getVehicleMakes: [],
                                errors: []
                            });
                        }
                    };
                },
                deleteEZTag: function () {
                    return {
                        then: function (cb) {
                            cb({
                                transactionId: 1234567,
                                tagSalesAmt: 15,
                                depositAmt: 40,
                                totalAmt: 40,
                                errors: []
                            });
                        }
                    };
                },
                addEZTag: function () {
                    return {
                        then: function (cb) {
                            cb({
                                transactionId: 1234567,
                                tagSalesAmt: 15,
                                depositAmt: 40,
                                totalAmt: 40,
                                vehicleModel: "Ranger",
                                vehicleColor: "Green",
                                errors: []
                            });
                        }
                    };
                },
                updateEZTag: function () {
                    return {
                        then: function (cb) {
                            cb({
                                transactionId: 1234567,
                                tagSalesAmt: 15,
                                depositAmt: 40,
                                totalAmt: 40,
                                errors: []
                            });
                        }
                    };
                },
                getYearlySummary: function () {
                    return {
                        then: function (cb) {
                            cb({
                                summaryYear: [{ quantity: 3 }, { quantity: 2 }, { quantity: 1 }],
                                tagSummary: [{ quantity: 3 }, { quantity: 2 }, { quantity: 1 }],
                                acctSummary: [{ quantity: 3 }, { quantity: 2 }, { quantity: 1 }],
                                errors: []
                            });
                        }
                    };
                },
                setupYearlyPage: function () {
                    return {
                        then: function (cb) {
                            cb({
                                dates: ["2015", "2014", "2013"],
                                errors: []
                            });
                        }
                    };
                },
                setupAccountStep1: function () {
                    return {
                        then: function (cb) {
                            cb({
                                acctId: 123413412,
                                acctActivity: "P",
                                errors: []
                            });
                        }
                    };
                },
                submitSetupOnlineAccessAccount: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                                acctId: '12345',
                                dbSessionId: 'test session id',
                                lastLoginIp: 'test login ip'
                            });
                        }
                    };
                },
                submitSetupOnlineAccessLoginInfo: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: []
                            });
                        }
                    };
                },
                getEZTagInfo: function () {
                    return {
                        then: function (cb) {
                            cb({
                                accountStatus: null,
                                accountTags: [{
                                        acctTagSeq: 22,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000001",
                                        licPlate: "TST123",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 114",
                                        tagId: "09000001",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    }],
                                pbpTags: [{
                                        acctTagSeq: 22,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000001",
                                        licPlate: "TST123",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 114",
                                        tagId: "09000001",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    },
                                    {
                                        acctTagSeq: 23,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000002",
                                        licPlate: "TST1232",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 1142",
                                        tagId: "09000002",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    },
                                    {
                                        acctTagSeq: 24,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000003",
                                        licPlate: "TST1233",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 1143",
                                        tagId: "09000003",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    },
                                    {
                                        acctTagSeq: 25,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000004",
                                        licPlate: "TST1234",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 1144",
                                        tagId: "09000004",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    },
                                    {
                                        acctTagSeq: 26,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000005",
                                        licPlate: "TST12345",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 1145",
                                        tagId: "09000005",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    }
                                ],
                                acctId: 2398428,
                                currentBalance: 940,
                                maxEzPlatesAllowed: 5,
                                alerts: [],
                                errors: []
                            });
                        }
                    };
                },
                searchAccountTags: function () {
                    return {
                        then: function (cb) {
                            cb({
                                accountStatus: null,
                                accountTags: [{
                                        acctTagSeq: 22,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000001",
                                        licPlate: "TST123",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 114",
                                        tagId: "09000001",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    }],
                                pbpTags: [{
                                        acctTagSeq: 22,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000001",
                                        licPlate: "TST123",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 114",
                                        tagId: "09000001",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "WHITE",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    }],
                                acctId: 2398428,
                                currentBalance: 940,
                                maxEzPlatesAllowed: 5,
                                alerts: [],
                                errors: []
                            });
                        }
                    };
                },
                addVehicleFromAccountInformation: function () {
                    return {
                        then: function (cb) {
                            cb({
                                acctTagSeq: 22,
                                acctTagSeqSpecified: true,
                                acctTagStatus: "A",
                                fullTagId: "HCTR09000001",
                                licPlate: "TST123",
                                licState: "TX",
                                motorcycle: false,
                                nickname: "Motor 114",
                                tagId: "09000001",
                                tagStatusDesc: "Active",
                                temporaryLicPlate: false,
                                vehicleClassCode: "2",
                                vehicleClassDesc: "Two Axle Vehicle",
                                vehicleColor: "BLACK",
                                vehicleMake: "COACHMAN",
                                vehicleModel: "ABC",
                                vehicleYear: "2001",
                                tagAmount: 123,
                                depositAmt: 100,
                                totalAmt: 150,
                                tagSalesAmt: 50,
                                transactionId: 522,
                                violationExist: false,
                                errors: [],
                                alerts: []
                            });
                        }
                    };
                },
                updateVehicleFromAccountInformation: function () {
                    return {
                        then: function (cb) {
                            cb({
                                acctTagSeq: 22,
                                acctTagSeqSpecified: true,
                                acctTagStatus: "A",
                                fullTagId: "HCTR09000001",
                                licPlate: "TST123",
                                licState: "TX",
                                motorcycle: false,
                                nickname: "Motor 114",
                                tagId: "09000001",
                                tagStatusDesc: "Active",
                                temporaryLicPlate: false,
                                vehicleClassCode: "2",
                                vehicleClassDesc: "Two Axle Vehicle",
                                vehicleColor: "BLACK",
                                vehicleMake: "COACHMAN",
                                vehicleModel: "ABC",
                                vehicleYear: "2001",
                                depositAmt: 100,
                                totalAmt: 150,
                                tagSalesAmt: 50,
                                transactionId: 522,
                                violationExist: false,
                                errors: [],
                                alerts: []
                            });
                        }
                    };
                },
                switchTagStatus: function () {
                    return {
                        then: function (cb) {
                            cb({
                                accountStatus: null,
                                accountTags: [{
                                        acctTagSeq: 22,
                                        acctTagSeqSpecified: true,
                                        acctTagStatus: "A",
                                        fullTagId: "HCTR09000001",
                                        licPlate: "TST123",
                                        licState: "TX",
                                        motorcycle: false,
                                        nickname: "Motor 114",
                                        tagId: "09000001",
                                        tagStatusDesc: "Active",
                                        temporaryLicPlate: false,
                                        vehicleClassCode: "2",
                                        vehicleClassDesc: "Two Axle Vehicle",
                                        vehicleColor: "BLACK",
                                        vehicleMake: "COACHMAN",
                                        vehicleModel: "ABC",
                                        vehicleYear: "2001"
                                    }],
                                acctId: 2398428,
                                currentBalance: 940,
                                maxEzPlatesAllowed: 5,
                                alerts: [{
                                        alertId: 32,
                                        altertMsg: "Vehicle with EZ TAG# HCTR09000001 has been made 'Active'."
                                    }],
                                errors: []
                            });
                        }
                    };
                },
                getHelpAndSupportInformation: function () {
                    return {
                        then: function (cb) {
                            cb({
                                name: 'Test User',
                                email: 'test@test.com',
                                accountNumber: '123456',
                                errors: []
                            });
                        }
                    };
                },
                sendHelpAndSupportEmail: function (helpAndSupportDetails) {
                    return {
                        then: function (cb) {
                            cb({
                                errors: []
                            });
                        }
                    };
                },
                updateRebillAmount: function (cb) {
                    return {
                        then: function (cb) {
                            cb({
                                errors: []
                            });
                        }
                    };
                },
                getAccountInformation: function () {
                    return {
                        then: function (cb) {
                            cb({
                                creditCardTypes: "test",
                                billingInfo: {
                                    billingTypeDisplay: "EFT",
                                    mailingAddress: "test",
                                    cards: [{
                                            test: "test"
                                        }]
                                },
                                depositAmtEFT: "10",
                                personalInfo: {},
                                errors: []
                            });
                        }
                    };
                },
                getEditEzTagData: function () {
                    return {
                        then: function (cb) {
                            cb({
                                states: ["AR", "TX"],
                                vehicleMakes: ["Ford"],
                                errors: []
                            });
                        }
                    };
                },
                updatePaymentBankAccount: function () {
                    return {
                        then: function (cb) {
                            cb({ errors: [] });
                        }
                    };
                },
                addPaymentBankAccount: function () {
                    return {
                        then: function (cb) {
                            cb({ transactionId: 42, errors: [] });
                        }
                    };
                },
                getCreditCardTypeAndState: function () {
                    return {
                        then: function (cb) {
                            cb({
                                creditCardTypes: [
                                    { cardCode: "A", cardName: "American Express" },
                                    { cardCode: "D", cardName: "Discover" },
                                    { cardCode: "M", cardName: "MasterCard" },
                                    { cardCode: "V", cardName: "Visa" },
                                ],
                                states: ["TX", "OK", "LA"],
                                errors: []
                            });
                        }
                    };
                },
                getAuthorizedContactsAndPreferences: function () {
                    return {
                        then: function (cb) {
                            cb({
                                authorizedContactList: [
                                    { firstName: 'NAME1A', lastName: 'NAME1B', accessCode: 'access1', contactId: '1' },
                                    { firstName: 'NAME2A', lastName: 'NAME2B', accessCode: 'access2', contactId: '2' },
                                    { firstName: 'NAME3A', lastName: 'NAME3B', accessCode: 'access3', contactId: '3' }
                                ],
                                authContactLimit: 20,
                                errors: []
                            });
                        }
                    };
                },
                getAuthorizedContacts: function () {
                    return {
                        then: function (cb) {
                            cb({
                                authorizedContactList: [
                                    { firstName: 'NAME1A', lastName: 'NAME1B', accessCode: 'access1', contactId: '1' },
                                    { firstName: 'NAME2A', lastName: 'NAME2B', accessCode: 'access2', contactId: '2' },
                                    { firstName: 'NAME3A', lastName: 'NAME3B', accessCode: 'access3', contactId: '3' }
                                ],
                                authContactLimit: 20,
                                errors: []
                            });
                        }
                    };
                },
                modifyAuthorizedContact: function (data) {
                    return {
                        then: function (cb) {
                            cb({ errors: [] });
                        }
                    };
                },
                getClosureAgreement: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                                accountClosureAgreement: 'WS closure agreement<br>'
                            });
                        }
                    };
                },
                getRefundData: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                                currentBalance: 40,
                                timeWithZone: 'January 1, 1970 at 12:00 am CST',
                                billingInfo: {
                                    address: null,
                                    billingInfoExists: true,
                                    billingType: 0,
                                    billingTypeCode: "C",
                                    billingTypeDisplay: "CREDIT",
                                    cards: [{
                                            address1: "1208 Oak Creek",
                                            address2: null,
                                            cardCode: "V",
                                            cardExpires: "01/2017",
                                            cardExpiresDate: "2017-01-01T13:09:13.369-06:00",
                                            cardNbr: "************-0013",
                                            cardType: 0,
                                            city: "CONROE",
                                            country: "USA",
                                            name: "AnotherTest",
                                            nameOnCard: "AnotherTest",
                                            paymentAmount: 0,
                                            paymentType: 0,
                                            plus4: "2124",
                                            state: "TX",
                                            zip: "77301",
                                            zipCode: "77301"
                                        }],
                                    creditCard: true,
                                    eft: null,
                                    mailingAddress: {
                                        country: 'USA',
                                        address1: 'address line 1',
                                        address2: 'address line 2',
                                        address3: 'address line 3',
                                        address4: 'address line 4',
                                        city: 'Houston',
                                        name: 'Test User',
                                        plus4: '1234',
                                        state: 'TX',
                                        zip: '12345',
                                        internationalAddress: false
                                    }
                                }
                            });
                        }
                    };
                },
                closeAccount: function (request) {
                    return {
                        then: function (cb) {
                            cb({
                                errors: []
                            });
                        }
                    };
                },
                menu: function () {
                    return {
                        then: function (cb) {
                            var rawObj = { "navBar": "[{\"itemID\": \"8827a45c-56fe-4901-9bc0-59d9b3501f82\", \"title\": \"EZ TAG Account\", \"totalMenuColumns\": 3, \"url\": \"\", \"menuColumns\": [{\"subMenus\": [{\"itemID\": \"5b571992-9164-40e4-bb57-be64b966beb9\", \"title\": \"Account Summary\", \"menuColumn\": 1, \"links\": [{\"title\": \"Account Status\", \"url\": \"/AccountSummary\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountSummary/ViewAccountSummary\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Make a Payment\", \"url\": \"/MakeOneTimePayment/EnterAmount\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountSummary/MakeOneTimePayment\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"MakeOneTimePayment\"}]}, {\"itemID\": \"0e5af3ad-4709-4076-9270-06241975ecb7\", \"title\": \"Account Activity\", \"menuColumn\": 1, \"links\": [{\"title\": \"Transactions\", \"url\": \"/AccountActivity\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/Transactions\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Receipts\", \"url\": \"/AccountActivityReceipts\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/Receipts\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Statements\", \"url\": \"/AccountActivityStatements\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/Statements\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Yearly Summary\", \"url\": \"/AccountActivityYearly\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/YearlySummary\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}, {\"subMenus\": [{\"itemID\": \"76ae5d89-3592-4c91-8405-a9cee1ec9e48\", \"title\": \"Account Information\", \"menuColumn\": 2, \"links\": [{\"title\": \"Account Details\", \"url\": \"/AccountInformation\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/ManageAccountInformation\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Change Username\", \"url\": \"/ChangeUsername\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/ChangeUserName\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Change Password\", \"url\": \"/ChangePassword\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/ChangePassword\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Security Question\", \"url\": \"/ChangeSecurityQuestion\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateSecurityQuestion\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Contact Information\", \"url\": \"/UpdatePersonalInformation\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateContactInformation\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Authorized Contacts\", \"url\": \"/UpdateAuthorizedContact\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateAuthorizedContact\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Billing Information\", \"url\": \"/ManagePayment\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateBillingInformation\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"UpdateBillingInformation\"}, {\"title\": \"Update Replenish Amount\", \"url\": \"/UpdateReplenishAmount\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateReplenishAmount\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Close Account\", \"url\": \"/CloseAccount/Agreement\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"b28b9626-c4d9-45dd-bd40-240a309a2fca\", \"title\": \"EZ TAG Account\", \"menuColumn\": 2, \"links\": [{\"title\": \"Benefits of EZ TAG\", \"url\": \"/NonSectional?path=/sitecore/content/HCTRA/EZTagAccount/Benefits of EZ TAG\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/Benefits of EZ TAG\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"First Time Login\", \"url\": \"/SetupOnlineAccess\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/SetupOnlineAccess\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Open EZ Tag Account\", \"url\": \"/NewAccount\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/EZTagAccount/OpenEZTagAccount\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"NewAccount\"}]}]}, {\"subMenus\": [{\"itemID\": \"3f5ad9e5-2bbb-49d9-9c06-d2dfeaee1cb2\", \"title\": \"Vehicles and EZ TAGs\", \"menuColumn\": 3, \"links\": [{\"title\": \"Update Existing Vehicles\", \"url\": \"/ManageVehicles\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/VehiclesandEZTags/ManageVehiclesEZTags\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Add EZ Plate\", \"url\": \"/AddEzPlate\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/VehiclesandEZTags/AddEZPlate\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Activate EZ TAG\", \"url\": \"/ActivateEzTag\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/ActivateEZTAG\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Add EZ TAG\", \"url\": \"/AddTag\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/VehiclesandEZTags/AddEZTAG\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}], \"tempSubMenu\": [{\"itemID\": \"5b571992-9164-40e4-bb57-be64b966beb9\", \"title\": \"Account Summary\", \"menuColumn\": 1, \"links\": [{\"title\": \"Account Status\", \"url\": \"/AccountSummary\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountSummary/ViewAccountSummary\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Make a Payment\", \"url\": \"/MakeOneTimePayment/EnterAmount\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountSummary/MakeOneTimePayment\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"MakeOneTimePayment\"}]}, {\"itemID\": \"0e5af3ad-4709-4076-9270-06241975ecb7\", \"title\": \"Account Activity\", \"menuColumn\": 1, \"links\": [{\"title\": \"Transactions\", \"url\": \"/AccountActivity\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/Transactions\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Receipts\", \"url\": \"/AccountActivityReceipts\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/Receipts\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Statements\", \"url\": \"/AccountActivityStatements\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/Statements\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Yearly Summary\", \"url\": \"/AccountActivityYearly\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountActivity/YearlySummary\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"76ae5d89-3592-4c91-8405-a9cee1ec9e48\", \"title\": \"Account Information\", \"menuColumn\": 2, \"links\": [{\"title\": \"Account Details\", \"url\": \"/AccountInformation\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/ManageAccountInformation\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Change Username\", \"url\": \"/ChangeUsername\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/ChangeUserName\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Change Password\", \"url\": \"/ChangePassword\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/ChangePassword\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Security Question\", \"url\": \"/ChangeSecurityQuestion\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateSecurityQuestion\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Contact Information\", \"url\": \"/UpdatePersonalInformation\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateContactInformation\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Authorized Contacts\", \"url\": \"/UpdateAuthorizedContact\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateAuthorizedContact\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Update Billing Information\", \"url\": \"/ManagePayment\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateBillingInformation\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"UpdateBillingInformation\"}, {\"title\": \"Update Replenish Amount\", \"url\": \"/UpdateReplenishAmount\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/AccountInformation/UpdateReplenishAmount\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Close Account\", \"url\": \"/CloseAccount/Agreement\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"b28b9626-c4d9-45dd-bd40-240a309a2fca\", \"title\": \"EZ TAG Account\", \"menuColumn\": 2, \"links\": [{\"title\": \"Benefits of EZ TAG\", \"url\": \"/NonSectional?path=/sitecore/content/HCTRA/EZTagAccount/Benefits of EZ TAG\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/Benefits of EZ TAG\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"First Time Login\", \"url\": \"/SetupOnlineAccess\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/SetupOnlineAccess\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Open EZ Tag Account\", \"url\": \"/NewAccount\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/EZTagAccount/OpenEZTagAccount\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"NewAccount\"}]}, {\"itemID\": \"3f5ad9e5-2bbb-49d9-9c06-d2dfeaee1cb2\", \"title\": \"Vehicles and EZ TAGs\", \"menuColumn\": 3, \"links\": [{\"title\": \"Update Existing Vehicles\", \"url\": \"/ManageVehicles\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/VehiclesandEZTags/ManageVehiclesEZTags\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Add EZ Plate\", \"url\": \"/AddEzPlate\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/VehiclesandEZTags/AddEZPlate\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Activate EZ TAG\", \"url\": \"/ActivateEzTag\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/ActivateEZTAG\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Add EZ TAG\", \"url\": \"/AddTag\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/EZTagAccount/VehiclesandEZTags/AddEZTAG\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}, {\"itemID\": \"c5fbf1aa-b038-43ed-bde3-999ef2bb0589\", \"title\": \"About HCTRA\", \"totalMenuColumns\": 3, \"url\": \"\", \"menuColumns\": [{\"subMenus\": [{\"itemID\": \"6c76e70a-3ac3-49b3-b569-85fc72aa7f40\", \"title\": \"Construction And Engineering\", \"menuColumn\": 1, \"links\": [{\"title\": \"Contracts & Bids\", \"url\": \"/Contracts\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/ContractsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Major Projects\", \"url\": \"/MajorProjects\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/MajorProjectsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"dd787d2b-8524-4343-96d3-50ba57f648f7\", \"title\": \"About HCTRA\", \"menuColumn\": 1, \"links\": [{\"title\": \"About Us\", \"url\": \"/Sectional?path=/sitecore/content/HCTRA/AboutHCTRA/AboutUsPage#OverviewSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/AboutUsPage\", \"sitecoreSectionName\": \"OverviewSection\", \"wizardStateName\": \"\"}, {\"title\": \"Policies\", \"url\": \"/NonSectional?path=/sitecore/content/HCTRA/AboutHCTRA/PoliciesPage\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/PoliciesPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}, {\"subMenus\": [{\"itemID\": \"e0f19b8a-c514-42b2-8cee-0fc0926e950f\", \"title\": \"HCTRA Employment\", \"menuColumn\": 2, \"links\": [{\"title\": \"Applications\", \"url\": \"/Employment#ApplicationsSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/EmploymentPage\", \"sitecoreSectionName\": \"ApplicationsSection\", \"wizardStateName\": \"\"}, {\"title\": \"Current Job Openings\", \"url\": \"/Employment#OpenningsSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/EmploymentPage\", \"sitecoreSectionName\": \"OpenningsSection\", \"wizardStateName\": \"\"}, {\"title\": \"How to Apply\", \"url\": \"/Employment#HowToApplySection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/EmploymentPage\", \"sitecoreSectionName\": \"HowToApplySection\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"adedf480-aeb6-4162-bdee-d2407d2c316c\", \"title\": \"Reports\", \"menuColumn\": 2, \"links\": [{\"title\": \"Financial Reports\", \"url\": \"/Sectional?path=/sitecore/content/HCTRA/AboutHCTRA/FinancialReportsPage\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/FinancialReportsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}, {\"subMenus\": [{\"itemID\": \"bbf61d2d-e230-4734-8ba2-57110b7cc995\", \"title\": \"Links\", \"menuColumn\": 3, \"links\": [{\"title\": \"Hardy Toll Road\", \"url\": \"/HardyTollRoad\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/HardyTollRoad\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Katy Managed Lanes\", \"url\": \"/KatyManagedLanes\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Katy Managed Lanes\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Sam Houston Tollway Northeast\", \"url\": \"/SamHoustonNortheast\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Sam Houston Northeast\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Ship Channel Bridge\", \"url\": \"/ShipChannelBridge\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Ship Channel Bridge\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Tomball Tollway\", \"url\": \"/Tomball\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Tomball\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}], \"tempSubMenu\": [{\"itemID\": \"6c76e70a-3ac3-49b3-b569-85fc72aa7f40\", \"title\": \"Construction And Engineering\", \"menuColumn\": 1, \"links\": [{\"title\": \"Contracts & Bids\", \"url\": \"/Contracts\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/ContractsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Major Projects\", \"url\": \"/MajorProjects\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/MajorProjectsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"dd787d2b-8524-4343-96d3-50ba57f648f7\", \"title\": \"About HCTRA\", \"menuColumn\": 1, \"links\": [{\"title\": \"About Us\", \"url\": \"/Sectional?path=/sitecore/content/HCTRA/AboutHCTRA/AboutUsPage#OverviewSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/AboutUsPage\", \"sitecoreSectionName\": \"OverviewSection\", \"wizardStateName\": \"\"}, {\"title\": \"Policies\", \"url\": \"/NonSectional?path=/sitecore/content/HCTRA/AboutHCTRA/PoliciesPage\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/PoliciesPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"e0f19b8a-c514-42b2-8cee-0fc0926e950f\", \"title\": \"HCTRA Employment\", \"menuColumn\": 2, \"links\": [{\"title\": \"Applications\", \"url\": \"/Employment#ApplicationsSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/EmploymentPage\", \"sitecoreSectionName\": \"ApplicationsSection\", \"wizardStateName\": \"\"}, {\"title\": \"Current Job Openings\", \"url\": \"/Employment#OpenningsSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/EmploymentPage\", \"sitecoreSectionName\": \"OpenningsSection\", \"wizardStateName\": \"\"}, {\"title\": \"How to Apply\", \"url\": \"/Employment#HowToApplySection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/EmploymentPage\", \"sitecoreSectionName\": \"HowToApplySection\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"bbf61d2d-e230-4734-8ba2-57110b7cc995\", \"title\": \"Links\", \"menuColumn\": 3, \"links\": [{\"title\": \"Hardy Toll Road\", \"url\": \"/HardyTollRoad\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/HardyTollRoad\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Katy Managed Lanes\", \"url\": \"/KatyManagedLanes\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Katy Managed Lanes\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Sam Houston Tollway Northeast\", \"url\": \"/SamHoustonNortheast\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Sam Houston Northeast\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Ship Channel Bridge\", \"url\": \"/ShipChannelBridge\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Ship Channel Bridge\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Tomball Tollway\", \"url\": \"/Tomball\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/Tomball\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"adedf480-aeb6-4162-bdee-d2407d2c316c\", \"title\": \"Reports\", \"menuColumn\": 2, \"links\": [{\"title\": \"Financial Reports\", \"url\": \"/Sectional?path=/sitecore/content/HCTRA/AboutHCTRA/FinancialReportsPage\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/AboutHCTRA/FinancialReportsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}, {\"itemID\": \"d4e3d3cf-1365-4350-a57b-c779e45682f9\", \"title\": \"Travel Tools\", \"totalMenuColumns\": 3, \"url\": \"\", \"menuColumns\": [{\"subMenus\": [{\"itemID\": \"f5ab52fa-739e-4e7b-814d-0083df8eed9c\", \"title\": \"Toll Road Information\", \"menuColumn\": 1, \"links\": [{\"title\": \"Lane Types\", \"url\": \"/LaneTypes\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/LaneTypesPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Toll Road Information\", \"url\": \"/TollRoadInformation\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/TollRoadInformationPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"9cc824a9-ce47-43f7-90aa-11403ae26370\", \"title\": \"News\", \"menuColumn\": 1, \"links\": [{\"title\": \"Latest HCTRA News\", \"url\": \"/News\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/NewsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"News Archive\", \"url\": \"/NewsArchive\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/NewsArchivePage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}]}, {\"subMenus\": [{\"itemID\": \"4893a1f2-2b11-4468-88bc-e8e7a26c6266\", \"title\": \"Closures\", \"menuColumn\": 2, \"links\": [{\"title\": \"Major Closures\", \"url\": \"/Closures\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/ClosuresPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Real Time Closures\", \"url\": \"http://traffic.houstontranstar.org/layers/#\", \"openNewTab\": 1, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": null, \"sitecoreSectionName\": null, \"wizardStateName\": null}, {\"title\": \"Closures Archive\", \"url\": \"/ClosuresArchive\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/ClosuresArchivePage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"5cabc844-948e-4a90-8bfb-832634063673\", \"title\": \"Maps\", \"menuColumn\": 2, \"links\": [{\"title\": \"Houston TranStar Traffic Map\", \"url\": \"http://www.houstontranstar.org/#\", \"openNewTab\": 1, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": null, \"sitecoreSectionName\": null, \"wizardStateName\": null}, {\"title\": \"Map\", \"url\": \"/TollRoadMap#OverviewSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/MapsPage\", \"sitecoreSectionName\": \"OverviewSection\", \"wizardStateName\": \"\"}]}]}, {\"subMenus\": [{\"itemID\": \"d4982387-6583-427a-ad98-afe9b78bdc2d\", \"title\": \"Rates\", \"menuColumn\": 3, \"links\": [{\"title\": \"Sam Houston Tollway\", \"url\": \"/TollRates#Sam Houston Tollway\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Sam Houston Tollway\", \"wizardStateName\": \"\"}, {\"title\": \"Hardy Toll Road\", \"url\": \"/TollRates#Hardy Toll Road\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Hardy Toll Road\", \"wizardStateName\": \"\"}, {\"title\": \"Westpark Tollway\", \"url\": \"/TollRates#Westpark Tollway\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Westpark Tollway\", \"wizardStateName\": \"\"}, {\"title\": \"Fort Bend Extension\", \"url\": \"/TollRates#Ft. Bend Extension\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Ft. Bend Extension\", \"wizardStateName\": \"\"}, {\"title\": \"Tomball Tollway\", \"url\": \"/TollRates#Tomball Tollway\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Tomball Tollway\", \"wizardStateName\": \"\"}, {\"title\": \"SH 242\", \"url\": \"/TollRates#SH 242\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"SH 242\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"6fa288e7-e789-4655-9b05-441a2b32ced2\", \"title\": \"Roadside Assistance\", \"menuColumn\": 3, \"links\": [{\"title\": \"Roadside Assistance\", \"url\": \"/RoadsideAssistance\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RoadsideAssistancePage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Contact Information\", \"url\": \"/RoadsideAssistance#ContactRoadsideAssistanceSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RoadsideAssistancePage\", \"sitecoreSectionName\": \"ContactRoadsideAssistanceSection\", \"wizardStateName\": \"\"}]}]}], \"tempSubMenu\": [{\"itemID\": \"f5ab52fa-739e-4e7b-814d-0083df8eed9c\", \"title\": \"Toll Road Information\", \"menuColumn\": 1, \"links\": [{\"title\": \"Lane Types\", \"url\": \"/LaneTypes\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/LaneTypesPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Toll Road Information\", \"url\": \"/TollRoadInformation\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/TollRoadInformationPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"4893a1f2-2b11-4468-88bc-e8e7a26c6266\", \"title\": \"Closures\", \"menuColumn\": 2, \"links\": [{\"title\": \"Major Closures\", \"url\": \"/Closures\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/ClosuresPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Real Time Closures\", \"url\": \"http://traffic.houstontranstar.org/layers/#\", \"openNewTab\": 1, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": null, \"sitecoreSectionName\": null, \"wizardStateName\": null}, {\"title\": \"Closures Archive\", \"url\": \"/ClosuresArchive\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/ClosuresArchivePage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"9cc824a9-ce47-43f7-90aa-11403ae26370\", \"title\": \"News\", \"menuColumn\": 1, \"links\": [{\"title\": \"Latest HCTRA News\", \"url\": \"/News\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/NewsPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"News Archive\", \"url\": \"/NewsArchive\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/NewsArchivePage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"5cabc844-948e-4a90-8bfb-832634063673\", \"title\": \"Maps\", \"menuColumn\": 2, \"links\": [{\"title\": \"Houston TranStar Traffic Map\", \"url\": \"http://www.houstontranstar.org/#\", \"openNewTab\": 1, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": null, \"sitecoreSectionName\": null, \"wizardStateName\": null}, {\"title\": \"Map\", \"url\": \"/TollRoadMap#OverviewSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/MapsPage\", \"sitecoreSectionName\": \"OverviewSection\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"d4982387-6583-427a-ad98-afe9b78bdc2d\", \"title\": \"Rates\", \"menuColumn\": 3, \"links\": [{\"title\": \"Sam Houston Tollway\", \"url\": \"/TollRates#Sam Houston Tollway\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Sam Houston Tollway\", \"wizardStateName\": \"\"}, {\"title\": \"Hardy Toll Road\", \"url\": \"/TollRates#Hardy Toll Road\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Hardy Toll Road\", \"wizardStateName\": \"\"}, {\"title\": \"Westpark Tollway\", \"url\": \"/TollRates#Westpark Tollway\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Westpark Tollway\", \"wizardStateName\": \"\"}, {\"title\": \"Fort Bend Extension\", \"url\": \"/TollRates#Ft. Bend Extension\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Ft. Bend Extension\", \"wizardStateName\": \"\"}, {\"title\": \"Tomball Tollway\", \"url\": \"/TollRates#Tomball Tollway\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"Tomball Tollway\", \"wizardStateName\": \"\"}, {\"title\": \"SH 242\", \"url\": \"/TollRates#SH 242\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RatesPage\", \"sitecoreSectionName\": \"SH 242\", \"wizardStateName\": \"\"}]}, {\"itemID\": \"6fa288e7-e789-4655-9b05-441a2b32ced2\", \"title\": \"Roadside Assistance\", \"menuColumn\": 3, \"links\": [{\"title\": \"Roadside Assistance\", \"url\": \"/RoadsideAssistance\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RoadsideAssistancePage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Contact Information\", \"url\": \"/RoadsideAssistance#ContactRoadsideAssistanceSection\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/TravelTools/RoadsideAssistancePage\", \"sitecoreSectionName\": \"ContactRoadsideAssistanceSection\", \"wizardStateName\": \"\"}]}]}, {\"itemID\": \"f035b7eb-0ee7-40b0-b3d0-c36087bfeb2c\", \"title\": \"Help & Support\", \"totalMenuColumns\": 1, \"url\": \"\", \"menuColumns\": [{\"subMenus\": [{\"itemID\": \"ed23b086-c7ad-4a8e-b1af-87278829369a\", \"title\": \"Help & Support\", \"menuColumn\": 1, \"links\": [{\"title\": \"Frequently Asked Questions\", \"url\": \"/FrequentlyAskedQuestions\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/FAQPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Customer Service Hours\", \"url\": \"/HelpAndSupport#customer-service\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"customer-service\", \"wizardStateName\": \"\"}, {\"title\": \"Documents\", \"url\": \"/HelpAndSupport#documents\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"documents\", \"wizardStateName\": \"\"}, {\"title\": \"EZ TAG Store Locations\", \"url\": \"/HelpAndSupport#ez-tag-store-locations\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"ez-tag-store-locations\", \"wizardStateName\": \"\"}, {\"title\": \"Email Us\", \"url\": \"/HelpAndSupport#email-us\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"email-us\", \"wizardStateName\": \"\"}, {\"title\": \"Call Us\", \"url\": \"/HelpAndSupport#contact-us\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"contact-us\", \"wizardStateName\": \"\"}]}]}], \"tempSubMenu\": [{\"itemID\": \"ed23b086-c7ad-4a8e-b1af-87278829369a\", \"title\": \"Help & Support\", \"menuColumn\": 1, \"links\": [{\"title\": \"Frequently Asked Questions\", \"url\": \"/FrequentlyAskedQuestions\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/FAQPage\", \"sitecoreSectionName\": \"\", \"wizardStateName\": \"\"}, {\"title\": \"Customer Service Hours\", \"url\": \"/HelpAndSupport#customer-service\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"customer-service\", \"wizardStateName\": \"\"}, {\"title\": \"Documents\", \"url\": \"/HelpAndSupport#documents\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"documents\", \"wizardStateName\": \"\"}, {\"title\": \"EZ TAG Store Locations\", \"url\": \"/HelpAndSupport#ez-tag-store-locations\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"ez-tag-store-locations\", \"wizardStateName\": \"\"}, {\"title\": \"Email Us\", \"url\": \"/HelpAndSupport#email-us\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"email-us\", \"wizardStateName\": \"\"}, {\"title\": \"Call Us\", \"url\": \"/HelpAndSupport#contact-us\", \"openNewTab\": null, \"alt\": null, \"showInMoibile\": null, \"sitecorePagePath\": \"/sitecore/content/HCTRA/HelpAndSupport/HelpAndSupportPage\", \"sitecoreSectionName\": \"contact-us\", \"wizardStateName\": \"\"}]}]}, {\"itemID\": \"7d9286d5-5f77-4fd8-b212-881efc1031c5\", \"title\": \"Missed a Toll?\", \"totalMenuColumns\": 0, \"url\": \"/MissedAToll\", \"menuColumns\": [], \"tempSubMenu\": []}, {\"itemID\": \"5d8b4373-a8f8-4599-adad-c3b98e8c599b\", \"title\": \"Got an Invoice?\", \"totalMenuColumns\": 0, \"url\": \"/Violations\", \"menuColumns\": [], \"tempSubMenu\": []}]", "errors": "[]", "alerts": "[]", "exception": null, "sessionTimedOut": false, "accountStatus": null };
                            rawObj.navBar = JSON.parse(rawObj.navBar);
                            rawObj.alerts = JSON.parse(rawObj.alerts);
                            rawObj.errors = JSON.parse(rawObj.errors);
                            cb(rawObj);
                        }
                    };
                },
                getLandingData: function () {
                    return {
                        then: function (cb) {
                            cb({
                                cmsResponse: '{"ItemID":"6a65b8a9-2f55-4f98-9e58-91b719c8b650","HasChildren":"True","LongDescription":"","Title":"Did You Miss a Toll?","Image":"<image mediaid=\\"{2328022B-68FE-4710-8E8B-1AA3FAC0A62B}\\" alt=\\"Save Money\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"","Children":[{"ItemID":"aeb9d0d9-c79a-4e53-bc08-b4d6e0eac0dc","HasChildren":"False","LongDescription":"<div class=\\"row\\"> \\n\\t<div class=\\"col-xs-12 col-md-7\\">\\n\\t\\t<!-- Add text content below here -->\\n\\t\\t<p>It may take several business days for recent violations and/or payments to be reflected on your balance.</p>\\n\\t\\t<p>More text here...</p>\\n\\t\\t<p>And even more text here too.</p>\\n\\t\\t<!-- Add text content above here -->\\n\\t</div>\\n\\t<div class=\\"col-xs-12 col-md-5\\">\\n\\t\\t<!-- Add image content below here -->\\n\\t\\t<img class=\\"desktopOnly\\" alt=\\"\\" height=\\"157\\" width=\\"299\\" src=\\"-/media/A93FF2BCE84640ABA8318D904453FC6C.ashx\\">\\n\\t\\t<!-- Add image content above here -->\\n\\t</div>\\n</div>","Title":"Missed A Toll Heading","Image":"","ShortDescription":""},{"ItemID":"54ac0791-89b6-4c3a-b6e7-04b21c680d28","HasChildren":"False","LongDescription":"<span style=\\"text-decoration: underline;\\">Note:</span> Tolls may take up to XX hours to be associated with a Vehicle\'s License Plate Number<p ng-if=\\"userNotLoggedIn()\\">Should not show when logged in.</p>","Title":"Search for Missed Tolls","Image":"<image mediaid=\\"{2328022B-68FE-4710-8E8B-1AA3FAC0A62B}\\" alt=\\"Save Money\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":""}]}',
                                cmsResponse2: '{"ItemID":"dd086fe4-41a7-4b37-834a-6ee3daa85c60","HasChildren":"True","LongDescription":"","Title":"Missed A Toll","Image":"","ShortDescription":"","Children":[{"ItemID":"2609ccff-36e2-455b-9095-294f7ea08c7f","HasChildren":"False","LongDescription":"<div class=\\"row\\"> \\n     <div class=\\"col-xs-12 col-md-6\\">\\n            <p>It may take several business days for recent violations and/or payments to be reflected on your balance.</p>\\n            <p>More text here...</p>\\n            <p>And even more text here too.</p>\\n     </div>\\n     <div class=\\"col-xs-12 col-md-6\\">\\n            <img class=\\"desktopOnly\\" alt=\\"\\" height=\\"157\\" width=\\"299\\" src=\\"-/media/A93FF2BCE84640ABA8318D904453FC6C.ashx\\">\\n     </div>\\n</div>","Title":"Important Information","Image":"","ShortDescription":""}]}',
                                cmsResponse3: '{"ItemID":"5d60495a-8c38-4262-930f-1280d9376510","HasChildren":"False","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","Title":"Pay Missed Toll","Image":"","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt."}',
                                errors: []
                            });
                        }
                    };
                },
                saveBillingInformationSuspended: function () {
                    return {
                        then: function (cb) {
                            cb({
                                errors: [],
                            });
                        }
                    };
                },
            }
        };
    },
    isInvoicedService: function (inVal) {
        return {
            isAccountInvoiced: function () {
                return inVal.value;
            },
            setAccountInvoiced: function (inBool) {
                inVal.value = inBool;
            },
            removeAccountInvoiced: function () {
                inVal.value = false;
            }
        };
    },
    accountSummaryAlertFilterService: function () {
        return {
            filterAccountSummaryAlerts: function () { },
            filterEmailConfirmationAlert: function () { },
            removeAccountSummaryAlerts: function () { }
        };
    },
    hctraSessionLogin: function (inSessionVal) {
        return {
            login: function (acctId) {
                inSessionVal.value = acctId;
            }
        };
    },
    USER_ROLES: function () {
        return {
            anonymous: 'anonymous',
            notAuthenticated: 'notAuthenticated',
            active: 'active',
            incomplete: 'incomplete',
            pendingClosure: 'pendingClosure',
            suspended: 'suspended',
            missingRequiredInformation: 'missingRequiredInformation',
        };
    },
    routes: function () {
        return {
            addMissingInformation: '/AddMissingInformation',
            makeOneTimePaymentPage: "133D03B5-3F06-4720-A177-9BFDA2CFC7B5",
            ezTagAccountTypes: "3045B316-D060-4173-9948-209CA74B70FE",
            nonSectionalCms: '/NonSectional',
            sectionalCms: '/Sectional',
            forgotPasswordEmailSent: '/ForgotPasswordEmailSent',
            forgotPasswordAccount: '/ForgotPasswordAccount',
            accountOverview: '/AccountOverview',
            forgotPasswordReset: '/ForgotPasswordReset',
            home: '/Home',
            login: '/Login',
            violationsInvoices: '/ViolationsInvoices',
            needHelp: '/NeedHelp',
            manageVehicles: '/ManageVehicles',
            tagReceipt: '/TagReceipt',
            openTabTarget: '_mhctra',
            selfTarget: '_selfTarger',
            confirmTagActivation: '/ConfirmTagActivation',
            tagActivationGratitude: '/TagActivationGratitude',
            closeAccount: '/CloseAccount',
            closeAccountAgreement: '/Agreement',
            closeAccountRefund: '/Refund',
            closeAccountCheckInformation: '/CloseAccount/CheckInformation',
            closeAccountCreditInformation: '/CloseAccount/CreditInformation',
            closeAccountSaveBillingInformation: '/CloseAccount/SaveBillingInformation',
            closeAccountPendingReview: '/Review',
            activateEzTag: 'https://tdeuat-olcsc.hctra.pri/eztagstore/mailedTagActivationDisplay.do',
            news: 'https://tdeuat-olcsc.hctra.pri/about_news?CSRT=18208781607148930682',
            katyLanes: 'https://tdeuat-olcsc.hctra.pri/katymanagedlanes/index.html?CSRT=18208781607148930682',
            travelTools: 'https://tdeuat-olcsc.hctra.pri/tollroads_map/?CSRT=18208781607148930682',
            internetSecurityPolicy: 'https://tdeuat-olcsc.hctra.pri/securitypolicy?CSRT=18208781607148930682',
            privacyPolicy: 'https://tdeuat-olcsc.hctra.pri/privacy/privacy_policy?CSRT=18208781607148930682',
            northAreaMapLink: 'https://goo.gl/maps/wMh9JNANHEp',
            northeastAreaMapLink: 'https://goo.gl/maps/PwGxCY5AnXU2',
            eastAreaMapLink: 'https://goo.gl/maps/LJrcm29GUQC2',
            southwestAreaMapLink: 'https://goo.gl/maps/vDFuoxvrmU22',
            westparkAreaMapLink: 'https://goo.gl/maps/LKMGjxJwJxx',
            westAreaMapLink: 'https://goo.gl/maps/HEoq2A1Zwet',
            whatIsEzPlateCms: '=%2Fsitecore%2Fcontent%2FHCTRA%2FEZTagAccount%2FEZPlatePage',
            contactUs: "/HelpAndSupport#email-us",
            updateReplenishAmount: '/updateReplenishAmount',
            accountActivityInvoices: '/accountActivityInvoices'
        };
    },
    stateNames: function () {
        return {
            oneTimeCheckout: "MakeOneTimePayment.OneTimeCheckout",
            addAdditionalVehicle: "NewAccount.AddEZTAG.AddAdditionalVehicle",
            login: 'theLoginState',
            faqChild: 'FrequentlyAskedQuestons.Child',
            choosePaymentMethod: 'NewAccount.PaymentMaster.ChooseMethod',
            enterBankAccount: "NewAccount.PaymentMaster.BankAccount",
            creditCardEntry: 'NewAccount.PaymentMaster.CreditCard',
            createAccountSummary: 'NewAccount.CreateAccountSummary',
            helpAndSupport: 'HelpAndSupport',
            helpAndSupportEmail: 'HelpAndSupport.Email',
            helpAndSupportConfirmation: 'HelpAndSupport.Confirmation',
            accountInformation: 'AccountInformationParent.AccountInformation',
            accountSummary: 'AccountSummary',
            newAccount: 'NewAccount',
            saveBillingInformation: 'ManagePaymentParent.SaveBillingInformation',
            setupOnlineAccessLoginInfo: 'SetupOnlineAccess.LoginInfo',
            setupOnlineAccessConfirmation: 'SetupOnlineAccess.Confirmation',
            manageVehicles: 'ManageVehicles',
            editEzTag: 'EditEzTag',
            addMoreVehicles: 'AddMoreVehicles',
            editUnfinalizedVehicle: 'EditUnfinalizedVehicle',
            vehicleSummary: 'VehicleSummary',
            tagCheckout: 'TagCheckout',
            tagReceipt: 'TagReceipt',
            addTag: 'AddTag',
            addEzPlate: 'AddEzPlate',
            editEzPlate: 'EditEzPlate',
            suspendedAccountWithViolations: 'SuspendedAccount.WithViolations',
            suspendedAccountWithoutViolationsPosBal: 'SuspendedAccount.WithoutViolationsPositiveBalance',
            suspendedAccountWithoutViolationsNegBal: 'SuspendedAccount.WithoutViolationsNegativeBalance',
            selectPaymentAmount: 'SuspendedAccount.SelectPaymentAmount',
            selectPaymentMethod: 'SuspendedAccount.SelectPaymentMethod',
            makePayment: 'SuspendedAccount.MakePayment',
            suspendedAccountPaymentReceipt: 'SuspendedAccount.SuspendedAccountPaymentReceipt',
            home: "Home",
            closeAccountParent: 'CloseAccount',
            closeAccountAgreement: 'CloseAccount.Agreement',
            closeAccountRefund: 'CloseAccount.Refund',
            closeAccountCheckInformation: 'AccountInformationParent.CloseAccountCheck',
            closeAccountCreditInformation: 'AccountInformationParent.CloseAccountCredit',
            closeAccountSaveBillingInformation: 'AccountInformationParent.CloseAccountSaveBillingInformation',
            closeAccountPendingReview: 'CloseAccount.PendingReview',
            personalAccount: 'NewAccount.CreateAccount.PersonalAccount',
            createAccount: 'NewAccount.CreateAccount',
            missedATollParent: 'MissedATollParent',
            missedATollLanding: 'MissedATollParent.MissedATollLanding',
            missedATollBillingInfo: 'MissedATollParent.MissedATollBillingInfo',
            missedATollViolationInformation: 'MissedATollParent.MissedATollViolationInformation',
            missedATollConfirmPayment: 'MissedATollParent.MissedATollConfirmPayment',
            faq: 'FrequentlyAskedQuestions',
            closuresArchive: 'ClosuresArchive',
            newsArchive: 'NewsArchive',
            newsFeed: 'NewsFeed',
            closures: 'Closures',
            forgotPassword: 'ForgotPassword',
            forgotPasswordAccount: 'ForgotPasswordParent.ForgotPasswordAccount',
            forgotPasswordValidateAccount: 'ForgotPasswordParent.ForgotPasswordValidateAccount',
            forgotPasswordEmail: 'ForgotPasswordParent.ForgotPasswordEmail',
            forgotPasswordEmailSent: 'ForgotPasswordParent.ForgotPasswordEmailSent',
            forgotPasswordValidateAccountEmail: 'ForgotPasswordParent.ForgotPasswordValidateAccountEmail',
            forgotPasswordReset: 'ForgotPasswordParent.ForgotPasswordReset',
            forgotPasswordParent: 'ForgotPasswordParent',
            closuresArchiveChild: 'ClosuresArchive.Child',
            faqChild: 'FrequentlyAskedQuestions.Child',
            newsArchiveChild: 'NewsArchive.Child'
        };
    },
    fakeWebStorage: function (inStorage) {
        return {
            setKeyValue: function (key, value) {
                inStorage[key] = value;
            },
            removeEntry: function (key) { delete inStorage[key]; },
            getValue: function (key) { return angular.copy(inStorage[key]); }
        };
    },
    webStorage: function (inStorage) {
        return {
            setKeyValue: function (key, value) {
                inStorage[key] = value;
            },
            validateOnValue: function (key, loc) {
                inStorage[key] = "true";
                return true;
            },
            removeEntry: function (key) {
                if (inStorage[key]) {
                    delete inStorage[key];
                }
            },
            getValue: function (key) {
                return angular.copy(inStorage[key]);
            }
        };
    },
    Session: function (inSession) {
        return {
            setAcctActivity: function (acctActivity) {
                inSession.acctActivity = acctActivity;
            },
            getAcctActivity: function () {
                return inSession.acctActivity;
            },
            getCurrentStep: function () {
                return 1;
            },
            setCurrentStep: function (step) {
                inSession.savedStep = step;
            },
            stepToStateName: function (currentStep) {
                switch (currentStep) {
                    case 1:
                        return 'PersonalAccount';
                        break;
                    case 3:
                        return 'VehicleInformation';
                        break;
                    case 4:
                        return 'ChoosePaymentMethod';
                        break;
                    case 5:
                        return 'CreateAccountSummary';
                        break;
                    default:
                        return 'PersonalAccount';
                        break;
                }
            },
            removeCurrentStep: function () { },
            create: function (acctId, userRole) { inSession.userRole = userRole; },
            userRole: ''
        };
    },
    responseErrorService: function (displayedMessage) {
        return {
            displayToast: function (msg, level) { displayedMessage.value = "Displayed a message"; },
            displayErrorsFromResponse: function (response, delayFlag) { displayedMessage.value = "Displayed a list of errors"; },
            displayAlertsFromResponse: function (response) { displayedMessage.value = "Displayed a list of alerts"; },
            formatErrorMessages: function (response) { return ["formatted message"]; },
            displayAlertsFromResponse: function (response) { displayedMessage.value = "Displayed a list of alerts"; },
            isErrorFree: function (response) { return true; },
            clearToasts: function () { }
        };
    },
    responsiveService: function () {
        return {
            isMobile: function () { return true; },
            isDesktop: function () { return true; },
            isIPadPortrait: function () { return false; }
        };
    },
    addMissingInformationService: function () {
        var response = {};
        response.passwordNeedsReset = false;
        response.profileCallHasOccured = false;
        response.emailIsMissing = false;
        response.securityQuestionIsMissing = false;
        return {
            missingInformationIsAnIssue: function () {
                return response.passwordNeedsReset || response.emailIsMissing || response.securityQuestionIsMissing;
            },
            setMissingInformation: function (pw, email, question) {
                response.passwordNeedsReset = pw;
                response.emailIsMissing = email;
                response.securityQuestionIsMissing = question;
            },
            destroyMissingInformationFlags: function () {
                response.passwordNeedsReset = false;
                response.emailIsMissing = false;
                response.securityQuestionIsMissing = false;
                return response;
            },
            returnMissingInformation: function () {
                return {
                    passwordNeedsReset: response.passwordNeedsReset,
                    emailIsMissing: response.emailIsMissing,
                    securityQuestionIsMissing: response.securityQuestionIsMissing
                };
            },
            setProfileCallHasOccured: function (data) {
                response.profileCallHasOccured = data;
            },
            returnProfileCallHasOccured: function (data) {
                return response.profileCallHasOccured;
            },
            newEmailRequired: function (pw, email, question) {
                return email;
            },
            isMissingInfo: function (pw, email, question) {
                return pw || email || question;
            },
            showBlockUserNavModal: function () {
            }
        };
    },
    validationService: function () {
        return function (formObj) {
            return "Uses validationService";
        };
    },
    validatePrimaryEmailService: function () {
        var emailSent;
        return {
            destroyEmailSent: function () {
                emailSent = null;
            },
            getEmailSent: function () {
                return true;
            },
            getEmailValidationId: function () {
                return 1;
            }
        };
    },
    AuthService: function (authObj) {
        return {
            login: function (data) {
                if ((data.userName === "rightUser") && (data.password === "rightPw")) {
                    return {
                        then: function (cb) {
                            //mock return value for correct data
                            cb(authObj.goodLoginRes);
                        }
                    };
                }
                else if ((data.userName === "exceptionUser") && (data.password === "exceptionPassword")) {
                    return {
                        then: function (success, reject) {
                            reject(authObj.goodLoginRes);
                        }
                    };
                }
                else {
                    return {
                        then: function (cb) {
                            //mock return value for error data
                            cb(authObj.badLoginRes);
                        }
                    };
                }
            },
            isAuthenticated: function () {
                return authObj.isAuthenticated;
            },
            isAuthorized: function (data) {
                authObj.data = data;
                return authObj.isAuthorized;
            },
            logout: function () {
                return {
                    then: function (cb) {
                        cb({ errors: [] });
                    }
                };
            }
        };
    },
    AUTH_EVENTS: function () {
        return {
            loginSuccess: 'auth-login-success',
            logoutSuccess: 'auth-logout-success',
            sessionTimedOut: 'auth-session-timeout',
            restoredUserState: 'restored-user-state',
            setNavBarLogin: 'set-nav-bar-login'
        };
    },
    APP_LIFECYCLE_EVENTS: function () {
        return {
            restoredUserState: 'restored-user-state',
            setNavBarLogin: 'set-nav-bar-login',
            newAccountNameEntered: "new-account-name-entered"
        };
    },
    usSpinnerService: function () {
        return {
            spin: function (spinId) {
            },
            stop: function (spinId) {
            }
        };
    },
    dateService: function () {
        return {
            getDaysAgo: function (data) {
                return 90;
            },
            isBefore: function (dateFrom, dateTo) {
                return true;
            },
            isAfter: function (dateFrom, dateTo) {
                return true;
            },
            isDate: function (dateinStringFormat) {
                var potentialDate = new Date(dateinStringFormat);
                if (Object.prototype.toString.call(potentialDate) === "[object Date]") {
                    // it is a date
                    if (!isNaN(potentialDate.getTime())) {
                        return true;
                    }
                }
                return false;
            },
            isExpiredFilterForCms: function (obj) {
                return true;
            },
            getDateOptions: function () {
                return {};
            }
        };
    },
    mapperService: function () {
        return {
            mapToAccountActivityDTO: function (data) {
                var accountActivityDTO = {};
                accountActivityDTO.page = 1;
                accountActivityDTO.dateFrom = "too cool to handle";
                return accountActivityDTO;
            },
            mapToViolationsData: function (data) {
                return {};
            }
        };
    },
    closeAccountService: function () {
        return {
            displayCloseAccountModal: function () { }
        };
    },
    billingInfoStateManagerService: function () {
        return {
            registerParent: function () { },
            stateAdvancementRules: function () { },
            checkStateValidity: function () { return true; }
        };
    },
    creditCardFilter: function () {
        return function (arg1, arg2) {
            return '****-****-****-****';
        };
    },
    newAccountService: function (configObj) {
        return {
            getTransactionId: function () {
                return 91827364;
            },
            getDeliveryMethod: function () {
                return 'mail';
            },
            getPayment: function () {
                return {
                    tagSalesAmt: 15,
                    depositAmt: 40,
                    totalAmt: 40,
                    paymentExists: true
                };
            },
            paymentExists: function () {
                return configObj.paymentExists;
            },
            setTransactionId: function (transactionId) {
                configObj.transactionId = transactionId;
            },
            setPayment: function (payment) {
                configObj.payment = payment;
            },
            setDeliveryMethod: function (deliveryMethod) {
                configObj.deliveryMethod = deliveryMethod;
            },
            getAccountInfo: function () {
                return {
                    companyName: null,
                    firstName: "First",
                    lastName: "Last",
                    acctType: "personal"
                };
            },
            setAccountInfo: function (info) {
                configObj.companyName = (info.companyName);
                configObj.firstName = (info.firstName);
                configObj.lastName = (info.lastName);
                configObj.accountType = (info.accountType);
            },
            localDataExists: function () {
                return configObj.localDataExists;
            },
            getVehicleList: function () {
                return configObj.inVehicleList;
            },
            setVehicleList: function () {
            },
            clearVehicleList: function () {
            }
        };
    },
    removeDoubleCharService: function () {
        return {
            removeDoubleChar: function (val) {
                //once a field reaches past its max length, no val sent
                if (!val) {
                    return;
                }
                val = val.toString();
                val = val.replace(/@@/g, '@');
                val = val.replace(/\s+/g, ' ');
                val = val.replace(/\.+/g, '.');
                val = val.replace(/\-+/g, '-');
                val = val.replace(/\_+/g, '_');
                val = val.replace(/[\<\>\'\"]/g, '');
                return val;
            }
        };
    },
    modalService: function (inModal, modalOptions) {
        return {
            showModal: function (optionA, optionB) {
                inModal.value = "called";
                modalOptions.A = optionA;
                modalOptions.B = optionB;
                return {
                    then: function () { }
                };
            },
            showUpdateSuccessModal: function (titleString, topicString) {
                inModal.value = 'called';
                inModal.title = titleString;
                inModal.topic = topicString;
                return {
                    then: function () { }
                };
            },
            violationsThisInvoicePaidModal: function () {
                return {
                    then: function () { }
                };
            },
            violationsPaymentPlanModal: function () {
                return {
                    then: function () { }
                };
            },
            violationsBelowMinimumPaymentModal: function (minPayment) {
                return {
                    then: function () { }
                };
            },
            violationsPaymentWillLeaveLowBalanceModal: function (defaultAmount) {
                return {
                    then: function () { }
                };
            },
            violationsPaymentCouldLeaveLowBalanceModal: function (defaultAmount, minimumPayment, defaultMinusMinimum) {
                return {
                    then: function () { }
                };
            },
            violationsOverpaymentModal: function (defaultAmount) {
                return {
                    then: function () { }
                };
            },
            violationsCannotAddVehicleModal: function () {
                return {
                    then: function () { }
                };
            },
            violationsNoViolationFoundWithInvoice: function () {
                return {
                    then: function () { }
                };
            }
        };
    },
    fakeModalService: function (inModal, modalOptions) {
        return {
            showModal: function (optionA, optionB) {
                inModal.value = "called";
                modalOptions.A = optionA;
                modalOptions.B = optionB;
                return {
                    then: function (cb) {
                        cb({});
                    }
                };
            }
        };
    },
    changePaymentMethodService: function (changePaymentMessage) {
        return {
            displayEftToast: function (reqMinRebillAmtForEFT, reqMinRebillAmtForCC, reqLowBalLevelForCC) {
                changePaymentMessage.value = "Called displayEftToast from changePaymentMethodService";
            },
            displayCreditCardToast: function (reqMinRebillAmtForEFT, reqMinRebillAmtForCC, reqLowBalLevelForCC) {
                changePaymentMessage.value = "Called displayCreditCardToast from changePaymentMethodService";
            }
        };
    },
    tagList: function () {
        return {
            accountTags: [
                { transactionId: 98743294 },
                { transactionId: 19098453 }
            ],
            accountTagsExists: true
        };
    },
    tagListConfigurable: function (inObj) {
        return inObj;
    },
    localDataRepo: function () {
        return {
            getModelYears: function () {
                var yearsArray = [];
                var curDate = new Date();
                var curYear = curDate.getFullYear();
                for (var x = curYear + 1; x >= 1900; x--) {
                    yearsArray.push(x);
                }
                return yearsArray;
            },
            getClasses: function () {
                var classesArr = [
                    { value: 2, label: "2-Axles" },
                    { value: 3, label: "3-Axles" },
                    { value: 4, label: "4-Axles" },
                    { value: 5, label: "5-Axles" },
                    { value: 6, label: "6+-Axles" }
                ];
                return classesArr;
            }
        };
    },
    bowserService: function () {
        var isFunction = function (functionToCheck) {
            var getType = {};
            return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
        };
        return {
            bowser: function () {
                return bowser;
            },
            getUserBrowserInfo: function () {
                var browserSummary = '';
                for (var property in bowser) {
                    if (bowser.hasOwnProperty(property)) {
                        if (!isFunction(bowser[property])) {
                            browserSummary = browserSummary + property + '=' + bowser[property] + '; ';
                        }
                    }
                }
                return browserSummary;
            }
        };
    },
    momentService: function (dates) {
        return {
            moment: function () {
                return moment(dates.endDate);
            }
        };
    },
    spaceReplaceFilter: function () {
        return {};
    },
    megaMenuCache: function () {
        return {
            cacheMegaMenu: function () {
                return [];
            },
            getCachedMegaMenu: function () {
                return [];
            },
            defaultCachedMegaMenu: function () {
                return [];
            }
        };
    },
    mobileMenuRouteService: function () {
        return {
            getNavRoutes: function () {
                return true;
            }
        };
    },
    desktopMenuRouteService: function () {
        return {
            getMegaMenuNavRoutes: function () {
                return {
                    then: function (cb) {
                        var routes = [
                            {
                                menuColumns: [
                                    {
                                        subMenus: [{
                                                links: [{
                                                        url: "test url1"
                                                    }]
                                            }]
                                    },
                                    {
                                        subMenus: [{
                                                links: [{
                                                        url: "test url2"
                                                    }]
                                            }]
                                    },
                                    {
                                        subMenus: [{
                                                links: [{
                                                        url: "test url3"
                                                    }]
                                            }]
                                    }
                                ]
                            },
                            {
                                menuColumns: [
                                    {
                                        subMenus: [{
                                                links: [{
                                                        url: "test url4"
                                                    }]
                                            }, {
                                                links: [{
                                                        url: "test url6"
                                                    }]
                                            }]
                                    },
                                    {
                                        subMenus: [{
                                                links: [{
                                                        url: "test url5"
                                                    }]
                                            }]
                                    }
                                ]
                            }
                        ];
                        cb(routes);
                        return true;
                    }
                };
            }
        };
    },
    $document: function (inDoc) {
        return {
            querySelector: function (selector) {
                inDoc = document.querySelector(selector);
                return document.querySelector(selector);
            },
            find: function (selector) {
                inDoc = document.querySelector(selector);
                return [document.querySelector(selector)];
            }
        };
    },
    $window: function (setUrl) {
        return {
            open: function (path, target) {
                if (path == null) {
                    path = '';
                }
                if (target == null) {
                    target = '';
                }
                setUrl.value = path + target;
            },
            print: function () {
                setUrl.value = "Printed!";
            },
            location: {
                reload: function () {
                    return true;
                }
            }
        };
    },
    document: function (setUrl) {
        return {
            location: function (inUrl) {
                setUrl.value = inUrl;
            }
        };
    },
    monthListService: function () {
        return {
            getMonths: function () {
                return {
                    1: 'January',
                    2: 'February',
                    3: 'March',
                    4: 'April',
                    5: 'May',
                    6: 'June',
                    7: 'July',
                    8: 'August',
                    9: 'September',
                    10: 'October',
                    11: 'November',
                    12: 'December'
                };
            }
        };
    },
    ratesService: function () {
        var allAxles = 'All Axles';
        var createAxleDropdown = function (tollRoad) {
            if (tollRoad.Directions.length > 0) {
                var axleArray = angular.copy(tollRoad.Directions[0].TollSections[0].Rates);
                // Sort based on axle class
                axleArray = axleArray.sort(function (a, b) {
                    if (a.Label > b.Label) {
                        return 1;
                    }
                    if (a.Label < b.Label) {
                        return -1;
                    }
                    return 0;
                });
                // Add All Axles option
                axleArray.unshift({
                    Label: this.allAxles,
                    Value: this.allAxles
                });
                return axleArray;
            }
        };
        var mapTollRoads = function (tollRoadsArray) {
            var tollRoads = [
                {
                    Title: "Sam Houston Tollway",
                    Directions: [{
                            Direction: "Clockwise",
                            TollSections: [{
                                    Bold: false,
                                    DisplayName: "Wilson Road",
                                    HasChildren: "False",
                                    ItemID: "b6f8a79d-14ba-4851-9e92-10d6081fb3d1",
                                    LocationType: "exit ramp ramp",
                                    Position: "1",
                                    Rates: [{
                                            $$hashKey: "object:565",
                                            Label: "2 Axles (Cash)",
                                            Value: "Cash Not Accepted"
                                        }],
                                    ShortDescription: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.",
                                    Title: "Wilson Road",
                                    TollingLocations: "Wilson Road"
                                }]
                        }],
                    LongDescription: ""
                }
            ];
            return tollRoads;
        };
        return {
            allAxles: allAxles,
            createAxleDropdown: createAxleDropdown,
            mapTollRoads: mapTollRoads
        };
    },
    helpAndSupportService: function () {
        var mapLocationTitle = function (title) {
            var mappedTitle = {};
            var openParen = title.indexOf('(');
            if (openParen !== -1) {
                mappedTitle.region = title.substring(0, openParen).trim();
                mappedTitle.subregion = title.substring(openParen, title.length);
            }
            else {
                mappedTitle.region = title;
            }
            return mappedTitle;
        };
        return {
            mapDocuments: function (documentsArray) {
                var documents = [];
                for (var i = 0; i < documentsArray.length; i++) {
                    var document = documentsArray[i];
                    var documentObj = {
                        Title: document.Title,
                        URL: document.URL
                    };
                    documents.push(documentObj);
                }
                return documents;
            },
            mapLocations: function (locationsArray) {
                var locations = [];
                for (var i = 0; i < locationsArray.length; i++) {
                    var location = locationsArray[i];
                    var mappedTitle = mapLocationTitle(location.Title);
                    var ariaText = location.ShortDescription;
                    var address = location.LongDescription.replace('&nbsp;', ' ').split(' ');
                    var addressStreet = address.slice(0, address.length - 3).join(' ').replace(',', '');
                    var addressCity = address.slice(address.length - 3, address.length).join(' ');
                    var locationObj = {
                        ariaAddressStreet: ariaText,
                        addressStreet: addressStreet,
                        addressCity: addressCity,
                        mapLink: location.MapURL,
                        region: mappedTitle.region,
                        subregion: mappedTitle.subregion,
                        imageSrc: location.Image
                    };
                    locations.push(locationObj);
                }
                return locations;
            },
            mapFields: function (fieldArray) {
                var fieldsObj = {};
                for (var i = 0; i < fieldArray.length; i++) {
                    var field = fieldArray[i];
                    fieldsObj[field.ItemName] = {};
                    if (field.Children && field.Type === 'Dropdown') {
                        var dropdownOptions = field.Children[0].Children;
                        fieldsObj[field.ItemName].Options = dropdownOptions;
                    }
                    if (field.Label) {
                        fieldsObj[field.ItemName].Label = field.Label;
                    }
                    if (field.Type) {
                        fieldsObj[field.ItemName].Type = field.Type;
                    }
                }
                return fieldsObj;
            },
            createFormMapping: function (formsArray) {
                var formMap = {};
                for (var i = 0; i < formsArray.length; i++) {
                    var form = formsArray[i];
                    formMap[form.ItemName] = {};
                    formMap[form.ItemName].LongDescription = form.LongDescription;
                    formMap[form.ItemName].Title = form.Title;
                    formMap[form.ItemName].Fields = [];
                    var fieldsArray = form.Children[0].Children;
                    for (var j = 0; j < fieldsArray.length; j++) {
                        var field = fieldsArray[j];
                        formMap[form.ItemName].Fields.push({
                            Field: field.Field,
                            IsRequired: field.IsRequired === '1' ? true : false
                        });
                    }
                }
                return formMap;
            },
            processDocumentsList: function (list) {
                var documentsList = list;
                var cmsRequests = {
                    requests: []
                };
                for (var i = 0; i < documentsList.length; i++) {
                    var request = {
                        path: documentsList[i].URL,
                        fields: 'ItemID,Size,Extension'
                    };
                    cmsRequests.requests.push(request);
                }
            }
        };
    },
    activateEzTagWizardDirectorService: function (inStorage) {
        return {
            saveStep: function (listOfVehicles, transactionId, currentScreen) {
                inStorage["transactionId"] = transactionId;
                var step = 0;
                switch (currentScreen) {
                    default:
                    case ("/ActivateEzTag"):
                        step = 2;
                        break;
                    case ("/ConfirmTagActivation"):
                        step = 3;
                        break;
                    case ("/TagActivationGratitude"):
                        step = 1;
                        break;
                }
                inStorage.step = step;
                inStorage.listOfVehicles = listOfVehicles;
            },
            redirectToCorrectScreen: function (step) {
                return false;
            },
            destroyActivateEzTagInformation: function () {
                inStorage.activateEzTagWizardInformation = {
                    transactionId: null,
                    step: null,
                    listOfVehicles: null,
                };
                return;
            }
        };
    },
    primaryAndSecondaryCreditCards: function () {
        return {
            billingType: "CREDIT",
            billingInfo: {
                address: null,
                billingInfoExists: true,
                billingType: 0,
                billingTypeCode: "C",
                billingTypeDisplay: "CREDIT",
                cards: [{
                        address1: "1208 Oak Creek",
                        address2: null,
                        cardCode: "V",
                        cardExpires: "01/2017",
                        cardExpiresDate: "2017-01-01T13:09:13.369-06:00",
                        cardNbr: "************-0013",
                        cardType: 0,
                        city: "CONROE",
                        country: "USA",
                        name: "AnotherTest",
                        nameOnCard: "AnotherTest",
                        paymentAmount: 0,
                        paymentType: 0,
                        plus4: "2124",
                        primary: true,
                        state: "TX",
                        zip: "77301",
                        zipCode: "77301"
                    },
                    {
                        address1: "234 Sample",
                        address2: null,
                        cardCode: "M",
                        cardExpires: "01/2034",
                        cardExpiresDate: "2034-01-01T13:09:13.369-06:00",
                        cardNbr: "************-1126",
                        cardType: 0,
                        city: "CONROE",
                        country: "USA",
                        name: "AnotherTest",
                        nameOnCard: "AnotherTest",
                        paymentAmount: 0,
                        paymentType: 0,
                        plus4: "2124",
                        primary: false,
                        state: "TX",
                        zip: "77301",
                        zipCode: "77301"
                    }],
                creditCard: true,
                eft: null
            }
        };
    },
    router: function () {
        return [
            {
                name: 'Home',
                config: {
                    url: 'home',
                    templateUrl: '/app/templates/home/home.html',
                    controller: 'HomeController',
                    settings: {
                        navlevel: 0,
                        nav: 1,
                        content: "<img src='../Content/icons/menu/hm_home.png' alt='Click to go to home page'>   HOME"
                    },
                    data: {
                        authorizedRoles: ['anonymous']
                    },
                    quickLink: {}
                }
            }, {
                name: 'eZTagAccount',
                config: {
                    settings: {
                        navlevel: 0,
                        nav: 2,
                        content: "<img src='../Content/icons/menu/hm_ez_tag_acct.png' alt='Click to see account options'>   EZ TAG ACCOUNT"
                    },
                    data: {
                        authorizedRoles: ['anonymous']
                    }
                }
            }, {
                name: 'accountSummary',
                config: {
                    url: 'accountSummary',
                    templateUrl: '/app/templates/account/accountSummary.html',
                    controller: 'AccountSummaryController',
                    settings: {
                        parent: 'eZTagAccount',
                        navlevel: 1,
                        nav: 1,
                        content: 'ACCOUNT SUMMARY'
                    },
                    data: {
                        authorizedRoles: ['active', 'suspended', 'pendingClosure']
                    },
                    quickLink: {
                        nav: 2,
                        content: 'View EZ TAG Account Summary'
                    }
                }
            }, {
                name: 'AccountActivity',
                config: {
                    url: 'accountActivity',
                    templateUrl: '/app/templates/accountActivity/accountActivity.html',
                    controller: 'AccountActivityController',
                    settings: {
                        parent: 'eZTagAccount',
                        navlevel: 1,
                        nav: 2,
                        content: 'ACCOUNT ACTIVITY'
                    },
                    data: {
                        authorizedRoles: ['active', 'suspended', 'pendingClosure']
                    },
                    quickLink: {
                        nav: 1,
                        content: 'View EZ TAG Account Activity'
                    }
                }
            }
        ];
    },
    capitalizeFilter: function () {
        return function (input, all) {
            if (!!input) {
                return input.replace(/([^\W_]+[^\s-]*) */g, function (txt) {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
            }
            else {
                return '';
            }
        };
    },
    charReplaceFilter: function () {
        return function (input, charReplaced, charReplacer) {
            if (!input) {
                return '';
            }
            return input.toString().trim().replace(charReplaced, charReplacer);
        };
    },
    creditCardCodeFilter: function () {
        return function (creditCardInput, creditCardCode) {
            if (!creditCardInput) {
                return '';
            }
            var value = creditCardInput.toString().trim().replace(/\D/g, '');
            value = value.substring(value.length - 4, value.length);
            var maskedCard;
            switch (creditCardCode.toLowerCase()) {
                case 'v': // ****-****-****-####
                case 'm':
                case 'd':
                    maskedCard = '****-****-****-' + value;
                    break;
                case 'a': //****-******-*####
                    maskedCard = '****-******-*' + value;
                    break;
                default:
                    break;
            }
            return maskedCard;
        };
    },
    NamesToCurrentUserService: function () {
        return {
            setNamesToCurrentUser: function () { }
        };
    },
    helloUserService: function () {
        return {
            setHelloName: function () { }
        };
    },
    updatePersonalInformationService: function () {
        var init = function ($scope) {
            $scope.personalInfo = {};
            $scope.personalInfo.mailingAddress = {};
            $scope.validations = {};
            $scope.international = false;
            $scope.mailingAddressDescription = "test mailing address description";
        };
        var onSave = function ($scope, isValid, saveState) {
            if (isValid) {
                $scope.personalInfo.mailingAddress.countryList = {};
                $scope.personalInfo.mailingAddress.stateList = {};
                if (!$scope.international) {
                    $scope.personalInfo.mailingAddress.country = "";
                }
                return saveState;
            }
        };
        var onCancel = function ($scope, cancelState) {
            return cancelState;
        };
        return {
            init: init,
            onSave: onSave,
            onCancel: onCancel
        };
    },
    updateBillingInformationService: function () {
        var init = function ($scope) { return; };
        var setEFT = function ($scope) { return; };
        var setEFTValidation = function ($scope) { return; };
        var setCreditCardValidation = function ($scope) { return; };
        var changePaymentMethod = function () { return; };
        return {
            init: init,
            setEFT: setEFT,
            setEFTValidation: setEFTValidation,
            setCreditCardValidation: setCreditCardValidation,
            changePaymentMethod: changePaymentMethod
        };
    },
    omnitureService: function () {
        var sendTag = function (toState, suffix) {
        };
        return {
            sendTag: sendTag
        };
    },
    googleAnalyticsService: function () {
        var sendTag = function () {
        };
        return {
            sendTag: sendTag
        };
    },
    creditCardTypes: {
        visa: 'VISA',
        mastercard: 'MASTERCARD',
        amex: 'AMERICAN EXPRESS',
        discover: 'DISCOVER'
    },
    menuUtilService: function () {
        var getLogo = function () {
            return {
                then: function (cb) {
                    cb("here's a logo");
                }
            };
        };
        var isLoginPage = function () {
            return true;
        };
        var goToLogin = function () {
        };
        var goToHome = function () {
        };
        var setCurrentBalanceFromWebStorage = function () {
        };
        var routeIs = function (url, wizardStateName) {
            return true;
        };
        var logout = function () {
        };
        var createGlobalGoogle = function () {
        };
        var setGoogleHide = function () {
        };
        var globalGoogleAttributes = {
            test: "testAttribute"
        };
        return {
            getLogo: getLogo,
            isLoginPage: isLoginPage,
            goToLogin: goToLogin,
            goToHome: goToHome,
            setCurrentBalanceFromWebStorage: setCurrentBalanceFromWebStorage,
            routeIs: routeIs,
            createGlobalGoogle: createGlobalGoogle,
            setGoogleHide: setGoogleHide,
            logout: logout,
            globalGoogleAttributes: globalGoogleAttributes
        };
    },
    cmsTextInsertionService: function () {
        return {
            insertValues: function (valuesObject, stringToInsert) {
                return "insertValues called";
            },
            checkOptional: function (valuesObject, stringToInsert) {
                return "insertValues called";
            }
        };
    },
    urlManagerService: function () {
        var metadataDictionary = null;
        var newRoutes = {};
        var megaMenuStructure = null;
        var footerCmsResponse = null;
        var getStartingRoutes = function () {
        };
        var getMegaMenu = function () {
        };
        var getMetadata = function () {
            var r = { metadata: "" };
            return r;
        };
        var getFooterdata = function () {
        };
        return {
            metadataDictionary: metadataDictionary,
            newRoutes: newRoutes,
            megaMenuStructure: megaMenuStructure,
            footerCmsResponse: footerCmsResponse,
            getStartingRoutes: getStartingRoutes,
            getMegaMenu: getMegaMenu,
            getMetadata: getMetadata,
            getFooterdata: getFooterdata
        };
    },
    documentLocationService: function (hrefUrl) {
        return {
            goToHref: function (url) {
                hrefUrl.value = url;
            }
        };
    },
    marketingImageService: function () {
        return {
            processImagesToObj: function (array) {
                return {};
            },
            getObj: function (loginObj, array) {
                return {};
            },
            getDefaultObj: function (array) {
                return {};
            },
            setImages: function (state, obj) {
                return [];
            }
        };
    },
    errorLogService: function () {
        return function log(exception, cause) { };
    },
    violationsCalcService: function () {
        return {
            calculateAllInvoicesSummary: function () {
                return "Invoices calculated";
            }
        };
    },
    violationsInvoicesService: function () {
        return {
            setupInvoices: function () {
                return;
            }
        };
    },
    violationsCmsService: function () {
        return {
            paymentPageSetup: function () {
                var paymentPageSetupOut = {};
                paymentPageSetupOut.insertionValues = "Test";
                paymentPageSetupOut.importantInfo = "Test";
                paymentPageSetupOut.violationsThankYou = "Test";
                paymentPageSetupOut.receiptPageSummary = "Test";
                return paymentPageSetupOut;
            },
            receiptPageSetup: function () {
                var receiptPageSetup = {};
                receiptPageSetup.thankYouData = "Test";
                receiptPageSetup.cmsData = "Test";
                return receiptPageSetup;
            }
        };
    },
    rssService: function (rssObj) {
        return {
            goToRssFeed: function (locationId) {
                rssObj.value = locationId;
            }
        };
    },
    accountBlockPopupService: function () {
        return {
            savePopupMessages: function (queryString) { },
            displayBlockPopup: function () { }
        };
    },
    browserExtensionHandlerService: function (inOmnitureTag) {
        return {
            sendTag: function (currentState, tagString) {
                inOmnitureTag.state = currentState;
                inOmnitureTag.tag = tagString;
            }
        };
    },
    pciInfoService: function () {
        return {
            registerCard: function (cardNum) {
                return {
                    then: function (cb) {
                        var fakeResponse = {
                            lastFour: '1234',
                            paypageRegistrationId: 'fakepaypageregistrationid'
                        };
                        if (Array.isArray(cardNum))
                            fakeResponse = [fakeResponse];
                        cb(fakeResponse);
                    }
                };
            }
        };
    },
    vantivPaymentService: function ($qFactory) {
        return {
            vantivPay: function (cardNum) {
                return null;
            }
        };
    },
    manageVehiclesGridRemote: function () {
        return {
            dataBindGrid: function () { },
            parseExtraPlateData: function () {
                return [{
                        desc: "tagless plate description",
                        licPlate: "tagless plate license plate",
                        state: "tagless plate state"
                    }];
            },
            addTaglessPlateStatusRow: function (row, descDataList) { }
        };
    },
    manageVehiclesPrintPrev: function () {
        return {
            setupGridPrint: function (accountId, windowCount) { }
        };
    },
    maintenanceService: function () {
        return {
            resolveMaintenanceStatus: function (navFeatures) { return; },
            considerMaintenancePopup: function () { return; }
        };
    },
    billingInfoUtilitiesService: function (utilitiesObj) {
        return {
            isPrimaryCCAvailable: function (billingInfo) { return utilitiesObj.isPrimary; },
            isInternationalAddress: function (objWithCountry) { return utilitiesObj.isInternational; },
            hasMultipleCards: function (cardsArray) { return utilitiesObj.hasMultiple; },
            hasNoBillingInfo: function (cardsArray) { return utilitiesObj.hasNoBillingInfo; }
        };
    },
    saveBillingService: function () {
        return {
            createSaveRequest: function (scope) { return scope; },
            saveCreditCard: function (request, nextState) { },
            saveEFT: function (request, nextState) { }
        };
    },
    hctraSpinnerService: function () {
        return {
            startSpinner: function () { },
            stopSpinner: function () { }
        };
    },
    StorefrontService: function () {
        return {
            isEnabled: function () {
                return false;
            },
            cmsRequests: {
                'hctraLogo': {
                    Path: '/sitecore/media library/Images/HCTRA/Header Footer/HCTRA_Logo',
                    Fields: 'ItemID,Alt,Width,Height'
                },
                'states': {
                    ItemId: "449337DB-4759-48A7-8982-DC56F92C1F27",
                    Fields: 'ItemId,Name,Children'
                },
                'dbIds': {
                    ItemId: "449337DB-4759-48A7-8982-DC56F92C1F27",
                    Fields: ''
                },
                'tasks': {
                    ItemId: "449337DB-4759-48A7-8982-DC56F92C1F27",
                    Fields: ''
                }
            }
        };
    }
};
(function () {
    'use strict';
    beforeEach(angular.mock.module('$$angularJSTestingModule'));
    //includes state provider
    beforeEach(angular.mock.module('ui.router'));
    beforeEach(angular.mock.module(function ($provide) {
        // Needed injected services because of index.cshtml
        $provide.constant('environmentConfig', hctraMocks.environmentConfig());
        $provide.value('loggingService', hctraMocks.loggingService());
        $provide.value('errorInterceptorService', hctraMocks.errorInterceptorService());
        $provide.value('perfToggle', hctraMocks.perfToggle());
        $provide.value('serverConstants', hctraMocks.serverConstants());
        $provide.value('sitecoreNameGuids', {});
        $provide.value('sitecoreApiParams', {});
        //use this if you need to test something 'thenable' but doesn't need to worry about digest cycles.
        $provide.factory("replacementQService", ["$window", function ($window) {
                var nativePromise = $window["Promise"] || Promise;
                var qService = function (f) { return new nativePromise(f); };
                qService.resolve = function (v) { return nativePromise.resolve(v); };
                qService.reject = function (v) { return nativePromise.reject(v); };
                qService.when = function (v) { return nativePromise.resolve(v); };
                qService.all = function (v) { return nativePromise.all(v); };
                qService.defer = function () {
                    var defer = {
                        reject: null,
                        resolve: null,
                        promise: null
                    };
                    defer.promise = new nativePromise(function (a, b) {
                        defer.reject = b;
                        defer.resolve = a;
                    });
                    return defer;
                };
                return qService;
            }]);
    }));
}());
(function (global) {
    'use strict';
    global.parent.hctraGlobalFromIndexCshtml = {
        omnitureEnv: '@uiConfig.OmnitureEnvironment'
    };
})(window);
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var UpdateBillingInformationService = /** @class */ (function () {
            function UpdateBillingInformationService(genericRepo, responseErrorService, countryConversionService, billingInfoUtilitiesService) {
                var _this = this;
                this.genericRepo = genericRepo;
                this.responseErrorService = responseErrorService;
                this.countryConversionService = countryConversionService;
                this.billingInfoUtilitiesService = billingInfoUtilitiesService;
                this.init = function ($scope) {
                    if ($scope.$parent.billingType === null || angular.isUndefined($scope.$parent.billingType)) {
                        _this.genericRepo.dataFactory.getAccountInformation().then(function (response) {
                            if (response.errors.length === 0) {
                                _this.responseErrorService.displayAlertsFromResponse(response);
                                $scope.$parent.billingInfo = response.billingInfo;
                                $scope.$parent.billingType = response.billingInfo.billingTypeDisplay;
                                $scope.$parent.creditCardTypes = response.creditCardTypes;
                                $scope.$parent.stateList = response.stateList;
                                $scope.$parent.countryList = response.countryList;
                                $scope.$parent.mailingAddress = response.billingInfo.mailingAddress;
                                if (angular.isArray(response.billingInfo.cards) && response.billingInfo.cards[0]) {
                                    $scope.$parent.billingInfo.cards[0].international = _this.billingInfoUtilitiesService.isInternationalAddress(response.billingInfo.cards[0]);
                                    if ($scope.$parent.billingInfo.cards[0].international) {
                                        $scope.$parent.billingInfo.cards[0].displayCountry = _this.countryConversionService.countryCodeToName(response.countryList, response.billingInfo.cards[0].country);
                                    }
                                }
                                if ($scope.$parent.billingType === "EFT") {
                                    _this.setEFT($scope);
                                }
                                else if ($scope.$parent.billingType === "CREDIT") {
                                    _this.setCreditCardValidation($scope);
                                }
                            }
                            else {
                                _this.responseErrorService.displayErrorsFromResponse(response);
                            }
                        });
                    }
                    else if ($scope.$parent.billingType === "EFT") {
                        _this.setEFT($scope);
                    }
                    else if ($scope.$parent.billingType === "CREDIT") {
                        _this.setCreditCardValidation($scope);
                    }
                };
                this.setEFT = function ($scope) {
                    $scope.$parent.billingInfo.eft.account2 = $scope.$parent.billingInfo.eft.accountNumber;
                    _this.setEFTValidation($scope);
                };
                this.setEFTValidation = function ($scope) {
                    $scope.validateAddress = $scope.validateCreditCard = false;
                    $scope.validateEFT = true;
                };
                this.setCreditCardValidation = function ($scope) {
                    $scope.validateAddress = $scope.validateCreditCard = true;
                    $scope.validateEFT = false;
                };
                this.changePaymentMethod = function ($scope) {
                    _this.responseErrorService.clearToasts();
                    if ($scope.$parent.billingType === "EFT") {
                        _this.setEFTValidation($scope);
                    }
                    else if ($scope.$parent.billingType === "CREDIT") {
                        _this.setCreditCardValidation($scope);
                    }
                };
            }
            UpdateBillingInformationService.$inject = ["genericRepo", "responseErrorService", "countryConversionService", "billingInfoUtilitiesService"];
            return UpdateBillingInformationService;
        }());
        Service.UpdateBillingInformationService = UpdateBillingInformationService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("updateBillingInformationService", HCTRA.Service.UpdateBillingInformationService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var BillingInfoStateManagerService = /** @class */ (function () {
            function BillingInfoStateManagerService($state, stateNames, profileStates) {
                var _this = this;
                this.$state = $state;
                this.stateNames = stateNames;
                this.profileStates = profileStates;
                this.BILLING_INFO_KEY = "BILLING_INFO_KEY";
                this.makeRedirectOccurWithlastValidState = function (redirectDecisionObject, lastValidState) {
                    redirectDecisionObject.shouldRedirect = true;
                    redirectDecisionObject.stateToRedirect = lastValidState;
                };
                this.saveBillingInformationRules = function (lastValidState, redirectDecisionObject) {
                    switch (lastValidState) {
                        case (_this.states.pos1a):
                        case (_this.states.pos1b): {
                            _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                            break;
                        }
                        case (_this.states.pos2):
                        case (_this.states.pos5):
                        case (_this.states.pos3):
                        case (_this.states.pos4):
                            break;
                        default: {
                            _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                            break;
                        }
                    }
                };
                this.updateSecondaryCreditCardRules = function (lastValidState, redirectDecisionObject, billingInfo, billingType) {
                    if (billingType !== "CREDIT" || !billingInfo || !billingInfo.cards || billingInfo.cards.length < 2) {
                        _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                    }
                    else {
                        switch (lastValidState) {
                            case (_this.states.pos1a):
                            case (_this.states.pos1b):
                            case (_this.states.pos2):
                            case (_this.states.pos4):
                                break;
                            case (_this.states.pos3): {
                                _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                                break;
                            }
                            case (_this.states.pos5):
                                break;
                            default: {
                                _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                                break;
                            }
                        }
                    }
                };
                this.addSecondaryCreditCardRules = function (lastValidState, redirectDecisionObject, billingInfo, billingType) {
                    if (billingType !== "CREDIT" || !billingInfo || !billingInfo.cards || billingInfo.cards.length !== 1) {
                        _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                    }
                    else {
                        switch (lastValidState) {
                            case (_this.states.pos1a):
                            case (_this.states.pos1b):
                            case (_this.states.pos2):
                            case (_this.states.pos3):
                                break;
                            case (_this.states.pos4): {
                                _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                                break;
                            }
                            case (_this.states.pos5):
                                break;
                            default: {
                                _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                                break;
                            }
                        }
                    }
                };
                this.updateBillingInformationRules = function (lastValidState, redirectDecisionObject) {
                    switch (lastValidState) {
                        case (_this.states.pos1a):
                        case (_this.states.pos1b):
                        case (_this.states.pos2):
                            break;
                        case (_this.states.pos3): {
                            _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                            break;
                        }
                        case (_this.states.pos4): {
                            _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                            break;
                        }
                        case (_this.states.pos5):
                            break;
                        default: {
                            _this.makeRedirectOccurWithlastValidState(redirectDecisionObject, lastValidState);
                            break;
                        }
                    }
                };
                this.stateAdvancementRules = function (desiredState, lastValidState, billingInfo, billingType) {
                    var redirectDecisionObject = {
                        shouldRedirect: false,
                        stateToRedirect: desiredState
                    };
                    if (_this.billingStateFunctions[desiredState]) {
                        // on refresh, kill
                        if (angular.isString(lastValidState)) {
                            _this.billingStateFunctions[desiredState](lastValidState, redirectDecisionObject, billingInfo, billingType);
                        }
                        else {
                            redirectDecisionObject.shouldRedirect = true;
                            redirectDecisionObject.stateToRedirect = _this.states.pos1a;
                        }
                    }
                    return redirectDecisionObject;
                };
                this.checkStateValidity = function (desiredState, billingInfo, billingType, parentStorageObject) {
                    var lastValidState = parentStorageObject[_this.BILLING_INFO_KEY];
                    var isValidState = true;
                    var redirectDecisionObject = _this.stateAdvancementRules(desiredState, lastValidState, billingInfo, billingType);
                    parentStorageObject[_this.BILLING_INFO_KEY] = redirectDecisionObject.stateToRedirect;
                    if (redirectDecisionObject.shouldRedirect) {
                        isValidState = false;
                        _this.$state.go(redirectDecisionObject.stateToRedirect);
                    }
                    return isValidState;
                };
                this.states = {
                    pos1a: this.stateNames.managePayment,
                    pos1b: this.profileStates.AccountDetails,
                    pos2: this.stateNames.updateBillingInformation,
                    pos3: this.stateNames.addSecondaryCreditCard,
                    pos4: this.stateNames.updateSecondaryCreditCard,
                    pos5: this.stateNames.saveBillingInformation
                };
                this.billingStateFunctions = {};
                this.billingStateFunctions[this.states.pos2] = function (lastValidState, redirectDecisionObject) {
                    _this.updateBillingInformationRules(lastValidState, redirectDecisionObject);
                };
                this.billingStateFunctions[this.states.pos3] = function (lastValidState, redirectDecisionObject, billingInfo, billingType) {
                    _this.addSecondaryCreditCardRules(lastValidState, redirectDecisionObject, billingInfo, billingType);
                };
                this.billingStateFunctions[this.states.pos4] = function (lastValidState, redirectDecisionObject, billingInfo, billingType) {
                    _this.updateSecondaryCreditCardRules(lastValidState, redirectDecisionObject, billingInfo, billingType);
                };
                this.billingStateFunctions[this.states.pos5] = function (lastValidState, redirectDecisionObject) {
                    _this.saveBillingInformationRules(lastValidState, redirectDecisionObject);
                };
            }
            BillingInfoStateManagerService.$inject = ["$state", "stateNames", "profileStates"];
            return BillingInfoStateManagerService;
        }());
        Service.BillingInfoStateManagerService = BillingInfoStateManagerService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("billingInfoStateManagerService", HCTRA.Service.BillingInfoStateManagerService);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var AddSecondaryCreditCardController = /** @class */ (function () {
            function AddSecondaryCreditCardController($scope, $state, stateNames, profileStates, billingInfoStateManagerService, broadcastSubmissionService) {
                var _this = this;
                this.$scope = $scope;
                this.$state = $state;
                this.stateNames = stateNames;
                this.profileStates = profileStates;
                this.billingInfoStateManagerService = billingInfoStateManagerService;
                this.broadcastSubmissionService = broadcastSubmissionService;
                this.continue = function (valid) {
                    if (valid) {
                        _this.broadcastSubmissionService.broadcast(_this.$scope.creditCardEntry.submit)
                            .then(function () {
                            _this.populateCard();
                            _this.$state.go(_this.stateNames.saveBillingInformation);
                        });
                    }
                };
                this.populateCard = function () {
                    var _a = _this.$scope.$parent.billingInfo.cards[0], address1 = _a.address1, address2 = _a.address2, city = _a.city, country = _a.country, plus4 = _a.plus4, state = _a.state, zip = _a.zip, zipCode = _a.zipCode, international = _a.international;
                    angular.extend(_this.$scope.creditCard, {
                        primary: false,
                        address1: address1,
                        address2: address2,
                        city: city,
                        country: country,
                        plus4: plus4,
                        state: state,
                        zip: zip,
                        zipCode: zipCode,
                        international: international
                    });
                    _this.$scope.$parent.billingInfo.cards.push(_this.$scope.creditCard);
                };
                angular.extend($scope, {
                    creditCardEntry: {
                        submit: 'creditCardEntry'
                    },
                    creditCard: {},
                    continue: this.continue,
                    cancel: function () { return $state.go(profileStates.AccountDetails, {}, { reload: true }); }
                });
                billingInfoStateManagerService.checkStateValidity($state.current.name, $scope.$parent.billingInfo, $scope.$parent.billingType, $scope.$parent.lastValidState);
            }
            AddSecondaryCreditCardController.$inject = [
                "$scope",
                "$state",
                "stateNames",
                "profileStates",
                "billingInfoStateManagerService",
                "broadcastSubmissionService"
            ];
            return AddSecondaryCreditCardController;
        }());
        Controller.AddSecondaryCreditCardController = AddSecondaryCreditCardController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("AddSecondaryCreditCardController", HCTRA.Controller.AddSecondaryCreditCardController);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var ManagePaymentController = /** @class */ (function () {
            function ManagePaymentController($scope, $state, stateNames, profileStates, editInvoicedMessageService, phoneNumbers, billingInfoStateManagerService, billingInfoUtilitiesService) {
                var _this = this;
                this.$scope = $scope;
                this.$state = $state;
                this.stateNames = stateNames;
                this.profileStates = profileStates;
                this.editInvoicedMessageService = editInvoicedMessageService;
                this.phoneNumbers = phoneNumbers;
                this.billingInfoStateManagerService = billingInfoStateManagerService;
                this.billingInfoUtilitiesService = billingInfoUtilitiesService;
                this.init = function () {
                    _this.billingInfoStateManagerService.checkStateValidity(_this.$state.current.name, null, null, _this.$scope.$parent.lastValidState);
                    // Requirement 14546: Work around for Blank billing info for accouns failed rebill 3 times
                    // Done originally in the parent controller but must be here too in case of navigation to this state without reloading the parent
                    if (angular.isObject(_this.$scope.billingInfo) && _this.billingInfoUtilitiesService.hasNoBillingInfo(_this.$scope.billingInfo)) {
                        _this.$state.go(_this.stateNames.updateBillingInformation);
                    }
                };
                this.init();
                $scope.addSecondaryPayment = function () {
                    return $state.go(stateNames.addSecondaryCreditCard);
                };
                $scope.editSecondaryCreditCard = function () {
                    return $state.go(stateNames.updateSecondaryCreditCard);
                };
                $scope.editPrimaryCreditCard = function () {
                    return $state.go(stateNames.updateBillingInformation);
                };
                $scope.editBank = function () {
                    return $state.go(stateNames.updateBillingInformation);
                };
                $scope.cancel = function () {
                    return $state.go(profileStates.AccountDetails);
                };
                $scope.onEditInvoiced = function () { return editInvoicedMessageService.setPhoneNumberDisplay(phoneNumbers.invoicedAccountSupport.display).invoicedMessage(); };
            }
            ManagePaymentController.$inject = ["$scope",
                "$state",
                "stateNames",
                "profileStates",
                "editInvoicedMessageService",
                "phoneNumbers",
                "billingInfoStateManagerService",
                "billingInfoUtilitiesService"];
            return ManagePaymentController;
        }());
        Controller.ManagePaymentController = ManagePaymentController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("ManagePaymentController", HCTRA.Controller.ManagePaymentController);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var ManagePaymentParentController = /** @class */ (function () {
            function ManagePaymentParentController($scope, genericRepo, responseErrorService, billingInfoStateManagerService, $state, countryConversionService, billingInfoUtilitiesService, stateNames) {
                var _this = this;
                this.$scope = $scope;
                this.genericRepo = genericRepo;
                this.responseErrorService = responseErrorService;
                this.billingInfoStateManagerService = billingInfoStateManagerService;
                this.$state = $state;
                this.countryConversionService = countryConversionService;
                this.billingInfoUtilitiesService = billingInfoUtilitiesService;
                this.stateNames = stateNames;
                this.init = function () {
                    _this.billingInfoStateManagerService.checkStateValidity(_this.$state.current.name, null, null, _this.$scope.lastValidState);
                    _this.genericRepo.dataFactory.getManagePaymentInformation().then(function (response) {
                        if (response.errors.length === 0) {
                            _this.responseErrorService.displayAlertsFromResponse(response);
                            _this.$scope.billingInfo = response.billingInfo;
                            _this.$scope.billingType = response.billingInfo.billingTypeDisplay;
                            _this.$scope.creditCardTypes = response.creditCardTypes;
                            _this.$scope.stateList = response.stateList;
                            _this.$scope.countryList = response.countryList;
                            _this.$scope.mailingAddress = response.billingInfo.mailingAddress;
                            _this.$scope.multiplecards = _this.billingInfoUtilitiesService.hasMultipleCards(response.billingInfo.cards);
                            if (angular.isArray(response.billingInfo.cards) && response.billingInfo.cards[0]) {
                                _this.$scope.billingInfo.cards[0].international = _this.billingInfoUtilitiesService.isInternationalAddress(response.billingInfo.cards[0]);
                                if (_this.$scope.billingInfo.cards[0].international) {
                                    _this.$scope.billingInfo.cards[0].displayCountry = _this.countryConversionService.countryCodeToName(response.countryList, response.billingInfo.cards[0].country);
                                }
                            }
                            // Check to see if there's a primary card set
                            _this.$scope.isPrimarySet = _this.billingInfoUtilitiesService.isPrimaryCCAvailable(response.billingInfo);
                            // Requirement 14546: Work around for Blank billing info for accounts failed rebill 3 times
                            if (_this.$scope.billingType !== 'INVOICE') {
                                if (_this.billingInfoUtilitiesService.hasNoBillingInfo(_this.$scope.billingInfo)) {
                                    _this.$state.go(_this.stateNames.updateBillingInformation);
                                }
                            }
                        }
                        else {
                            _this.responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                };
                $scope.lastValidState = {};
                this.init();
            }
            ManagePaymentParentController.$inject = ["$scope",
                "genericRepo",
                "responseErrorService",
                "billingInfoStateManagerService",
                "$state",
                "countryConversionService",
                "billingInfoUtilitiesService",
                "stateNames"];
            return ManagePaymentParentController;
        }());
        Controller.ManagePaymentParentController = ManagePaymentParentController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("ManagePaymentParentController", HCTRA.Controller.ManagePaymentParentController);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var SaveBillingInformationController = /** @class */ (function () {
            function SaveBillingInformationController($scope, $state, stateNames, profileStates, saveBillingService, billingInfoStateManagerService) {
                var _this = this;
                this.$scope = $scope;
                this.$state = $state;
                this.stateNames = stateNames;
                this.profileStates = profileStates;
                this.saveBillingService = saveBillingService;
                this.billingInfoStateManagerService = billingInfoStateManagerService;
                this.init = function () {
                    _this.billingInfoStateManagerService.checkStateValidity(_this.$state.current.name, _this.$scope.$parent.billingInfo, _this.$scope.$parent.billingType, _this.$scope.$parent.lastValidState);
                };
                $scope.addSecondaryPayment = function () {
                    return $state.go(stateNames.addSecondaryCreditCard);
                };
                $scope.editSecondaryCreditCard = function () {
                    return $state.go(stateNames.updateSecondaryCreditCard);
                };
                $scope.editPrimaryCreditCard = function () {
                    return $state.go(stateNames.updateBillingInformation);
                };
                $scope.editBank = function () {
                    return $state.go(stateNames.updateBillingInformation);
                };
                $scope.cancel = function () {
                    // Force a controller reload so that account info parent will make an api call
                    return $state.go(_this.profileStates.AccountDetails, {}, { reload: true });
                };
                $scope.save = function () {
                    // Anything done here must be applied in the Close Account & Make Payment update billing information path as well
                    var request = saveBillingService.createSaveRequest($scope);
                    if ($scope.billingType === "CREDIT") {
                        return saveBillingService.saveCreditCard(request, _this.profileStates.AccountDetails);
                    }
                    else {
                        return saveBillingService.saveEFT(request, _this.profileStates.AccountDetails);
                    }
                };
                this.init();
            }
            SaveBillingInformationController.$inject = ["$scope",
                "$state",
                "stateNames",
                "profileStates",
                "saveBillingService",
                "billingInfoStateManagerService"];
            return SaveBillingInformationController;
        }());
        Controller.SaveBillingInformationController = SaveBillingInformationController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("SaveBillingInformationController", HCTRA.Controller.SaveBillingInformationController);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var UpdateBillingInformationController = /** @class */ (function () {
            function UpdateBillingInformationController($scope, profileStates, $state, stateNames, $timeout, $anchorScroll, billingInfoStateManagerService, isInvoicedService, updateBillingInformationService, $rootScope, billingInfoUtilitiesService, modalService, routes, genericRepo, stringUtilsService, responseErrorService, broadcastSubmissionService) {
                var _this = this;
                this.$scope = $scope;
                this.profileStates = profileStates;
                this.$state = $state;
                this.stateNames = stateNames;
                this.$timeout = $timeout;
                this.$anchorScroll = $anchorScroll;
                this.billingInfoStateManagerService = billingInfoStateManagerService;
                this.isInvoicedService = isInvoicedService;
                this.updateBillingInformationService = updateBillingInformationService;
                this.$rootScope = $rootScope;
                this.billingInfoUtilitiesService = billingInfoUtilitiesService;
                this.modalService = modalService;
                this.routes = routes;
                this.genericRepo = genericRepo;
                this.stringUtilsService = stringUtilsService;
                this.responseErrorService = responseErrorService;
                this.broadcastSubmissionService = broadcastSubmissionService;
                this.init = function () {
                    if (_this.billingInfoStateManagerService.checkStateValidity(_this.$state.current.name, _this.$scope.$parent.billingInfo, _this.$scope.$parent.billingType, _this.$scope.$parent.lastValidState)) {
                        _this.$scope.isAccountInvoiced = _this.isInvoicedService.isAccountInvoiced();
                        if (_this.$scope.$parent.billingInfo) {
                            if (_this.$scope.$parent.billingInfo.eft)
                                _this.$scope.$parent.billingInfo.eft.account2 = _this.$scope.$parent.billingInfo.eft.accountNumber;
                        }
                        if (_this.$scope.billingType === "EFT") {
                            _this.updateBillingInformationService.setEFTValidation(_this.$scope);
                        }
                        else if (_this.$scope.billingType === "CREDIT") {
                            _this.updateBillingInformationService.setCreditCardValidation(_this.$scope);
                        }
                        // Requirement 14546: Work around for Blank billing info for accouns failed rebill 3 times
                        if (_this.billingInfoUtilitiesService.hasNoBillingInfo(_this.$scope.$parent.billingInfo)) {
                            _this.getCMSContentModal();
                        }
                    }
                };
                this.getCMSContentModal = function () {
                    return _this.genericRepo.dataFactory.getCmsPageById({ itemId: _this.routes.updateBillingInfoPage }).then(function (res) {
                        if (res.errors && res.errors.length === 0) {
                            var getUrlParameter = function (name) { return _this.stringUtilsService.getUrlParameter(name, angular.fromJson(res.cmsResponse).Popups); };
                            var modalOptions = {
                                closeButtonText: getUrlParameter("NoBillingInfoPopupButton"),
                                headerText: getUrlParameter("NoBillingInfoPopupHeader"),
                                bodyText: getUrlParameter("NoBillingInfoPopupBody")
                            };
                            _this.modalService.showModal({
                                templateUrl: "/app/templates/common/modalAlert.html"
                            }, modalOptions);
                        }
                        else {
                            _this.responseErrorService.displayErrorsFromResponse(res);
                        }
                    });
                };
                $scope.creditCardEntry = {
                    submit: 'creditCardEntry'
                };
                $scope.continue = function (valid) {
                    return $timeout(function () {
                        //make sure a payment method was selected
                        if (!$scope.$parent.billingType) {
                            $scope.paymentsform.paymentmethod.$setValidity('required', false);
                            return;
                        }
                        if (!valid) {
                            $anchorScroll("topOfPage");
                            return;
                        }
                        if ($scope.$parent.billingInfo.cards[0]) {
                            $scope.$parent.billingInfo.cards[0].primary = true;
                        }
                        if ($scope.$parent.billingType === "EFT") {
                            var _a = $scope.$parent.billingInfo.eft, accountType = _a.accountType, routingNumber = _a.routingNumber, accountNumber = _a.accountNumber;
                            return _this.genericRepo.dataFactory.eftValidateRouting({
                                AccountType: accountType,
                                RoutingNumber: routingNumber,
                                AccountNumber: accountNumber
                            }).then(function (response) {
                                if (response.alerts.length !== 0) {
                                    _this.responseErrorService.displayAlertsFromResponse(response, true);
                                }
                                return $state.go(stateNames.saveBillingInformation);
                            });
                        }
                        else {
                            return _this.broadcastSubmissionService.broadcast($scope.creditCardEntry.submit)
                                .then(function () { return $state.go(stateNames.saveBillingInformation); })
                                .catch(function () { return $anchorScroll("topOfPage"); });
                        }
                    });
                };
                $scope.cancel = function () { return $state.go(_this.profileStates.AccountDetails, {}, { reload: true }); };
                $scope.changePaymentMethod = function () {
                    updateBillingInformationService.changePaymentMethod($scope);
                    if (angular.isString($scope.paymentsform.paymentmethod.$modelValue) && $scope.paymentsform.paymentmethod.$modelValue !== "") {
                        $scope.paymentsform.paymentmethod.$setValidity('required', true);
                    }
                };
                this.init();
            }
            UpdateBillingInformationController.$inject = ["$scope",
                "profileStates",
                "$state",
                "stateNames",
                "$timeout",
                "$anchorScroll",
                "billingInfoStateManagerService",
                "isInvoicedService",
                "updateBillingInformationService",
                "$rootScope",
                "billingInfoUtilitiesService",
                "modalService",
                "routes",
                "genericRepo",
                "stringUtilsService",
                "responseErrorService",
                "broadcastSubmissionService"];
            return UpdateBillingInformationController;
        }());
        Controller.UpdateBillingInformationController = UpdateBillingInformationController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("UpdateBillingInformationController", HCTRA.Controller.UpdateBillingInformationController);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("UpdateSecondaryCreditCardController", ['profileStates', '$scope', '$state', 'stateNames', 'validationService', 'billingInfoStateManagerService', 'broadcastSubmissionService',
        function (profileStates, $scope, $state, stateNames, validationService, billingInfoStateManagerService, broadcastSubmissionService) {
            $scope.creditCardEntry = {
                submit: 'creditCardEntry'
            };
            $scope.creditCard = $scope.$parent.billingInfo.cards[1];
            billingInfoStateManagerService.checkStateValidity($state.current.name, $scope.$parent.billingInfo, $scope.$parent.billingType, $scope.$parent.lastValidState);
            var unwatch = $scope.$watch('paymentsform', function () {
                if ($scope.paymentsform) {
                    $scope.validations = validationService($scope.paymentsform);
                    unwatch();
                }
            });
            $scope.continue = function (valid) {
                if (valid) {
                    if ($scope.$parent.billingInfo.cards[1])
                        $scope.$parent.billingInfo.cards[1].primary = false;
                    return broadcastSubmissionService.broadcast($scope.creditCardEntry.submit)
                        .then(function () { return $state.go(stateNames.saveBillingInformation); });
                }
            };
            $scope.cancel = function () { return $state.go(profileStates.AccountDetails, {}, { reload: true }); };
        }]);
}());
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller("NewAccountController", ['$scope', '$location', 'genericRepo', '$rootScope', 'AUTH_EVENTS', 'newAccountService', 'SessionService', '$state', 'routes', 'AuthService', 'responseErrorService',
        function ($scope, $location, genericRepo, $rootScope, AUTH_EVENTS, newAccountService, SessionService, $state, routes, AuthService, responseErrorService) {
            var unregisterNewAccountData = $rootScope.$on(AUTH_EVENTS.logoutSuccess, function () {
                //$scope.$parent.logAction('NewAcct-LogoutClearData', 'Clear New Account data on logout');
                newAccountService.clearData();
                newAccountService.clearPaymentData();
                newAccountService.setTransactionId(null);
                newAccountService.setDeliveryMethod(null);
            });
            $rootScope.$on("$destroy", function () {
                unregisterNewAccountData();
            });
            $scope.$on("$destroy", function () {
                //$scope.$parent.logAction('NewAcct-scopeDestroy', 'Clear New Account data on scope destruction');
                newAccountService.clearData();
                newAccountService.clearPaymentData();
                newAccountService.setTransactionId(null);
                newAccountService.setDeliveryMethod(null);
                // Requirement 60300: Motorocycle flag change
                //newAccountService.clearVehicleList();
            });
            $scope.fromEditScreen = false;
            $scope.stepClass = function (spanStep) {
                return ($scope.stepNum == spanStep) ? 'stepOn' : 'step';
            };
            if ($location.url() == routes.newAccount) { // If this state's url was specifically navigated to
                var currentStep = parseInt(SessionService.getCurrentStep(), 10);
                // Only incomplete accounts can be authenticated and still make it to this point
                // So, in essence, we're checking to see if they're incomplete
                // but do not have a known currentStep
                if (AuthService.isAuthenticated() && isNaN(currentStep)) {
                    genericRepo.dataFactory.getCurrentStep().then(function (res) {
                        if (res.errors.length === 0) {
                            var currentStep = res.newAccountStep.currentStep;
                            SessionService.setCurrentStep(currentStep);
                            $state.go(SessionService.stepToStateName(currentStep), {}, { location: 'replace' });
                        }
                        else {
                            responseErrorService.displayErrorsFromResponse(res);
                        }
                    });
                }
                else {
                    $state.go(SessionService.stepToStateName(currentStep), {}, { location: 'replace' });
                }
            }
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var NewAccountService = /** @class */ (function () {
            function NewAccountService(webStorage) {
                var _this = this;
                this.webStorage = webStorage;
                this.payment = new HCTRA.Model.PaymentCalculation();
                this.flexbookerFlag = false;
                this.setCompanyName = function (companyName) {
                    sessionStorage.setItem("NA_companyName", companyName);
                };
                this.setFirstName = function (firstName) {
                    sessionStorage.setItem("NA_firstName", firstName);
                };
                this.setLastName = function (lastName) {
                    sessionStorage.setItem("NA_lastName", lastName);
                };
                this.setTransactionId = function (newTransactionId) {
                    _this.transactionId = newTransactionId;
                };
                this.setTagSalesAmt = function (newTagSalesAmt) {
                    _this.payment.tagSalesAmt = newTagSalesAmt;
                };
                this.setDepositAmt = function (newDepositAmt) {
                    _this.payment.depositAmt = newDepositAmt;
                };
                this.setTotalAmt = function (newTotalAmt) {
                    _this.payment.totalAmt = newTotalAmt;
                };
                this.setLowBalanceAmt = function (newLowBalanceAmt) {
                    _this.payment.lowBalanceAmt = newLowBalanceAmt;
                };
                this.setRebillAmt = function (newRebillAmt) {
                    _this.payment.rebillAmt = newRebillAmt;
                };
                this.setDeliveryMethod = function (newDeliveryMethod) {
                    _this.deliveryMethod = newDeliveryMethod;
                };
                this.setSkipScheduling = function (willSkipScheduling) {
                    _this.skipScheduling = willSkipScheduling;
                };
                this.setFlexbookerFlag = function (flexbookerFlag) {
                    _this.flexbookerFlag = flexbookerFlag;
                };
                this.getCompanyName = function () {
                    return sessionStorage.getItem("NA_companyName");
                };
                this.getFirstName = function () {
                    return sessionStorage.getItem("NA_firstName");
                };
                this.getLastName = function () {
                    return sessionStorage.getItem("NA_lastName");
                };
                this.getTransactionId = function () {
                    return _this.transactionId;
                };
                this.getTagSalesAmt = function () {
                    return _this.payment.tagSalesAmt;
                };
                this.getDepositAmt = function () {
                    return _this.payment.depositAmt;
                };
                this.getTotalAmt = function () {
                    return _this.payment.totalAmt;
                };
                this.getDeliveryMethod = function () {
                    return _this.deliveryMethod;
                };
                this.getSkipScheduling = function () {
                    return _this.skipScheduling;
                };
                this.getFlexbookerFlag = function () {
                    return _this.flexbookerFlag;
                };
                this.setAccountInfo = function (info) {
                    _this.setCompanyName(info.companyName);
                    _this.setFirstName(info.firstName);
                    _this.setLastName(info.lastName);
                };
                this.getAccountInfo = function () {
                    return {
                        companyName: _this.getCompanyName(),
                        firstName: _this.getFirstName(),
                        lastName: _this.getLastName()
                    };
                };
                this.setPayment = function (info) {
                    _this.setTagSalesAmt(info.tagSalesAmt);
                    _this.setDepositAmt(info.depositAmt);
                    _this.setTotalAmt(info.totalAmt);
                    _this.setLowBalanceAmt(info.lowBalanceAmt);
                    _this.setRebillAmt(info.rebillAmt);
                };
                this.getPayment = function () {
                    return {
                        tagSalesAmt: _this.payment.tagSalesAmt,
                        depositAmt: _this.payment.depositAmt,
                        totalAmt: _this.payment.totalAmt,
                        lowBalanceAmt: _this.payment.lowBalanceAmt,
                        rebillAmt: _this.payment.rebillAmt
                    };
                };
                this.setVehicleList = function (vehicleList) {
                    _this.webStorage.setKeyValue("NA_vehicleList", vehicleList);
                };
                this.getVehicleList = function () {
                    return _this.webStorage.getValue("NA_vehicleList");
                };
                this.clearVehicleList = function () {
                    _this.webStorage.removeEntry("NA_vehicleList");
                };
                this.localDataExists = function () {
                    var hasFirstName = !!_this.getFirstName();
                    var hasLastName = !!_this.getLastName();
                    return hasFirstName && hasLastName;
                };
                this.paymentExists = function () {
                    var hasTagSalesAmt = angular.isNumber(_this.payment.tagSalesAmt);
                    var hasDepositAmt = angular.isNumber(_this.payment.depositAmt);
                    var hasTotalAmt = angular.isNumber(_this.payment.totalAmt);
                    var hasLowBalanceAmt = angular.isNumber(_this.payment.lowBalanceAmt);
                    var hasRebillAmt = angular.isNumber(_this.payment.rebillAmt);
                    return hasTagSalesAmt && hasDepositAmt && hasTotalAmt && hasLowBalanceAmt && hasRebillAmt;
                };
                this.transactionIdExists = function () {
                    return !!_this.transactionId;
                };
                this.clearData = function () {
                    sessionStorage.removeItem("NA_companyName");
                    sessionStorage.removeItem("NA_firstName");
                    sessionStorage.removeItem("NA_lastName");
                };
                this.clearPaymentData = function () {
                    _this.payment = new HCTRA.Model.PaymentCalculation();
                };
            }
            NewAccountService.$inject = ["webStorage"];
            return NewAccountService;
        }());
        Service.NewAccountService = NewAccountService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("newAccountService", HCTRA.Service.NewAccountService);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var CreateAccountController = /** @class */ (function () {
            function CreateAccountController($scope, $rootScope, $state, newAccountService, responseErrorService, genericRepo, AuthService, stateNames, $anchorScroll, validationService, hctraSessionLogin, AUTH_EVENTS, SessionService, NamesToCurrentUserService, routes, CurrentUser, stringUtilsService) {
                var _this = this;
                this.$scope = $scope;
                this.$rootScope = $rootScope;
                this.$state = $state;
                this.newAccountService = newAccountService;
                this.responseErrorService = responseErrorService;
                this.genericRepo = genericRepo;
                this.AuthService = AuthService;
                this.stateNames = stateNames;
                this.$anchorScroll = $anchorScroll;
                this.validationService = validationService;
                this.hctraSessionLogin = hctraSessionLogin;
                this.AUTH_EVENTS = AUTH_EVENTS;
                this.SessionService = SessionService;
                this.NamesToCurrentUserService = NamesToCurrentUserService;
                this.routes = routes;
                this.CurrentUser = CurrentUser;
                this.stringUtilsService = stringUtilsService;
                this.isValid = function (input) { return _this.$scope.form.personalAccountForm[input] && _this.$scope.form.personalAccountForm[input].$valid; };
                this.populateSecurityQuestions = function (response) {
                    return _this.$scope.securityQuestions = _this.responseErrorService.isErrorFree(response) ? response.securityQuestions : [];
                };
                this.populateAccountInfo = function (response) {
                    if (_this.responseErrorService.isErrorFree(response) && response.accountInfoExists && !_this.newAccountService.localDataExists()) {
                        angular.extend(_this.$scope.accountInfo, {
                            companyName: response.companyName,
                            firstName: response.firstName,
                            lastName: response.lastName
                        });
                    }
                };
                this.onSubmit = function (isValid) {
                    if (isValid) {
                        _this.$scope.accountInfo.companyName = _this.$scope.accountInfo.companyName || "";
                        _this.newAccountService.setAccountInfo(_this.$scope.accountInfo);
                        if (_this.$scope.isLoggedIn) {
                            _this.NamesToCurrentUserService.setNamesToCurrentUser(_this.$scope.accountInfo.firstName, _this.$scope.accountInfo.lastName, _this.$scope.accountInfo.companyName);
                            _this.$state.go(_this.stateNames.createAccountDetails);
                        }
                        else {
                            _this.genericRepo.dataFactory.setupAccountStep1(_this.$scope.accountInfo).then(function (response) {
                                if (_this.responseErrorService.isErrorFree(response)) {
                                    _this.hctraSessionLogin.login(response.acctId, response.acctActivity, response.newAccountStep.currentStep);
                                    _this.CurrentUser.updateCurrentUser(response);
                                    _this.$rootScope.$broadcast(_this.AUTH_EVENTS.loginSuccess, response);
                                    var savedStep = _this.SessionService.getCurrentStep();
                                    if (savedStep === null || parseInt(savedStep, 10) <= _this.$scope.stepNum)
                                        _this.SessionService.setCurrentStep(_this.$scope.stepNum);
                                    _this.$state.go(_this.stateNames.createAccountDetails);
                                }
                            });
                        }
                    }
                };
                this.populateCmsParams = function (res) {
                    if (_this.responseErrorService.isErrorFree(res)) {
                        var parsedRes = angular.fromJson(res.cmsResponse);
                        var parsedParams = _this.stringUtilsService.getParameterObject(parsedRes.Parameters);
                        _this.$scope.createAccVM.existingEzTagNotice = parsedRes.LongDescription;
                        _this.$scope.createAccVM.pwPlaceHolder = parsedParams["PasswordPlaceholder"];
                        _this.$scope.createAccVM.minPassword = parsedParams["MinPassword"];
                        _this.$scope.createAccVM.maxPassword = parsedParams["MaxPassword"];
                        _this.$scope.createAccVM.invalidCharacter = parsedParams["InvalidCharacter"];
                    }
                };
                $scope.$parent.stepNum = 1;
                $anchorScroll();
                $scope.createAccVM = {};
                angular.extend($scope, {
                    form: {},
                    confirmModels: {},
                    isLoggedIn: AuthService.isAuthenticated(),
                    accountInfo: newAccountService.getAccountInfo() || {},
                    toSetupOnlineAccess: function () { return $state.go(stateNames.setupOnlineAccessIdentification); },
                    isValid: this.isValid,
                    onSubmit: this.onSubmit
                });
                genericRepo.dataFactory.getPersonalInfo().then(this.populateAccountInfo);
                genericRepo.dataFactory.getSecurityQuestions().then(this.populateSecurityQuestions);
                genericRepo.dataFactory.getCmsPageById({ ItemId: routes.createAccountCMS }).then(this.populateCmsParams);
                var unwatch = $scope.$watch('form', function () {
                    if ($scope.form.personalAccountForm) {
                        $scope.validations = validationService(_this.$scope.form.personalAccountForm);
                        unwatch();
                    }
                });
            }
            CreateAccountController.$inject = [
                "$scope",
                "$rootScope",
                "$state",
                "newAccountService",
                "responseErrorService",
                "genericRepo",
                "AuthService",
                "stateNames",
                "$anchorScroll",
                "validationService",
                "hctraSessionLogin",
                "AUTH_EVENTS",
                "SessionService",
                "NamesToCurrentUserService",
                "routes",
                "CurrentUser",
                "stringUtilsService"
            ];
            return CreateAccountController;
        }());
        Controller.CreateAccountController = CreateAccountController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("CreateAccountController", HCTRA.Controller.CreateAccountController);
    //moved here since this is the only place it's used and I wanted to kill that folder!
    angular.module('HCTRAModule').service('NamesToCurrentUserService', ['$rootScope',
        function ($rootScope) {
            this.setNamesToCurrentUser = function (firstName, lastName, companyName) {
                $rootScope.currentUser.firstName = firstName;
                $rootScope.currentUser.lastName = lastName;
                $rootScope.currentUser.companyName = companyName;
            };
        }]);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var CreateAccountDetailsController = /** @class */ (function () {
            function CreateAccountDetailsController($scope, $rootScope, $state, newAccountService, responseErrorService, genericRepo, stateNames, $anchorScroll, validationService, SessionService, billingInfoUtilitiesService, CurrentUser, APP_LIFECYCLE_EVENTS, environmentConfig) {
                var _this = this;
                this.$scope = $scope;
                this.$rootScope = $rootScope;
                this.$state = $state;
                this.newAccountService = newAccountService;
                this.responseErrorService = responseErrorService;
                this.genericRepo = genericRepo;
                this.stateNames = stateNames;
                this.$anchorScroll = $anchorScroll;
                this.validationService = validationService;
                this.SessionService = SessionService;
                this.billingInfoUtilitiesService = billingInfoUtilitiesService;
                this.CurrentUser = CurrentUser;
                this.APP_LIFECYCLE_EVENTS = APP_LIFECYCLE_EVENTS;
                this.environmentConfig = environmentConfig;
                this.populateAccountDetails = function (response) {
                    if (_this.responseErrorService.isErrorFree(response)) {
                        angular.extend(_this.$scope, {
                            countryList: response.mailingAddress.countryList,
                            statesList: response.mailingAddress.stateList,
                            authContactLimit: response.authContactLimit
                        });
                        if (response.accountInfoExists) {
                            var isInternational = _this.billingInfoUtilitiesService.isInternationalAddress(response);
                            angular.extend(_this.$scope.accountDetails, {
                                isEdit: true,
                                address1: response.address1,
                                address2: response.address2,
                                address3: response.address3,
                                address4: response.address4,
                                country: isInternational ? response.country : null,
                                altPhoneNumberExt: response.workPhoExt,
                                altPhoneNumber: response.workPhoNbr,
                                city: response.city,
                                companyName: angular.isString(_this.$scope.accountDetails.companyName) ? _this.$scope.accountDetails.companyName : response.companyName,
                                taxId: response.companyTaxId,
                                driverLicNumber: response.driverLicNbr,
                                driverLicState: response.driverLicState || "TX",
                                firstName: _this.$scope.accountDetails.firstName || response.firstName,
                                lastName: _this.$scope.accountDetails.lastName || response.lastName,
                                plus4: response.plus4,
                                primaryPhone: response.homePhoNbr,
                                state: response.state || "TX",
                                zip: response.zip,
                                accountPreferences: response.accountPreferences,
                                internationalAddress: isInternational,
                                authorizedContacts: response.authorizedContactList
                            });
                        }
                    }
                };
                this.onSubmit = function (isValid) {
                    if (isValid) {
                        _this.$scope.contactsSubmitted();
                        _this.$scope.accountDetails.alternatePhone = _this.$scope.accountDetails.altPhoneNumber;
                        _this.$scope.accountDetails.altPhoneExt = _this.$scope.accountDetails.altPhoneNumberExt;
                        _this.genericRepo.dataFactory.setPersonalInfo(_this.$scope.accountDetails).then(function (response) {
                            if (_this.responseErrorService.isErrorFree(response)) {
                                _this.CurrentUser.setCurrentUser();
                                _this.$rootScope.$broadcast(_this.APP_LIFECYCLE_EVENTS.newAccountNameEntered);
                                var savedStep = _this.SessionService.getCurrentStep();
                                if (savedStep == null || parseInt(savedStep, 10) <= _this.$scope.stepNum)
                                    _this.SessionService.setCurrentStep(_this.$scope.stepNum + 1);
                                // If transactionId was passed in, the API will pass back the same Id
                                _this.newAccountService.setTransactionId(response.transactionId);
                                if (response.tagCostExists)
                                    _this.newAccountService.setPayment(response);
                                if (_this.$scope.fromEditScreen)
                                    _this.$state.go(_this.stateNames.createAccountSummary);
                                else
                                    _this.$state.go(_this.stateNames.addEZTag);
                            }
                        });
                    }
                };
                $scope.$parent.stepNum = 2;
                $anchorScroll('new-account-title');
                $scope.removeDL = environmentConfig.removeDL;
                angular.extend($scope, {
                    form: {},
                    accountDetails: angular.extend({
                        isEdit: false,
                        driverLicState: "TX",
                        state: "TX",
                        transactionId: newAccountService.getTransactionId(),
                        acctType: "personal",
                        internationalAddress: false,
                        authorizedContacts: [],
                        accountPreferences: {
                            byEmail: true,
                            emailStatement: true
                        }
                    }, newAccountService.getAccountInfo()),
                    statesList: [],
                    loggedIn: false,
                    tentativeAuthorizedContact: {},
                    onPrevious: function () { return $state.go(stateNames.createAccount); },
                    onSubmit: this.onSubmit
                });
                genericRepo.dataFactory.getPersonalInfo().then(this.populateAccountDetails);
                var unwatch = $scope.$watch('form', function () {
                    if ($scope.form.personalInformationForm) {
                        $scope.validations = validationService($scope.form.personalInformationForm);
                        unwatch();
                    }
                });
            }
            CreateAccountDetailsController.$inject = [
                "$scope",
                "$rootScope",
                "$state",
                "newAccountService",
                "responseErrorService",
                "genericRepo",
                "stateNames",
                "$anchorScroll",
                "validationService",
                "SessionService",
                "billingInfoUtilitiesService",
                "CurrentUser",
                "APP_LIFECYCLE_EVENTS",
                "environmentConfig"
            ];
            return CreateAccountDetailsController;
        }());
        Controller.CreateAccountDetailsController = CreateAccountDetailsController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("CreateAccountDetailsController", HCTRA.Controller.CreateAccountDetailsController);
})();
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller("AddAdditionalVehicleController", ['$scope', '$state', 'stateNames', 'responseErrorService', 'SessionService',
        function ($scope, $state, stateNames, responseErrorService, SessionService) {
            // Shouldn't be necessary, but just in case
            if (!$scope.hasVehicles())
                $state.go(stateNames.vehicleInformation);
            $scope.onAddAdditionalVehicle = function () {
                $scope.$parent.repoName = "addEZTag";
                $scope.$parent.isEdit = false;
                $state.go(stateNames.vehicleInformation);
            };
            $scope.onContinue = function () {
                var savedStep = SessionService.getCurrentStep();
                if (savedStep == null || parseInt(savedStep, 10) <= $scope.stepNum)
                    SessionService.setCurrentStep($scope.stepNum + 1);
                if (!$scope.hasVehicles()) { // Shouldn't be necessary, but just in case
                    responseErrorService.displayToast("Please add a vehicle");
                    $state.go(stateNames.vehicleInformation);
                }
                else {
                    // Requirement 60300: Motorocycle flag change
                    //if ($scope.$parent.vehicleList || angular.isUndefined($scope.$parent.vehicleList)) {
                    //    newAccountService.setVehicleList($scope.$parent.vehicleList);
                    //};
                    if ($scope.fromEditScreen)
                        $state.go(stateNames.createAccountSummary);
                    else
                        $state.go(stateNames.choosePaymentMethod);
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller("AddEZTAGController", ['$scope', '$state', '$anchorScroll', 'localDataRepo', 'genericRepo', 'responseErrorService', 'tagList', 'stateNames', '$rootScope', 'newAccountService', 'modalService', '$timeout',
        function ($scope, $state, $anchorScroll, localDataRepo, genericRepo, responseErrorService, tagList, stateNames, $rootScope, newAccountService, modalService, $timeout) {
            $scope.$parent.stepNum = 3;
            $anchorScroll('new-account-title');
            $scope.form = {};
            $scope.repoName = "addEZTag";
            $scope.isEdit = false;
            $scope.vehicleInfo = {};
            $scope.stateBeforeAddEZTag = $rootScope.previousState;
            tagList.accountTags.forEach(function (elem) {
                if (elem.nickname == (elem.licState + "-" + elem.licPlate)) {
                    elem.nickname = null;
                }
            });
            // Retrieve transactionId from memory (or undefined if it isn't saved)
            //$scope.vehicleInfo.transactionId = newAccountService.getTransactionId();
            // Requirement 60300: Motorocycle flag change
            //$scope.vehicleList = newAccountService.getVehicleList() || [];
            $scope.vehicleList = []; // List to be submitted to WS
            // Requirement 60300: Motorocycle flag change
            // Re-added
            $scope.vehicleList = tagList.accountTags;
            // moves assignments to next digest cycle
            $timeout(function () {
                $scope.statesList = tagList.states;
                $scope.makesList = tagList.vehicleMakes;
            });
            $scope.hasVehicles = function () {
                return $scope.vehicleList.length > 0;
            };
            // If list contains at least one vehicle, skip over the form
            if ($scope.hasVehicles())
                $state.go(stateNames.addAdditionalVehicle, {}, { location: 'replace' });
            else
                $state.go(stateNames.vehicleInformation, {}, { location: 'replace' });
            $scope.classList = localDataRepo.getClasses(); // Axle classifications
            $scope.yearsList = localDataRepo.getModelYears(); // Years from 1900 to present year + 1
            $scope.makesList = [];
            $scope.statesList = [];
            $scope.classIdToLabel = function (id) {
                var label;
                $scope.classList.forEach(function (elem) {
                    if (elem.value == id) {
                        label = elem.label;
                        return;
                    }
                });
                return label;
            };
            $scope.onEdit = function (id) {
                $scope.editId = id;
                $scope.repoName = "updateEZTag";
                $scope.isEdit = true;
                $scope.vehicleInfo = angular.extend({}, $scope.vehicleList[id]);
                $scope.vehicleInfo.vehicleClassCode = parseInt($scope.vehicleInfo.vehicleClassCode);
                $state.go(stateNames.vehicleInformation);
            };
            $scope.onDelete = function (id) {
                $scope.vehicleList[id].transactionId = newAccountService.getTransactionId();
                var modalOptions = {
                    closeButtonText: 'Cancel',
                    actionButtonText: 'Delete Tag',
                    headerText: 'Delete Tag?',
                    bodyText: 'Are you sure you want to delete the Tag with License Plate ' + $scope.vehicleList[id].licState + ' - ' + $scope.vehicleList[id].licPlate + '?'
                };
                modalService.showModal({}, modalOptions).then(function () {
                    genericRepo.dataFactory.deleteEZTag($scope.vehicleList[id]).then(function (res) {
                        var hasErrors = res.errors.length > 0;
                        if (hasErrors) {
                            responseErrorService.displayErrorsFromResponse(res);
                        }
                        else { // Successful delete
                            $scope.vehicleList.splice(id, 1);
                            newAccountService.setTransactionId(res.transactionId);
                            newAccountService.setPayment(res);
                            if ($scope.hasVehicles()) {
                                if ($scope.isEdit && $scope.editId == id) {
                                    responseErrorService.displayAlertsFromResponse(res, true);
                                    $state.go(stateNames.addAdditionalVehicle);
                                }
                                else if ($scope.isEdit && id < $scope.editId) { // if an element under the element being edited is removed, the id will drop by 1
                                    responseErrorService.displayAlertsFromResponse(res);
                                    $scope.editId--;
                                }
                            }
                            else { // deleted last vehicle
                                $scope.vehicleInfo = {}; // reset
                                $scope.isEdit = false;
                                $scope.vehicleInfo.licState = "TX";
                                $scope.vehicleInfo.vehicleClassCode = 2; // 2-Axles
                                $scope.repoName = "addEZTag";
                                responseErrorService.displayAlertsFromResponse(res, true);
                                $state.go(stateNames.vehicleInformation);
                            }
                        }
                    });
                });
            };
            $scope.onPrevious = function () {
                genericRepo.dataFactory.getPersonalInfo().then(function (res) {
                    if (res.accountInfoExists) {
                        $state.go(stateNames.createAccountDetails);
                    }
                    else { // Else, go to Step 1
                        $state.go(stateNames.createAccount);
                    }
                });
            };
            $scope.goToAddAdditionalVehicle = function () {
                $state.go(stateNames.addAdditionalVehicle);
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("VehicleInformationController", ['$scope', '$state', 'genericRepo', 'stateNames', 'responseErrorService', 'newAccountService', 'validationService', 'modalService',
        function ($scope, $state, genericRepo, stateNames, responseErrorService, newAccountService, validationService, modalService) {
            var unwatch = $scope.$watch('form', function () {
                if ($scope.form.vehicleInformationForm) {
                    $scope.validations = validationService($scope.form.vehicleInformationForm);
                    unwatch();
                }
            });
            if (!$scope.isEdit) {
                $scope.$parent.vehicleInfo = {};
                $scope.$parent.vehicleInfo.licState = "TX";
                $scope.$parent.vehicleInfo.vehicleClassCode = 2; // 2-Axles
            }
            $scope.classChange = function () {
                $scope.disableMotorcycle = ($scope.$parent.vehicleInfo.vehicleClassCode != 2);
                if ($scope.disableMotorcycle)
                    $scope.$parent.vehicleInfo.motorcycle = false;
            };
            $scope.classChange(); // Run once on controller creation
            $scope.onSubmit = function (isValid) {
                if (isValid) {
                    $scope.$parent.vehicleInfo.transactionId = newAccountService.getTransactionId();
                    // $scope.repoName is the api action, edit or add, appropriate for the current state
                    genericRepo.dataFactory[$scope.repoName]($scope.$parent.vehicleInfo).then(function (res) {
                        var hasErrors = res.errors.length > 0;
                        if (hasErrors) {
                            responseErrorService.displayErrorsFromResponse(res);
                        }
                        else { // Successful edit
                            newAccountService.setTransactionId(res.transactionId);
                            if (!$scope.isEdit) {
                                newAccountService.setPayment(res);
                            }
                            if (!res.violationExist) {
                                res.vehicleModel = res.vehicleModel.toUpperCase();
                                res.vehicleColor = res.vehicleColor.toUpperCase();
                                //if (!res.nickname) {
                                //    res.nickname = res.licState + "-" + res.licPlate;
                                //}
                                if (!$scope.isEdit)
                                    $scope.$parent.vehicleList.push(res);
                                else
                                    $scope.$parent.vehicleList[$scope.editId] = res;
                                responseErrorService.displayAlertsFromResponse(res, true);
                                $state.go(stateNames.addAdditionalVehicle);
                            }
                            else {
                                responseErrorService.displayAlertsFromResponse(res);
                                modalService.violationsCannotAddVehicleModal();
                            }
                        }
                    });
                }
            };
            $scope.hasSelectedTwoAxle = function () {
                return $scope.$parent.vehicleInfo.vehicleClassCode === 2;
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var AddBankAccountController = /** @class */ (function () {
            function AddBankAccountController($scope, $state, removeDoubleCharService, genericRepo, responseErrorService, stateNames, newAccountService, SessionService, validationService) {
                this.$scope = $scope;
                this.$state = $state;
                this.removeDoubleCharService = removeDoubleCharService;
                this.genericRepo = genericRepo;
                this.responseErrorService = responseErrorService;
                this.stateNames = stateNames;
                this.newAccountService = newAccountService;
                this.SessionService = SessionService;
                this.validationService = validationService;
                var unwatch = $scope.$watch("paymentEntry", function () {
                    if ($scope.paymentEntry) {
                        $scope.validations = validationService($scope.paymentEntry);
                        unwatch();
                    }
                });
                $scope.$parent.choice = "bk";
                $scope.bankDetails.types = [
                    { val: "personal", txt: "Personal Account" },
                    { val: "business", txt: "Business Account" }
                ];
                $scope.removeDoubles = function (input, itm) {
                    var val = removeDoubleCharService.removeDoubleChar(input);
                    if (val) {
                        $scope.forgot[itm] = val;
                    }
                };
                $scope.isValid = function (input) {
                    return $scope.paymentEntry[input].$valid;
                };
                $scope.submitBK = function (formIsValid) {
                    if (formIsValid) {
                        $scope.bankDetails.transactionId = newAccountService.getTransactionId();
                        $scope.bankDetails.accountType = $scope.bankDetails.accountTypeDisplay;
                        return genericRepo.dataFactory[$scope.apiAction + "PaymentBankAccount"](angular.toJson($scope.bankDetails)).then(function (response) {
                            if (angular.isArray(response.alerts) && response.alerts.length !== 0) {
                                responseErrorService.displayAlertsFromResponse(response, true);
                            }
                            //check to see if system error
                            if (angular.isArray(response.errors) && response.errors.length == 0) {
                                var savedStep = SessionService.getCurrentStep();
                                if (savedStep == null || parseInt(savedStep, 10) <= $scope.stepNum)
                                    SessionService.setCurrentStep($scope.stepNum + 1);
                                if ($scope.apiAction == "add") {
                                    newAccountService.setTransactionId(response.transactionId);
                                    newAccountService.setPayment(response);
                                }
                                //let eftRequest: HCTRA.Model.BaseBankAccountRequest = { AccountType: $scope.bankDetails.accountType, RoutingNumber: $scope.bankDetails.routingNumber, AccountNumber: $scope.bankDetails.accountNumber };
                                //this.genericRepo.dataFactory.eftValidateRouting(eftRequest).then((vResponse) => {
                                //    if (angular.isArray(vResponse.alerts) && vResponse.alerts.length !== 0) {
                                //        this.responseErrorService.displayAlertsFromResponse(vResponse, true);
                                //    }
                                //    $state.go(stateNames.createAccountSummary);
                                //})
                                return $state.go(stateNames.createAccountSummary);
                            }
                            else {
                                return responseErrorService.displayErrorsFromResponse(response);
                            }
                        });
                    }
                    return false;
                };
            }
            AddBankAccountController.$inject = ["$scope",
                "$state",
                "removeDoubleCharService",
                "genericRepo",
                "responseErrorService",
                "stateNames",
                "newAccountService",
                "SessionService",
                "validationService"];
            return AddBankAccountController;
        }());
        Controller.AddBankAccountController = AddBankAccountController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("AddBankAccountController", HCTRA.Controller.AddBankAccountController);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("AddCreditCardController", ['$scope', '$state', 'removeDoubleCharService', 'genericRepo', 'responseErrorService', 'stateNames', 'newAccountService', 'SessionService', 'validationService', 'countryConversionService', 'toggleButtonsService', "broadcastSubmissionService",
        function ($scope, $state, removeDoubleCharService, genericRepo, responseErrorService, stateNames, newAccountService, SessionService, validationService, countryConversionService, toggleButtonsService, broadcastSubmissionService) {
            $scope.creditCardEntry = {
                submit: 'creditCardEntry'
            };
            var unwatch = $scope.$watch('paymentEntry', function () {
                if ($scope.paymentEntry) {
                    $scope.validations = validationService($scope.paymentEntry);
                    unwatch();
                }
            });
            $scope.$parent.choice = "ct";
            //$scope.displayCountry;
            $scope.removeDoubles = function (obj, modelName) {
                var val = removeDoubleCharService.removeDoubleChar(obj[modelName]);
                if (val) {
                    obj[modelName] = val;
                }
            };
            $scope.init = function () {
                genericRepo.dataFactory.getCreditCardTypeAndState().then(function (response) {
                    if (response.errors.length === 0) {
                        //no system error or exception
                        $scope.stateList = response.states;
                        $scope.accountDetails.state = "TX";
                        $scope.countryList = response.countries;
                        // waits for countryList and mailingAddress to exist, then converts country code to name
                        var unwatchMail_1 = $scope.$watch('mailingAddress.country', function () {
                            if ($scope.mailingAddress.country) {
                                $scope.displayCountry = countryConversionService.countryCodeToName($scope.countryList, $scope.mailingAddress.country);
                                unwatchMail_1();
                            }
                        });
                    }
                    else {
                        responseErrorService.displayErrorsFromResponse(response);
                    }
                });
            };
            $scope.submitCC = function (formIsValid) {
                if (formIsValid) {
                    var submissionProm = broadcastSubmissionService.broadcast($scope.creditCardEntry.submit).then(function () {
                        var request = {};
                        if ($scope.paymentInfo.sameAddress)
                            request = angular.copy($scope.mailingAddress);
                        else
                            request = $scope.accountDetails ? angular.copy($scope.accountDetails) : {};
                        angular.extend(request, {
                            hasSecondaryCard: false,
                            creditCardNumber: $scope.creditCard.cardNbr,
                            type: $scope.creditCard.cardCode,
                            nameOnCard: $scope.creditCard.nameOnCard,
                            expMonth: $scope.creditCard.expMonth,
                            expYear: $scope.creditCard.selectedYear,
                            internationalAddress: $scope.international || request.international,
                            accountBillingMethodIdPrimary: $scope.creditCard.accountBillingMethodId,
                            paypageRegistrationId: $scope.creditCard.paypageRegistrationId,
                            omniToken: $scope.creditCard.omniToken,
                            transactionId: newAccountService.getTransactionId()
                        });
                        return genericRepo.dataFactory[$scope.apiAction + "PaymentCreditCard"](angular.toJson(request));
                    }).then(function (response) {
                        if (response.errors.length === 0) {
                            var savedStep = SessionService.getCurrentStep();
                            if (savedStep == null || parseInt(savedStep, 10) <= $scope.stepNum)
                                SessionService.setCurrentStep($scope.stepNum + 1);
                            if ($scope.apiAction === "add") {
                                newAccountService.setTransactionId(response.transactionId);
                                newAccountService.setPayment(response);
                            }
                            return $state.go(stateNames.createAccountSummary);
                        }
                        else {
                            return responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                    return toggleButtonsService.disableUntilResolved(submissionProm);
                }
                return false;
            };
            $scope.init();
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var AddPaymentController = /** @class */ (function () {
            function AddPaymentController($scope, $state, $anchorScroll, stateNames, genericRepo, newAccountService, $window, routes, linkLookupService, billingInfoUtilitiesService, responseErrorService, stringUtilsService) {
                var _this = this;
                this.$scope = $scope;
                this.$state = $state;
                this.$anchorScroll = $anchorScroll;
                this.stateNames = stateNames;
                this.genericRepo = genericRepo;
                this.newAccountService = newAccountService;
                this.$window = $window;
                this.routes = routes;
                this.linkLookupService = linkLookupService;
                this.billingInfoUtilitiesService = billingInfoUtilitiesService;
                this.responseErrorService = responseErrorService;
                this.stringUtilsService = stringUtilsService;
                this.initializeScope = function () {
                    _this.$scope.$parent.stepNum = 4;
                    angular.extend(_this.$scope, {
                        accountDetails: {},
                        creditCard: {
                            transactionId: _this.newAccountService.getTransactionId()
                        },
                        bankDetails: {
                            transactionId: _this.newAccountService.getTransactionId()
                        },
                        mailingAddress: {},
                        billingInfoExists: false,
                        apiAction: "add",
                        previousDestName: _this.stateNames.addAdditionalVehicle,
                        paymentInfo: {
                            sameAddress: true
                        },
                        international: false,
                        changeMethod: _this.changeMethod,
                        goToTagFAQ: function () { return _this.$state.go(_this.stateNames.helpAndSupport); },
                        goToEzTagInformationPage: function () { return _this.$window.open(_this.linkLookupService.articleLookupById(_this.routes.ezTagAccountTypes)); },
                        onPrevious: function () { return _this.$state.go(_this.$scope.previousDestName); },
                        goToContactUs: function () { return _this.$window.open(_this.routes.contactUs); }
                    });
                };
                this.changeMethod = function () {
                    var stateMapping = {
                        "ct": _this.stateNames.creditCardEntry,
                        "bk": _this.stateNames.enterBankAccount
                    };
                    var nextState = stateMapping[_this.$scope.choice];
                    if (nextState) {
                        _this.$state.go(nextState);
                    }
                };
                this.isErrorFree = function (response) { return !response.errors || response.errors.length === 0 ? true : (_this.responseErrorService.displayErrorsFromResponse(response), false); };
                this.populatePersonalInfo = function (response) {
                    if (_this.isErrorFree(response)) {
                        var firstName = response.firstName, lastName = response.lastName, address1 = response.address1, address2 = response.address2, address3 = response.address3, address4 = response.address4, country = response.country, city = response.city, state = response.state, zip = response.zip, plus4 = response.plus4;
                        angular.extend(_this.$scope.mailingAddress, {
                            firstName: firstName,
                            lastName: lastName,
                            address1: address1,
                            address2: address2,
                            address3: address3,
                            address4: address4,
                            country: country,
                            city: city,
                            state: state,
                            zip: zip,
                            plus4: plus4 === null ? "" : plus4,
                            international: _this.billingInfoUtilitiesService.isInternationalAddress(response)
                        });
                    }
                };
                this.populateBillingInfo = function (response) {
                    if (_this.isErrorFree(response)) {
                        _this.$scope.billingInfoExists = response.billingInfoExists;
                        if (_this.$scope.billingInfoExists) {
                            if (response.billingType === HCTRA.Constant.PaymentType.CREDIT) {
                                _this.populateCreditCardInfo(response.cards);
                            }
                            else if (response.billingType === HCTRA.Constant.PaymentType.EFT) {
                                _this.populateBankDetails(response.eft);
                            }
                            _this.changeMethod();
                        }
                    }
                };
                this.populateCreditCardInfo = function (cards) {
                    _this.$scope.apiAction = "update";
                    _this.$scope.choice = 'ct';
                    _this.$scope.international = _this.billingInfoUtilitiesService.isInternationalAddress(cards[0]);
                    _this.$scope.paymentInfo.sameAddress = false;
                    if (cards.length > 0) {
                        var _a = cards[0], address1 = _a.address1, address2 = _a.address2, address3 = _a.address3, address4 = _a.address4, country = _a.country, city = _a.city, state = _a.state, zip = _a.zip, plus4 = _a.plus4, nameOnCard = _a.nameOnCard, cardCode = _a.cardCode, cardNbr = _a.cardNbr, accountBillingMethodId = _a.accountBillingMethodId, cardExpiresDate = _a.cardExpiresDate;
                        angular.extend(_this.$scope.accountDetails, {
                            address1: address1,
                            address2: address2,
                            address3: address3,
                            address4: address4,
                            country: country,
                            city: city,
                            state: state,
                            zip: zip,
                            plus4: plus4
                        });
                        var expirationDate = new Date(cardExpiresDate);
                        angular.extend(_this.$scope.creditCard, {
                            nameOnCard: nameOnCard,
                            cardCode: cardCode,
                            cardNbr: cardNbr,
                            accountBillingMethodId: accountBillingMethodId,
                            expMonth: (expirationDate.getMonth() + 1),
                            selectedYear: expirationDate.getFullYear().toString()
                        });
                    }
                };
                this.populateBankDetails = function (eft) {
                    var accountTypeDisplay = eft.accountTypeDisplay, routingNumber = eft.routingNumber, accountNumber = eft.accountNumber, accountBillingMethodId = eft.accountBillingMethodId;
                    _this.$scope.apiAction = "update";
                    _this.$scope.choice = 'bk';
                    angular.extend(_this.$scope.bankDetails, {
                        accountTypeDisplay: accountTypeDisplay,
                        routingNumber: routingNumber,
                        accountBillingMethodId: accountBillingMethodId,
                        accountNumber: accountNumber,
                        account2: accountNumber
                    });
                };
                this.populateCmsParams = function (res) {
                    if (_this.responseErrorService.isErrorFree(res)) {
                        var parsedRes = angular.fromJson(res.cmsResponse);
                        var parsedParams = _this.stringUtilsService.getParameterObject(parsedRes.Parameters);
                        angular.extend(parsedParams, _this.stringUtilsService.getParameterObject(parsedRes.Children[0].Parameters));
                        _this.$scope.additionalFeeHeader = parsedParams["AdditionalFeeHeader"];
                        _this.$scope.oneTimeActivationFeeMessage = parsedParams["OneTimeActiviationFeeMessage"];
                        _this.$scope.openingCostsHeader = parsedParams["OpeningCostsHeader"];
                        _this.$scope.openingCostsMessage = parsedParams["OpeningCostsMessage"];
                        _this.$scope.learnMoreButton = parsedParams["LearnMoreButton"];
                        //From Child Sitecore item
                        _this.$scope.ezTagAgreementDescription = parsedRes.Children[0].ShortDescription;
                        _this.$scope.ezTagAgreement = parsedRes.Children[0].LongDescription;
                        _this.$scope.ezTagAgreementHeader = parsedParams["EzTagAgreementHeader"];
                        _this.$scope.ezTagAgreementCheckBoxMessage = parsedParams["EzTagAgreementCheckBoxMessage"];
                        _this.$scope.ezTagAgreementCheckBoxError = parsedParams["EzTagAgreementCheckBoxError"];
                        _this.$scope.contactUsButton = parsedParams["ContactUsButton"];
                        _this.$scope.contactUsPreButton = parsedParams["ContactUsPreButton"];
                        _this.$scope.ezTagAgreementScreenReader = parsedParams["EzTagAgreementScreenReader"];
                    }
                };
                $anchorScroll('new-account-title');
                this.initializeScope();
                genericRepo.dataFactory.getBillingInfo().then(this.populateBillingInfo);
                genericRepo.dataFactory.getPersonalInfo().then(this.populatePersonalInfo);
                genericRepo.dataFactory.getCmsPageById({ ItemId: this.routes.openingCostsCms }).then(this.populateCmsParams);
            }
            AddPaymentController.$inject = [
                "$scope",
                "$state",
                "$anchorScroll",
                "stateNames",
                "genericRepo",
                "newAccountService",
                "$window",
                "routes",
                "linkLookupService",
                "billingInfoUtilitiesService",
                "responseErrorService",
                "stringUtilsService"
            ];
            return AddPaymentController;
        }());
        Controller.AddPaymentController = AddPaymentController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("AddPaymentController", HCTRA.Controller.AddPaymentController);
}());
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller("CreateAccountSummaryController", ['$scope', '$anchorScroll', '$state', 'genericRepo', 'stateNames', 'CurrentUser', 'responseErrorService', 'billingInfoUtilitiesService', 'newAccountService',
        function ($scope, $anchorScroll, $state, genericRepo, stateNames, CurrentUser, responseErrorService, billingInfoUtilitiesService, newAccountService) {
            $scope.$parent.stepNum = 5;
            $anchorScroll('new-account-title');
            $scope.$parent.fromEditScreen = false;
            $scope.stateNames = stateNames;
            $scope.goTo = function (stateName) {
                $scope.$parent.fromEditScreen = true;
                $state.go(stateName);
            };
            $scope.goToPersonalOrBusinessInfo = function () {
                $scope.$parent.fromEditScreen = true;
                $state.go(stateNames.createAccountDetails);
            };
            $scope.billingInfo = {};
            $scope.personalInfo = {};
            $scope.vehicleList = {};
            // Requirement 60300: Motorocycle flag change
            //$scope.vehicleList = newAccountService.getVehicleList();
            //if ($scope.vehicleList === null || $scope.vehicleList === undefined) {
            //    $state.go(stateNames.addAdditionalVehicle);
            //}
            genericRepo.dataFactory.getCreateAccountSummary().then(function (res) {
                if (res.errors.length === 0) {
                    $scope.billingInfo = res.billingInfo;
                    $scope.personalInfo = res.personalInfo;
                    $scope.vehicleList = res.accountTags;
                    // Requirement 60300: Motorocycle flag change
                    //$scope.vehicleList = $scope.vehicleList;
                    $scope.authContacts = res.contactNames;
                    $scope.preferences = res.accountPreferences;
                    var userInfo = CurrentUser.getCurrentUser();
                    userInfo.driverLic = res.personalInfo.driverLicNbr;
                    userInfo.driverLicState = res.personalInfo.driverLicState;
                    CurrentUser.updateCurrentUser(userInfo);
                    $scope.personalInfo.international = billingInfoUtilitiesService.isInternationalAddress($scope.personalInfo);
                    if (angular.isArray(res.billingInfo.cards) && res.billingInfo.cards[0]) {
                        $scope.billingInfo.cards[0].international = billingInfoUtilitiesService.isInternationalAddress(res.billingInfo.cards[0]);
                    }
                }
                else {
                    responseErrorService.displayErrorsFromResponse(res);
                }
            });
            $scope.onPrevious = function () {
                return $state.go(stateNames.choosePaymentMethod);
            };
            $scope.onContinue = function () {
                var vehicleList = $scope.vehicleList;
                newAccountService.setVehicleList(vehicleList);
                return $state.go(stateNames.checkout);
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("CheckoutController", ['$scope', '$state', '$anchorScroll', 'genericRepo', 'responseErrorService', 'stateNames', 'newAccountService', 'SessionService', 'USER_ROLES', '$rootScope', 'CurrentUser', '$q',
        function ($scope, $state, $anchorScroll, genericRepo, responseErrorService, stateNames, newAccountService, SessionService, USER_ROLES, $rootScope, CurrentUser, $q) {
            $scope.$parent.stepNum = 6;
            $anchorScroll('new-account-title');
            $scope.vehicleList = newAccountService.getVehicleList();
            $scope.payment = {};
            $scope.paymentIsPending = false;
            //if (newAccountService.paymentExists()) {
            //    $scope.payment = newAccountService.getPayment();
            //}
            //else {
            $scope.init = function () {
                return genericRepo.dataFactory.checkoutPayment({ transactionId: newAccountService.getTransactionId() }).then(function (res) {
                    var hasErrors = res.errors.length > 0;
                    if (hasErrors) {
                        responseErrorService.displayErrorsFromResponse(res);
                    }
                    else { // Successful call
                        responseErrorService.displayAlertsFromResponse(res);
                        var transaction = res.ezTagTransaction;
                        $scope.payment.tagSalesAmt = transaction.tagSalesAmt;
                        $scope.payment.depositAmt = transaction.depositAmt;
                        $scope.payment.totalAmt = transaction.totalAmt;
                        $scope.payment.lowBalanceAmt = transaction.lowBalanceAmt;
                        $scope.payment.rebillAmt = transaction.rebillAmt;
                        $scope.payment.tagCostExists = transaction.tagCostExists;
                        $scope.payment.transactionId = transaction.transactionId;
                        // Requirement 60300: Motorocycle flag change
                        //$scope.payment.vehicleList = $scope.vehicleList;
                        newAccountService.setTransactionId(transaction.transactionId);
                        newAccountService.setPayment(transaction);
                    }
                });
            };
            //}
            $scope.payment.deliveryMethod = "mail";
            $scope.payment.transactionId = newAccountService.getTransactionId();
            $scope.onPrevious = function () {
                return $state.go(stateNames.createAccountSummary).finally(function () {
                    $scope.paymentIsPending = false;
                });
            };
            $scope.onCheckout = function () {
                if ($scope.paymentIsPending) {
                    return $q.resolve({ status: 'processing' });
                }
                $scope.paymentIsPending = true;
                return genericRepo.dataFactory.makePayment($scope.payment)
                    .then(function (res) {
                    var hasErrors = res.errors.length > 0;
                    if (hasErrors) {
                        return responseErrorService.displayErrorsFromResponse(res);
                        // Bug 7876 Fix - on error, reload the page so that either
                        //  a) A new transactionId is generated, or
                        //  b) the user is transitioned to Account Details
                        //$timeout(function() {
                        //    $window.location.reload();
                        //}, 1000);
                    }
                    else { // Successful call
                        responseErrorService.displayAlertsFromResponse(res, true);
                        var successPayment = {};
                        successPayment.tagSalesAmt = res.tagSalesAmt;
                        successPayment.depositAmt = res.depositAmt;
                        successPayment.totalAmt = res.totalAmt;
                        newAccountService.setPayment(successPayment);
                        newAccountService.setTransactionId(res.transactionId);
                        newAccountService.setDeliveryMethod(res.deliveryMethod);
                        SessionService.userRole = USER_ROLES.active;
                        SessionService.setAcctActivity("A");
                        $rootScope.currentUser.acctActivity = "A";
                        CurrentUser.updateCurrentUser($rootScope.currentUser);
                        SessionService.removeCurrentStep();
                        newAccountService.clearVehicleList();
                        if (newAccountService.getDeliveryMethod() == 'mail') {
                            return $state.go(stateNames.createAccountReceipt);
                        }
                        else {
                            return genericRepo.dataFactory.getFlexbookerConfig().then(function (res) {
                                if (res.errors.length > 0) {
                                    newAccountService.setFlexbookerFlag(false);
                                    return $state.go(stateNames.createAccountReceipt);
                                }
                                else {
                                    newAccountService.setFlexbookerFlag(res.createAccountFlexbookerEnabled);
                                    if (res.createAccountFlexbookerEnabled) {
                                        return $state.go(stateNames.flexbooker);
                                    }
                                    else {
                                        return $state.go(stateNames.createAccountReceipt);
                                    }
                                }
                            });
                        }
                    }
                })
                    .finally(function () {
                    $scope.paymentIsPending = false;
                });
            };
            $scope.editVehicles = function () {
                $scope.$parent.fromEditScreen = true;
                $state.go(stateNames.addAdditionalVehicle).finally(function () {
                    $scope.paymentIsPending = false;
                });
            };
            $scope.init();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("CreateAccountReceiptController", [
        '$scope',
        '$state',
        '$anchorScroll',
        'genericRepo',
        'responseErrorService',
        'stateNames',
        'newAccountService',
        'billingInfoUtilitiesService',
        'routes',
        'stringUtilsService',
        'accountOverviewStates',
        function ($scope, $state, $anchorScroll, genericRepo, responseErrorService, stateNames, newAccountService, billingInfoUtilitiesService, routes, stringUtilsService, accountOverviewStates) {
            $scope.$parent.stepNum = 8;
            $anchorScroll('new-account-title');
            $scope.printMessage = "Print Receipt";
            $scope.billingInfo = {};
            $scope.personalInfo = {};
            $scope.vehicleList = {};
            $scope.goToNextState = function () {
                return $state.go(accountOverviewStates.Frame);
            };
            $scope.deliveryMethod = newAccountService.getDeliveryMethod();
            $scope.flexbookerFlag = false;
            $scope.skippedFlexbooker = false;
            $scope.isMail = false;
            if ($scope.deliveryMethod === 'mail') {
                $scope.isMail = true;
            }
            else {
                $scope.flexbookerFlag = newAccountService.getFlexbookerFlag();
                $scope.skippedFlexbooker = newAccountService.getSkipScheduling();
            }
            $scope.transactionId = newAccountService.getTransactionId();
            $scope.payment = newAccountService.getPayment();
            $scope.accountOpened = new Date();
            genericRepo.dataFactory.getCreateAccountReceipt().then(function (res) {
                var hasErrors = res.errors.length > 0;
                if (hasErrors) {
                    responseErrorService.displayErrorsFromResponse(res);
                }
                else { // Successful edit
                    responseErrorService.displayAlertsFromResponse(res);
                    $scope.billingInfo = res.billingInfo;
                    $scope.personalInfo = res.personalInfo;
                    $scope.vehicleList = res.accountTags;
                    $scope.orderShippingTime = res.orderShippingTime;
                    $scope.authContacts = res.contactNames;
                    $scope.preferences = res.accountPreferences;
                    $scope.personalInfo.international = billingInfoUtilitiesService.isInternationalAddress($scope.personalInfo);
                    if (angular.isArray(res.billingInfo.cards) && res.billingInfo.cards[0]) {
                        $scope.billingInfo.cards[0].international = billingInfoUtilitiesService.isInternationalAddress(res.billingInfo.cards[0]);
                    }
                }
            });
            genericRepo.dataFactory.getCmsPageById({ ItemId: routes.createAccountReceiptCMS }).then(function (res) {
                if (responseErrorService.isErrorFree(res)) {
                    var parsedRes = angular.fromJson(res.cmsResponse);
                    var parsedParams = stringUtilsService.getParameterObject(parsedRes.Parameters);
                    $scope.thankYouMessage = parsedParams["ThankYouMessage"];
                    $scope.orderReceivedMessage = parsedParams["OrderReceivedMessage"];
                    $scope.byMailMessage = parsedParams["ByMailMessage"];
                    $scope.byPickupMessage = parsedParams["ByPickupMessage"];
                    $scope.emailConfirmMessage = parsedParams["EmailConfirmMessage"];
                    $scope.flexbookerPickupMessage = parsedParams["FlexbookerPickupMessage"];
                    $scope.flexbookerSkipMessage = parsedParams["FlexbookerSkipMessage"];
                    $scope.flexbookerPickupDisclaimer = parsedRes.shortDescription;
                }
            });
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var FlexbookerCreateAccountController = /** @class */ (function () {
            function FlexbookerCreateAccountController($scope, $state, stateNames, newAccountService) {
                var _this = this;
                this.$scope = $scope;
                this.$state = $state;
                this.stateNames = stateNames;
                this.newAccountService = newAccountService;
                this.bookingComplete = false;
                this.skipBooking = false;
                this.onContinue = function () {
                    _this.newAccountService.setSkipScheduling(false);
                    return _this.$state.go(_this.stateNames.createAccountReceipt);
                };
                this.onSkip = function () {
                    _this.newAccountService.setSkipScheduling(true);
                    return _this.$state.go(_this.stateNames.createAccountReceipt);
                };
            }
            FlexbookerCreateAccountController.prototype.$onInit = function () {
                this.$scope.$parent.stepNum = 7;
            };
            FlexbookerCreateAccountController.prototype.onBookingComplete = function (event) {
                this.bookingComplete = event;
            };
            FlexbookerCreateAccountController.prototype.onSkipBooking = function (event) {
                this.skipBooking = event;
            };
            FlexbookerCreateAccountController.$inject = [
                "$scope",
                "$state",
                "stateNames",
                "newAccountService"
            ];
            return FlexbookerCreateAccountController;
        }());
        Controller.FlexbookerCreateAccountController = FlexbookerCreateAccountController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module('HCTRAModule')
        .component("flexbookerCreateAccountController", {
        templateUrl: '/app/account/newAccount/stepFlexbooker/createAccountFlexbooker.html',
        bindings: {},
        controller: HCTRA.Controller.FlexbookerCreateAccountController
    });
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').controller('SendEmailConfirmationController', ['genericRepo', '$state', 'accountOverviewStates', 'validatePrimaryEmailService',
        function (genericRepo, $state, accountOverviewStates, validatePrimaryEmailService) {
            genericRepo.dataFactory.sendEmailConfirmation().then(function () {
                validatePrimaryEmailService.setEmailSent(true);
                $state.go(accountOverviewStates.Frame, {}, { location: 'replace' });
            });
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller('ValidatePrimaryEmailController', ['$state', '$stateParams', 'accountOverviewStates', 'validatePrimaryEmailService', function ($state, $stateParams, accountOverviewStates, validatePrimaryEmailService) {
            //sessionStorage.setItem("emailValidationId", $stateParams.id);
            validatePrimaryEmailService.setEmailValidationId($stateParams.id);
            $state.go(accountOverviewStates.Frame, {}, { location: 'replace' });
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ActivateEzTagController", ['$scope', 'homeRoutes', 'genericRepo', 'responseErrorService', '$location', '$window', 'routes', 'validationService', 'activateEzTagWizardDirectorService', 'linkLookupService', 'environmentConfig', 'AuthService', 'SessionService',
        function ($scope, homeRoutes, genericRepo, responseErrorService, $location, $window, routes, validationService, activateEzTagWizardDirectorService, linkLookupService, environmentConfig, AuthService, SessionService) {
            $scope.activateEzTag = {
                transactionId: '',
                verificationSelect: '',
                emailAddress: '',
                phoneNumber: ''
            };
            $scope.removeDL = environmentConfig.twoFactorAuth.enableTagActivation;
            $scope.isAuthenticated = false;
            //to be removed
            $scope.activateEzTag.acctInfoSelect = '';
            $scope.activateEzTag.driversLicense = '';
            $scope.activateEzTag.taxIdNumber = '';
            $scope.init = function (activateTagStep1Form) {
                $scope.validations = validationService(activateTagStep1Form);
                $scope.isAuthenticated = AuthService.isAuthenticated();
                genericRepo.dataFactory.getStates().then(function (response) {
                    if (response.errors.length == 0) {
                        $scope.stateList = response.states;
                        $scope.activateEzTag.selectedState = "TX";
                    }
                    else {
                        responseErrorService.displayErrorsFromResponse(response);
                    }
                    responseErrorService.displayAlertsFromResponse(response);
                });
            };
            // TODO: make directive dropdown
            $scope.isItalic = function (member) {
                if ($scope.activateEzTag[member] !== 'waterm') {
                    return '';
                }
                else {
                    return 'setItalic';
                }
            };
            $scope.blankOutUnusedFields = function () {
                var specificTagsInformation = {
                    transactionId: $scope.activateEzTag.transactionId,
                    accountId: null
                };
                if ($scope.removeDL) {
                    if ($scope.isAuthenticated) {
                        specificTagsInformation.accountId = SessionService.acctId;
                    }
                    else if ($scope.activateEzTag.verificationSelect === 'emailAddress') {
                        specificTagsInformation.emailAddress = $scope.activateEzTag.emailAddress;
                    }
                    else {
                        specificTagsInformation.phoneNumber = $scope.activateEzTag.phoneNumber;
                    }
                }
                else if ($scope.activateEzTag.acctInfoSelect === 'driversLicense') {
                    specificTagsInformation.driversLicense = $scope.activateEzTag.driversLicense;
                    specificTagsInformation.state = $scope.activateEzTag.selectedState;
                }
                else {
                    var cleansedTaxId = $scope.activateEzTag.taxIdNumber
                        ? $scope.activateEzTag.taxIdNumber.replace(/-/g, "")
                        : undefined;
                    specificTagsInformation.taxIdNumber = cleansedTaxId;
                }
                return specificTagsInformation;
            };
            $scope.submitInfo = function (formIsValid) {
                if (formIsValid) {
                    var specificTagsInformation = $scope.blankOutUnusedFields();
                    genericRepo.dataFactory.findTagsToActivate(specificTagsInformation).then(function (response) {
                        if (response.errors.length == 0) {
                            $scope.createActivateEzTagStep1MarkerAndAdvance(response.ezTags);
                        }
                        else {
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                        responseErrorService.displayAlertsFromResponse(response);
                    });
                }
            };
            $scope.onCancel = function () {
                $location.url(homeRoutes.Frame);
            };
            $scope.searchFaqMountEzTag = function () {
                $window.open(linkLookupService.articleLookupById(routes.howToMountEzTag));
            };
            $scope.createActivateEzTagStep1MarkerAndAdvance = function (listOfVehicles) {
                activateEzTagWizardDirectorService.saveStep(listOfVehicles, $scope.activateEzTag.transactionId, routes.activateEzTag);
                $location.url(routes.confirmTagActivation);
            };
            //$scope.init();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').service('activateEzTagWizardDirectorService', ['webStorage', '$location', 'routes',
        function (webStorage, $location, routes) {
            var mapScreenToStep = function (screen) {
                switch (screen) {
                    default:
                    case (routes.activateEzTag): return 1;
                    case (routes.confirmTagActivation): return 2;
                    case (routes.tagActivationGratitude): return 3;
                }
            };
            var mapStepToScreen = function (step) {
                switch (step) {
                    default:
                    case (1): return routes.activateEzTag;
                    case (2): return routes.confirmTagActivation;
                    case (3): return routes.tagActivationGratitude;
                }
            };
            this.saveStep = function (listOfVehicles, transactionId, currentScreen) {
                var activateEzTagWizardInformation = {
                    transactionId: transactionId,
                    step: (mapScreenToStep(currentScreen) + 1),
                    listOfVehicles: listOfVehicles
                };
                webStorage.setKeyValue("activateEzTagWizardInformation", activateEzTagWizardInformation);
            };
            this.destroyActivateEzTagInformation = function () {
                webStorage.removeEntry("activateEzTagWizardInformation");
            };
            this.redirectToCorrectScreen = function (currentScreen) {
                var activateEzTagWizardInformation = webStorage.getValue("activateEzTagWizardInformation");
                var currentStep = mapScreenToStep(currentScreen);
                if (currentStep > 1 && !activateEzTagWizardInformation) {
                    $location.url(routes.activateEzTag);
                    return true;
                }
                if (currentStep != activateEzTagWizardInformation.step && currentStep != 1) {
                    $location.url(mapStepToScreen(activateEzTagWizardInformation.step));
                    return true;
                }
                return false;
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ConfirmTagActivationController", ['$scope', 'genericRepo', 'responseErrorService', '$location', 'routes', 'webStorage', 'activateEzTagWizardDirectorService', 'validationService',
        function ($scope, genericRepo, responseErrorService, $location, routes, webStorage, activateEzTagWizardDirectorService, validationService) {
            $scope.activateEzTag = {};
            $scope.activateEzTag.transactionId = "";
            $scope.activateEzTag.vehicleList = [];
            $scope.activateEzTag.userHasConfirmed = false;
            $scope.init = function (activateTagStep2Form) {
                $scope.validations = validationService(activateTagStep2Form);
                var redirectOccured = activateEzTagWizardDirectorService.redirectToCorrectScreen(routes.confirmTagActivation);
                if (redirectOccured)
                    return;
                var activateEzTagWizardInformation = webStorage.getValue("activateEzTagWizardInformation");
                $scope.activateEzTag.transactionId = activateEzTagWizardInformation.transactionId;
                //$scope.activateEzTag.vehicleList = angular.fromJson(activateEzTagWizardInformation.listOfVehicles);
                $scope.activateEzTag.vehicleList = activateEzTagWizardInformation.listOfVehicles;
                if (angular.isString($scope.activateEzTag.vehicleList)) {
                    $scope.activateEzTag.vehicleList = angular.fromJson($scope.activateEzTag.vehicleList);
                }
            };
            //        var unwatch = $scope.$watch('activateTagStep2Form', function () {
            //            if ($scope.activateTagStep2Form) {
            //                $scope.validations = validationService($scope.activateTagStep2Form);
            //                unwatch();
            //            }
            //        }, true);
            $scope.submitInfo = function (formIsValid) {
                if (formIsValid) {
                    genericRepo.dataFactory.finalizeTagActivation({ transactionId: $scope.activateEzTag.transactionId }).then(function (response) {
                        if (response.errors.length == 0) {
                            $scope.createActivateEzTagStep2MarkerAndAdvance();
                            responseErrorService.displayAlertsFromResponse(response, true);
                        }
                        else {
                            responseErrorService.displayErrorsFromResponse(response);
                            responseErrorService.displayAlertsFromResponse(response);
                        }
                    });
                }
            };
            $scope.onCancel = function () {
                activateEzTagWizardDirectorService.destroyActivateEzTagInformation();
                $location.url(routes.activateEzTag);
            };
            $scope.createActivateEzTagStep2MarkerAndAdvance = function () {
                activateEzTagWizardDirectorService.saveStep($scope.activateEzTag.vehicleList, $scope.activateEzTag.transactionId, routes.confirmTagActivation);
                $location.url(routes.tagActivationGratitude);
            };
            //$scope.init();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("TagActivationGratitudeController", ['$scope', 'homeRoutes', '$location', 'routes', 'webStorage', 'activateEzTagWizardDirectorService', 'AuthService',
        function ($scope, homeRoutes, $location, routes, webStorage, activateEzTagWizardDirectorService, AuthService) {
            $scope.activateEzTag = {};
            $scope.activateEzTag.vehicleList = [];
            $scope.init = function () {
                var redirectOccured = activateEzTagWizardDirectorService.redirectToCorrectScreen(routes.tagActivationGratitude);
                if (redirectOccured)
                    return;
                var activateEzTagWizardInformation = webStorage.getValue("activateEzTagWizardInformation");
                $scope.activateEzTag.vehicleList = activateEzTagWizardInformation.listOfVehicles;
                if (angular.isString($scope.activateEzTag.vehicleList)) {
                    $scope.activateEzTag.vehicleList = angular.fromJson($scope.activateEzTag.vehicleList);
                }
            };
            $scope.exitWizard = function () {
                activateEzTagWizardDirectorService.destroyActivateEzTagInformation();
                if (AuthService.isAuthenticated()) {
                    $location.url(routes.manageVehicles);
                }
                else {
                    $location.url(homeRoutes.Frame);
                }
            };
            $scope.init();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ConstructionAndEngineeringFrameController", ['$scope', '$state', 'stateNames',
        function ($scope, $state, stateNames) {
            $scope.currentState = $state.current.name;
            $scope.majorProjectsState = stateNames.majorProjects;
            $scope.contractsState = stateNames.contracts;
            $scope.proServiceRegState = stateNames.proServiceReg;
            $scope.goToMajorProjects = function () {
                $state.go(stateNames.majorProjects);
                $scope.currentState = stateNames.majorProjects;
            };
            $scope.goToContracts = function () {
                $state.go(stateNames.contracts);
                $scope.currentState = stateNames.contracts;
            };
            $scope.goToProServiceReg = function () {
                $state.go(stateNames.proServiceReg);
                $scope.currentState = stateNames.proServiceReg;
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ContractsController", ['$scope', 'genericRepo', 'responseErrorService', 'cmsUtilService', '$anchorScroll', '$timeout', '$state', 'routes', '$location',
        function ($scope, genericRepo, responseErrorService, cmsUtilService, $anchorScroll, $timeout, $state, routes, $location) {
            $scope.$parent.currentState = $state.current.name;
            $scope.exists = function (variable) {
                if (variable)
                    return true;
                return false;
            };
            var requestObject = {
                itemId: $state.current.cms.itemId,
                fields: $state.current.cms.fields
            };
            //key off of itemName to enable jumping to a div on a page
            genericRepo.dataFactory.getCmsPageById(requestObject).then(function (response) {
                if (response.errors.length <= 0) {
                    var cmsData = angular.fromJson(response.cmsResponse);
                    $scope.contractsPageTitle = cmsData.Title;
                    $scope.contractsPageDescription = cmsData.LongDescription;
                    $scope.contractsSectionArray = cmsData.Children;
                    cmsData = pdfLinkCreator(cmsData);
                    for (var i = 0; i < $scope.contractsSectionArray.length; i++) {
                        $scope.contractsSectionArray[i].ItemName = $scope.contractsSectionArray[i].ItemName.toLowerCase();
                    }
                    $timeout(function () {
                        $location.hash($location.hash().toLowerCase());
                        $anchorScroll();
                    });
                }
                else {
                    responseErrorService.displayErrorsFromResponse(response);
                }
            });
            var pdfLinkCreator = function (parentPage) {
                var bidsList = parentPage.Children[0].Children[0].Children;
                var cmsRequests = {
                    requests: []
                };
                for (var i = 0; i < bidsList.length; i++) {
                    var request = {
                        // Extract the item path
                        path: bidsList[i].BidDocument,
                        fields: 'ItemID,Size,Extension'
                    };
                    cmsRequests.requests.push(request);
                }
                return genericRepo.dataFactory.getCmsPages(cmsRequests).then(function (res) {
                    for (var i = 0; i < res.responses.length; i++) {
                        var response = res.responses[i];
                        var parsedRes = angular.fromJson(response.cmsResponse);
                        var properBidDocUrl = routes.cmsMediaUrl + cmsUtilService.processItemId(parsedRes.ItemID) + routes.cmsMediaExt;
                        // Put path with item id back in parentPage 
                        parentPage.Children[0].Children[0].Children[i].BidDocument = properBidDocUrl;
                    }
                    return parentPage;
                });
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("MajorProjectsController", ['$scope', 'genericRepo', 'responseErrorService', '$location', '$anchorScroll', '$timeout', '$state', 'linkLookupService',
        function ($scope, genericRepo, responseErrorService, $location, $anchorScroll, $timeout, $state, linkLookupService) {
            $scope.$parent.currentState = $state.current.name;
            $scope.exists = function (variable) {
                if (variable)
                    return true;
                return false;
            };
            $scope.toFullArticle = function (cmsId) {
                $location.url(linkLookupService.articleLookupById(cmsId));
            };
            var requestObject = {
                itemId: $state.current.cms.itemId,
                fields: $state.current.cms.fields
            };
            //key off of itemName to enable jumping to a div on a page
            genericRepo.dataFactory.getCmsPageById(requestObject).then(function (response) {
                if (response.errors.length <= 0) {
                    var cmsData = angular.fromJson(response.cmsResponse);
                    $scope.majorProjectsPageTitle = cmsData.Title;
                    $scope.majorProjectsPageDescription = cmsData.LongDescription;
                    $scope.majorProjectsSectionArray = cmsData.Children;
                    for (var i = 0; i < $scope.majorProjectsSectionArray.length; i++) {
                        $scope.majorProjectsSectionArray[i].ItemName = $scope.majorProjectsSectionArray[i].ItemName.toLowerCase();
                    }
                    $timeout(function () {
                        $location.hash($location.hash().toLowerCase());
                        $anchorScroll();
                    });
                }
                else {
                    responseErrorService.displayErrorsFromResponse(response);
                }
            });
            $scope.unCamelCaser = function (text) {
                return text.replace(/([A-Z])/g, ' $1').trim();
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ProServiceRegController", ['$scope', 'genericRepo', 'responseErrorService', '$location', '$anchorScroll', '$timeout', '$state', 'linkLookupService',
        function ($scope, genericRepo, responseErrorService, $location, $anchorScroll, $timeout, $state, linkLookupService) {
            $scope.$parent.currentState = $state.current.name;
            var requestObject = {
                itemId: $state.current.cms.itemId,
                fields: $state.current.cms.fields
            };
            //key off of itemName to enable jumping to a div on a page
            genericRepo.dataFactory.getCmsPageById(requestObject).then(function (response) {
                if (response.errors.length <= 0) {
                    var cmsData = angular.fromJson(response.cmsResponse);
                    $scope.proServiceRegPageTitle = cmsData.Title;
                    $scope.proServiceRegPageDescription = cmsData.LongDescription;
                }
                else {
                    responseErrorService.displayErrorsFromResponse(response);
                }
            });
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("EmploymentPageController", ['$scope', 'genericRepo', 'responseErrorService', '$location', '$anchorScroll', '$timeout', '$state', 'linkLookupService',
        function ($scope, genericRepo, responseErrorService, $location, $anchorScroll, $timeout, $state, linkLookupService) {
            var requestObject = {
                itemId: $state.current.cms.itemId,
                fields: $state.current.cms.fields
            };
            $scope.toFullArticle = function (cmsId) {
                $location.url(linkLookupService.articleLookupById(cmsId));
            };
            $scope.exists = function (variable) {
                if (variable)
                    return true;
                return false;
            };
            //key off of itemName to enable jumping to a div on a page
            genericRepo.dataFactory.getCmsPageById(requestObject).then(function (response) {
                if (response.errors.length <= 0) {
                    var cmsData = angular.fromJson(response.cmsResponse);
                    $scope.employmentPageTitle = cmsData.Title;
                    $scope.employmentPageDescription = cmsData.LongDescription;
                    $scope.employmentSectionsArray = cmsData.Children;
                    for (var i = 0; i < $scope.employmentSectionsArray.length; i++) {
                        $scope.employmentSectionsArray[i].ItemName = $scope.employmentSectionsArray[i].ItemName.toLowerCase();
                    }
                    $timeout(function () {
                        $location.hash($location.hash().toLowerCase());
                        $anchorScroll();
                    });
                }
                else {
                    responseErrorService.displayErrorsFromResponse(response);
                }
            });
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("GenericJobPageController", ['$scope', 'genericRepo', 'responseErrorService', '$anchorScroll', '$timeout', '$state', '$location',
        function ($scope, genericRepo, responseErrorService, $anchorScroll, $timeout, $state, $location) {
            var requestObject = {
                itemId: $state.current.cms.id
            };
            $scope.exists = function (variable) {
                if (variable)
                    return true;
                return false;
            };
            //key off of itemName to enable jumping to a div on a page
            genericRepo.dataFactory.getCmsPageById(requestObject).then(function (response) {
                if (response.errors.length <= 0) {
                    var cmsData = angular.fromJson(response.cmsResponse);
                    $scope.jobTitle = cmsData.Title;
                    $scope.jobShortDescription = cmsData.ShortDescription;
                    $scope.jobObject = {
                        department: {
                            Title: 'Department',
                            Value: cmsData.Department
                        },
                        location: {
                            Title: 'Location',
                            Value: cmsData.Location
                        },
                        hours: {
                            Title: 'Hours',
                            Value: cmsData.Hours
                        },
                        salary: {
                            Title: 'Salary',
                            Value: cmsData.Salary
                        },
                        jobDescription: {
                            Title: 'Job Description',
                            Value: cmsData.LongDescription
                        },
                        jobRequirements: {
                            Title: 'Job Requirements',
                            Value: cmsData.JobRequirements
                        },
                        closing: {
                            Title: 'Closing Time/Day',
                            Value: cmsData.Closing
                        },
                        contactPerson: {
                            Title: 'Contact Person',
                            Value: cmsData.Contact
                        }
                    };
                    $scope.image = cmsData.Image;
                    $scope.file = cmsData.File;
                    $timeout(function () {
                        $location.hash($location.hash().toLowerCase());
                        $anchorScroll();
                    });
                }
                else {
                    responseErrorService.displayErrorsFromResponse(response);
                }
            });
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ArticleController", ['$scope', 'genericRepo', 'responseErrorService', '$state', 'stateNames', '$location', '$anchorScroll', '$timeout', 'cmsUtilService', 'rssService', 'operatingSystemSnifferService',
        function ($scope, genericRepo, responseErrorService, $state, stateNames, $location, $anchorScroll, $timeout, cmsUtilService, rssService, operatingSystemSnifferService) {
            var init = function () {
                $scope.archiveName = $state.current.cms.archiveName;
                $scope.isClosures = $state.current.name === stateNames.closures;
                $scope.articleArray = [];
                var cmsRequests = {
                    requests: [
                        {
                            itemId: $state.current.cms.pageTitleId,
                            fields: "ItemID,Title"
                        },
                        {
                            itemId: $state.current.cms.allSearchQueryId,
                            fields: "ItemID,Query"
                        }
                    ]
                };
                genericRepo.dataFactory.getCmsPages(cmsRequests).then(function (response) {
                    if (response.errors.length === 0) {
                        $scope.topTitle = angular.fromJson(response.responses[0].cmsResponse).Title;
                        $scope.articleArray = cmsUtilService.processArticleArray(angular.fromJson(response.responses[1].cmsResponse).Query.Results);
                        $scope.addExtraMargin = $scope.shouldShowExtraMargin($scope.articleArray, operatingSystemSnifferService.isDesktopOs());
                        $timeout(function () {
                            $location.hash($location.hash().toLowerCase());
                            $anchorScroll();
                        });
                    }
                    else {
                        responseErrorService.displayErrorsFromResponse(response);
                    }
                });
            };
            $scope.shouldShowExtraMargin = function (articleArray, isDesktop) {
                return (!articleArray || articleArray.length == 0 || articleArray.length == 1 && articleArray[0].title === 'Transtar Map') && !isDesktop;
            };
            $scope.goToRssFeed = function () {
                if ($scope.isClosures) {
                    rssService.goToRssFeed(rssService.rssMajorClosuresKey);
                }
                else {
                    rssService.goToRssFeed(rssService.rssLatestNewsKey);
                }
            };
            $scope.toArchive = function () {
                $state.go($state.current.cms.archive);
            };
            init();
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("GenericHeaderBodyController", ['$scope', 'genericRepo', '$state', 'responseErrorService',
        function ($scope, genericRepo, $state, responseErrorService) {
            if ($scope.$parent.currentState) {
                $scope.$parent.currentState = $state.current.name;
            }
            var request = {
                itemId: $state.current.cms.itemId,
                fields: $state.current.cms.fields
            };
            genericRepo.dataFactory.getCmsPageById(request).then(function (res) {
                if (res.errors.length == 0) {
                    var parsedRes = angular.fromJson(res.cmsResponse);
                    $scope.headerTitle = parsedRes.Title;
                    $scope.headerContent = parsedRes.LongDescription;
                    $scope.bodyDataList = parsedRes.Children[0].Children[0].Children;
                }
                else {
                    responseErrorService.displayErrorsFromResponse(res);
                }
            });
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("GenericNonSectionalCmsController", ['$scope', 'genericRepo', '$sce', 'responseErrorService', '$state',
        function ($scope, genericRepo, $sce, responseErrorService, $state) {
            var requestObject = {
                itemId: $state.current.cms.id,
                fields: "Title,LongDescription"
            };
            genericRepo.dataFactory.getCmsPageById(requestObject).then(function (response) {
                if (response.errors.length <= 0) {
                    var cmsData = angular.fromJson(response.cmsResponse);
                    $scope.title = cmsData.Title;
                    $scope.rawHTML = cmsData.LongDescription;
                    $scope.content = $sce.trustAsHtml($scope.rawHTML);
                }
                else {
                    responseErrorService.displayErrorsFromResponse(response);
                }
            });
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("GenericSectionalCmsController", ['$scope', 'routes', 'genericRepo', 'responseErrorService', '$location', '$state', '$anchorScroll', '$timeout', '$window', 'cmsUtilService',
        function ($scope, routes, genericRepo, responseErrorService, $location, $state, $anchorScroll, $timeout, $window, cmsUtilService) {
            $scope.closeNeedHelp = function () {
                $window.close();
            };
            var setHelpPageFlag = function (currentPath) {
                var needHelpPaths = [routes.violationInvoiceInformation, routes.needHelpCms, routes.whatIsEzPlateCms, routes.eftHelp];
                for (var i = 0; i < needHelpPaths.length; i++) {
                    if (decodeURIComponent(needHelpPaths[i]).toLowerCase().endsWith(currentPath.toLowerCase())) {
                        $scope.isHelpPage = true;
                        return;
                    }
                }
                $scope.isHelpPage = false;
            };
            var init = function () {
                var requestObject = {
                    itemId: $state.current.cms.id,
                    fields: "Title,ShortDescription,LongDescription,Image,File,ItemName"
                };
                setHelpPageFlag(requestObject.itemId);
                //key off of itemName to enable jumping to a div on a page
                genericRepo.dataFactory.getCmsPageById(requestObject).then(function (response) {
                    if (response.errors.length <= 0) {
                        var cmsData = angular.fromJson(response.cmsResponse);
                        $scope.parentTitle = cmsData.Title;
                        $scope.parentShortDescription = cmsData.ShortDescription;
                        $scope.parentLongDescription = cmsData.LongDescription;
                        $scope.cmsChildSectionArray = cmsData.Children;
                        for (var i = 0; i < $scope.cmsChildSectionArray.length; i++) {
                            $scope.cmsChildSectionArray[i].Image = cmsUtilService.generateFileSrc($scope.cmsChildSectionArray[i].Image);
                            $scope.cmsChildSectionArray[i].ItemName = $scope.cmsChildSectionArray[i].ItemName.toLowerCase();
                        }
                        $timeout(function () {
                            $location.hash($location.hash().toLowerCase());
                            $anchorScroll();
                        });
                    }
                    else {
                        responseErrorService.displayErrorsFromResponse(response);
                    }
                });
            };
            init();
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var SearchArticleChildController = /** @class */ (function () {
            function SearchArticleChildController($scope, $state, homeStates, $stateParams) {
                var _this = this;
                this.$scope = $scope;
                this.$state = $state;
                this.homeStates = homeStates;
                this.$stateParams = $stateParams;
                this.formatParentPagingObjectAndRedirectIfNeeded = function () {
                    // strictly optional, could be null or number
                    _this.$scope.$parent.pagingObject.currentPage = _this.$stateParams.page && !isNaN(parseInt(_this.$stateParams.page, 10)) ?
                        Number(_this.$stateParams.page) : 0;
                    // strictly optional, could be null, an empty string ("") -- this is set to empty string in other places -- or number
                    _this.$scope.$parent.pagingObject.pageSize = _this.$stateParams.size && !isNaN(parseInt(_this.$stateParams.size, 10)) ?
                        Number(_this.$stateParams.size) : _this.$scope.$parent.mobilePagingorInitialSize;
                    // if category is blank, then this is a programmer error! --> redirect to home to optimize possible degradation in user experience
                    if (_this.$stateParams.category !== null && angular.isDefined(_this.$stateParams.category) && _this.$stateParams.category !== "") {
                        _this.$scope.$parent.categoryHolder.category.itemName = _this.$stateParams.category;
                        return true;
                    }
                    else {
                        _this.$state.go(_this.homeStates.Frame);
                        return false;
                    }
                };
                if (this.formatParentPagingObjectAndRedirectIfNeeded()) {
                    if ($scope.$parent.parentIsLoaded) {
                        $scope.$parent.userClickedSearch();
                    }
                    else {
                        $scope.$parent.parentIsLoaded = true;
                        $scope.$parent.init();
                    }
                }
            }
            SearchArticleChildController.$inject = ["$scope", "$state", "homeStates", "$stateParams"];
            return SearchArticleChildController;
        }());
        Controller.SearchArticleChildController = SearchArticleChildController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("SearchArticleChildController", HCTRA.Controller.SearchArticleChildController);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("SearchArticleController", ['$scope', 'genericRepo', 'responseErrorService', '$state', '$location', '$anchorScroll', '$timeout', 'operatingSystemSnifferService', 'stateNames', 'cmsUtilService',
        function ($scope, genericRepo, responseErrorService, $state, $location, $anchorScroll, $timeout, operatingSystemSnifferService, stateNames, cmsUtilService) {
            // Globals
            $scope.pageLinks = {};
            var nextVirtualScrollPage;
            $scope.articleNotFoundText;
            $scope.categoryHolder = { category: {} };
            $scope.pagingObject = {};
            $scope.parentIsLoaded = false;
            $scope.navigationUrls = {};
            $scope.archiveTypeChecker = {};
            //constants
            $scope.mobilePagingorInitialSize = "";
            var ALL_CATEGORY_NAME = "All";
            var CHILD_STATE = ".Child";
            $scope.isDesktop = operatingSystemSnifferService.isDesktopOs();
            var DEFAULT_PAGE_SIZE = ($state.is(stateNames.faq) || $state.is(stateNames.faqChild)) && $scope.isDesktop ? 50 : 5; //this janky stuff is needed in order to give JUST FAQs a default page size
            //constants
            // Globals
            $scope.initializeScrollingGlobals = function (virtualScrollisPaused) {
                $scope.endOfDataReached = false;
                $scope.virtualScrollisPaused = virtualScrollisPaused;
                nextVirtualScrollPage = 0;
                $scope.articleArray = [];
                $scope.totalItems = 0;
                if (!$scope.isDesktop) { // mobile should ignore all stateParams except category
                    $scope.pagingObject.currentPage = 0;
                    $scope.pagingObject.pageSize = $scope.mobilePagingorInitialSize;
                    $scope.pagingObject.numberOfPages = 0;
                }
            };
            $scope.addDisplayDateToArticles = function (articleArr) {
                if (articleArr && articleArr.length > 0) {
                    articleArr = cmsUtilService.convertStartEndDates(articleArr);
                    var isClosuresArchive = $state.current.name === stateNames.closuresArchiveChild;
                    articleArr = articleArr.map(function (article) {
                        return cmsUtilService.addDisplayDates(article, isClosuresArchive);
                    });
                }
                return articleArr;
            };
            $scope.setArchiveType = function () {
                $scope.archiveTypeChecker.isClosures = $state.current.name === stateNames.closuresArchiveChild;
                $scope.archiveTypeChecker.isFaqs = $state.current.name === stateNames.faqChild;
                $scope.archiveTypeChecker.isNews = $state.current.name === stateNames.newsArchiveChild;
            };
            $scope.getStateThatTriggersSearch = function () {
                return $state.current.parentState === $state.current.name ? CHILD_STATE : $state.current.name;
            };
            $scope.createInitialRequestObject = function () {
                return {
                    requests: [
                        {
                            itemId: $state.current.cms.pageTitleId,
                            fields: $state.current.cms.pageTitleFields
                        },
                        {
                            itemId: $state.current.cms.categoriesFolderId,
                            fields: $state.current.cms.categoriesFields
                        }
                    ],
                    topId: $state.current.cms.topSearch,
                    topFields: $state.current.cms.topFields,
                    searchSpecificCategory: true,
                    categoryId: $scope.categoryHolder.category.itemId,
                    categoryPagingInformation: {
                        pagingSuffix: "",
                        pageSize: $scope.pagingObject.pageSize === $scope.mobilePagingorInitialSize
                            ? DEFAULT_PAGE_SIZE : $scope.pagingObject.pageSize,
                        currentPage: $scope.pagingObject.currentPage,
                        itemId: "",
                        isClosures: $scope.archiveTypeChecker.isClosures,
                        isNews: $scope.archiveTypeChecker.isNews
                    }
                };
            };
            $scope.init = function () {
                $scope.setArchiveType();
                $scope.titleType = $state.current.cms.titleType;
                $scope.initializeScrollingGlobals(true); // virtual scroll should be paused until initial web api comes back 
                //$scope.categoryHolder.category.itemPath = $state.current.cms.categoriesPath + "/" + $scope.categoryHolder.category.itemName;
                var itemNameOnPageLoad = $scope.categoryHolder.category.itemName;
                $scope.categoryHolder.category.itemId = $state.current.cms.categoriesId;
                genericRepo.dataFactory.loadArchivePage($scope.createInitialRequestObject()).then(function (res) {
                    if (res.errors.length === 0) {
                        $scope.topTitle = angular.fromJson(res.responses[0].cmsResponse).Title;
                        $scope.articleNotFoundText = res.articleNotFoundText;
                        $scope.categories = res.categories;
                        var parsedFaqTopSearchResults = angular.fromJson(res.topSearchResults);
                        $scope.categoryHolder.category = $scope.categories[res.categoryIndex];
                        res.hyperLinkedArticles.articles = $scope.addDisplayDateToArticles(res.hyperLinkedArticles.articles);
                        $scope.saveSearchParameters(res.hyperLinkedArticles, false);
                        if (parsedFaqTopSearchResults) {
                            $scope.commonFaqArray = parsedFaqTopSearchResults.Query.Results;
                            $scope.topSearchResultsCount = parsedFaqTopSearchResults.Query.TotalCount;
                        }
                        $scope.virtualScrollisPaused = false; // should now unpause virtual scroll
                        if (itemNameOnPageLoad !== $scope.categoryHolder.category.itemName) {
                            var categoryFromUrl = $scope.categories.find(function (category) {
                                return category.itemName === itemNameOnPageLoad;
                            });
                            if (categoryFromUrl) {
                                $scope.categoryHolder.category = categoryFromUrl;
                                $scope.triggerPureSearchInChildState();
                                $scope.userClickedSearch();
                            }
                        }
                    }
                    else {
                        responseErrorService.displayErrorsFromResponse(res);
                    }
                });
            };
            $scope.buildSearchObject = function () {
                return {
                    pagingSuffix: "",
                    pageSize: $scope.pagingObject.pageSize === $scope.mobilePagingorInitialSize
                        ? DEFAULT_PAGE_SIZE : $scope.pagingObject.pageSize,
                    currentPage: $scope.pagingObject.currentPage,
                    itemId: $scope.categoryHolder.category.queryID,
                    //itemPath: $scope.categoryHolder.category.itemPath,
                    isClosures: $scope.archiveTypeChecker.isClosures,
                    isNews: $scope.archiveTypeChecker.isNews
                };
            };
            $scope.userClickedSearch = function () {
                $scope.initializeScrollingGlobals(false); // need to reset entire search if the user clicks search & virtual scroll should not be stopped (since page data has already been loaded)
                $scope.performSearch();
            };
            $scope.performSearch = function () {
                if (!$scope.isDesktop) { // Mobile specific checks
                    if ($scope.endOfDataReached || $scope.virtualScrollisPaused) { // should return if no more data is left or if angular still has not completed past WebApi call
                        return;
                    }
                    $scope.pagingObject.currentPage = nextVirtualScrollPage; // need to assign next page to load for virtual scroll
                }
                $scope.virtualScrollisPaused = true; // need to pause virtual scroll for call to Web Api
                var searchObject = $scope.buildSearchObject();
                genericRepo.dataFactory.executeCmsPaging(searchObject).then(function (response) {
                    if (response.errors.length === 0) {
                        response.articles = $scope.addDisplayDateToArticles(response.articles);
                        $scope.saveSearchParameters(response, true);
                        $scope.virtualScrollisPaused = false; // can now unpause virtual scroll
                    }
                    else {
                        responseErrorService.displayErrorsFromResponse(response);
                    }
                });
            };
            $scope.saveSearchParameters = function (response, shouldScroll) {
                $scope.pagingObject.numberOfPages = response.numberOfPages;
                $scope.totalItems = response.numberOfArticles;
                if ($scope.isDesktop) { // Desktop Paging -- this implementation does not cache!
                    $scope.setDesktopParameters(response, shouldScroll);
                }
                else { // Mobile Virtual Scrolling -- This implementation must cache!  Cache is erased on refresh.
                    $scope.setMobileParameters(response);
                }
            };
            $scope.setMobileParameters = function (response) {
                if ($scope.pagingObject.currentPage === $scope.pagingObject.numberOfPages - 1) { // if true, then reached the end of data
                    $scope.endOfDataReached = true;
                }
                else { // the end of Data has not yet been reached
                    $scope.endOfDataReached = false;
                    nextVirtualScrollPage++; // assigning next page to load
                }
                if (response.articles && response.articles.length > 0) {
                    response.articles.forEach(function (element) {
                        $scope.articleArray.push(element);
                    });
                }
            };
            $scope.setDesktopParameters = function (response, shouldScroll) {
                if (shouldScroll)
                    $scope.scrollToSearchResults();
                $scope.createNavigationUrls();
                $scope.articleArray = response.articles;
            };
            $scope.scrollToSearchResults = function () {
                $timeout(function () {
                    $location.hash("search-results");
                    $anchorScroll();
                    $location.hash("");
                });
            };
            $scope.createNavigationUrls = function () {
                $scope.navigationUrls.nextPage = $state.href($state.current.name, {
                    category: $scope.categoryHolder.category.itemName,
                    page: ($scope.pagingObject.currentPage) === (($scope.pagingObject.numberOfPages) - 1) ? $scope.pagingObject.currentPage : $scope.pagingObject.currentPage + 1,
                    size: $scope.pagingObject.pageSize
                });
                $scope.navigationUrls.previousPage = $state.href($state.current.name, {
                    category: $scope.categoryHolder.category.itemName,
                    page: ($scope.pagingObject.currentPage) === 0 ? $scope.pagingObject.currentPage : $scope.pagingObject.currentPage - 1,
                    size: $scope.pagingObject.pageSize
                });
            };
            $scope.loadArchivePage = function () {
                if ($state.current.parentState && $state.is($state.current.parentState)) {
                    $state.go(CHILD_STATE, {
                        category: ALL_CATEGORY_NAME,
                        page: 0,
                        size: $scope.mobilePagingorInitialSize
                    });
                }
            };
            $scope.triggerSearchAndClearInChildState = function () {
                $state.go($scope.getStateThatTriggersSearch(), {
                    category: $scope.categoryHolder.category.itemName,
                    page: 0,
                    size: $scope.mobilePagingorInitialSize
                });
            };
            $scope.triggerPureSearchInChildState = function () {
                $state.go($scope.getStateThatTriggersSearch(), {
                    category: $scope.categoryHolder.category.itemName,
                    page: $scope.pagingObject.currentPage,
                    size: $scope.pagingObject.pageSize
                });
            };
            // redirect controller
            $scope.loadArchivePage();
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("SingleArticleController", ['$scope', 'homeStates', 'genericRepo', 'responseErrorService', '$state', 'stateNames', '$filter', 'cmsUtilService',
        function ($scope, homeStates, genericRepo, responseErrorService, $state, stateNames, $filter, cmsUtilService) {
            $scope.returnState;
            $scope.date = "";
            var CLOSURES_REDIRECT_TEXT = "View Closures Archive";
            var FAQ_REDIRECT_TEXT = "View all Frequently Asked Questions";
            $scope.init = function () {
                var path = $state.current.cms.path;
                var id = $state.current.cms.id;
                if (path) {
                    if (path.indexOf("Closures") !== -1) {
                        $scope.redirectText = CLOSURES_REDIRECT_TEXT;
                        $scope.returnState = stateNames.closuresArchive;
                        $scope.initialRequestById(id);
                    }
                    else if (path.indexOf("FAQ") !== -1) {
                        $scope.redirectText = FAQ_REDIRECT_TEXT;
                        $scope.returnState = stateNames.faq;
                        $scope.initialRequestById(id);
                    }
                    else if (path.indexOf("News") !== -1) {
                        $scope.redirectText = "View News Archive";
                        $scope.returnState = stateNames.newsArchive;
                        $scope.initialRequestById(id);
                    }
                    else {
                        $state.go(homeStates.Frame);
                    }
                }
                else {
                    $state.go(homeStates.Frame);
                }
            };
            var neededSitecoreFields = "Title,ShortDescription,LongDescription,StartDate,EndDate,__Updated,HasChildren,ItemID,NewsDisplayDate,SubTitle&includeStandardTemplatefields=true";
            $scope.initialRequestById = function (id) {
                var requestObject = {
                    itemId: id,
                    fields: neededSitecoreFields
                };
                genericRepo.dataFactory.getCmsPageById(requestObject).then(formatResponseData);
            };
            var formatResponseData = function (response) {
                if (response.errors.length <= 0) {
                    $scope.cmsData = angular.fromJson(response.cmsResponse);
                    $scope.date = $scope.formatDate($scope.cmsData);
                    if ($scope.cmsData.LongDescription) {
                        $scope.cmsData.description = $scope.cmsData.LongDescription;
                    }
                    else {
                        $scope.cmsData.description = $scope.cmsData.ShortDescription;
                    }
                }
                else {
                    responseErrorService.displayErrorsFromResponse(response);
                }
            };
            $scope.formatDate = function (cmsData) {
                if ($scope.redirectText === CLOSURES_REDIRECT_TEXT) {
                    var article = cmsUtilService.convertStartEndDates(angular.copy([cmsData]))[0];
                    return cmsUtilService.addDisplayDates(article, true).displayDate;
                }
                else {
                    var date = $scope.redirectText === FAQ_REDIRECT_TEXT ? cmsData.__Updated : cmsData.NewsDisplayDate;
                    return "Published on: " + $filter('date')(date, 'longDate');
                }
            };
            $scope.returnToListOfArticles = function () {
                $state.go($scope.returnState);
            };
            $scope.init();
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("MapsCmsController", ['$scope', 'genericRepo', '$state', 'responseErrorService',
        function ($scope, genericRepo, $state, responseErrorService) {
            var request = {
                itemId: $state.current.cms.itemId,
                fields: $state.current.cms.fields
            };
            genericRepo.dataFactory.getCmsPageById(request).then(function (res) {
                if (res.errors.length == 0) {
                    var parsedRes = angular.fromJson(res.cmsResponse);
                    //$scope.headerTitle = parsedRes.Title;
                    //$scope.headerContent = parsedRes.LongDescription;
                    //$scope.bodyDataList = parsedRes.Children[0].Children[0].Children;
                    $scope.map = parsedRes;
                    $scope.topContent = parsedRes.Children[0];
                    $scope.bottomContent = parsedRes.Children[1];
                }
                else {
                    responseErrorService.displayErrorsFromResponse(res);
                }
            });
        }
    ]);
}());
/*
(function () {
    'use strict';

    angular.module('HCTRAModule').controller("RatesController", ['$scope', '$state', '$location', 'genericRepo', 'ratesService', 'stringCheckService', 'objectUtilService',
        function ($scope, $state, $location, genericRepo, ratesService, stringCheckService, objectUtilService) {

            $scope.isFloat = stringCheckService.isFloat;

            $scope.axleClassSelected = function (axleClass) {
                if ($scope.selectedClass) {
                    return $scope.selectedClass.Label == axleClass || $scope.selectedClass.Label == ratesService.allAxles;
                }
                return true;
            };

            $scope.$on("$locationChangeSuccess", function () {
                if ($scope.tollRoads) {
                    setFirstSelectedOptions();
                }
            });


            function setFirstSelectedOptions() {
                var urlSelectedTollRoad = objectUtilService.toLowerCaseKeys($location.search()).tollroad;
                if (urlSelectedTollRoad) {
                    for (var i = 0; i < $scope.tollRoads.length; i++) {
                        if (urlSelectedTollRoad === $scope.tollRoads[i].Title) {
                            $scope.selectedTollRoad = $scope.tollRoads[i];
                        }
                    }
                }
                if (!$scope.selectedTollRoad) {
                    $scope.selectedTollRoad = $scope.tollRoads[0];
                }

                $scope.selectedDirection = $scope.selectedTollRoad.Directions[0];
            }

            var init = function () {
                var requestRates = {
                    itemId: $state.current.cms.itemId,
                    fields: $state.current.cms.fields
                };
                genericRepo.dataFactory.getCmsPageById(requestRates).then(function (res) {
                    var parsedRes = angular.fromJson(res.cmsResponse);

                    $scope.pageTitle = parsedRes.Title;
                    $scope.tollRoads = ratesService.mapTollRoads(parsedRes.Children[0].Children);
                    $scope.ratesService = ratesService;

                    if ($scope.tollRoads) {
                        setFirstSelectedOptions();
                    }
                });
            };
            init();

        }]);
}());
*/ 
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("RoadsideAssistanceCmsController", ['$scope', 'genericRepo', 'cmsUtilService', 'responseErrorService', 'routes', '$timeout', '$anchorScroll', '$location',
        function ($scope, genericRepo, cmsUtilService, responseErrorService, routes, $timeout, $anchorScroll, $location) {
            var request = {
                itemId: routes.roadsideAssistanceContentCms,
                fields: "LongDescription,Title,FullName,Location,ShortDescription,Image,ItemName"
            };
            genericRepo.dataFactory.getCmsPageById(request).then(function (res) {
                if (res.errors.length == 0) {
                    var parsedRes = angular.fromJson(res.cmsResponse);
                    $scope.topTitle = parsedRes.Title;
                    $scope.header = parsedRes.Children[0];
                    $scope.header.ItemName = $scope.header.ItemName.toLowerCase();
                    $scope.contact = parsedRes.Children[1];
                    $scope.contact.ItemName = $scope.contact.ItemName.toLowerCase();
                    $scope.about = parsedRes.Children[2];
                    $scope.about.ItemName = $scope.about.ItemName.toLowerCase();
                    $scope.testimonialsHeader = parsedRes.Children[3];
                    $scope.testimonialsHeader.ItemName = $scope.testimonialsHeader.ItemName.toLowerCase();
                    $scope.testimonialsList = parsedRes.Children[3].Children[0].Children;
                    $scope.overviewImageSrc = cmsUtilService.generateFileSrc($scope.header.Image);
                    $scope.overviewImageAltText = cmsUtilService.parseAltText($scope.header.Image);
                    $timeout(function () {
                        $location.hash($location.hash().toLowerCase());
                        $anchorScroll();
                    }, 500);
                }
                else {
                    responseErrorService.displayErrorsFromResponse(res);
                }
            });
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("TollRoadInformationFrameController", ['$scope', '$state', 'stateNames',
        function ($scope, $state, stateNames) {
            $scope.currentState = $state.current.name;
            $scope.tollRoadInformationState = stateNames.tollRoadInformation;
            $scope.laneTypesState = stateNames.laneTypes;
            $scope.goToTollRoadInformation = function () {
                $state.go(stateNames.tollRoadInformation);
                $scope.currentState = stateNames.tollRoadInformation;
            };
            $scope.goToLaneTypes = function () {
                $state.go(stateNames.laneTypes);
                $scope.currentState = stateNames.laneTypes;
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var CmsTextInsertionService = /** @class */ (function () {
            function CmsTextInsertionService() {
            }
            CmsTextInsertionService.prototype.dynamicContent = function (inputString, options) {
                if (options === void 0) { options = null; }
                options = angular.extend({ pathNorm: [] }, options || {});
                var propPath = options.pathNorm.map(function (p) { return p.replace("$", "$$"); }).slice();
                propPath.push("$1");
                return (inputString || "").replace(/\[\[([\w|\s]+)\]\]/g, "{{" + propPath.join('.') + "}}");
            };
            CmsTextInsertionService.prototype.insertValues = function (valuesObject, stringToInsert) {
                for (var key in valuesObject) {
                    if (valuesObject.hasOwnProperty(key)) {
                        if (stringToInsert.indexOf('[[' + key + ']]') !== -1) {
                            stringToInsert = stringToInsert.replace('[[' + key + ']]', valuesObject[key]);
                        }
                    }
                }
                return stringToInsert;
            };
            CmsTextInsertionService.prototype.checkOptional = function (valuesObject, stringToInsert) {
                for (var key in valuesObject) {
                    if (valuesObject.hasOwnProperty(key)) {
                        if (!valuesObject[key]) {
                            var regex = new RegExp("\\{(?:\\{|\\^)\\{.*\\[\\[" + key + "\\]\\].*\\}(?:\\}|\\^)\\}");
                            stringToInsert = stringToInsert.replace(regex, "");
                        }
                        else {
                            stringToInsert = stringToInsert.replace('[[' + key + ']]', valuesObject[key]);
                        }
                    }
                }
                stringToInsert = stringToInsert.replace("{{{", "").replace("}}}", "").replace("{^{", "").replace("}^}", "");
                return stringToInsert;
            };
            return CmsTextInsertionService;
        }());
        Service.CmsTextInsertionService = CmsTextInsertionService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('cmsTextInsertionService', [function () { return new HCTRA.Service.CmsTextInsertionService(); }]);
}());
//migrated
/*
(function () {

    'use strict';

    angular.module('HCTRAModule').factory('metadataManagerService', ['javaObjectUtilService', '$location', '$q', 'urlManagerService', 'objectUtilService', 'wildCardUrlCheckerService',
        function (javaObjectUtilService, $location, $q, urlManagerService, objectUtilService, wildCardUrlCheckerService) {

            // these are template name configured in Sitecore for the respective articles
            var articleArray = ["News", "Closure", "FAQ"];

            var metadataDictionary = {};

            function injectMetaDataIfNeeded(relativeUrl) {
                return $q(function (fulfill) {

                    // if metaDataDictionary is not empty and contains the neccessary information, then no WebApi call is neccessary
                    if (!javaObjectUtilService.isEmpty(metadataDictionary)) {
                        fulfill(returnMetadataOrIndicatePageShouldBeIgnored(relativeUrl));
                    } else { // missing information, need to make a WebApi call for info
                        urlManagerService.getMetadata().then(
                            function (response) {
                                if (!response.errors) {
                                    metadataDictionary = response.metadata;
                                    fulfill(returnMetadataOrIndicatePageShouldBeIgnored(relativeUrl));
                                }
                            }
                        );
                    }
                });
            }

            var urlParametersToConsider = ['tollRoad'];
            //function modifyRelativeUrlForUrlParamsInSitecore(relativeUrl) {
            function modifyRelativeUrlForUrlParamsInSitecore(relativeUrl) {
                // Include url search parameter if the full url has its own Sitecore page
                return objectUtilService.hasAnyOfKeysInList($location.search(), urlParametersToConsider) ?
                    decodeURIComponent($location.url()) : relativeUrl;
            }

            function lookupMetadataForWilcardRelativeUrl(neededMetadataEntry, relativeUrl) {
                // this is needed for angular states that have dynamic state parameters
                return neededMetadataEntry ? neededMetadataEntry :
                                    metadataDictionary[wildCardUrlCheckerService.findParentUrlInWildCardDict(relativeUrl)];
            }

            function returnMetadataOrIndicatePageShouldBeIgnored(relativeUrl) {
                relativeUrl = modifyRelativeUrlForUrlParamsInSitecore(relativeUrl);
                var neededMetadataEntry = metadataDictionary[relativeUrl];
                neededMetadataEntry = lookupMetadataForWilcardRelativeUrl(neededMetadataEntry, relativeUrl);
                if (neededMetadataEntry) {
                    if (neededMetadataEntry.includeInSearch) {
                        if (articleArray.indexOf(neededMetadataEntry.templateName) == -1) {
                            neededMetadataEntry.templateName = "";
                        }
                        neededMetadataEntry.doNotIndex = false;
                        return neededMetadataEntry;
                    } else {
                        return { doNotIndex: true, searchTitle: neededMetadataEntry.searchTitle };
                    }
                } else {
                    return {doNotIndex: true};
                }
            }

            return {
                metadataDictionary: metadataDictionary,
                injectMetaDataIfNeeded: injectMetaDataIfNeeded,
                urlParametersToConsider: urlParametersToConsider,
                modifyRelativeUrlForUrlParamsInSitecore: modifyRelativeUrlForUrlParamsInSitecore,
                lookupMetadataForWilcardRelativeUrl: lookupMetadataForWilcardRelativeUrl,
                returnMetadataOrIndicatePageShouldBeIgnored: returnMetadataOrIndicatePageShouldBeIgnored
            };
        }]);
}());
*/ 
(function () {
    'use strict';
    angular.module('HCTRAModule').service('ratesService', ['stringCheckService', 'stringUtilsService', '$filter',
        function (stringCheckService, stringUtilsService, $filter) {
            this.allAxles = 'All Axles';
            var noRateData = 'No rate data';
            var mapTollSections = function (tollLocationsArray) {
                var locationRates = [];
                if (!tollLocationsArray) {
                    locationRates.push({
                        TollingLocations: noRateData
                    });
                    return locationRates;
                }
                for (var i = 0; i < tollLocationsArray.length; i++) {
                    var currentLocation = tollLocationsArray[i];
                    // Ensure no blank strings
                    for (var prop in currentLocation) {
                        if (prop.toLowerCase().indexOf('rates') > -1) {
                            var propValue = currentLocation[prop];
                            var ratesArray = formatRatesArray(stringUtilsService.getParameterArray(propValue));
                            for (var index = 0; index < ratesArray.length; index++) {
                                if (ratesArray[index].Value.toString().trim() === '' && ratesArray[index].Label.toString().toLowerCase().includes("cash")) {
                                    ratesArray[index].Value = 'Cash Not Accepted';
                                }
                                else if (stringCheckService.isFloat(ratesArray[index].Value)) {
                                    ratesArray[index].Value = $filter('currency')(ratesArray[index].Value);
                                }
                            }
                            delete currentLocation[prop];
                            currentLocation[prop] = ratesArray;
                        }
                    }
                    // Set Bold to boolean
                    if (currentLocation['Bold'].toLowerCase() === 'yes') {
                        currentLocation['Bold'] = true;
                    }
                    else {
                        currentLocation['Bold'] = false;
                    }
                    // Set Position to float
                    currentLocation['Position'] = parseFloat(currentLocation['Position']);
                    locationRates.push(currentLocation);
                }
                // Sort based on Position property
                locationRates = locationRates.sort(function (a, b) {
                    if (a.Position > b.Position) {
                        return 1;
                    }
                    if (a.Position < b.Position) {
                        return -1;
                    }
                    return 0;
                });
                return locationRates;
            };
            var mapTollRoadDirections = function (directionsArray) {
                var directions = [];
                if (!directionsArray) {
                    return directions;
                }
                for (var i = 0; i < directionsArray.length; i++) {
                    var currentDirection = directionsArray[i];
                    directions.push({
                        Direction: currentDirection.DisplayName,
                        TollSections: mapTollSections(currentDirection.Children)
                    });
                }
                return directions;
            };
            this.createAxleDropdown = function (tollRoad) {
                if (tollRoad.Directions.length > 0) {
                    var axleArray = angular.copy(tollRoad.Directions[0].TollSections[0].Rates);
                    // Sort based on axle class
                    axleArray = axleArray.sort(function (a, b) {
                        if (a.Label > b.Label) {
                            return 1;
                        }
                        if (a.Label < b.Label) {
                            return -1;
                        }
                        return 0;
                    });
                    // Add All Axles option
                    axleArray.unshift({
                        Label: this.allAxles,
                        Value: this.allAxles
                    });
                    return axleArray;
                }
            };
            var formatRatesArray = function (ratesArray) {
                var rates = [];
                for (var index = 0; index < ratesArray.length; index++) {
                    var rateLabel = ratesArray[index][0];
                    var rateValue = ratesArray[index][1];
                    rates.push({
                        Label: rateLabel,
                        Value: rateValue
                    });
                }
                return rates;
            };
            this.mapTollRoads = function (tollRoadsArray) {
                var tollRoads = [];
                for (var i = 0; i < tollRoadsArray.length; i++) {
                    var currentTollRoad = tollRoadsArray[i];
                    var tollRoadObj = {
                        Title: currentTollRoad.Title,
                        LongDescription: currentTollRoad.LongDescription,
                        Directions: mapTollRoadDirections(currentTollRoad.Children)
                    };
                    if (tollRoadObj.Directions.length === 0) {
                        tollRoadObj.HideSelect = true;
                    }
                    tollRoads.push(tollRoadObj);
                }
                return tollRoads;
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller('AppController', ['$scope', 'USER_ROLES', 'AuthService', '$rootScope', 'routes', '$window', 'responsiveService', 'bowserService', 'operatingSystemSnifferService', 'stateStackMemoryService', '$location', 'metadataManagerService', 'genericRepo', 'responseErrorService', 'focusExclusionService', 'wildCardUrlCheckerService', 'rssService', 'maintenanceService', 'serverConstants', 'StorefrontService', '$transitions',
        function ($scope, USER_ROLES, AuthService, $rootScope, routes, $window, responsiveService, bowserService, operatingSystemSnifferService, stateStackMemoryService, $location, metadataManagerService, genericRepo, responseErrorService, focusExclusionService, wildCardUrlCheckerService, rssService, maintenanceService, serverConstants, StorefrontService, $transitions) {
            $rootScope.currentUser = null;
            $scope.isAuthorized = AuthService.isAuthorized;
            $scope.isAuthenticated = AuthService.isAuthenticated;
            $scope.userRoles = USER_ROLES;
            $scope.remoteObj = {};
            $scope.isMobile = responsiveService.isMobile();
            $scope.metaData = {};
            $scope.rssData = {};
            $scope.isDesktopMode = true;
            if (StorefrontService.isEnabled()) {
                $scope.isDesktopMode = false;
            }
            //call the service to set the correct OS for reference 
            operatingSystemSnifferService.getOS();
            //$scope.focusFirstField = function () {
            //    var locationPath = $location.path();
            //    if ( $scope.remoteObj.focusFirstField && !focusExclusionService.dictByUrl[locationPath]
            //        && !wildCardUrlCheckerService.wildCardUrlisMatch(locationPath, focusExclusionService.dictByWildCard)) {
            //        $scope.remoteObj.focusFirstField();
            //    }
            //};
            $scope.focusFirstField = function () {
                var locationPath = $location.path();
                if (!focusExclusionService.dictByUrl[locationPath]
                    && !wildCardUrlCheckerService.wildCardUrlisMatch(locationPath, focusExclusionService.dictByWildCard)) {
                    var jqFields = angular.element('input[required], input[required="required"], select[required], select[required="required"], textarea[required], textarea[required="required"]');
                    if (jqFields.length > 0) {
                        var jqFirst = jqFields.eq(0);
                        if (jqFirst.attr('id') === 'inputSearch') {
                            jqFirst = jqFields.eq(1);
                        }
                        if (jqFirst.focus) {
                            angular.element(jqFirst).focus();
                        }
                    }
                }
            };
            $scope.$on('$viewContentLoaded', function () {
                if (serverConstants.currentlyDownloadedWebUiVersion && $rootScope.latestWebUiVersion &&
                    $rootScope.latestWebUiVersion !== serverConstants.currentlyDownloadedWebUiVersion) {
                    if (StorefrontService.isEnabled()) {
                        StorefrontService.hardReset();
                    }
                    else {
                        $window.location.reload(true);
                    }
                }
            });
            /**
             * Event-Listener for Back-Button
             */
            /** Event-listener for state changes for addition to logging*/
            //		$scope.$on('$stateChangeStart', function (evt, toState) {
            //			var stateSub = toState.name.substr(0, 10);
            //			if (stateSub === 'SectionalC' || stateSub === 'NonSection') {
            //				stateStackMemoryService.addStateToStackMemory($location.url(), 'url');
            //			} else {
            //				stateStackMemoryService.addStateToStackMemory(toState.name, 'state');
            //			}
            //		});
            $transitions.onStart({}, function (transition) {
                var stateSub = transition.to().name.substr(0, 10);
                if (stateSub === 'SectionalC' || stateSub === 'NonSection') {
                    stateStackMemoryService.addStateToStackMemory($location.url(), 'url');
                }
                else {
                    stateStackMemoryService.addStateToStackMemory(transition.to().name, 'state');
                }
            });
            $scope.executeMetadataInjection = function (path) {
                metadataManagerService.injectMetaDataIfNeeded(path).then(function (metaDataGetResponse) {
                    $scope.metaData = angular.copy(metaDataGetResponse);
                }, function (rejectedResponse) {
                    responseErrorService.displayErrorsFromResponse(rejectedResponse);
                });
            };
            $scope.executeRssInjection = function () {
                rssService.injectRssData().then(function (rssDataResponse) {
                    $scope.rssData = angular.copy(rssDataResponse);
                });
            };
            /* Fix for Bug 5049: */
            // Issue exists with incorporating SVGs and Prototype.js in IE11 because XPath feature isn't supported by IE11
            // As such Prototype.js uses hasClassName for DOM elements, but SVG isn't a basic DOM element
            // Runs into "Object doesn't support property or method 'match'" error
            if (bowserService.bowser.name == 'Internet Explorer' && bowserService.bowser.version >= 10) {
                if (angular.isUndefined(SVGAnimatedString.prototype.match)) {
                    SVGAnimatedString.prototype.match = function () { return String.prototype.match.apply(this.baseVal, arguments); };
                }
                if (angular.isUndefined(SVGElement.prototype.className)) {
                    SVGElement.prototype.className = (function () {
                        if (this && this.attributes && this.attributes.length > 0) {
                            for (var i = 0; this.attributes.length; i++) {
                                var attr = this.attributes[i];
                                if (attr.name && attr.name === 'class') {
                                    return attr.name;
                                }
                            }
                        }
                        return '';
                    }());
                }
            }
            /* End Fix for Bug 5049 */
            // Footer CMS call
            var request = {
                itemId: routes.footerLinksCms,
                fields: "URL,SitecorePagePath,OpenNewTab,ShowInMobile,ShortDescription,Title,SitecoreSectionName"
            };
            genericRepo.dataFactory.getCmsPageById(request).then(function (res) {
                if (res.errors.length == 0) {
                    var parsedRes = angular.fromJson(res.cmsResponse);
                    $scope.footerCopyright = parsedRes.Children[1];
                    $scope.footerLinkList = parsedRes.Children[0].Children[0].Children;
                }
                else {
                    responseErrorService.displayErrorsFromResponse(res);
                }
            });
            maintenanceService.considerMaintenancePopup();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('AuthResolver', ['$q', '$rootScope', '$state', 'AuthService',
        'USER_ROLES', 'addMissingInformationService', 'loginStates', 'authenticateRedirectService', 'StorefrontUtilityService',
        function ($q, $rootScope, $state, AuthService, USER_ROLES, addMissingInformationService, loginStates, authenticateRedirectService, StorefrontUtilityService) {
            return {
                resolve: function (authorizedRoles) {
                    var deferred = $q.defer();
                    if (authorizedRoles.indexOf(USER_ROLES.anonymous) > -1 &&
                        !addMissingInformationService.missingInformationIsAnIssue() && addMissingInformationService.returnProfileCallHasOccured()) { //profileCallHasOccured needed to accurately check missinginformation
                        deferred.resolve("success");
                    }
                    else {
                        var unwatch = $rootScope.$watch('currentUser', function (currentUser) {
                            if (currentUser != null) {
                                if (AuthService.isAuthorized(authorizedRoles) || // need rest of if statement in order to verify that missing information is not an issue
                                    (authorizedRoles.indexOf(USER_ROLES.anonymous) > -1 && (!addMissingInformationService.missingInformationIsAnIssue()
                                        || !AuthService.isAuthenticated()))) {
                                    deferred.resolve("success");
                                }
                                else {
                                    if (!AuthService.isAuthenticated()) {
                                        deferred.reject('notAuthenticated');
                                    }
                                    else if (addMissingInformationService.missingInformationIsAnIssue()) {
                                        var isKiosk = StorefrontUtilityService.isRunningAsKiosk;
                                        var isFullSiteMode = StorefrontUtilityService.webStoreData
                                            ? StorefrontUtilityService.webStoreData.fullSiteMode
                                            : false;
                                        //don't block kiosk from navigating away in kiosk mode
                                        if (isKiosk && !isFullSiteMode) {
                                            deferred.resolve("success");
                                        }
                                        else {
                                            addMissingInformationService.showBlockUserNavModal();
                                            deferred.reject(USER_ROLES.missingRequiredInformation);
                                        }
                                    }
                                    else {
                                        deferred.reject('notAuthorized');
                                    }
                                }
                                unwatch && unwatch();
                            }
                        });
                    }
                    deferred.promise.then(function () {
                        //only enters this code if deferred.resolve is called
                    }, function (res) {
                        //$location.replace();
                        if (res === "notAuthenticated") {
                            authenticateRedirectService.saveToState();
                            return $state.go(loginStates.Login);
                        }
                        else if (res === USER_ROLES.missingRequiredInformation) {
                            return $state.go(loginStates.AddMissingInformation);
                        }
                        else if (res === "notAuthorized") {
                            // Handled automatically by ui-router.
                            // User will be sent back to last successfully loaded state.
                            // If a url was entered, the last successfully loaded state is "".
                            // This case is handled in the app.js callback $stateChangeError.
                        }
                    });
                    return deferred.promise;
                }
            };
        }]);
}());
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
describe("ScriptInjectorComponent tests", function () {
    var $window;
    var scriptTagSpy;
    var environmentConfig;
    var loggingService;
    var serverConstants;
    var component;
    beforeEach(angular.mock.module("HCTRAModule"));
    beforeEach(angular.mock.inject(function () {
        $window = {
            document: jasmine.createSpyObj("document", ["createElement", "getElementsByTagName", "querySelector", "readyState"]),
            setTimeout: function (func, num) { setTimeout(func, num); },
            addEventListener: function () { }
        };
        scriptTagSpy = jasmine.createSpyObj("scriptTagSpy", ["setAttribute", "addEventListener", "appendChild"]);
        loggingService = jasmine.createSpyObj("loggingService", ["logMessage"]);
        $window.document.createElement.and.returnValue(scriptTagSpy);
        $window.document.getElementsByTagName.and.returnValue([scriptTagSpy]);
        environmentConfig = {
            scriptIntegrityConfig: {},
            mcAfeeIconQuerySelector: 'fake selector'
        };
        serverConstants = { currentlyDownloadedWebUiVersion: "1.2.3" };
        component = new HCTRA.Controller.ScriptInjectorController($window, environmentConfig, loggingService, serverConstants);
        component.$onInit();
    }));
    it("can create a component", function () {
        expect(component).toBeDefined();
    });
    describe("bindings based logic", function () {
        it("does not try to create script tags if disabled", function () {
            component["enable"] = false;
            component.$postLink();
            expect($window.document.createElement).not.toHaveBeenCalled();
        });
        it("tries to create script tags if enabled", function () {
            component["enable"] = true;
            spyOn(component, "isValidIntegrityValue").and.returnValue(true);
            component.$postLink();
            expect($window.document.createElement).toHaveBeenCalled();
        });
    });
    describe("$postLink", function () {
        it("should call addScriptElementToDOM() ", function () {
            component["enable"] = true;
            component["srcAttempt"] = "https://cdn.test.org";
            component["srcFallback"] = "/Client_build/mcAfeeFallbackScript.js";
            spyOn(component, "addScriptElementToDOM");
            spyOn(component, "isValidIntegrityValue").and.returnValue(true);
            component.$postLink();
            expect(component["addScriptElementToDOM"]).toHaveBeenCalledTimes(1);
        });
        it("should not call addScriptElementToDOM() ", function () {
            component["enable"] = true;
            component["srcAttempt"] = "https://cdn.test.org";
            component["srcFallback"] = "/Client_build/mcAfeeFallbackScript.js";
            spyOn(component, "addScriptElementToDOM");
            spyOn(component, "isValidIntegrityValue").and.returnValue(false);
            component.$postLink();
            expect(component["addScriptElementToDOM"]).toHaveBeenCalledTimes(0);
        });
    });
    describe("addScriptElementToDOM()", function () {
        it("should set all attributes of the script tag", function () {
            spyOn(component, "addScriptElementToDOM").and.callThrough();
            component["addScriptElementToDOM"]({ myAttr: 'hello' });
            expect($window.document.createElement).toHaveBeenCalledWith("script");
            expect($window.document.createElement).toHaveBeenCalledTimes(1);
            expect(scriptTagSpy.setAttribute).toHaveBeenCalledTimes(1);
        });
        it("should call getElementsByTagName() and appendChild()", function () {
            spyOn(component, "addScriptElementToDOM").and.callThrough();
            component["addScriptElementToDOM"]({ myAttr: 'hello' });
            expect($window.document.getElementsByTagName).toHaveBeenCalledWith("head");
            expect($window.document.getElementsByTagName).toHaveBeenCalledTimes(1);
            var myElement = $window.document.getElementsByTagName("scriptTagHere")[0];
            expect(myElement.appendChild).toHaveBeenCalledTimes(1);
        });
        it("should prove checkElementPresence() is added to new script tag load event", function () {
            //Assemble
            spyOn(component, "addScriptElementToDOM").and.callThrough();
            spyOn(component, "checkElementPresence");
            scriptTagSpy.addEventListener.and.callThrough();
            //Act
            component["addScriptElementToDOM"]({ myAttr: 'hello' });
            var myElement = $window.document.getElementsByTagName("scriptTagHere")[0];
            //Assert
            expect(myElement.addEventListener.calls.argsFor(0)).toEqual(["load", jasmine.any(Function), false]);
        });
    });
    describe("isValidIntegrityValue()", function () {
        [
            { shaKey: "sha256-test" },
            { shaKey: "sha384-test" },
            { shaKey: "sha512-test" }
        ].forEach(function (_a) {
            var shaKey = _a.shaKey;
            it("should return true when shaKey is " + shaKey, function () {
                var result = component["isValidIntegrityValue"]("" + shaKey);
                expect(result).toBe(true);
            });
        });
        [
            { shaKey: "sha999-test" },
            { shaKey: "test-test" },
            { shaKey: "" },
            { shaKey: " " },
            { shaKey: undefined },
            { shaKey: null },
            { shaKey: null }
        ].forEach(function (_a) {
            var shaKey = _a.shaKey;
            it("should return false when shaKey is " + shaKey, function () {
                var result = component["isValidIntegrityValue"]("" + shaKey);
                expect(result).toBe(false);
            });
        });
    });
    describe("onError()", function () {
        it("should call log()", function () {
            var myElement = {
                src: "mysrc",
                parentNode: {
                    removeChild: jasmine.createSpy('removeChild')
                },
                hasAttribute: jasmine.createSpy('hasAttribute')
            };
            myElement.parentNode.removeChild.and.callThrough();
            myElement.hasAttribute.and.returnValue(false);
            spyOn(component, "logSrcThatFailedToLoad").and.callThrough();
            component["onError"](myElement);
            expect(component["logSrcThatFailedToLoad"]).toHaveBeenCalledTimes(1);
        });
        it("should call parentNode.removeChild()", function () {
            var myElement = {
                src: "mysrc",
                parentNode: {
                    removeChild: jasmine.createSpy('removeChild')
                },
                hasAttribute: jasmine.createSpy('hasAttribute')
            };
            myElement.parentNode.removeChild.and.callThrough();
            myElement.hasAttribute.and.returnValue(false);
            component["onError"](myElement);
            expect(myElement.parentNode.removeChild).toHaveBeenCalledTimes(1);
        });
        it('should call addScriptElementToDOM() when element has attribute "srcFallback"', function () {
            var myElement = {
                src: "mysrc",
                parentNode: {
                    removeChild: jasmine.createSpy('removeChild')
                },
                hasAttribute: jasmine.createSpy('hasAttribute')
            };
            component["scriptIntegrityObj"] = {
                ShaKey: "fakeShaKey",
                CrossoriginAttribute: "fakeCrossoriginAttribute",
                SrcFallback: "hurdeedur.js"
            };
            spyOn(component, "addScriptElementToDOM").and.callThrough();
            myElement.parentNode.removeChild.and.callThrough();
            myElement.hasAttribute.and.returnValue(true);
            component["onError"](myElement);
            expect(component["addScriptElementToDOM"]).toHaveBeenCalledTimes(1);
            expect(component["addScriptElementToDOM"]).toHaveBeenCalledWith({ type: "text/javascript", src: "hurdeedur.js?123" });
        });
        it('should not call addScriptElementToDOM() when element does not have attribute "srcFallback"', function () {
            var myElement = {
                src: "mysrc",
                parentNode: {
                    removeChild: jasmine.createSpy('removeChild')
                },
                hasAttribute: jasmine.createSpy('hasAttribute')
            };
            spyOn(component, "addScriptElementToDOM").and.callThrough();
            myElement.parentNode.removeChild.and.callThrough();
            myElement.hasAttribute.and.returnValue(false);
            component["onError"](myElement);
            expect(component["addScriptElementToDOM"]).toHaveBeenCalledTimes(0);
        });
    });
    describe("checkElementPresence()", function () {
        var originalTimeout;
        beforeEach(function () {
            originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
            jasmine.DEFAULT_TIMEOUT_INTERVAL = 200000;
        });
        afterEach(function () {
            jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;
        });
        it("should not call loggingService.logMessage()", function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spyOn($window, "setTimeout").and.callThrough();
                        $window.document.querySelector.and.returnValue('element exists');
                        return [4 /*yield*/, component["checkElementPresence"]('fakeElementId')];
                    case 1:
                        _a.sent();
                        expect(loggingService.logMessage).toHaveBeenCalledTimes(0);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should call loggingService.logMessage()", function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spyOn($window, "setTimeout").and.callThrough();
                        $window.document.querySelector.and.returnValue(undefined);
                        return [4 /*yield*/, component["checkElementPresence"]('fakeElementId')];
                    case 1:
                        _a.sent();
                        expect(loggingService.logMessage).toHaveBeenCalledTimes(1);
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        // Dynamically builds a script tag and add it the head tag then the enable attribute turns true
        var ScriptInjectorController = /** @class */ (function () {
            function ScriptInjectorController($window, environmentConfig, loggingService, serverConstants) {
                var _this = this;
                this.$window = $window;
                this.environmentConfig = environmentConfig;
                this.loggingService = loggingService;
                this.serverConstants = serverConstants;
                // Properties
                this.elementType = "text/javascript";
                this.$onInit = function () {
                    _this.scriptIntegrityObj = _this.environmentConfig.scriptIntegrityConfig[_this.srcAttempt] || {};
                };
                this.$postLink = function () {
                    if (_this.enable) {
                        var originalElementAttributes = {
                            type: _this.elementType,
                            src: _this.srcAttempt,
                            integrity: _this.scriptIntegrityObj.ShaKey,
                            crossorigin: _this.scriptIntegrityObj.CrossoriginAttribute,
                            srcFallback: _this.scriptIntegrityObj.SrcFallback
                        };
                        if (_this.isValidIntegrityValue(_this.scriptIntegrityObj.ShaKey)) {
                            _this.addScriptElementToDOM(originalElementAttributes);
                        }
                    }
                };
                this.onError = function (newScriptElement) {
                    _this.logSrcThatFailedToLoad(newScriptElement.src);
                    newScriptElement.parentNode.removeChild(newScriptElement);
                    if (newScriptElement.hasAttribute("srcFallback")) {
                        var fallBackScriptPath = _this.serverConstants[_this.scriptIntegrityObj.SrcFallback] || _this.scriptIntegrityObj.SrcFallback;
                        var fallbackElementAttributes = {
                            type: _this.elementType,
                            src: fallBackScriptPath + "?" + _this.serverConstants.currentlyDownloadedWebUiVersion.replace(/\./g, "")
                        };
                        _this.addScriptElementToDOM(fallbackElementAttributes);
                    }
                };
                //TODO: When migrating scriptInjectorComponent to Angular, see if it is possible to simplify addScriptElementToDOM().
                //It was split up this way due to unit test complications.
                this.addScriptElementToDOM = function (newElementAttributes) {
                    var newScriptElement = _this.$window.document.createElement("script");
                    Object.keys(newElementAttributes)
                        .forEach(function (attr) { return newScriptElement.setAttribute(attr, newElementAttributes[attr]); });
                    newScriptElement.addEventListener("load", function () { return _this.checkElementPresence(_this.environmentConfig.mcAfeeIconQuerySelector); }, false);
                    newScriptElement.addEventListener("error", function () { return _this.onError(newScriptElement); }, false);
                    _this.$window.document.getElementsByTagName("head")[0].appendChild(newScriptElement);
                };
                this.logSrcThatFailedToLoad = function (srcThatFailedAndThrewError) {
                    _this.loggingService.logMessage("Error from ScriptInjectorComponent. Failed to load from source: '" + srcThatFailedAndThrewError + "'.", null, null);
                };
                //TODO: When migrating scriptInjectorComponent to Angular, use RXJS to replace "delay" AND forLoop 
                //(see MatIconAvailabilityService at.pipe(retryWhen())
                this.checkElementPresence = function (elementQuerySelector) { return __awaiter(_this, void 0, void 0, function () {
                    var delay, element, i;
                    var _this = this;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                delay = function (ms) { return new Promise(function (res) { return _this.$window.setTimeout(res, ms); }); };
                                i = 0;
                                _a.label = 1;
                            case 1:
                                if (!(i < 2 && !element)) return [3 /*break*/, 4];
                                return [4 /*yield*/, delay(2500)];
                            case 2:
                                _a.sent();
                                element = this.$window.document.querySelector(elementQuerySelector);
                                _a.label = 3;
                            case 3:
                                i++;
                                return [3 /*break*/, 1];
                            case 4:
                                //Log Error if element is not detected
                                //Do nothing if element is detected successfully.
                                if (!element) {
                                    this.loggingService.logMessage("Error from ScriptInjectorComponent: Unable to locate presence of element with query selector: '" + elementQuerySelector + "'.", null, null);
                                    //TODO: Delete this line. it is only here for testing purposes
                                    //alert(`failure: ${elementQuerySelector}`);
                                }
                                return [2 /*return*/];
                        }
                    });
                }); };
                this.isValidIntegrityValue = function (shaKey) {
                    return angular.isString(shaKey)
                        && ["sha256-", "sha384-", "sha512-"].some(function (prefix) { return shaKey.startsWith(prefix); });
                };
            }
            ScriptInjectorController.$inject = [
                "$window",
                "environmentConfig",
                "loggingService",
                "serverConstants"
            ];
            return ScriptInjectorController;
        }());
        Controller.ScriptInjectorController = ScriptInjectorController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module('HCTRAModule').component("scriptInjector", {
        bindings: {
            enable: "<",
            srcAttempt: "@"
        },
        controller: HCTRA.Controller.ScriptInjectorController
    });
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var DateService = /** @class */ (function () {
            function DateService(objectUtilService, momentService) {
                var _this = this;
                this.objectUtilService = objectUtilService;
                this.momentService = momentService;
                this.getDaysAgo = function (diffDays, date) {
                    var newDate = angular.copy(date) || _this.momentService.moment().toDate();
                    newDate.setDate(newDate.getDate() - diffDays);
                    return newDate;
                };
                this.isBefore = function (dateFrom, dateTo, compareFn) {
                    return _this.compareDates(dateFrom, dateTo, compareFn) > 0;
                };
                this.isAfter = function (dateFrom, dateTo, compareFn) {
                    return _this.compareDates(dateFrom, dateTo, compareFn) < 0;
                };
                this.isExpiredFilterForCms = function (articleParam) {
                    var article = _this.objectUtilService.toCapitalizedCaseKeys(articleParam, ["isPermanent", "endDate", "startDate"]);
                    return _this.shouldShowArticle(article.IsPermanent, article.EndDate);
                };
                this.isDate = function (dateinStringFormat) {
                    // TODO: Use the momentService to convert to Date
                    var potentialDate = new Date(dateinStringFormat);
                    if (angular.isDate(potentialDate)) {
                        // it is a date
                        if (!isNaN(potentialDate.getTime())) {
                            return true;
                        }
                    }
                    return false;
                };
                this.pickerFormat = "MM/dd/yyyy";
                this.getDateOptions = function (minDate, today) {
                    return {
                        formatDay: "d",
                        showWeeks: false,
                        minDate: _this.momentService.moment(minDate).toDate(),
                        maxDate: _this.momentService.moment(today).toDate()
                    };
                };
                this.compareDates = function (dateFrom, dateTo, compareFn) {
                    if (!dateFrom || !dateTo)
                        return 0;
                    return angular.isFunction(compareFn) ? compareFn(dateFrom, dateTo) : _this.daysBetween(dateFrom, dateTo);
                };
                this.daysBetween = function (first, second) {
                    var date1 = Date.UTC(first.getFullYear(), first.getMonth(), first.getDate());
                    var date2 = Date.UTC(second.getFullYear(), second.getMonth(), second.getDate());
                    var millisPerDay = 1000 * 60 * 60 * 24;
                    var millisBetween = date2 - date1;
                    var days = millisBetween / millisPerDay;
                    return Math.round(days);
                };
                this.specificTimeBetween = function (first, second) {
                    var date1 = Date.UTC(first.getFullYear(), first.getMonth(), first.getDate(), first.getHours(), first.getMinutes(), first.getSeconds(), first.getMilliseconds());
                    var date2 = Date.UTC(second.getFullYear(), second.getMonth(), second.getDate(), second.getHours(), second.getMinutes(), second.getSeconds(), second.getMilliseconds());
                    return date2 - date1;
                };
                this.shouldShowArticle = function (isPermanent, endDate) {
                    var showPermanently = isPermanent === "1";
                    var noEndDate = endDate === null || endDate === "";
                    var hasNotReachedEndDate = false;
                    if (!noEndDate && angular.isDefined(endDate)) {
                        hasNotReachedEndDate = _this.isBefore(_this.momentService.moment().toDate(), endDate, _this.specificTimeBetween);
                    }
                    return showPermanently || noEndDate || hasNotReachedEndDate;
                };
            }
            DateService.$inject = ["objectUtilService", "momentService"];
            return DateService;
        }());
        Service.DateService = DateService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("dateService", HCTRA.Service.DateService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').service('desktopAutoRedirect', ['$document', 'responsiveService', 'responseErrorService',
        function ($document, responsiveService, responseErrorService) {
            var viewport = $document.find("meta[name=viewport]")[0];
            var setDesktop = function () {
                sessionStorage.setItem("FOOTER_FORCE_DESKTOP_VIEW", true);
                viewport.setAttribute('content', 'width=768');
            };
            this.isForcedDesktopView = function () {
                return sessionStorage.getItem("FOOTER_FORCE_DESKTOP_VIEW") === "true";
            };
            this.forceDesktopView = function () {
                if (responsiveService.isMobile()) {
                    setDesktop();
                }
            };
            this.forceAutoRedirectDesktopView = function () {
                if (responsiveService.isMobile()) {
                    setDesktop();
                    responseErrorService.displayToast('You have been automatically redirected to the desktop view in order to see this page. To revert back to the mobile view, please click "Show Mobile View" at the bottom of the page.', 'warning', true);
                }
            };
            this.revertDesktopView = function () {
                sessionStorage.setItem("FOOTER_FORCE_DESKTOP_VIEW", false);
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0');
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        'use strict';
        //Migrated to angular already common\services\downloadService
        //Use new DownloadService when considering migration
        var FileDownloadService = /** @class */ (function () {
            function FileDownloadService($window, $state, serverConstants, CurrentUser, $document, $timeout) {
                var _this = this;
                this.$window = $window;
                this.$state = $state;
                this.serverConstants = serverConstants;
                this.CurrentUser = CurrentUser;
                this.$document = $document;
                this.$timeout = $timeout;
                this.downloadFile = function (url, queryDict) {
                    var apiUrl = _this.getUrl(url, queryDict);
                    if (_this.CurrentUser.currentUserIsInSyncAcrossTabs()) {
                        _this.$window.open(apiUrl, '_blank');
                    }
                    else {
                        location.reload();
                    }
                };
                this.getUrl = function (url, queryDict) {
                    var queryDictIsObject = angular.isObject(queryDict);
                    var mandatoryQueries = {
                        angularState: _this.$state.current.name,
                        clientVersion: _this.serverConstants.currentlyDownloadedWebUiVersion
                    };
                    var fullQueryDict = queryDictIsObject ? angular.extend(queryDict, mandatoryQueries) : mandatoryQueries;
                    var queryString = _this.queryDictToString(fullQueryDict);
                    return (url + '?' + queryString);
                };
                this.downloadPdf = function (data, fileName) {
                    //pdf specification required for proper iOS download
                    var file = new Blob([data], { type: 'application/pdf' });
                    _this.downloadBlob(file, fileName);
                };
                this.downloadExcel = function (data, fileName) {
                    var file = new Blob([data], { type: 'application' });
                    _this.downloadBlob(file, fileName);
                };
                this.downloadBlob = function (file, fileName) {
                    if (navigator['msSaveOrOpenBlob']) {
                        navigator['msSaveOrOpenBlob'](file, fileName);
                    }
                    else {
                        var body_1 = angular.element(_this.$document[0].getElementsByTagName('body'));
                        var fileURL_1 = URL.createObjectURL(file);
                        _this.$timeout(function () {
                            var a = angular.element("<a></a>")[0];
                            a.href = fileURL_1;
                            a.download = fileName;
                            body_1.append(a);
                            a.click();
                            a.remove();
                        }, 0);
                    }
                };
                this.queryDictToString = function (queryDict) {
                    var queryArray = [];
                    for (var key in queryDict) {
                        if (queryDict.hasOwnProperty(key)) {
                            var addString = key;
                            if (angular.isDefined(queryDict[key]) && queryDict[key] !== null) {
                                addString += "=" + queryDict[key].toString();
                            }
                            queryArray.push(addString);
                        }
                    }
                    return queryArray.join('&');
                };
                this.getFileNameFromHeader = function (headers) {
                    var fileName = "";
                    var disposition = headers('Content-Disposition');
                    if (disposition && disposition.indexOf('attachment') !== -1) {
                        var filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                        var matches = filenameRegex.exec(disposition);
                        if (matches != null && matches[1]) {
                            fileName = matches[1].replace(/['"]/g, '');
                        }
                    }
                    return fileName;
                };
            }
            FileDownloadService.$inject = ['$window', '$state', 'serverConstants', 'CurrentUser', '$document', '$timeout'];
            return FileDownloadService;
        }());
        Service.FileDownloadService = FileDownloadService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("fileDownloadService", HCTRA.Service.FileDownloadService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('focusExclusionService', ['routes',
        function (routes) {
            var dictByUrl = {};
            dictByUrl[routes.faq] = true;
            dictByUrl[routes.closuresArchive] = true;
            dictByUrl[routes.newsArchive] = true;
            var dictByWildCard = {};
            dictByWildCard[routes.faq] = { expectedSegments: 4, path: routes.faq };
            dictByWildCard[routes.closuresArchive] = { expectedSegments: 4, path: routes.closuresArchive };
            dictByWildCard[routes.newsArchive] = { expectedSegments: 4, path: routes.newsArchive };
            return {
                dictByUrl: dictByUrl,
                dictByWildCard: dictByWildCard
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').service('hctraSessionLogin', ['SessionService', function (SessionService) {
            this.login = function (acctId, acctActivity, currentStep) {
                SessionService.create(acctId, acctActivity, currentStep, false);
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').service('javaObjectUtilService', [
        function () {
            this.isEmpty = function (obj) {
                for (var key in obj) {
                    // eslint-disable-next-line no-prototype-builtins
                    if (obj.hasOwnProperty(key))
                        return false; // object is not empty
                }
                return true; // object is empty
            };
        }
    ]);
}());
(function () {
    "use strict";
    var manageBillingInformationResolver = function (environmentConfig, $q, $state, stateNames, $location, profileStates) {
        var resolve = function (alternateStateName, valid) {
            var replaceLocation = $state.current.url !== $location.url();
            return valid
                ? $q.resolve()
                : $q.reject().catch(function () {
                    return $state.go(alternateStateName, null, replaceLocation
                        ? { location: 'replace' }
                        : {});
                });
        };
        return {
            resolveManagePayment: function () {
                return resolve(profileStates.UpdateBillingInformation, !environmentConfig.billingInformation.UseUpdatedPage);
            },
            resolveUpdateBillingInformation: function () {
                return resolve(stateNames.managePayment, environmentConfig.billingInformation.UseUpdatedPage);
            }
        };
    };
    angular.module("HCTRAModule").factory("manageBillingInformationResolver", [
        "environmentConfig",
        "$q",
        "$state",
        "stateNames",
        "$location",
        "profileStates",
        manageBillingInformationResolver
    ]);
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var MapperService = /** @class */ (function () {
            function MapperService(releaseToggle, momentService) {
                var _this = this;
                this.releaseToggle = releaseToggle;
                this.momentService = momentService;
                this.mapToAccountActivityDTO = function (data, vehicleData) {
                    var accountActivityDTO = new HCTRA.Model.AccountActivityDTO();
                    accountActivityDTO.page = data.page;
                    accountActivityDTO.dateFrom = _this.momentService.moment(data.dateFrom).format("L");
                    accountActivityDTO.dateTo = _this.momentService.moment(data.dateTo).format("L");
                    accountActivityDTO.vehicle = vehicleData.text ? vehicleData.text : "";
                    accountActivityDTO.vehicleNickNameType = vehicleData.value ? vehicleData.value : "";
                    accountActivityDTO.transaction = data.transaction ? data.transaction : "";
                    accountActivityDTO.dateRangeType = data.dateRangeType ? data.dateRangeType : "";
                    // console.log(accountActivityDTO);
                    return accountActivityDTO;
                };
                this.mapToViolationsData = function (invoice, paymentAmount) {
                    var violationsData = {
                        adjustmentEligible: invoice.adjustmentEligible,
                        adminFee: invoice.adminFee,
                        agency: invoice.agency,
                        alreadyPaid: invoice.alreadyPaid,
                        amountAlreadyPaid: invoice.amountAlreadyPaid,
                        amountDue: (_this.releaseToggle.r2p3_rtvIsActive === "true" ?
                            (invoice.totalDue - invoice.amountAlreadyPaid) :
                            (invoice.totalDue - invoice.amountAlreadyPaid - invoice.paymentsPending)),
                        collectionFee: invoice.collectionFee,
                        currentAmountDue: invoice.currentAmountDue,
                        dueDate: invoice.dueDate,
                        finalAmountDue: invoice.finalAmountDue,
                        invoiceDate: invoice.invoiceDate,
                        invoiceDue: invoice.invoiceDue,
                        invoiceId: invoice.invoiceId,
                        invoiceNumber: invoice.invoiceId,
                        issueDate: invoice.issueDate,
                        itemType: invoice.itemType,
                        onlineDiscountEligible: invoice.onlineDiscountEligible,
                        otherFee: invoice.otherFee,
                        pastPayments: invoice.pastPayments,
                        payment: parseFloat(invoice.payment ? invoice.payment : paymentAmount),
                        paymentsPending: invoice.paymentsPending,
                        paymentType: invoice.paymentType ?
                            invoice.paymentType :
                            parseFloat(invoice.currentAmountDue) - parseFloat(invoice.payment) < 0.009 ? "PAY_IN_FULL" : "SPECIFY_AMOUNT",
                        payNow: parseFloat(invoice.payment ? invoice.payment : paymentAmount),
                        remainingBalance: parseFloat(invoice.currentAmountDue) - parseFloat(invoice.payment),
                        totalDue: invoice.totalDue,
                        waiverEligible: invoice.waiverEligible,
                        invoicePreviousPayment: undefined
                    };
                    if (violationsData.agency === "HCTRA") {
                        violationsData.agency = "h";
                    }
                    else if (violationsData.agency === "MCTRA") {
                        violationsData.agency = "m";
                    }
                    else if (violationsData.agency === "FBGPTRA") {
                        violationsData.agency = "f";
                    }
                    if ("invoicePreviousPayment" in invoice) {
                        violationsData.invoicePreviousPayment = invoice.invoicePreviousPayment;
                    }
                    return violationsData;
                };
            }
            MapperService.$inject = ["releaseToggle", "momentService"];
            return MapperService;
        }());
        Service.MapperService = MapperService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("mapperService", HCTRA.Service.MapperService);
}());
var HCTRA;
(function (HCTRA) {
    var HctraMath = /** @class */ (function () {
        function HctraMath() {
        }
        /** Returns dividend mod divisor; both must be integers */
        HctraMath.mod = function (dividend, divisor) {
            if (!HCTRA.HctraMath.isInteger(dividend) || !HCTRA.HctraMath.isInteger(divisor))
                return;
            var remainder = dividend % divisor;
            var moddedValue;
            if (!HCTRA.HctraMath.isBetweenBaseAndZero(remainder, divisor))
                moddedValue = remainder + divisor;
            else
                moddedValue = remainder;
            return moddedValue;
        };
        HctraMath.isInteger = function (value) {
            return typeof value === 'number' &&
                isFinite(value) &&
                window.Math.floor(value) === value;
        };
        HctraMath.isBetweenBaseAndZero = function (value, base) {
            if (HCTRA.HctraMath.isNegative(base))
                return value > base && value <= 0;
            else
                return value < base && value >= 0;
        };
        HctraMath.isNegative = function (value) {
            return value < 0;
        };
        return HctraMath;
    }());
    HCTRA.HctraMath = HctraMath;
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var ModalService = /** @class */ (function () {
            function ModalService($uibModal, osSniffer, $q, $rootScope, responsiveService, modalServiceModalNames, errorDisplayService) {
                var _this = this;
                this.$uibModal = $uibModal;
                this.osSniffer = osSniffer;
                this.$q = $q;
                this.$rootScope = $rootScope;
                this.responsiveService = responsiveService;
                this.modalServiceModalNames = modalServiceModalNames;
                this.errorDisplayService = errorDisplayService;
                //track all open modals
                this.modalServiceInstances = {};
                //track all destruction listener methods
                this.listeners = [];
                this.modalDefaults = {
                    backdrop: true,
                    keyboard: true,
                    modalFade: true,
                    templateUrl: '/app/templates/common/modal.html'
                };
                this.alertModalDefaults = {
                    backdrop: true,
                    keyboard: true,
                    modalFade: true,
                    templateUrl: '/app/templates/common/modalAlert.html'
                };
                this.currentModalSettings = this.modalDefaults;
                this.currentAlertModalSettings = this.alertModalDefaults;
                this.maintenanceModalOptions = {
                    backdrop: true,
                    keyboard: true,
                    modalFade: true,
                    templateUrl: '/app/templates/common/modalMaintenance.html',
                    windowClass: 'maintenance-modal-window'
                };
                this.modalOptions = {
                    closeButtonText: 'Close',
                    actionButtonText: 'OK',
                    headerText: 'Proceed?',
                    bodyText: 'Perform this action?'
                };
                this.showModal = function (customModalDefaults, customModalOptions, modalName) {
                    if (modalName === void 0) { modalName = null; }
                    if (!customModalDefaults) {
                        customModalDefaults = {};
                    }
                    customModalDefaults.backdrop = 'static';
                    return _this.show(customModalDefaults, customModalOptions, angular.isDefined(modalName) && modalName !== null ? modalName : _this.modalServiceModalNames.GenericAlert);
                };
                this.showSlidingModal = function (componentName, resolveObject, modalName) {
                    if (modalName === void 0) { modalName = null; }
                    var modalDefaults = {
                        backdrop: true,
                        keyboard: true,
                        modalFade: true,
                        component: componentName,
                        windowClass: "side-drawer",
                        resolve: resolveObject
                    };
                    return _this.showModal(modalDefaults, {}, modalName !== null ? modalName : componentName);
                };
                this.show = function (customModalDefaults, customModalOptions, modalName) {
                    if (modalName === void 0) { modalName = null; }
                    modalName = modalName || customModalDefaults.templateUrl;
                    //Create temp objects to work with since we're in a singleton service
                    //Map angular-ui modal custom defaults to modal defaults defined in service
                    var tempModalDefaults = angular.extend({}, _this.currentModalSettings);
                    //Map modal.html $scope custom properties to defaults defined in service
                    var tempModalOptions = angular.extend({}, _this.modalOptions);
                    tempModalDefaults = angular.extend({}, tempModalDefaults, customModalDefaults);
                    tempModalOptions = angular.extend({}, tempModalOptions, customModalOptions);
                    if (_this.listeners) {
                        //allow listeners to alter the modal's settings or cancel it altogether
                        var event_1 = {
                            currentScope: _this.$rootScope,
                            targetScope: _this.$rootScope,
                            name: "ModalOpening",
                            stopPropagation: angular.noop,
                            preventDefault: null,
                            defaultPrevented: false
                        };
                        event_1.preventDefault = function () { return event_1.defaultPrevented = true; };
                        var listenerPromises = _this.listeners
                            .map(function (listener) { return listener(event_1, modalName, tempModalDefaults, tempModalOptions); })
                            .filter(function (p) { return p; });
                        if (event_1.defaultPrevented) {
                            //race
                            var settled_1 = false;
                            var winner_1 = _this.$q.defer();
                            listenerPromises.forEach(function (listenerPromise) { return listenerPromise
                                .then(function (v) { return !settled_1 && (settled_1 = true) && winner_1.resolve(v); }, function (e) { return !settled_1 && (settled_1 = true) && winner_1.reject(e); }); });
                            if (listenerPromises.length === 0) {
                                winner_1.resolve();
                            }
                            return winner_1.promise;
                        }
                    }
                    //add and allow additional resolves to be added for modal controller's constructor injection
                    tempModalDefaults.resolve = angular.extend({}, _this.currentModalSettings.resolve || {}, {
                        "modalOptions": function () { return tempModalOptions; },
                        "modalName": function () { return modalName; }
                    }, tempModalDefaults.resolve || {});
                    if (!tempModalDefaults.controller) {
                        tempModalDefaults.controller = ["$scope", "$uibModalInstance", "modalOptions",
                            function ($scope, $uibModalInstance, modalOptions) {
                                $scope.$uibModalInstance = $uibModalInstance;
                                $scope.modalOptions = modalOptions;
                                $scope.modalOptions.ok = function (result) {
                                    $uibModalInstance.close(result);
                                };
                                $scope.modalOptions.close = function () {
                                    $uibModalInstance.dismiss('cancel');
                                };
                            }
                        ];
                    }
                    //track modal
                    var modalServiceInstance = _this.$uibModal.open(tempModalDefaults);
                    if (!_this.modalServiceInstances[modalName]) {
                        _this.modalServiceInstances[modalName] = [];
                    }
                    _this.modalServiceInstances[modalName].push(modalServiceInstance);
                    return modalServiceInstance.result
                        .finally(function () {
                        //untrack modal when closed
                        if (_this.modalServiceInstances[modalName]) {
                            var mIndex = _this.modalServiceInstances[modalName].indexOf(modalServiceInstance);
                            if (mIndex >= 0) {
                                _this.modalServiceInstances[modalName].splice(mIndex, 1);
                            }
                        }
                    });
                };
                this.showUpdateSuccessModal = function (topic, updatedValue) {
                    _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: 'Ok',
                        headerText: topic + ' Confirmation',
                        bodyText: 'Your ' + updatedValue + ' has been successfully updated.'
                    }, _this.modalServiceModalNames.UpdateSuccess);
                };
                this.showMaintenanceModal = function () {
                    var imageSrc = "-/media/B820D13393F34580A738639AA0291EA5.ashx";
                    var altText = "Website Mobile Maintenance Image";
                    if (_this.osSniffer.isDesktopOs()) {
                        imageSrc = "-/media/4C541629D7D64FA6B8DA2DB8243ACC89.ashx";
                        altText = "Website Desktop Maintenance Image";
                    }
                    return _this.showModal(_this.maintenanceModalOptions, {
                        closeButtonText: 'Close',
                        bodyText: "<img alt=\"" + altText + "\" src=\"" + imageSrc + "\" />"
                    }, _this.modalServiceModalNames.Maintenance);
                };
                this.violationsThisInvoicePaidModal = function () {
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: 'Close',
                        headerText: 'Violation Invoice Already Paid',
                        bodyText: 'Only violation invoices with an outstanding balance are displayed. Please use a desktop computer to view all violation invoices associated with this license plate.'
                    }, _this.modalServiceModalNames.ViolationsInvoicePaid);
                };
                this.violationsPaymentPlanModal = function () {
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: 'Close',
                        headerText: 'Payment Plan',
                        bodyText: 'A payment plan already exists for this license plate. Please contact <a target="_blank" href="/HelpAndSupport#email-us">Customer Service</a>.'
                    }, _this.modalServiceModalNames.ViolationsPaymentPlan);
                };
                this.violationsBelowMinimumPaymentModal = function (minPayment) {
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: 'Close',
                        headerText: 'Minimum Payment',
                        bodyText: 'The amount entered is less than the minimum required amount. Please enter a value greater than or equal to ' + minPayment + '.'
                    }, _this.modalServiceModalNames.VioloationsBelowMinimumPayment);
                };
                this.violationsPaymentWillLeaveLowBalanceModal = function (defaultAmount) {
                    var popUpMessage = 'The amount entered will leave a remaining balance that is below the minimum payment required. Please enter the full amount of ' + defaultAmount + '.';
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: 'Close',
                        headerText: 'Minimum Payment',
                        bodyText: popUpMessage
                    }, _this.modalServiceModalNames.ViolationsPaymentWillLeaveLowBalance);
                };
                this.violationsPaymentCouldLeaveLowBalanceModal = function (defaultAmount, minimumPayment, defaultMinusMinimum) {
                    var popUpMessage = 'The amount entered will leave a remaining balance that is below the minimum payment required. Please enter an amount between ' + minimumPayment + ' and ' + defaultMinusMinimum + ' or the full amount of ' + defaultAmount;
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: 'Close',
                        headerText: 'Minimum Payment',
                        bodyText: popUpMessage
                    }, _this.modalServiceModalNames.ViolationsPaymentCouldLeaveLowBalance);
                };
                this.violationsOverpaymentModal = function (defaultAmount) {
                    var popUpMessage = 'The amount entered is greater than what is due. Please enter a value less than or equal to ' + defaultAmount + '.';
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: 'Close',
                        headerText: 'Violation Overpayment',
                        bodyText: popUpMessage
                    }, _this.modalServiceModalNames.ViolationsOverpayment);
                };
                this.invoicePaymentModal = function (headerText, paymentPostDelayMsg) {
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: "Close",
                        headerText: headerText,
                        bodyText: paymentPostDelayMsg
                    }, _this.modalServiceModalNames.InvoicePayment);
                };
                this.closeAccountInfoUpdatePromptModal = function (headerText, bodyText) {
                    return _this.showModal(_this.currentAlertModalSettings, {
                        closeButtonText: "Edit",
                        headerText: headerText,
                        bodyText: bodyText
                    }, _this.modalServiceModalNames.CloseAccountUpdateInfo);
                };
                this.resetSettings();
            }
            Object.defineProperty(ModalService.prototype, "modalNames", {
                get: function () { return this.modalServiceModalNames; },
                enumerable: true,
                configurable: true
            });
            ModalService.prototype.newModalScope = function (initState) {
                return angular.extend(this.$rootScope.$new(), initState || {});
            };
            ModalService.prototype.clearListeners = function () {
                this.listeners = [];
            };
            ModalService.prototype.resetSettings = function () {
                var _this = this;
                this.clearListeners();
                //add a defult listener that will 'deny' a modal called 'ViolationsCannotAddVehicle' from opening
                this.listeners.push(function (evt, name, modalSettings, modalTextOptions) {
                    switch (name) {
                        //general supressed modals
                        case _this.modalServiceModalNames.ViolationsCannotAddVehicle:
                            evt.preventDefault();
                            break;
                        //non-mobile supressed modals: only show these is the web is in mobile mode
                        case _this.modalServiceModalNames.ViolationsInvoicePaid:
                        case _this.modalServiceModalNames.ViolationsPaymentPlan:
                        case _this.modalServiceModalNames.ViolationsNoInviocesFound:
                            if (!_this.responsiveService.isMobile()) {
                                evt.preventDefault();
                            }
                            break;
                        case _this.modalServiceModalNames.ViolationsNoViolationFoundWithInvoice:
                            if (!_this.responsiveService.isMobile()) {
                                evt.preventDefault();
                                _this.errorDisplayService.displayToasts([modalTextOptions.bodyText], "error");
                            }
                            break;
                        default:
                    }
                    return undefined;
                });
            };
            ModalService.prototype.onOpening = function (listener) {
                this.listeners.push(listener);
            };
            ModalService.prototype.isModalOpen = function (name) {
                return this.modalServiceInstances[name] && this.modalServiceInstances[name].length > 0;
            };
            ModalService.prototype.closeAll = function (dismiss) {
                for (var name_1 in this.modalServiceInstances) {
                    if (this.modalServiceInstances.hasOwnProperty(name_1) && this.modalServiceInstances[name_1]) {
                        for (var _i = 0, _a = this.modalServiceInstances[name_1]; _i < _a.length; _i++) {
                            var m = _a[_i];
                            if (dismiss) {
                                m.dismiss();
                            }
                            else {
                                m.close();
                            }
                        }
                        delete this.modalServiceInstances[name_1];
                    }
                }
            };
            ModalService.prototype.closeByName = function (name, dismiss) {
                if (this.modalServiceInstances[name]) {
                    for (var _i = 0, _a = this.modalServiceInstances[name]; _i < _a.length; _i++) {
                        var m = _a[_i];
                        if (dismiss) {
                            m.dismiss();
                        }
                        else {
                            m.close();
                        }
                    }
                    delete this.modalServiceInstances[name];
                }
            };
            ModalService.prototype.violationsCannotAddVehicleModal = function () {
                var popUpMessage = '';
                return this.showModal(this.currentAlertModalSettings, {
                    closeButtonText: 'Close',
                    headerText: 'Your vehicle has a violation and cannot be added at this time.',
                    bodyText: popUpMessage
                }, this.modalServiceModalNames.ViolationsCannotAddVehicle);
            };
            ModalService.prototype.violationsNoViolationFound = function (information) {
                return this.showModal(this.currentAlertModalSettings, {
                    closeButtonText: 'Close',
                    headerText: 'No violations found',
                    bodyText: information
                }, this.modalServiceModalNames.ViolationsNoViolationFound);
            };
            ModalService.prototype.violationsNoInviocesFound = function () {
                return this.showModal({
                    backdrop: true,
                    keyboard: true,
                    modalFade: true,
                    templateUrl: '/app/templates/common/modalAlert.html'
                }, {
                    closeButtonText: 'Close',
                    headerText: 'No Invoices Found',
                    bodyText: 'No violation invoices with an outstanding balance were found.'
                }, this.modalServiceModalNames.ViolationsNoInviocesFound);
            };
            ModalService.prototype.violationsNoViolationFoundWithInvoice = function (information) {
                return this.showModal(this.currentAlertModalSettings, {
                    closeButtonText: 'Close',
                    headerText: 'No violations found with provided invoice',
                    bodyText: information
                }, this.modalServiceModalNames.ViolationsNoViolationFoundWithInvoice);
            };
            ModalService.prototype.addEZPlateModal = function (modalOptions) {
                return this.showModal(this.currentAlertModalSettings, modalOptions, this.modalServiceModalNames.AddEZPlate);
            };
            ModalService.prototype.creditCardPromptModal = function (scope) {
                var settings = angular.extend({}, this.currentAlertModalSettings);
                settings.scope = scope;
                settings.templateUrl = "/app/templates/storefront/StorefrontCreditCardPromptTemplate.html";
                settings.backdrop = "static";
                return this.showModal(settings, {
                    closeButtonText: null,
                    headerText: null,
                    bodyText: null
                }, this.modalServiceModalNames.CreditCardPrompt);
            };
            ModalService.$inject = ["$uibModal", "operatingSystemSnifferService", "$q", "$rootScope", "responsiveService", "ModalServiceModalNames", "errorDisplayService"];
            return ModalService;
        }());
        Service.ModalService = ModalService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule")
        .service("modalService", HCTRA.Service.ModalService)
        .constant("ModalServiceModalNames", {
        "UpdateSuccess": "UpdateSuccess",
        "Maintenance": "Maintenance",
        "ViolationsInvoicePaid": "ViolationsInvoicePaid",
        "ViolationsPaymentPlan": "ViolationsPaymentPlan",
        "VioloationsBelowMinimumPayment": "VioloationsBelowMinimumPayment",
        "ViolationsPaymentWillLeaveLowBalance": "ViolationsPaymentWillLeaveLowBalance",
        "ViolationsPaymentCouldLeaveLowBalance": "ViolationsPaymentCouldLeaveLowBalance",
        "ViolationsOverpayment": "ViolationsOverpayment",
        "InvoicePayment": "InvoicePayment",
        "ViolationsCannotAddVehicle": "ViolationsCannotAddVehicle",
        "ViolationsNoViolationFound": "ViolationsNoViolationFound",
        "ViolationsNoInviocesFound": "ViolationsNoInviocesFound",
        "ViolationsNoViolationFoundWithInvoice": "ViolationsNoViolationFoundWithInvoice",
        "AddEZPlate": "AddEZPlate",
        "CreditCardPrompt": "CreditCardPrompt",
        "GenericAlert": "GenericAlert",
        "ViolationsLandingLogin": "ViolationsLandingLogin",
        "PaymentModal": "PaymentModal",
        "VehicleInfoSlidingPanel": "vehicleInfoSlidingPanel",
        "MailingAddressInfoSlidingPanel": "mailingAddressInfoSlidingPanel",
        "PhoneEmailInfoSlidingPanel": "phoneEmailInfoSlidingPanel",
        "CancelSlidingPanel": "cancelSlidingPanel",
        "EditBillingInfoSlidingPanel": "editBillingInfoSlidingPanel",
        "InvoiceListSlidingPanel": "invoiceListSlidingPanel",
        "CloseAccountUpdateInfo": "closeAccountUpdateInfo"
    });
})();
/* eslint-disable no-useless-escape */
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('removeDoubleCharService', function () {
        return {
            removeDoubleChar: function (val) {
                //once a field reaches past its max length, no val sent
                if (!val) {
                    return;
                }
                val = val.toString();
                val = val.replace(/@@/g, '@');
                val = val.replace(/\s+/g, ' ');
                val = val.replace(/\.+/g, '.');
                val = val.replace(/\-+/g, '-');
                val = val.replace(/\_+/g, '_');
                val = val.replace(/[\<\>\'\"]/g, '');
                return val;
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('serverErrorService', ['errorDisplayService', 'siteVerbiage',
        function (errorDisplayService, siteVerbiage) {
            return {
                handleServerError: function () {
                    var level = 'error';
                    var msgArr = [siteVerbiage.genericErrorMsg];
                    errorDisplayService.displayToasts(msgArr, level);
                }
            };
        }]);
}());
(function () {
    'use strict';
    // angular.module('HCTRAModule').service('Session', ['USER_ROLES', 'webStorage', 'stateNames', function (USER_ROLES, webStorage, stateNames) {
    //     this.default = function () {
    //         this.acctId = 0;
    //         this.userRole = USER_ROLES.notAuthenticated;
    //     };
    //     this.create = function (acctId, acctActivity, currentStep, missingInformation, accountStaus = null) {
    //         this.acctId = acctId;
    //         if (sessionStorage) {
    //             sessionStorage.setItem("acctActivity", acctActivity);
    //             this.userRole = mapAcctActivityToUserRole(sessionStorage.getItem("acctActivity"), accountStaus);
    //         }
    //         if (this.userRole == USER_ROLES.incomplete) {
    //             if (sessionStorage && currentStep != null) {
    //                 sessionStorage.setItem("currentStep", currentStep);
    //                 this.currentStep = currentStep;
    //             }
    //         }
    //         if (sessionStorage && missingInformation && acctActivity != null && this.userRole !== USER_ROLES.notAuthenticated) {
    //             this.userRole = USER_ROLES.missingRequiredInformation;
    //         }
    //     };
    //     this.setAcctActivity = function (acctActivity) {
    //         if (sessionStorage && acctActivity != null) {
    //             sessionStorage.setItem("acctActivity", acctActivity);
    //         }
    //         this.userRole = mapAcctActivityToUserRole(sessionStorage.getItem("acctActivity"));
    //     };
    //     this.setCurrentStep = function (currentStep) {
    //         if (sessionStorage && currentStep != null) {
    //             sessionStorage.setItem("currentStep", currentStep);
    //         }
    //         this.currentStep = sessionStorage.getItem("currentStep");
    //     };
    //     this.destroy = function () {
    //         this.acctId = 0;
    //         webStorage.removeEntry("acctActivity");
    //         webStorage.removeEntry("currentStep");
    //         this.userRole = USER_ROLES.notAuthenticated;
    //     };
    //     this.getAcctActivity = function () {
    //         var val = null;
    //         if (sessionStorage) {
    //             val = sessionStorage.getItem("acctActivity");
    //         }
    //         return val;
    //     };
    //     this.getCurrentStep = function () {
    //         var val = null;
    //         if (sessionStorage) {
    //             val = sessionStorage.getItem("currentStep");
    //         }
    //         return val;
    //     };
    //     this.removeCurrentStep = function () {
    //         webStorage.removeEntry("currentStep");
    //     };
    //     this.stepToStateName = function (currentStep) { // Account Creation wizard step to its state name
    //         switch (currentStep) {
    //             case 1:
    //                 return stateNames.createAccount;
    //             case 3:
    //                 return stateNames.vehicleInformation;
    //             case 4:
    //                 return stateNames.choosePaymentMethod;
    //             case 5:
    //                 return stateNames.createAccountSummary;
    //             default:
    //                 return stateNames.createAccount;
    //         }
    //     };
    //     var mapAcctActivityToUserRole = function (acctActivity, accountStaus = null) {
    //         switch (acctActivity) {
    //             case "A":
    //                 if (accountStaus === "PF")
    //                     return USER_ROLES.pendingFunds;
    //                 return USER_ROLES.active;
    //             case "P":
    //                 return USER_ROLES.incomplete;
    //             case "I":
    //                 return USER_ROLES.pendingClosure;
    //             case "S":
    //                 return USER_ROLES.suspended;
    //             default:
    //                 return USER_ROLES.notAuthenticated;
    //         }
    //     };
    // }]);
}());
angular.module('HCTRAModule').service('stringCheckService', [
    function () {
        this.isFloat = function (numberString) {
            if (numberString && !isNaN(parseFloat(numberString)) && isFinite(numberString)) {
                return true;
            }
            else {
                return false;
            }
        };
    }
]);
(function () {
    'use strict';
    angular.module('HCTRAModule').service('toggleFullWebsiteService', ['$window', '$document', 'webStorage',
        function ($window, $document, webStorage) {
            // TODO: Make unit tests for this service
            var init = function () {
                var viewport = $document.find("meta[name=viewport]")[0];
                var forceDesktopView = webStorage.getValue("FOOTER_FORCE_DESKTOP_VIEW") === "true";
                if (forceDesktopView && angular.isDefined(viewport)) {
                    viewport.setAttribute('content', 'width=1200');
                }
            };
            this.onMobileClick = function () {
                webStorage.setKeyValue("FOOTER_FORCE_DESKTOP_VIEW", true);
                //scope.forceDesktopView = true;
                //viewport.setAttribute('content', 'width=768');
                $window.location.reload();
            };
            this.onDesktopClick = function () {
                webStorage.setKeyValue("FOOTER_FORCE_DESKTOP_VIEW", false);
                //scope.forceDesktopView = false;
                //viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0');
                $window.location.reload();
            };
            init();
        }
    ]);
}());
(function () {
    'use strict';
    // angular.module('HCTRAModule').service('urlManagerService', ['javaObjectUtilService', '$q', 'genericRepo',
    // function (javaObjectUtilService, $q, genericRepo) {
    //     var self = this;
    //     var deferred = $q.defer();
    //     var promise = deferred.promise;
    //     this.metadataDictionary = null;
    //     this.newRoutes = {
    //         //states
    //         //cmsPathDictionary
    //         //cmsIdDictionary
    //     };
    //     this.megaMenuStructure = null;
    //     this.footerCmsResponse = null;
    //     // this function should start running before all other public functions
    //     this.getStartingRoutes = function (angularStatesObject) {
    //         return $q(function (fulfill) {
    //             if (javaObjectUtilService.isEmpty(self.newRoutes)) {
    //                 const request = Object.assign({getMin: true}, angularStatesObject);
    //                 genericRepo.dataFactory.GetAllMenuUrlMetadata(request).then(function (response) {
    //                     if (response.errors.length === 0) {
    //                         self.metadataDictionary = response.metadata;
    //                         const rekeyed = Object.keys(response.metadata).reduce((acc, key)=> {
    //                             const obj = response.metadata[key];
    //                             acc.articleLookupByPath[obj.itemPath] = obj;
    //                             acc.articleLookupById[obj.itemID] = obj;
    //                             return acc;                               
    //                         }, {articleLookupByPath: {}, articleLookupById: {}});
    //                         const { articleLookupByPath, articleLookupById } = rekeyed;
    //                         self.newRoutes = {
    //                             states: response.states,
    //                             articleLookupByPath,
    //                             articleLookupById
    //                         };
    //                         self.megaMenuStructure = response.navBar;
    //                         self.footerCmsResponse = response.footerURls;
    //                         deferred.resolve();
    //                         fulfill(self.newRoutes);
    //                     } else {
    //                         deferred.reject();
    //                         fulfill({ errors: response.errors });
    //                     }
    //                 });
    //             } else {
    //                 fulfill(self.newRoutes);
    //             }
    //         });
    //     };
    //     this.getMegaMenu = function () {
    //         return $q(function (fulfill) {
    //             if (self.megaMenuStructure === null) {
    //                 promise.then(function () { // success
    //                     fulfill({ navBar: self.megaMenuStructure });
    //                 }, function () {//failure
    //                     fulfill({ errors: true });
    //                 });
    //             } else {
    //                 fulfill({ navBar: self.megaMenuStructure });
    //             }
    //         });
    //     };
    //     this.getMetadata = function () {
    //         return $q(function (fulfill) {
    //             if (self.metadataDictionary === null) {
    //                 promise.then(function () {// success
    //                     fulfill({ metadata: self.metadataDictionary });
    //                 }, function () {//failure
    //                     fulfill({ errors: true });
    //                 });
    //             } else {
    //                 fulfill({ metadata: self.metadataDictionary });
    //             }
    //         });
    //     };
    //     this.getFooterdata = function () {
    //         return $q(function (fulfill) {
    //             if (self.footerCmsResponse === null) {
    //                 promise.then(function () {// success
    //                     fulfill({ footerCmsResponse: self.footerCmsResponse });
    //                 }, function () {//failure
    //                     fulfill({ errors: true });
    //                 });
    //             } else {
    //                 fulfill(self.footerCmsResponse);
    //             }
    //         });
    //     };
    // }]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        'use strict';
        var ValidatePrimaryEmailService = /** @class */ (function () {
            function ValidatePrimaryEmailService(accountSummaryAlertFilterService, responseErrorService, emailConfirmationConstants) {
                var _this = this;
                this.accountSummaryAlertFilterService = accountSummaryAlertFilterService;
                this.responseErrorService = responseErrorService;
                this.emailConfirmationConstants = emailConfirmationConstants;
                this.setEmailValidationId = function (id) {
                    _this.emailValidationId = id;
                };
                this.getEmailValidationId = function () {
                    return _this.emailValidationId;
                };
                this.destroyEmailValidationId = function () {
                    _this.emailValidationId = null;
                };
                this.setEmailSent = function (isSent) {
                    _this.emailSent = isSent;
                };
                this.getEmailSent = function () {
                    return _this.emailSent;
                };
                this.destroyEmailSent = function () {
                    _this.emailSent = null;
                };
                this.processEmailConfirmationStatus = function (emailConfirmationStatus, emailAddress, previousState) {
                    if (_this.accountSummaryAlertFilterService.filterEmailConfirmationAlert(emailAddress, emailConfirmationStatus)) {
                        var msg, type;
                        if (emailConfirmationStatus == _this.emailConfirmationConstants.NOT_CONFIRMED && previousState != "SendEmailConfirmation") {
                            var url = "'/SendEmailConfirmation'";
                            msg = "Your email address " + emailAddress + " has not been verified. <a href=" + url + ">Please confirm your email address.</a>";
                            type = "warning";
                            _this.responseErrorService.displayToast(msg, type);
                        }
                        else if (emailConfirmationStatus == _this.emailConfirmationConstants.JUST_CONFIRMED) {
                            msg = "Thank you for confirming your email address" + (emailAddress ? ", " + emailAddress + "." : ".");
                            type = "success";
                            _this.responseErrorService.displayToast(msg, type);
                        }
                        // else it's "previouslyConfirmed" and we do nothing
                    }
                };
            }
            ValidatePrimaryEmailService.$inject = ['accountSummaryAlertFilterService', 'responseErrorService', 'emailConfirmationConstants'];
            return ValidatePrimaryEmailService;
        }());
        Service.ValidatePrimaryEmailService = ValidatePrimaryEmailService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('validatePrimaryEmailService', HCTRA.Service.ValidatePrimaryEmailService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        //no need to export, this concrete class willnever be exposed outside of ValidationService
        var Validator = /** @class */ (function () {
            function Validator(formObj) {
                var _this = this;
                this.formObj = formObj;
                this.isErrorTriggered = function (input) {
                    return !_this.formObj[input].$valid && _this.formObj.$submitted;
                };
                this.getErrorStatusClass = function (input) {
                    return _this.isErrorTriggered(input) ? "has-error" : "";
                };
                this.getErrorList = function (input) {
                    return _this.formObj[input].$error;
                };
                this.hasSubmitted = function () {
                    return _this.formObj.$submitted;
                };
                this.isValid = function (input) {
                    return _this.formObj[input].$valid;
                };
                this.getErrorStatusClassForDateRange = function (input) {
                    return !_this.formObj[input].$valid ? "has-error" : "";
                };
                this.getErrorStatusClassFastWithNullCheck = function (input) {
                    if (_this.formObj[input]) {
                        return !_this.formObj[input].$valid ? "has-error" : "";
                    }
                    else {
                        return "";
                    }
                };
                this.getErrorListWithNullCheck = function (input) {
                    if (_this.formObj[input]) {
                        return _this.formObj[input].$error;
                    }
                    else {
                        return [];
                    }
                };
                this.isValidWithNullCheck = function (input) {
                    return _this.formObj[input] && _this.formObj[input].$valid;
                };
                this.isInvalidWithNullCheck = function (input) {
                    return _this.formObj[input] && _this.formObj[input].$invalid;
                };
                this.setPristine = function () {
                    _this.formObj.$setPristine();
                };
            }
            return Validator;
        }());
        // Does not explicitly implement IValidationService because constructors cannot return functions
        var ValidationService = /** @class */ (function () {
            function ValidationService() {
                this.serviceFunction = function (form) {
                    return new Validator(form);
                };
                return this.serviceFunction;
            }
            ValidationService.$inject = [];
            return ValidationService;
        }());
        Service.ValidationService = ValidationService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("validationService", HCTRA.Service.ValidationService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var WildCardDictionaryElement = /** @class */ (function () {
            function WildCardDictionaryElement(_expectedSegments, _path) {
                this.expectedSegments = _expectedSegments;
                this.path = _path;
            }
            return WildCardDictionaryElement;
        }());
        Service.WildCardDictionaryElement = WildCardDictionaryElement;
        var WildCardUrlCheckerService = /** @class */ (function () {
            function WildCardUrlCheckerService(routes) {
                var _this = this;
                this.wildCardDictionary = {};
                this.findParentUrlInWildCardDict = function (relativeUrl) {
                    return _this.findMatch(relativeUrl, _this.wildCardDictionary);
                };
                this.wildCardUrlisMatch = function (relativeUrl, wilcardDict) {
                    return _this.findMatch(relativeUrl, wilcardDict) !== null;
                };
                this.findMatch = function (relativeUrl, wilcardDict) {
                    if (relativeUrl == null || angular.isUndefined(relativeUrl) || relativeUrl.search("/") === -1) {
                        return null;
                    }
                    var numberofUrlSegments = relativeUrl.match(/\//g).length;
                    var locationArray = relativeUrl.split("/");
                    return wilcardDict["/" + locationArray[1]] && wilcardDict["/" + locationArray[1]].expectedSegments >= numberofUrlSegments ?
                        wilcardDict["/" + locationArray[1]].path : null;
                };
                this.wildCardDictionary[routes.faq] = new WildCardDictionaryElement(4, routes.faq);
                //this.wildCardDictionary[routes.closuresArchive] = new WildCardDictionaryElement(4, routes.closuresArchive);
                this.wildCardDictionary[routes.newsArchive] = new WildCardDictionaryElement(4, routes.newsArchive);
            }
            WildCardUrlCheckerService.$inject = ["routes"];
            return WildCardUrlCheckerService;
        }());
        Service.WildCardUrlCheckerService = WildCardUrlCheckerService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("wildCardUrlCheckerService", HCTRA.Service.WildCardUrlCheckerService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('wizardStepperService', function () {
        return function () {
            return {
                checkStep: function (inStep) {
                    //if (currentStep.value === inStep) {
                    if (this.currentStep == inStep) {
                        return "stepOn";
                    }
                    else {
                        return "step";
                    }
                },
                currentStep: 0
            };
        };
    });
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        function assignNullDataDefaults(response) {
            if (angular.isObject(response) && !response.data)
                response.data = {};
            if (angular.isObject(response.data)) {
                if (!response.data.errors)
                    response.data.errors = [];
                if (!response.data.alerts)
                    response.data.alerts = [];
            }
            return response;
        }
        Service.assignNullDataDefaults = assignNullDataDefaults;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").factory("assignNullDataDefaults", [function () { return HCTRA.Service.assignNullDataDefaults; }]);
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var GlobalVariableInterceptor = /** @class */ (function () {
            function GlobalVariableInterceptor(CurrentUser, $rootScope, webStorage, webStorageConst, serverConstants) {
                var _this = this;
                this.CurrentUser = CurrentUser;
                this.$rootScope = $rootScope;
                this.webStorage = webStorage;
                this.webStorageConst = webStorageConst;
                this.serverConstants = serverConstants;
                this.response = function (response) {
                    if (response.headers(_this.serverConstants.latestWebUiVersionHeaderKey)) {
                        _this.$rootScope.latestWebUiVersion = response.headers(_this.serverConstants.latestWebUiVersionHeaderKey);
                    }
                    //This updates current balance on the menu
                    if (angular.isObject(response.data) && response.data.currentBalanceObj && response.data.currentBalanceObj.currentBalance != null) {
                        var currentBalance = response.data.currentBalanceObj.currentBalance;
                        if (currentBalance) {
                            _this.webStorage.setKeyValue(_this.webStorageConst.currentBalance, currentBalance);
                            var tempCurrentUser = _this.CurrentUser.getCurrentUser();
                            if (angular.isObject(tempCurrentUser) && angular.isObject(tempCurrentUser.currentBalanceObj)
                                && tempCurrentUser.currentBalanceObj.currentBalance !== response.data.currentBalanceObj.currentBalance) {
                                tempCurrentUser.currentBalanceObj.currentBalance = response.data.currentBalanceObj.currentBalance;
                                _this.CurrentUser.updateCurrentUser(tempCurrentUser);
                            }
                            _this.webStorage.setKeyValue(_this.webStorageConst.currentBalance, currentBalance);
                        }
                        else {
                            _this.webStorage.removeEntry(_this.webStorageConst.currentBalance);
                        }
                        _this.$rootScope.currentBalance = currentBalance;
                    }
                    //This updates payment plan current balance on the menu
                    if (angular.isObject(response.data) && response.data.currentPaymentPlanBalanceObj) {
                        var currentPaymentPlanBalance = response.data.currentPaymentPlanBalanceObj.currentBalance;
                        if (currentPaymentPlanBalance) {
                            _this.webStorage.setKeyValue(_this.webStorageConst.currentPaymentPlanBalance, currentPaymentPlanBalance);
                        }
                        else {
                            _this.webStorage.removeEntry(_this.webStorageConst.currentPaymentPlanBalance);
                        }
                        _this.CurrentUser.updateCurrentUser(angular.extend({}, _this.CurrentUser.getCurrentUser(), { paymentPlanBalance: currentPaymentPlanBalance }));
                    }
                    return response;
                };
            }
            GlobalVariableInterceptor.$inject = ["CurrentUser", "$rootScope", "webStorage", "webStorageConst", "serverConstants"];
            return GlobalVariableInterceptor;
        }());
        Service.GlobalVariableInterceptor = GlobalVariableInterceptor;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .service("GlobalVariableInterceptor", HCTRA.Service.GlobalVariableInterceptor);
})();
var HttpResponseErrorLogInterceptor = /** @class */ (function () {
    function HttpResponseErrorLogInterceptor($q, applicationLoggingService, siteVerbiage, $injector, errorInterceptorService, assignNullDataDefaults, $window) {
        var _this = this;
        this.$q = $q;
        this.applicationLoggingService = applicationLoggingService;
        this.siteVerbiage = siteVerbiage;
        this.$injector = $injector;
        this.errorInterceptorService = errorInterceptorService;
        this.assignNullDataDefaults = assignNullDataDefaults;
        this.$window = $window;
        this.response = function (response) {
            var firstNumber = response.status && response.status.toString().substring(0, 1);
            if (response.data && angular.isArray(response.data.errors) && response.data.errors.length > 0) {
                if (response.data.errors
                    .filter(function (error) { return _this.errorInterceptorService.shouldMessageTriggerLogging(error.message); })
                    .length > 0) {
                    _this.applicationLoggingService.interceptorError(angular.toJson({
                        method: response.config.method,
                        url: response.config.url,
                        message: response.data,
                        status: response.status
                    }));
                }
            }
            else if (response.status === null
                || firstNumber === "5"
                || response.status === 0
                || firstNumber === "4"
                || response.status === 204
                || response.status === 206) {
                // F5 responded with sticky note .png
                if (response.status === 503) {
                    _this.$window.location.reload(true); // reload so they will be served the stickynote png
                }
                //Log out user and navigating to login component on status code 417 and displays 417 message
                if (response.status === 417) {
                    var authService = _this.$injector.get('AuthService');
                    authService.logOutOnFourOneSeven();
                }
                var error = {
                    method: response.config.method,
                    url: response.config.url,
                    message: response.data,
                    status: response.status
                };
                _this.applicationLoggingService.error(angular.toJson(error));
                if (!angular.isObject(response.data)) {
                    response.data = { originalResponse: response.data };
                }
                _this.assignNullDataDefaults(response);
                //Stop adding other errors on status code 417 
                if (response.status !== 417) {
                    error.message = _this.siteVerbiage.genericErrorMsg;
                    if (angular.isArray(response.data.errors)) {
                        response.data.errors.push(error);
                    }
                }
            }
            return response;
        };
        this.responseError = function (response) { return _this.response(response); };
    }
    HttpResponseErrorLogInterceptor.$inject = ["$q", "applicationLoggingService", "siteVerbiage", "$injector", "errorInterceptorService", "assignNullDataDefaults", "$window"];
    return HttpResponseErrorLogInterceptor;
}());
angular.module("HCTRAModule").service("HttpResponseErrorLogInterceptor", HttpResponseErrorLogInterceptor);
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('actionDefaultFilter', {
        defaultFilter: ['cardNbr', 'card', 'username', 'userName', 'password', 'authorizedContactList', 'authorizedContacts']
    });
}());
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
        var AppLifecycleEventsConst = /** @class */ (function () {
            function AppLifecycleEventsConst() {
            }
            Object.defineProperty(AppLifecycleEventsConst, "Default", {
                get: function () {
                    return {
                        restoredUserState: "restored-user-state",
                        setNavBarLogin: "set-nav-bar-login",
                        newAccountNameEntered: "new-account-name-entered",
                        currentUserHeaderInfomation: "current-user-header-infomation"
                    };
                },
                enumerable: true,
                configurable: true
            });
            return AppLifecycleEventsConst;
        }());
        Constant.AppLifecycleEventsConst = AppLifecycleEventsConst;
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").constant("APP_LIFECYCLE_EVENTS", HCTRA.Constant.AppLifecycleEventsConst.Default);
}());
//Migrated
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('cmsMediaLibrary', {
        mvuInstructions: 'F6E5148CC5504D919B33B17166E77D8E',
        mvuTemplate: 'A46C6509C4794F12821598AC861641A1'
    });
}());
//just one cookieName used just by current user service.
//should this be in a separate constants file?
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('creditCardTypes', {
        visa: 'VISA',
        mastercard: 'MASTERCARD',
        amex: 'AMERICAN EXPRESS',
        discover: 'DISCOVER'
    });
}());
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        var EmailConfirmationConstants;
        (function (EmailConfirmationConstants) {
            EmailConfirmationConstants[EmailConfirmationConstants["NOT_CONFIRMED"] = 1] = "NOT_CONFIRMED";
            EmailConfirmationConstants[EmailConfirmationConstants["JUST_CONFIRMED"] = 2] = "JUST_CONFIRMED";
            EmailConfirmationConstants[EmailConfirmationConstants["PREVIOUSLY_CONFIRMED"] = 3] = "PREVIOUSLY_CONFIRMED";
        })(EmailConfirmationConstants = Constant.EmailConfirmationConstants || (Constant.EmailConfirmationConstants = {}));
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('emailConfirmationConstants', HCTRA.Constant.EmailConfirmationConstants);
}());
(function () {
    'use strict';
    // Have to do this here so the constant can be injected into config.route.js
    var initUrl = window.location.href; // eslint-disable-line angular/window-service
    var urlResult = initUrl.match(/sc_itemid/);
    var isSitecore = !!urlResult && !!urlResult[0];
    angular.module('HCTRAModule').constant('environments', {
        isSitecore: isSitecore,
        isExperienceEditor: false
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('minimumPaymentAmount', {
        minimumPaymentAmount: 5.00
    });
}());
//Migrated
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('sitecoreTemplateMap', {
        homeQuickLinksTemplate: {
            sitecore: '/sitecore/9BD5E5DB-03CF-4B79-8CD3-75C87E675262',
            dotNet: '/app/directives/home/homeQuickLinksTemplate.html'
        },
        desktopHome: {
            sitecore: '/sitecore/0F89086A-8B3B-4170-98E8-3578F45800C0',
            dotNet: '/app/templates/home/desktopHome.html'
        },
        footerCopyright: {
            sitecore: '/sitecore/DC3D277D-C715-4459-8524-100382DAA52E',
            dotNet: '/app/templates/menu/footerCopyright.html'
        },
        homeCarouselTemplate: {
            sitecore: '/sitecore/F2AEBDC0-F015-4D90-9FF3-6C152B8DFB72',
            dotNet: '/app/directives/home/homeCarouselTemplate.html'
        },
        homeModuleTemplate: {
            sitecore: '/sitecore/77AE0153-7E1E-4153-A71A-A9BB5448A3B6',
            dotNet: '/app/directives/home/homeModuleTemplate.html'
        },
        footerLinkList: {
            sitecore: '/sitecore/228426D3-4884-469F-BFC9-E1D2D9F08479',
            dotNet: '/app/templates/menu/footerLinkList.html'
        }
    });
}());
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
//migrated to Angular
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('validationMessages', {
        genericPre: 'Please enter a valid ',
        genericPreAlt: 'Please enter your ',
        genericPost: '',
        confirmPre: 'Does not match ',
        confirmPost: '',
        alphaNumPre: 'Characters must be alphanumeric',
        alphaNumPost: '',
        alphaNumPostAlt: ' or @_.-',
        minLengthPre: 'Must be at least ',
        minLengthPost: ' characters',
        maxLengthPre: 'Must be at most ',
        maxLengthPost: ' characters'
    });
}());
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
        // Must match the PaymentType enum in BosWebServices
        var PaymentType;
        (function (PaymentType) {
            PaymentType[PaymentType["CREDIT"] = 0] = "CREDIT";
            PaymentType[PaymentType["EFT"] = 1] = "EFT";
            PaymentType[PaymentType["INVOICE"] = 2] = "INVOICE";
            PaymentType[PaymentType["NON_REVENUE"] = 3] = "NON_REVENUE";
            PaymentType[PaymentType["CASH"] = 4] = "CASH";
        })(PaymentType = Constant.PaymentType || (Constant.PaymentType = {}));
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
        var StorefrontWhitelist = /** @class */ (function () {
            function StorefrontWhitelist() {
            }
            Object.defineProperty(StorefrontWhitelist, "Default", {
                get: function () {
                    return {
                        whitelistUrls: [
                            "api/sessions/MissedAToll",
                            "api/sessions/Login",
                            "api/sessions/AddMissingInformation",
                            "api/sessions/AccountActivity",
                            "api/sessions/ManageVehicles",
                            "api/sessions/ActivateEzTag",
                            "api/sessions/AccountSummary",
                            "api/sessions/Storefront",
                            "api/sessions/Violations",
                            "api/sessions/AccountInformation",
                            "api/sessions/MakeOneTimePayment",
                            "api/sessions/ManagePayment",
                            "api/sessions/PersonalInfo",
                            "api/sessions/UpdateRebillAmount",
                            "api/sessions/SentALetter",
                            "api/sessions/PersonalBusinessData",
                            "api/sessions/PersonalBusinessDetails",
                            "api/sessions/PersonalInfo",
                            "api/sessions/AddPaymentDetails",
                            "api/sessions/AddEZTag",
                            "api/sessions/CreateAccountSummary",
                            "api/sessions/Checkout",
                            "api/sessions/CreateAccountReceipt",
                            "api/sessions/GetCurrentStep",
                            "api/sessions/MultiVehicleUpload"
                        ]
                    };
                },
                enumerable: true,
                configurable: true
            });
            return StorefrontWhitelist;
        }());
        Constant.StorefrontWhitelist = StorefrontWhitelist;
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").constant("storefrontWhitelist", HCTRA.Constant.StorefrontWhitelist.Default);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('violationControls', {
        fullBack: 0,
        back: 1,
        forward: 2,
        fullForward: 3
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').constant('violationDiscountEnum', {
        none: 0,
        frp: 1,
        cfdp: 2
    });
}());
var HCTRA;
(function (HCTRA) {
    var Datastructure;
    (function (Datastructure) {
        "use strict";
        var CircularList = /** @class */ (function () {
            function CircularList(inArray) {
                var _this = this;
                this.headPosition = 0;
                this.moveHeadLeft = function () {
                    _this.shiftHeadPosition(-1);
                    return _this.peekCurrent();
                };
                this.moveHeadRight = function () {
                    _this.shiftHeadPosition(1);
                    return _this.peekCurrent();
                };
                this.peekCurrent = function () {
                    return _this.baseArray[_this.headPosition];
                };
                this.peekLeft = function () {
                    var oldPosition = _this.headPosition;
                    var value = _this.moveHeadLeft();
                    _this.headPosition = oldPosition;
                    return value;
                };
                this.peekRight = function () {
                    var oldPosition = _this.headPosition;
                    var value = _this.moveHeadRight();
                    _this.headPosition = oldPosition;
                    return value;
                };
                this.shiftHeadPosition = function (relativePosition) {
                    var newHeadPosition = (relativePosition + _this.headPosition);
                    // Check intended to prevent unneeded use of expensive mod operation
                    if (newHeadPosition < 0 || newHeadPosition >= _this.baseArray.length) {
                        // Should keep the headPosition between 0 and (length - 1)
                        newHeadPosition = HCTRA.HctraMath.mod(newHeadPosition, _this.baseArray.length);
                    }
                    _this.headPosition = newHeadPosition;
                    return _this.headPosition;
                };
                if (!inArray || !angular.isArray(inArray)) {
                    throw new TypeError("Circular list requires an array");
                }
                else {
                    this.baseArray = [].concat(inArray);
                }
            }
            return CircularList;
        }());
        Datastructure.CircularList = CircularList;
    })(Datastructure = HCTRA.Datastructure || (HCTRA.Datastructure = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Datastructure;
    (function (Datastructure) {
        'use strict';
        var Paginator = /** @class */ (function () {
            function Paginator(initArray, itemsPerPage) {
                var _this = this;
                this.itemsPerPage = itemsPerPage;
                this.getPage = function (pageNum) {
                    return _this.paginatedArr[pageNum - 1];
                };
                this.setPageSize = function (newPageSize) {
                    _this.itemsPerPage = newPageSize;
                    _this.paginatedArr = _this.divideIntoPages(_this.flatArr, newPageSize);
                };
                this.divideIntoPages = function (flatArr, itemsPerPage) {
                    var flatArrCopy = flatArr.slice(); // if not for this copy line, the method would be destructive to the input array
                    var outArr = [];
                    do {
                        outArr.push(flatArrCopy.splice(0, itemsPerPage));
                    } while (flatArrCopy.length > 0);
                    return outArr;
                };
                this.flatArr = initArray.slice(); // only use the copy
                this.paginatedArr = this.divideIntoPages(this.flatArr, itemsPerPage);
            }
            Object.defineProperty(Paginator.prototype, "itemCount", {
                get: function () {
                    return this.flatArr.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Paginator.prototype, "pageCount", {
                get: function () {
                    return this.paginatedArr.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Paginator.prototype, "pageSize", {
                get: function () {
                    return this.itemsPerPage;
                },
                enumerable: true,
                configurable: true
            });
            return Paginator;
        }());
        Datastructure.Paginator = Paginator;
    })(Datastructure = HCTRA.Datastructure || (HCTRA.Datastructure = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Decorator;
    (function (Decorator) {
        var GenericRepoVantivDecorator = /** @class */ (function () {
            function GenericRepoVantivDecorator($delegate, webStorage, webStorageConst) {
                var _this = this;
                this.$delegate = $delegate;
                this.webStorage = webStorage;
                this.webStorageConst = webStorageConst;
                // VantivLog/LogVantivRequestData
                var LogVantivRequestFn = $delegate.dataFactory.LogVantivRequest;
                var newLogVantivRequestFn = function (data) {
                    // Get violations data from webStorage and set in data
                    data.violationsData = _this.webStorage.getValue(_this.webStorageConst.violationsLogData);
                    return LogVantivRequestFn.call($delegate, data);
                };
                $delegate.dataFactory.LogVantivRequest = newLogVantivRequestFn;
                // VantivLog/LogVantivResponseData
                var LogVantivResponseFn = $delegate.dataFactory.LogVantivResponse;
                var newLogVantivResponseFn = function (data) {
                    // Get violations data from webStorage and set in data
                    data.violationsData = _this.webStorage.getValue(_this.webStorageConst.violationsLogData);
                    return LogVantivResponseFn.call($delegate, data);
                };
                $delegate.dataFactory.LogVantivResponse = newLogVantivResponseFn;
                return $delegate;
            }
            GenericRepoVantivDecorator.$inject = ["$delegate", "webStorage", "webStorageConst"];
            return GenericRepoVantivDecorator;
        }());
        Decorator.GenericRepoVantivDecorator = GenericRepoVantivDecorator;
    })(Decorator = HCTRA.Decorator || (HCTRA.Decorator = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").decorator("genericRepo", HCTRA.Decorator.GenericRepoVantivDecorator);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('authorizedContacts', function () {
        return {
            transclude: true,
            scope: {
                contacts: "=",
                showEdit: "=",
                onEdit: "&",
                isAccountInformation: "="
            },
            templateUrl: '/app/directives/account/authorizedContactsTemplate.html',
            link: function ($scope) {
                $scope.displayEdit = $scope.showEdit;
            }
        };
    });
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var OneTimeEnterAmountDirective = /** @class */ (function () {
            function OneTimeEnterAmountDirective(validationService, $filter) {
                var _this = this;
                this.validationService = validationService;
                this.$filter = $filter;
                this.templateUrl = "/app/directives/account/makeOneTimePayment/oneTimeEnterAmount.html";
                this.scope = {
                    floatAmount: "=",
                    showAmount: "=",
                    paymentAmount: "=",
                    onAmountChange: "=?",
                    formName: "=",
                    zeroIsAccepted: "=",
                    minimumAcceptedAmount: "=?",
                    treatBlankAsBlank: "=?"
                };
                this.link = function ($scope) {
                    var isValidAmount = !$scope.treatBlankAsBlank;
                    if ($scope.zeroIsAccepted) {
                        $scope.minimumAcceptedAmount = 0.00;
                    }
                    else {
                        if (!$scope.minimumAcceptedAmount) {
                            $scope.minimumAcceptedAmount = 1;
                        }
                    }
                    $scope.validation = _this.validationService($scope.formName);
                    if (angular.isUndefined($scope.paymentAmount)) {
                        $scope.paymentAmount = "$10.00";
                        $scope.showAmount = "10.00";
                        $scope.cleanAmount = "10.00";
                        $scope.floatAmount = 10.00;
                    }
                    else {
                        $scope.cleanAmount = $scope.showAmount;
                    }
                    $scope.onAmountChange = function () {
                        if (angular.isDefined($scope.paymentAmount)) {
                            if ($scope.paymentAmount === "") {
                                $scope.paymentAmount = ($scope.treatBlankAsBlank) ? "" : "$0.00";
                            }
                            $scope.cleanAmount = $scope.paymentAmount.replace(/\$/g, '');
                            $scope.floatAmount = parseFloat($scope.cleanAmount);
                        }
                        // Have to explicitly set all manual validation to true due to form validaiton check below
                        $scope.formName.paymentAmount.$setValidity("NaN", true);
                        $scope.formName.paymentAmount.$setValidity("tooLow", true);
                        isValidAmount = angular.isNumber($scope.floatAmount) && $scope.formName.$valid;
                        if (!isValidAmount) {
                            $scope.formName.paymentAmount.$setValidity("NaN", false);
                        }
                        else {
                            $scope.formName.paymentAmount.$setValidity("NaN", true);
                            if ($scope.floatAmount >= $scope.minimumAcceptedAmount) {
                                $scope.formName.paymentAmount.$setValidity("tooLow", true);
                            }
                            else {
                                $scope.formName.paymentAmount.$setValidity("tooLow", false);
                            }
                        }
                        if ($scope.formName.$valid)
                            $scope.showAmount = $scope.cleanAmount;
                        else
                            $scope.showAmount = "0";
                    };
                    $scope.onBlur = function () {
                        if (isValidAmount) {
                            $scope.paymentAmount = _this.$filter('currency')($scope.paymentAmount.replace(/\$/g, "")).replace(/,/g, "");
                        }
                    };
                };
            }
            OneTimeEnterAmountDirective.factory = function () {
                var directive = function (validationService, $filter) { return new OneTimeEnterAmountDirective(validationService, $filter); };
                directive.$inject = ["validationService", "$filter"];
                return directive;
            };
            return OneTimeEnterAmountDirective;
        }());
        Directive.OneTimeEnterAmountDirective = OneTimeEnterAmountDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("oneTimeEnterAmount", HCTRA.Directive.OneTimeEnterAmountDirective.factory());
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("resizeAccountSummary", ['$window', 'responsiveService',
        function ($window, responsiveService) {
            return {
                restrict: "E",
                scope: {
                    func: '='
                },
                link: function ($scope) {
                    $window.onresize = function () {
                        if (responsiveService.isDesktop()) {
                            $scope.func.createGraph();
                        }
                    };
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('tabControls', function () {
        return {
            scope: {
                thisPage: '=',
                tabTitles: '='
            },
            templateUrl: '/app/directives/account/tabControlsTemplate.html'
        };
    });
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var AccountDetailsHeaderController = /** @class */ (function () {
            function AccountDetailsHeaderController(CurrentUser, environmentConfig) {
                var _this = this;
                this.CurrentUser = CurrentUser;
                this.environmentConfig = environmentConfig;
                this.currentUserListenerDestroyerFunction = this.CurrentUser.currentUserListener(function (currentUserPassBack) {
                    _this.currentUser = currentUserPassBack || {};
                    _this.togglePaymentPlan = _this.currentUser.hasPaymentPlans ? _this.currentUser.paymentPlanBalance > 0 : false;
                });
                this.$onInit = function () {
                    _this.maxNameLength = 23;
                    _this.currentUser = _this.CurrentUser.getCurrentUser() || {};
                    _this.togglePaymentPlan = _this.currentUser.hasPaymentPlans ? _this.currentUser.paymentPlanBalance > 0 : false;
                    _this.balanceUpdate = new Date();
                };
                this.fullName = function () {
                    return _this.currentUser.firstName + " " + _this.currentUser.lastName;
                };
                this.$onDestroy = function () {
                    _this.currentUserListenerDestroyerFunction();
                };
            }
            AccountDetailsHeaderController.$inject = [
                'CurrentUser',
                'environmentConfig'
            ];
            return AccountDetailsHeaderController;
        }());
        Controller.AccountDetailsHeaderController = AccountDetailsHeaderController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').component("accountDetailsHeader", {
        templateUrl: "/app/directives/accountDetailsHeaderTemplate.html",
        bindings: {
            currentBalance: '<',
            suspended: '=?'
        },
        controller: HCTRA.Controller.AccountDetailsHeaderController
    });
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var AccountHeaderController = /** @class */ (function () {
            function AccountHeaderController(CurrentUser, environmentConfig) {
                var _this = this;
                this.CurrentUser = CurrentUser;
                this.environmentConfig = environmentConfig;
                this.currentUserListenerDestroyerFunction = this.CurrentUser.currentUserListener(function (currentUserPassBack) {
                    _this.currentUser = currentUserPassBack || {};
                    _this.togglePaymentPlan = _this.currentUser.hasPaymentPlans ? _this.currentUser.paymentPlanBalance > 0 : false;
                });
                this.$onInit = function () {
                    _this.currentUser = _this.CurrentUser.getCurrentUser() || {};
                    _this.balanceUpdate = new Date();
                    _this.togglePaymentPlan = _this.currentUser.hasPaymentPlans ? _this.currentUser.paymentPlanBalance > 0 : false;
                };
                this.$onDestroy = function () {
                    _this.currentUserListenerDestroyerFunction();
                };
            }
            AccountHeaderController.$inject = [
                'CurrentUser',
                'environmentConfig'
            ];
            return AccountHeaderController;
        }());
        Controller.AccountHeaderController = AccountHeaderController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').component("accountHeader", {
        templateUrl: "/app/directives/accountHeaderTemplate.html",
        bindings: {
            currentBalance: '<',
            acctId: '<'
        },
        controller: HCTRA.Controller.AccountHeaderController
    });
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var AccountIdentificationDirective = /** @class */ (function () {
            function AccountIdentificationDirective($window, routes, validationService, removeDoubleCharService, linkLookupService, $timeout) {
                var _this = this;
                this.$window = $window;
                this.routes = routes;
                this.validationService = validationService;
                this.removeDoubleCharService = removeDoubleCharService;
                this.linkLookupService = linkLookupService;
                this.$timeout = $timeout;
                this.restrict = "E";
                this.templateUrl = "/app/directives/accountIdentificationTemplate.html";
                this.scope = {
                    passwordResetOption: "=",
                    idInfoObject: "=",
                    parentForm: "=",
                    tabOrderingIndex: "=",
                    remote: "="
                };
                this.controller = AccountIdentificationDirectiveController;
                this.link = function ($scope) {
                    $scope.removeDoubles = function (input, itm) {
                        var val = _this.removeDoubleCharService.removeDoubleChar(input);
                        if (val) {
                            $scope.idInfoObject[itm] = val;
                        }
                    };
                    $scope.$watch("parentForm.personalInfo.$viewValue", function (personalInfoInput) {
                        if (personalInfoInput) {
                            var personalInfoSelectionValid = ["driversLicense", "taxId"].indexOf(personalInfoInput) > -1;
                            $scope.parentForm.personalInfo.$setValidity("required", personalInfoSelectionValid);
                        }
                    });
                    $scope.validations = _this.validationService($scope.parentForm);
                    $scope.needHelp = function () {
                        _this.$window.open(_this.linkLookupService.articleLookupById(_this.routes.needHelpCms));
                    };
                    $scope.isItalic = function (member) {
                        if ($scope.idInfoObject[member] !== "waterm") {
                            return "";
                        }
                        else {
                            return "setItalic";
                        }
                    };
                    $scope.changeFirstInfo = function () {
                        _this.$timeout(function () {
                            angular.element("#accountNumber, #eztagOrg").focus();
                        }, 200);
                    };
                    $scope.changeSecondInfo = function () {
                        _this.$timeout(function () {
                            angular.element("#taxIdNumber, #driverState").focus();
                        }, 200);
                    };
                };
            }
            AccountIdentificationDirective.factory = function () {
                var directive = function ($window, routes, validationService, removeDoubleCharService, linkLookupService, $timeout) { return new AccountIdentificationDirective($window, routes, validationService, removeDoubleCharService, linkLookupService, $timeout); };
                directive.$inject = ["$window",
                    "routes",
                    "validationService",
                    "removeDoubleCharService",
                    "linkLookupService",
                    "$timeout"];
                return directive;
            };
            return AccountIdentificationDirective;
        }());
        Directive.AccountIdentificationDirective = AccountIdentificationDirective;
        var AccountIdentificationDirectiveController = /** @class */ (function () {
            function AccountIdentificationDirectiveController($scope, genericRepo, responseErrorService) {
                var _this = this;
                this.$scope = $scope;
                this.genericRepo = genericRepo;
                this.responseErrorService = responseErrorService;
                $scope.idInfoObject = {
                    accountInfo: "waterm",
                    accountNumber: "",
                    tagNumber: "",
                    personalInfo: "waterm",
                    driversLicense: "",
                    taxIdNumber: "",
                    driverState: "TX",
                    eztagOrg: "HCTR",
                    option: $scope.passwordResetOption
                };
                this.genericRepo.dataFactory.setupFpAccount().then(function (response) {
                    if (_this.responseErrorService.isErrorFree(response)) {
                        $scope.authorityList = response.authorities;
                        $scope.stateList = response.states;
                    }
                });
            }
            AccountIdentificationDirectiveController.$inject = ["$scope", "genericRepo", "responseErrorService"];
            return AccountIdentificationDirectiveController;
        }());
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("accountIdentification", HCTRA.Directive.AccountIdentificationDirective.factory());
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("accountInformation", [
        function () {
            return {
                restrict: "E",
                templateUrl: "/app/directives/accountInformationTemplate.html",
                transclude: true,
                scope: {
                    currentUser: '=',
                    paymentDate: '=',
                    deliveryMethod: '=',
                    hideTransactionId: '=',
                    hideDeliveryMethod: '='
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("accountSetupCharges", ['genericRepo',
        'responseErrorService',
        'cmsTextInsertionService',
        'routes',
        function (genericRepo, responseErrorService, cmsTextInsertionService, routes) {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/accountSetupChargesPartial.html",
                scope: {
                    payment: "=data",
                    isAddPlate: "="
                },
                link: function ($scope) {
                    var transHeaders = angular.element("#accountSetupHeaderTransclude > :header").first();
                    genericRepo.dataFactory.getCmsPageById({ ItemId: routes.accountSetupChargesCms }).then(function (res) {
                        if (responseErrorService.isErrorFree(res)) {
                            var parsedRes = angular.fromJson(res.cmsResponse);
                            $scope.tagFeeNotice = cmsTextInsertionService.dynamicContent(parsedRes.LongDescription, { pathNorm: ["payment"] });
                        }
                    });
                    if (transHeaders.length > 0) { // They included a header tag
                        $scope.transcludeIncluded = true;
                    }
                    else {
                        $scope.transcludeIncluded = false;
                    }
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("addMultipleVehicles", ['localDataRepo',
        function (localDataRepo) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/addMultipleVehiclesTemplate.html",
                scope: {
                    vehicleList: '=',
                    editFunction: '&',
                    deleteFunction: '&',
                    hideDelete: '=?',
                    title: '=?'
                },
                link: function ($scope) {
                    if (!$scope.hideDelete) {
                        $scope.hideDelete = false;
                    }
                    if (!$scope.title) {
                        $scope.title = "EZ TAGs Requested";
                    }
                    $scope.onEdit = function (index) {
                        var functionFromParentController = $scope.editFunction();
                        functionFromParentController(index);
                    };
                    var classList = localDataRepo.getClasses(); // Axle classifications
                    $scope.classIdToLabel = function (id) {
                        var label;
                        classList.forEach(function (elem) {
                            if (elem.value == id) {
                                label = elem.label;
                                return;
                            }
                        });
                        return label;
                    };
                    $scope.onDelete = function (index) {
                        var functionFromParentController = $scope.deleteFunction();
                        functionFromParentController(index);
                    };
                }
            };
        }]);
}());
//migrated
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("articleSearchParameter", [
        function () {
            return {
                restrict: "E",
                templateUrl: "/app/directives/articleSearchParameterTemplate.html",
                scope: {
                    userClickedSearch: '&',
                    categories: '=',
                    categoryHolder: '='
                },
                link: function ($scope) {
                    $scope.isItalic = function (member) {
                        if ($scope[member] !== '') {
                            return '';
                        }
                        else {
                            return 'setItalic';
                        }
                    };
                }
            };
        }
    ]);
}());
/* eslint-disable no-useless-escape */
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('bankAccountEntry', ['validationService', '$window', 'routes', 'linkLookupService',
        function (validationService, $window, routes, linkLookupService) {
            return {
                scope: {
                    bankDetails: "=",
                    paymentsform: "=",
                    validate: "="
                },
                templateUrl: '/app/directives/billingEntry/bankAccountEntryTemplate.html',
                link: function ($scope, elem, attrs) {
                    $scope.showNameField = 'showName' in attrs;
                    $scope.nameOnBankAccountValidation = new RegExp(/^(?=.*[a-zA-Z])([a-zA-Z0-9\-\,\.\'\s]{0,80})$/);
                    $scope.bankRoutingNumberValidation = new RegExp(/^\d{9}$/);
                    $scope.bankAccountNumberValidation = new RegExp(/^(\d{1,17}|\*{12}\d{4})$/);
                    if (!$scope.bankDetails)
                        $scope.bankDetails = {};
                    $scope.clearReq = function (obj, prop, field) {
                        if ($scope[obj][prop]) {
                            $scope.paymentsform[field].$setValidity('required', true);
                        }
                    };
                    $scope.clickedHelp = function () {
                        $window.open(linkLookupService.articleLookupById(routes.eftHelp));
                    };
                    $scope.validation = validationService($scope.paymentsform);
                }
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var CreditCardEntry = /** @class */ (function () {
            function CreditCardEntry(validationService, expirationDateService, monthListService, creditCardInputService) {
                var _this = this;
                this.validationService = validationService;
                this.expirationDateService = expirationDateService;
                this.monthListService = monthListService;
                this.creditCardInputService = creditCardInputService;
                this.templateUrl = "/app/directives/billingEntry/creditCardEntryTemplate.html";
                this.scope = {
                    creditCard: "=",
                    paymentsform: "=",
                    nameSuffix: "=",
                    useExistingCard: "=?",
                    disableValidation: "=?"
                };
                this.link = function ($scope, element, attr) {
                    var updateValidity = function (property, criteria, valid) {
                        return $scope.paymentsform[$scope.addSuffix(property)].$setValidity(criteria, valid);
                    };
                    var validateAndUpdateExpirationDate = function () {
                        updateValidity("expMonth", "required", _this.expirationDateService.isMonthValid($scope.creditCard.expMonth, $scope.creditCard.selectedYear));
                        updateValidity("expYear", "required", _this.expirationDateService.isYearValid($scope.creditCard.selectedYear));
                        $scope.creditCard.cardExpires = $scope.creditCard.expMonth + "/" + $scope.creditCard.selectedYear;
                    };
                    angular.extend($scope, {
                        toasterVisible: false,
                        useExistingCard: null,
                        months: _this.monthListService.months,
                        addSuffix: function (cardItem) { return cardItem + $scope.nameSuffix; },
                        update: function () { return _this.creditCardInputService.update($scope); },
                        strategyUsed: 17,
                        strategies: HCTRA.Model.CreditCardInputStrategyEnum,
                        autoUpdate: angular.isDefined(attr.autoUpdate),
                        creditCardNameDisabled: true,
                        creditCardNumberDisabled: true,
                        creditCardExpYearDisabled: true,
                        creditCardExpMothDisabled: true
                    });
                    _this.creditCardInputService.setup($scope);
                    $scope.$watch("creditCard.expMonth", function (expMonth) {
                        expMonth && validateAndUpdateExpirationDate();
                    });
                    $scope.$watch("creditCard.selectedYear", function (selectedYear) {
                        $scope.yearList = _this.expirationDateService.getExpirationYearList(selectedYear, 20);
                        selectedYear && validateAndUpdateExpirationDate();
                    });
                    $scope.$on($scope.nameSuffix, function (event, deferred) {
                        _this.creditCardInputService
                            .submit($scope)
                            .then(function () { return deferred.resolve(); })
                            .catch(function () { return deferred.reject(); });
                    });
                    $scope.validation = _this.validationService($scope.paymentsform);
                };
            }
            CreditCardEntry.$inject = ["validationService", "expirationDateService", "monthListService", "creditCardInputService"];
            return CreditCardEntry;
        }());
        Directive.CreditCardEntry = CreditCardEntry;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    function genericDirectiveFactory(functionConstructor) {
        var directive = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new (functionConstructor.bind.apply(functionConstructor, [null].concat(args)))();
        };
        directive.$inject = functionConstructor.$inject;
        return directive;
    }
    angular.module("HCTRAModule")
        .directive("creditCardEntry", genericDirectiveFactory(HCTRA.Directive.CreditCardEntry));
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('creditCardNameNumValidator', [
        function () {
            return {
                scope: {
                    "creditCardNameNumValidator": '@'
                },
                require: "ngModel",
                link: function (scope, element, attributes, ngModel) {
                    ngModel.$validators.creditCardNameNumValidator = function (modelValue) {
                        if (angular.isUndefined(modelValue)) {
                            return false;
                        }
                        if (angular.isDefined(scope.$parent.creditCard.cardNbr)) {
                            var nameOnCard = modelValue;
                            if (nameOnCard.search(/\d{10}/) !== -1) {
                                return false;
                            }
                        }
                        return true;
                    };
                    scope.$watch('creditCardNameNumValidator', function () {
                        ngModel.$validate();
                    });
                }
            };
        }
    ]);
}());
/* eslint-disable no-useless-escape */
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("creditCardNameValidator", ['responseErrorService',
        function (responseErrorService) {
            return {
                require: "ngModel",
                link: function (scope, element, attributes, ngModel) {
                    var cardPrefixLengthRegex = /.*\d{5}.*/;
                    var validCardNameRegex = /^[0-9a-zA-Z\-\,\.\'\s\/]*$/;
                    ngModel.$validators.creditCardNameValidator = function (modelValue) {
                        if (angular.isUndefined(modelValue)) {
                            return false;
                        }
                        if (validCardNameRegex.test(modelValue)) {
                            if (cardPrefixLengthRegex.test(modelValue)) {
                                if (!scope.$parent.toasterVisible) {
                                    responseErrorService.displayToast("Please verify the name on the credit card is correct.", 'warning');
                                    scope.$parent.toasterVisible = true;
                                }
                            }
                            else {
                                scope.$parent.toasterVisible = false;
                            }
                            return true;
                        }
                        return false;
                    };
                    scope.$watch('modelValue', function () {
                        ngModel.$validate();
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("creditCardTypeValidator", ['creditCardTypeService',
        //CreditCardType is convereted to enum in Angular
        function (creditCardTypeService) {
            return {
                require: "ngModel",
                scope: {
                    "creditcard.cardCode": "="
                },
                link: function (scope, element, attributes, ngModel) {
                    ngModel.$validators.creditCardTypeValidator = function (modelValue) {
                        var autoFilledCardNumberRegex = /^\*{12}-\d{4}/;
                        if (angular.isUndefined(modelValue) || modelValue == "") {
                            if (scope.$parent.creditCard) {
                                scope.$parent.creditCard.cardCode = "NA";
                            }
                            return false;
                        }
                        if (!autoFilledCardNumberRegex.test(modelValue) && modelValue) {
                            scope.$parent.creditCard.cardCode = creditCardTypeService.findCardCode(modelValue);
                        }
                        if (scope.$parent.creditCard.cardCode === "NA") {
                            return false;
                        }
                        return true;
                    };
                    scope.$watch('creditCard.cardNbr', function () {
                        ngModel.$validate();
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("bankInfo", function () {
        return {
            restrict: "E",
            transclude: true,
            templateUrl: "/app/directives/billingInfo/bankInfo.html",
            scope: {
                bank: '=',
                onEdit: '&',
                hideEdit: '=?',
                isAccountInformation: "="
            },
            link: function ($scope, elem, attrs, ctrl, $transclude) {
                $scope.showEdit = !!attrs.onEdit;
                $scope.noTransHeader = false;
                $scope.headerText = "Update Billing Information";
                $scope.showAccountNumber = 'showAccountNumber' in attrs;
                $scope.guaranteedPrimary = 'guaranteedPrimary' in attrs;
                var unwatch = $scope.$watch('bank', function () {
                    if ($scope.bank && $scope.bank.accountNumber) {
                        $scope.bankDetails = {};
                        $scope.bankDetails = $scope.bank;
                        if (!$scope.bankDetails.accountType) {
                            $scope.bankDetails.accountType = $scope.bankDetails.accountTypeDisplay;
                        }
                        unwatch();
                    }
                });
                // Checks if there is a transcluded header or not
                $transclude(function (header) {
                    if (!header.length) {
                        $scope.noTransHeader = true;
                    }
                });
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("billingAddress", function () {
        return {
            restrict: "E",
            templateUrl: "/app/directives/billingInfo/billingAddress.html",
            scope: {
                internationalIn: '=international',
                creditCard: '=',
                noH4: '='
            },
            link: function ($scope) {
                // $scope.internationalIn could be a bool or an object
                if ($scope.internationalIn === true) {
                    $scope.international = $scope.internationalIn;
                }
                else if (angular.isObject($scope.internationalIn) && angular.isDefined($scope.internationalIn.value)) {
                    $scope.international = $scope.internationalIn.value;
                }
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("creditCardInfo", ["arrayUtilService", "cmsUtilService",
        function (arrayUtilService, cmsUtilService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/billingInfo/creditCardInfo.html",
                transclude: true,
                scope: {
                    creditcard: '=',
                    onEdit: '&',
                    onCreditCardEdit: '&',
                    addSecondaryPayment: '&',
                    multiplecards: '&',
                    hideEdit: '=?',
                    international: '=',
                    isAccountInformation: '=',
                    numCards: '=',
                    isPrimarySet: '=',
                    cardCmsContent: '<?'
                },
                link: function ($scope, elem, attrs, ctrl, $transclude) {
                    var multipleCreditCards = $scope.multiplecards();
                    $scope.showEdit = !!attrs.onEdit && !multipleCreditCards;
                    $scope.noTransHeader = false;
                    $scope.headerText = "Update Billing Information";
                    $scope.showAddSecondaryPayment = 'addSecondaryPayment' in attrs && !multipleCreditCards;
                    $scope.showNameOnCard = 'showNameOnCard' in attrs;
                    $scope.hideTitle = 'card2' in attrs;
                    $scope.showCardEdit = multipleCreditCards && 'multiplecards' in attrs;
                    $scope.hideAddress = 'hideAddress' in attrs;
                    $scope.guaranteedPrimary = 'guaranteedPrimary' in attrs;
                    $scope.creditCard = $scope.creditcard === null ? {} : $scope.creditcard;
                    var unwatch = $scope.$watch('creditcard', function () {
                        if ($scope.creditcard && $scope.creditcard.cardNbr) {
                            $scope.creditCard = $scope.creditcard === null ? {} : $scope.creditcard;
                            if (multipleCreditCards && !$scope.guaranteedPrimary) {
                                $scope.creditCard.orderDisplay = $scope.creditCard.primary ? "Primary" : "Secondary";
                            }
                            else if ($scope.guaranteedPrimary) {
                                $scope.creditCard.orderDisplay = 'Primary';
                            }
                            else {
                                $scope.creditCard.orderDisplay = '';
                            }
                            assignCardImage($scope.cardCmsContent, $scope.creditCard.cardCode);
                            unwatch();
                        }
                    });
                    var unwatch2 = $scope.$watch('cardCmsContent', function () {
                        if ($scope.cardCmsContent) {
                            assignCardImage($scope.cardCmsContent, $scope.creditCard.cardCode);
                            unwatch2();
                        }
                    });
                    $scope.$watch('isPrimarySet', function (newValue) {
                        $scope.showAddSecondaryPayment = 'addSecondaryPayment' in attrs && !multipleCreditCards && newValue;
                    });
                    // Checks if there is a transcluded header or not
                    $transclude(function (header) {
                        if (!header.length) {
                            $scope.noTransHeader = true;
                        }
                    });
                    function assignCardImage(cardCmsContent, cardCode) {
                        if (cardCmsContent && cardCode) {
                            var paymentMethodImageDict = arrayUtilService.toDictionary(cardCmsContent, function (u) { return u.Label[0].toUpperCase(); });
                            $scope.imageSrc = cmsUtilService.generateFileSrc(paymentMethodImageDict[cardCode].Image);
                        }
                    }
                }
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var BillingInfoDirective = /** @class */ (function () {
            //CreditCardType is convereted to enum in Angular
            function BillingInfoDirective(creditCardTypes, billingInfoUtilitiesService) {
                var _this = this;
                this.creditCardTypes = creditCardTypes;
                this.billingInfoUtilitiesService = billingInfoUtilitiesService;
                this.transclude = true;
                this.restrict = "E";
                this.templateUrl = "/app/directives/billingInfoPartial.html";
                this.scope = {
                    billingInfo: "=data",
                    onEdit: "&",
                    addSecondaryPayment: "&",
                    billingtype: "=?",
                    hideEdit: "=?",
                    intitle: "=?"
                };
                this.link = function ($scope, elem, attrs) {
                    $scope.showEdit = !!attrs.onEdit;
                    $scope.hideAddress = "hideAddress" in attrs;
                    $scope.showAddSecondaryPayment = "addSecondaryPayment" in attrs;
                    $scope.showNameOnCard = "showNameOnCard" in attrs;
                    $scope.showAccountNumber = "showAccountNumber" in attrs;
                    $scope.billingtypeAvailable = !!attrs.billingtype;
                    if (!$scope.intitle) {
                        $scope.intitle = "Billing Information";
                    }
                    var cardCodeToName = function (code) {
                        switch (code) {
                            case "V":
                                return _this.creditCardTypes.visa;
                            case "M":
                                return _this.creditCardTypes.mastercard;
                            case "D":
                                return _this.creditCardTypes.discover;
                            case "A":
                                return _this.creditCardTypes.amex;
                        }
                    };
                    var transHeaders = angular.element("#accountSetupHeaderTransclude > :header").first();
                    if (transHeaders.length > 0) { // They included a header tag
                        $scope.transcludeIncluded = true;
                    }
                    else {
                        $scope.transcludeIncluded = false;
                    }
                    if ($scope.billingtypeAvailable && $scope.billingtype === "EFT") {
                        $scope.bankDetails = $scope.billingInfo.eft;
                        $scope.billingtypeDisplay = "Bank Account";
                    }
                    else if ($scope.billingtypeAvailable && $scope.billingtype === "CREDIT") {
                        $scope.creditCard = $scope.billingInfo.cards[0] === null ? {} : $scope.billingInfo.cards[0];
                        $scope.secondaryCreditCard = $scope.billingInfo.cards[1] === null ? {} : $scope.billingInfo.cards[1];
                        $scope.cardType = cardCodeToName($scope.creditCard.cardCode);
                        $scope.billingtypeDisplay = "Credit Card";
                        $scope.creditCard.international = _this.billingInfoUtilitiesService.isInternationalAddress($scope.creditCard);
                    }
                    var unwatch = $scope.$watch("billingInfo", function () {
                        if ($scope.billingInfo && $scope.billingInfo.billingType === HCTRA.Constant.PaymentType.EFT && $scope.billingInfo.eft && $scope.billingInfo.eft.accountNumber && !$scope.billingtypeAvailable) {
                            $scope.bankDetails = {};
                            $scope.bankDetails = $scope.billingInfo.eft;
                            $scope.bankDetails.accountType = $scope.bankDetails.accountType ? "Business" : "Personal";
                            $scope.billingtypeDisplay = "Bank Account";
                            $scope.billingtype = $scope.billingInfo.billingTypeDisplay;
                            unwatch();
                        }
                        if ($scope.billingInfo && $scope.billingInfo.billingType === HCTRA.Constant.PaymentType.CREDIT && $scope.billingInfo.cards && $scope.billingInfo.cards[0] && $scope.billingInfo.cards[0].cardNbr && !$scope.billingtypeAvailable) {
                            $scope.creditCard = $scope.billingInfo.cards[0] === null ? {} : $scope.billingInfo.cards[0];
                            $scope.secondaryCreditCard = $scope.billingInfo.cards[1] === null ? {} : $scope.billingInfo.cards[1];
                            // Hide Add secondary link if the only card returned is non-primary
                            // This directive isn't currently (6/2/17) used anywhere where the secondary credit card would be added so no need for this change yet
                            //if ($scope.billingInfo.cards.length === 1 && !$scope.billingInfo.cards[0].primary) {
                            //    $scope.showAddSecondaryPayment = false;
                            //}
                            $scope.cardType = cardCodeToName($scope.creditCard.cardCode);
                            if ($scope.secondaryCreditCard)
                                $scope.secondaryCardType = cardCodeToName($scope.secondaryCreditCard.cardCode);
                            $scope.billingtype = $scope.billingInfo.billingTypeDisplay;
                            $scope.billingtypeDisplay = "Credit Card";
                            $scope.creditCard.international = _this.billingInfoUtilitiesService.isInternationalAddress($scope.creditCard);
                            unwatch();
                        }
                    });
                };
            }
            BillingInfoDirective.factory = function () {
                var directive = function (creditCardTypes, billingInfoUtilitiesService) { return new BillingInfoDirective(creditCardTypes, billingInfoUtilitiesService); };
                directive.$inject = ["creditCardTypes",
                    "billingInfoUtilitiesService"];
                return directive;
            };
            return BillingInfoDirective;
        }());
        Directive.BillingInfoDirective = BillingInfoDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("billingInfo", HCTRA.Directive.BillingInfoDirective.factory());
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("borderBottomButtons", [
        function () {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/borderBottomButtonsTemplate.html",
                scope: {
                    previousText: '@',
                    onContinueSave: '&',
                    onCancel: '&',
                    onPrevious: '&',
                    cancelText: '@',
                    isDisabled: '=',
                    excludeGlobalDisable: '=',
                    formComplete: '=?',
                    form: '=' // pass in the form if the directive is outside the form tag
                },
                link: function ($scope, elem, attrs) {
                    $scope.hideContinueSave = 'hideContinueSave' in attrs;
                    $scope.preserveWorkItem = 'preserveWorkItem' in attrs;
                    $scope.showCancel = 'showCancel' in attrs;
                    $scope.showPrevious = 'showPrevious' in attrs;
                    //this attr can be used to determine of user is at an exit point of the current 'wizard'
                    if (angular.isDefined(attrs['formComplete']) && attrs['formComplete'] === '') {
                        $scope.formComplete = true;
                    }
                    else if (angular.isUndefined(attrs['formComplete'])) {
                        $scope.formComplete = false;
                    }
                    if (angular.isDefined(attrs['storefrontOnly']) && attrs['storefrontOnly'] === '') {
                        $scope.storefrontOnly = true;
                    }
                    if (!('cancelText' in attrs) || angular.isUndefined(attrs.cancelText)) {
                        $scope.cancelText = 'Cancel';
                    }
                    $scope.continueSaveInvoked = function () {
                        var returnValue = $scope.onContinueSave(); //TODO: needto redirect for suspended accounts
                        $scope.setSubmitted();
                        if ($scope.onClick)
                            $scope.onClick();
                        return returnValue;
                    };
                    // sets submitted property for validation purposes
                    $scope.setSubmitted = function () {
                        if ($scope.form) {
                            $scope.form.$setSubmitted();
                        }
                    };
                    //$scope.onClick = function () {
                    //    $scope.permanentDisable = true;
                    //};
                    // Extracts the transcluded button text
                    // TODO: Need to fix commented code for /NewAccount/AddEZTAG
                    //$transclude(function (buttonText) {
                    //    if (buttonText.text().trim().length > 0) {
                    //        $scope.buttonText = buttonText.text();
                    //    }
                    //});
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("capitalizeAll", ['$parse',
        function ($parse) {
            return {
                restrict: 'A',
                require: "ngModel",
                link: function (scope, element, attrs, ctrl) {
                    var capitalizeAll = function (inputValue) {
                        if (angular.isUndefined(inputValue)) {
                            inputValue = '';
                        }
                        var capitalized = inputValue.toUpperCase();
                        if (capitalized !== inputValue) {
                            ctrl.$setViewValue(capitalized);
                            ctrl.$render();
                        }
                        return capitalized;
                    };
                    ctrl.$parsers.push(capitalizeAll);
                    capitalizeAll($parse(attrs.ngModel)(scope));
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("checkbox", ['validationService',
        function (validationService) {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/checkboxTemplate.html",
                scope: {
                    checkboxIsTruthy: '=',
                    parentForm: '=',
                    errorMessage: '='
                },
                link: function ($scope) {
                    $scope.validation = validationService($scope.parentForm);
                }
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var chooseDeliveryMethodController = /** @class */ (function () {
            function chooseDeliveryMethodController($window, routes, StorefrontService, responseErrorService, stringUtilsService, genericRepo, environmentConfig) {
                var _this = this;
                this.$window = $window;
                this.routes = routes;
                this.StorefrontService = StorefrontService;
                this.responseErrorService = responseErrorService;
                this.stringUtilsService = stringUtilsService;
                this.genericRepo = genericRepo;
                this.environmentConfig = environmentConfig;
                this.$onInit = function () {
                    _this.allowDeliveryByMail = _this.environmentConfig.tagDeliveryConfig.AllowDeliveryByMail;
                    _this.allowPickup = _this.environmentConfig.tagDeliveryConfig.AllowPickup;
                    _this.setDeliveryMethod();
                    return _this.getDeliveryMethodCMS();
                };
                this.setDeliveryMethod = function () {
                    // Customers can only pick up in store if using Kiosk
                    if (_this.StorefrontService && _this.StorefrontService.isEnabled()) {
                        _this.delivery = "store";
                        return;
                    }
                    // Feature Toggles dominate delivery method(s)
                    if (_this.allowDeliveryByMail && !_this.allowPickup) {
                        _this.delivery = "mail";
                    }
                    else if (!_this.allowDeliveryByMail && _this.allowPickup) {
                        _this.delivery = "store";
                    }
                };
                this.populateCMSContent = function (res) {
                    if (_this.responseErrorService.isErrorFree(res)) {
                        var deliveryMethodCMS = angular.fromJson(res.cmsResponse);
                        var params = _this.stringUtilsService.getParameterObject(deliveryMethodCMS.Parameters);
                        _this.deliveryMethodHeader = params.Delivery_Method_Header_Text;
                        _this.byMailDeliveryMethod = deliveryMethodCMS.ShortDescription;
                        _this.pickUpInStoreDeliveryMethod = deliveryMethodCMS.LongDescription;
                    }
                };
                this.getDeliveryMethodCMS = function () {
                    return _this.genericRepo.dataFactory.getCmsPageById({
                        path: null,
                        itemId: _this.routes.deliveryMethodCMS
                    }).then(_this.populateCMSContent);
                };
            }
            chooseDeliveryMethodController.$inject = [
                "$window",
                "routes",
                "StorefrontService",
                "responseErrorService",
                "stringUtilsService",
                "genericRepo",
                "environmentConfig"
            ];
            return chooseDeliveryMethodController;
        }());
        Controller.chooseDeliveryMethodController = chooseDeliveryMethodController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').component("chooseDeliveryMethod", {
        templateUrl: "/app/directives/chooseDeliveryMethodPartial.html",
        bindings: {
            "delivery": "="
        },
        controller: HCTRA.Controller.chooseDeliveryMethodController
    });
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var CmsImageIdDirective = /** @class */ (function () {
            function CmsImageIdDirective(genericRepo, cmsUtilService) {
                var _this = this;
                this.genericRepo = genericRepo;
                this.cmsUtilService = cmsUtilService;
                this.link = function (scope, element, attrs) {
                    var id = angular.isDefined(attrs.cmsImageId) && attrs.cmsImageId;
                    _this.genericRepo.dataFactory.getCmsPageById({
                        ItemId: id,
                        Fields: "Image"
                    })
                        .then(function (res) {
                        var obj = angular.fromJson(res.cmsResponse);
                        var img = _this.cmsUtilService.parseAllImageAttributes(obj.Image);
                        element
                            .attr("src", img.image)
                            .attr("alt", img.alt);
                    });
                };
            }
            CmsImageIdDirective.$inject = ["genericRepo", "cmsUtilService"];
            return CmsImageIdDirective;
        }());
        Directive.CmsImageIdDirective = CmsImageIdDirective;
        var CmsTextIdDirective = /** @class */ (function () {
            function CmsTextIdDirective(genericRepo, $sanitize) {
                var _this = this;
                this.genericRepo = genericRepo;
                this.$sanitize = $sanitize;
                this.link = function (scope, element, attrs) {
                    var id = angular.isDefined(attrs.cmsTextId) && attrs.cmsTextId;
                    var field = angular.isDefined(attrs.cmsTextField) && attrs.cmsTextField;
                    _this.genericRepo.dataFactory.getCmsPageById({
                        ItemId: id,
                        Fields: field
                    })
                        .then(function (res) {
                        var obj = angular.fromJson(res.cmsResponse);
                        element.html(_this.$sanitize(obj[field]));
                    });
                };
            }
            CmsTextIdDirective.$inject = ["genericRepo", "$sanitize"];
            return CmsTextIdDirective;
        }());
        Directive.CmsTextIdDirective = CmsTextIdDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    function genericDirectiveFactory(functionConstructor) {
        var directive = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new (functionConstructor.bind.apply(functionConstructor, [null].concat(args)))();
        };
        directive.$inject = functionConstructor.$inject;
        return directive;
    }
    angular.module("HCTRAModule")
        .directive("cmsImageId", genericDirectiveFactory(HCTRA.Directive.CmsImageIdDirective))
        .directive("cmsTextId", genericDirectiveFactory(HCTRA.Directive.CmsTextIdDirective));
    // .directive("cmsTextId", genericDirectiveFactory(HCTRA.Directive.CmsImageIdDirective))
    // .directive("cmsTextPath", genericDirectiveFactory(HCTRA.Directive.CmsImagePathDirective));
})();
(function () {
    'use strict';
    // angular.module('HCTRAModule').directive("readMoreOrLess", ['readMoreOrLessService', '$window',
    //     function (readMoreOrLessService, $window) {
    //         return {
    //             restrict: "E",
    //             templateUrl: "/app/directives/cms/readMoreOrLessTemplate.html",
    //             scope: {
    //                 longContent: "=",
    //                 shortContent: "=",
    //                 defaultToMore: "=",
    //                 titleName: "=",
    //                 itemId: "=",
    //                 itemPath: "="
    //             },
    //             link: function (scope : any) {                    
    //                 scope.vm = {};
    //                 scope.expanderClicked = function () {
    //                     const setToLongContent = (scope.vm.expanderText === readMoreOrLessService.readMore);
    //                     scope.vm.expanderText = setToLongContent ? readMoreOrLessService.readLess : readMoreOrLessService.readMore;
    //                     scope.vm.content = (setToLongContent ? scope.longContent : scope.shortContent) || scope.shortContent || scope.longContent || "";
    //                 };
    //                 scope.goToBreakoutPage = function (link) {
    //                     $window.open(link, "_blank");
    //                 };
    //                 const unwatch = scope.$watch('titleName', function () {
    //                     if (scope.titleName) {
    //                         scope.vm = readMoreOrLessService.getReadMoreOrLessInitialState(scope.shortContent, scope.longContent, scope.defaultToMore, scope.titleName, scope.itemId, scope.itemPath);
    //                         unwatch();
    //                     }
    //                 });
    //             }
    //         };
    //     }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("rss", [
        function () {
            return {
                restrict: "E",
                templateUrl: "/app/directives/cms/rssTemplate.html",
                replace: true,
                scope: {
                    onRssClick: "&"
                },
                link: function (scope) {
                    scope.titleText = "Click to add RSS for regular updates";
                    // Use rssService if they want the rss icon in Sitecore
                    scope.rssIcon = "/Content/icons/feed-icon.svg";
                }
            };
        }
    ]);
}());
/*
(function () {
    'use strict';

    angular.module('HCTRAModule').directive("tollRatesSelect", ['$location', 'ratesService',
        function ($location, ratesService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/cms/tollRatesSelectTemplate.html",
                scope: {
                    tollRoads: '=',
                    selectedTollRoad: '=',
                    selectedDirection: '=',
                    selectedClass: '='
                },
                link: function (scope) {
                    scope.changeUrl = function () {
                        $location.search('tollRoad', scope.selectedTollRoad.Title);
                    };

                    scope.createDynamicClassifications = function () {
                        if (scope.selectedTollRoad.Directions && scope.selectedTollRoad.Directions.length > 0) {
                            scope.classifications = ratesService.createAxleDropdown(scope.selectedTollRoad);
                            scope.selectedClass = scope.classifications[0];
                        }
                    };

                    scope.selectDefaultDirection = function () {
                        scope.selectedDirection = scope.selectedTollRoad.Directions[0];
                    };

                    var unwatch = scope.$watch('selectedTollRoad', function () {
                        if (scope.selectedTollRoad) {
                            scope.createDynamicClassifications();
                            unwatch();
                        }
                    });

                }
            };
        }]);

}());
*/ 
(function () {
    'use strict';
    var compareTo = function () {
        return {
            require: "ngModel",
            scope: {
                otherModelValue: "=compareTo"
            },
            link: function (scope, element, attributes, ngModel) {
                ngModel.$validators.compareTo = function (modelValue) {
                    if (isFalsy(modelValue) && isFalsy(scope.otherModelValue))
                        return true;
                    if (modelValue && scope.otherModelValue && attributes && ("caseInsensitive" in attributes))
                        return ((modelValue.toLowerCase() == scope.otherModelValue.toLowerCase()));
                    else
                        return ((modelValue == scope.otherModelValue));
                };
                scope.$watch('otherModelValue', function () {
                    ngModel.$validate();
                });
                //scope.$watch('modelValue', function () {
                //    ngModel.$validate();
                //});
            }
        };
        function isFalsy(val) { return !val; }
    };
    angular.module('HCTRAModule').directive("compareTo", compareTo);
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('compileTemplate', ["$compile", "$parse",
        function ($compile, $parse) {
            return {
                link: function (scope, element, attr) {
                    var parsed = $parse(attr.ngBindHtml);
                    function getStringValue() { return (parsed(scope) || '').toString(); }
                    //Recompile if the template changes
                    scope.$watch(getStringValue, function () {
                        $compile(element, null, -9999)(scope); //The -9999 makes it skip directives so that we do not recompile ourselves
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("accountPreferences", [
        function () {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/contactEntry/accountPreferences.html",
                scope: {
                    preferences: '=',
                    readOnly: '=',
                    showEdit: '=',
                    onEdit: '&'
                },
                link: function ($scope) {
                    $scope.displayEdit = $scope.showEdit;
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("authorizedContactEntry", ['validationService', 'operatingSystemSnifferService',
        function (validationService, operatingSystemSnifferService) {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/contactEntry/authorizedContactEntry.html",
                scope: {
                    authorizedContactDetails: '=',
                    tentativeAuthorizedContact: '=',
                    authContactLimit: '=',
                    form: '=',
                    contactsSubmitted: '='
                },
                link: function ($scope, elem, attrs) {
                    $scope.alwaysShowPassword = !('conditionalPassword' in attrs); // only show password field if an authorized contact is being typed in
                    $scope.neverShowPassword = ('noPassword' in attrs); // never show password field (account creation)
                    $scope.allowOneRow = ('oneRow' in attrs); // only allow one auth contact to be entered (account creation)
                    $scope.isDesktop = operatingSystemSnifferService.isDesktopOs();
                    $scope.wasRemoval = false;
                    $scope.validations = validationService($scope.form);
                    var unwatch = $scope.$watch('form', function () {
                        if ($scope.form.innerAuthForm) {
                            $scope.validationsInner = validationService($scope.form.innerAuthForm);
                            unwatch();
                        }
                    });
                    var unwatch2 = $scope.$watch('form.$submitted', function () {
                        if ($scope.form.$submitted) {
                            $scope.form.innerAuthForm.$setSubmitted();
                            unwatch2();
                        }
                    });
                    $scope.addAuthorizedContact = function () {
                        $scope.authorizedContactDetails.authorizedContacts.push($scope.tentativeAuthorizedContact);
                        $scope.tentativeAuthorizedContact = {};
                        $scope.wasRemoval = true;
                    };
                    $scope.removeAuthorizedContact = function (index) {
                        $scope.authorizedContactDetails.authorizedContacts.splice(index, 1);
                        $scope.wasRemoval = true;
                    };
                    $scope.isNullOrEmpty = function (string) {
                        return string === null || angular.isUndefined(string) || string === '';
                    };
                    var isTentativeAuthorizedContactEmpty = function () {
                        return $scope.isNullOrEmpty($scope.tentativeAuthorizedContact.firstName)
                            && $scope.isNullOrEmpty($scope.tentativeAuthorizedContact.lastName)
                            && $scope.isNullOrEmpty($scope.tentativeAuthorizedContact.accessCode);
                    };
                    $scope.contactsSubmitted = function () {
                        if (!isTentativeAuthorizedContactEmpty()) {
                            $scope.addAuthorizedContact();
                        }
                    };
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("contactInfoEntry", ['validationService', '$timeout',
        function (validationService, $timeout) {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/contactEntry/contactInfoEntry.html",
                scope: {
                    contactInfo: '=',
                    form: '='
                },
                link: function ($scope, elem, attrs) {
                    $scope.showConfirm = "showConfirm" in attrs;
                    if ($scope.showConfirm) {
                        $timeout(function () {
                            $scope.validations = validationService($scope.form);
                        }, 50);
                        $scope.confirmModels = {};
                        var unwatch = $scope.$watch('contactInfo', function () {
                            if ($scope.contactInfo && $scope.contactInfo.emailAddress) {
                                $scope.confirmModels.confirmEmailAddress = $scope.contactInfo.emailAddress;
                                $scope.confirmModels.confirmAltEmailAddress = $scope.contactInfo.altEmailAddress;
                                unwatch();
                            }
                        });
                    }
                }
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var EmailInputDirective = /** @class */ (function () {
            function EmailInputDirective(validationService, conditionalStylesService) {
                var _this = this;
                this.validationService = validationService;
                this.conditionalStylesService = conditionalStylesService;
                this.transclude = true;
                this.restrict = "E";
                this.templateUrl = "/app/directives/contactEntry/emailInputTemplate.html";
                this.scope = {
                    emailAddr: "=model",
                    form: "=",
                    emailid: "@",
                    required: "=",
                    notEqual: "="
                };
                this.link = function ($scope, elem, attrs) {
                    $scope.validations = _this.validationService($scope.form);
                    $scope.formWidthClass = _this.conditionalStylesService.formWidth("noFixedWidth" in attrs);
                };
            }
            EmailInputDirective.factory = function () {
                var directive = function (validationService, conditionalStylesService) { return new EmailInputDirective(validationService, conditionalStylesService); };
                directive.$inject = ["validationService",
                    "conditionalStylesService"];
                return directive;
            };
            return EmailInputDirective;
        }());
        Directive.EmailInputDirective = EmailInputDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("setEmailAddress", HCTRA.Directive.EmailInputDirective.factory());
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("phoneNumberAndExt", ['validationService', '$filter',
        function (validationService, $filter) {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/contactEntry/phoneNumberAndExt.html",
                scope: {
                    altPhoneAndExt: '=',
                    form: '='
                },
                link: function ($scope) {
                    $scope.validations = validationService($scope.form);
                    $scope.onBlurOrChange = function () {
                        if ($scope.altPhoneAndExt.altPhoneNumber)
                            $scope.altPhoneAndExt.altPhoneNumber = $filter('usPhone')($scope.altPhoneAndExt.altPhoneNumber);
                    };
                    var unwatch = $scope.$watch('altPhoneAndExt', function () {
                        if ($scope.altPhoneAndExt && $scope.altPhoneAndExt.altPhoneNumber) {
                            $scope.altPhoneAndExt.altPhoneNumber = $filter('usPhone')($scope.altPhoneAndExt.altPhoneNumber);
                            unwatch();
                        }
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("primaryPhone", ['validationService', '$filter',
        function (validationService, $filter) {
            return {
                restrict: "E",
                transclude: true,
                templateUrl: "/app/directives/contactEntry/primaryPhone.html",
                scope: {
                    primaryPhone: '=',
                    form: '=',
                    full: '=?'
                },
                link: function ($scope) {
                    $scope.validations = validationService($scope.form);
                    $scope.onBlurOrChange = function () {
                        if ($scope.primaryPhone)
                            $scope.primaryPhone = $filter('usPhone')($scope.primaryPhone);
                    };
                    var unwatch = $scope.$watch('primaryPhone', function () {
                        if ($scope.primaryPhone) {
                            $scope.primaryPhone = $filter('usPhone')($scope.primaryPhone);
                            unwatch();
                        }
                    });
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("addressDisplay", [
        function () {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/contactInfo/addressDisplayTemplate.html",
                scope: {
                    address: "=",
                    international: "=",
                    displayCountry: "=",
                    onAddressEdit: "&",
                    showEditConditional: "=",
                    hasRefundFields: "=?"
                },
                link: function ($scope, elem, attrs) {
                    $scope.showEdit = ('showEdit' in attrs) || $scope.showEditConditional;
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("nameAndAddressDisplay", [
        function () {
            return {
                restrict: "E",
                templateUrl: "/app/directives/contactInfo/nameAndAddressDisplayTemplate.html",
                scope: {
                    address: "=",
                    international: "=",
                    displayCountry: "=",
                    name: '=',
                    onAddressEdit: "&"
                }
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var VerboseLoginInfoDirective = /** @class */ (function () {
            function VerboseLoginInfoDirective() {
                this.transclude = true;
                this.restrict = "E";
                this.templateUrl = "/app/directives/contactInfo/verboseLoginInfo.html";
                this.scope = {
                    account: "="
                };
                this.controller = VerboseLoginInfoDirectiveController;
            }
            VerboseLoginInfoDirective.factory = function () {
                var directive = function () { return new VerboseLoginInfoDirective(); };
                directive.$inject = [];
                return directive;
            };
            return VerboseLoginInfoDirective;
        }());
        Directive.VerboseLoginInfoDirective = VerboseLoginInfoDirective;
        var VerboseLoginInfoDirectiveController = /** @class */ (function () {
            function VerboseLoginInfoDirectiveController($scope, genericRepo) {
                this.$scope = $scope;
                this.genericRepo = genericRepo;
                var unwatch = $scope.$watch("account", function (account) {
                    if (account && account.firstName) {
                        //reconcile naming differences
                        if (account.loginId)
                            $scope.account.userName = account.loginId;
                        genericRepo.dataFactory.getSecurityQuestions().then(function (response) {
                            var questions = response.securityQuestions;
                            questions.forEach(function (elem) {
                                if (elem.securityQuestionID && (elem.securityQuestionID == $scope.account.securityQuestionID)) {
                                    $scope.securityQuestion = elem.securityQuestion;
                                }
                            });
                        });
                        unwatch();
                    }
                });
            }
            VerboseLoginInfoDirectiveController.$inject = ["$scope", "genericRepo"];
            return VerboseLoginInfoDirectiveController;
        }());
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("verboseLoginInfo", HCTRA.Directive.VerboseLoginInfoDirective.factory());
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("convertToNumber", function () {
        return {
            restrict: "A",
            require: 'ngModel',
            link: function (scope, element, attrs, ngModel) {
                ngModel.$parsers.push(function (val) {
                    return val && !isNaN(parseInt(val)) ? parseInt(val) : "";
                });
                ngModel.$formatters.push(function (val) {
                    return (val || val === 0) && !isNaN(parseInt(val)) ? "" + val : "";
                });
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("currentPassword", ['validationService',
        function (validationService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/currentPasswordTemplate.html",
                scope: {
                    password: '=',
                    confirmPassword: '=',
                    currentPassword: '=',
                    showCurrentPassword: '=',
                    parentForm: '=',
                    tabOrderingIndex: '='
                },
                link: function ($scope) {
                    $scope.validation = validationService($scope.parentForm);
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("currentPasswordIsolated", ['validationService',
        function (validationService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/currentPasswordIsolatedTemplate.html",
                scope: {
                    password: '=',
                    confirmPassword: '=',
                    currentPassword: '=',
                    showCurrentPassword: '=',
                    parentForm: '=',
                    tabOrderingIndex: '='
                },
                link: function ($scope) {
                    $scope.validation = validationService($scope.parentForm);
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("hctraDateRangeMax", ['environmentConfig', 'momentService',
        function (environmentConfig, momentService) {
            return {
                require: "ngModel",
                link: function (scope, element, attributes, ngModel) {
                    var dateToModelName = attributes.hctraDateRangeMax;
                    scope.$watch(dateToModelName, function () {
                        ngModel.$validate();
                    });
                    ngModel.$validators.hctraDateRangeMax = function (modelValue) {
                        var dateToFromModel = scope.$eval(dateToModelName);
                        //return valid for invalid dates to avoid calling toISOString() on a string.
                        //Valid Date validator will catch it later on so it's ok to set to true.
                        if (!dateToFromModel || !angular.isDate(dateToFromModel))
                            return true;
                        var dateToISOString = dateToFromModel.toISOString().replace(/[\\"]/g, "");
                        var dateFrom = momentService.moment(modelValue);
                        var dateTo = momentService.moment(dateToISOString);
                        var diffDays = dateTo.diff(dateFrom, 'days');
                        return diffDays <= environmentConfig.accountActivityMaxDaysInSearch;
                    };
                }
            };
        }]);
})();
(function () {
    'use strict';
    describe('directive: desktop-ui', function () {
        beforeEach(angular.mock.module('HCTRATemplates'));
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope;
        var element;
        var directive;
        var $window;
        var $timeout;
        var $transitions;
        var $transitionsCapturedFunc;
        beforeEach(angular.mock.module(function () {
            $window = jasmine.createSpy('$window');
            $timeout = jasmine.createSpy('$timeout').and.callFake(function (fn, delay) { return setTimeout(fn, delay); });
            $timeout.cancel = jasmine.createSpy('cancel').and.callFake(function (timeoutPromise) { clearTimeout(timeoutPromise); });
            $transitions = jasmine.createSpyObj('$transitions', ['onSuccess']);
            $transitions.onSuccess.and.callFake(function (obj, capturedFunc) {
                $transitionsCapturedFunc = capturedFunc;
            });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            $templateCache.put('/app/directives/desktopUi/DesktopUiTemplate.html', $templateCache.get('app/directives/desktopUi/DesktopUiTemplate.html'));
            element = angular.element('<div desktop-ui></div>');
            $compile(element)(scope);
            scope.$digest();
            directive = new HCTRA.Directive.DesktopUiDirective(null, $window, $timeout, $transitions);
        }));
        describe('link', function () {
            beforeEach(function () {
                spyOn(directive, 'modifyStateForRefresh');
                spyOn(directive, 'modifySiteForRefresh');
                spyOn(directive, 'resize');
            });
            [
                true,
                null,
                '',
                0,
                {}
            ].forEach(function (definedVal) {
                it('should resize when force full screen is an attribute', function () {
                    var listenerResizeFn;
                    spyOn(angular, 'element').and.returnValue({
                        resize: function (resizeFn) { listenerResizeFn = resizeFn; }
                    });
                    directive.link(scope, element, { forceFullscreen: definedVal });
                    expect(angular.element).toHaveBeenCalledTimes(1);
                    expect(angular.element).toHaveBeenCalledWith($window);
                    expect(directive["resize"]).toHaveBeenCalledTimes(1);
                    listenerResizeFn();
                    expect(directive["resize"]).toHaveBeenCalledTimes(2);
                });
            });
            it('should ignore resize when force full screen is not an attribute', function () {
                spyOn(angular, 'element');
                directive.link(scope, element, { forceFullscreen: undefined });
                expect(angular.element).toHaveBeenCalledTimes(0);
                expect(directive["resize"]).toHaveBeenCalledTimes(0);
            });
            it('should call edge-to-edge page modification function', function () {
                directive.link(scope, element, {});
                $transitionsCapturedFunc({ to: function () { return ({ name: 'fakeState' }); } });
                expect(directive['modifyStateForRefresh']).toHaveBeenCalledTimes(1);
                expect(directive['modifyStateForRefresh']).toHaveBeenCalledWith({ name: 'fakeState' });
                expect(directive['modifySiteForRefresh']).toHaveBeenCalledTimes(1);
            });
        });
        describe('resize', function () {
            it('should try to resize the given element to the window size', function () {
                var fakeHeightSpyReturn = {};
                var fakeWidthSpyReturn = {};
                var windowHeightSpy = jasmine.createSpy('height').and.returnValue(fakeHeightSpyReturn);
                var windowWidthSpy = jasmine.createSpy('width').and.returnValue(fakeWidthSpyReturn);
                spyOn(angular, 'element').and.returnValue({
                    height: windowHeightSpy,
                    width: windowWidthSpy
                });
                var elementParamSpy = jasmine.createSpyObj('element', ['outerHeight', 'outerWidth']);
                directive['resize'](elementParamSpy);
                expect(angular.element).toHaveBeenCalledTimes(1);
                expect(angular.element).toHaveBeenCalledWith($window);
                expect(elementParamSpy.outerHeight).toHaveBeenCalledTimes(1);
                expect(elementParamSpy.outerHeight).toHaveBeenCalledWith(fakeHeightSpyReturn);
                expect(windowHeightSpy).toHaveBeenCalledTimes(1);
                expect(elementParamSpy.outerWidth).toHaveBeenCalledTimes(1);
                expect(elementParamSpy.outerWidth).toHaveBeenCalledWith(fakeWidthSpyReturn);
                expect(windowWidthSpy).toHaveBeenCalledTimes(1);
            });
        });
        describe('modifySiteForRefresh', function () {
            it('should modify some common top level DOM elements if edge-to-edge is enabled', function () {
                var angularElementSpy = jasmine.createSpyObj('angularElementSpy', ['css', 'removeClass', 'on']);
                spyOn(angular, 'element').and.returnValue(angularElementSpy);
                $window.outerWidth = 767;
                directive['modifySiteForRefresh']();
                expect(angularElementSpy.css).toHaveBeenCalledWith('margin-top', '54px');
            });
            it('should add listeners for mobile header if edge-to-edge is enabled', function () {
                var angularElementSpy = jasmine.createSpyObj('angularElementSpy', ['css', 'removeClass', 'on']);
                spyOn(angular, 'element').and.returnValue(angularElementSpy);
                $window.pageYOffset = 1;
                directive['modifySiteForRefresh']();
                expect(directive['prevScrollPos']).toEqual(1);
                expect(angularElementSpy.on).toHaveBeenCalledWith('scroll', jasmine.any(Function));
                expect(angularElementSpy.on).toHaveBeenCalledWith('resize', jasmine.any(Function));
            });
        });
        describe('modifyStateForRefresh', function () {
            it('should modify every state dependent on hybrid flag: true', function () {
                var spies = {};
                spyOn(angular, 'element').and.callFake(function (selector) {
                    spies[selector] = jasmine.createSpyObj('angularElementSpy', ['css', 'addClass', 'attr']);
                    if (selector === '.storefrontSmallButton.exit-button') {
                        spies[selector].attr.and.returnValue('fakeStyles');
                    }
                    return spies[selector];
                });
                directive['modifyStateForRefresh']({ settings: { isHybrid: true } });
                expect(spies['body'].css).toHaveBeenCalledTimes(1);
                expect(spies['#desktopUiViewRoot'].css).toHaveBeenCalledTimes(2);
                expect(spies['body'].css).toHaveBeenCalledWith('margin-bottom', '0px');
                expect(spies['#desktopUiViewRoot'].css).toHaveBeenCalledWith('margin-top', '0px');
                expect(spies['#desktopUiViewRoot'].css).toHaveBeenCalledWith('background-color', '#ffffff');
                expect(spies['.storefrontFullSite'].css).toHaveBeenCalledWith('padding-bottom', '0px');
                expect(spies['.storefrontFullSite'].css).toHaveBeenCalledWith('background-color', '');
                expect(spies['.storefrontSmallButton.exit-button'].css).toHaveBeenCalledWith('border', 'none');
                expect(spies['.storefrontSmallButton.exit-button'].css).toHaveBeenCalledWith('float', 'unset');
                expect(spies['.storefrontSmallButton.exit-button'].css).toHaveBeenCalledWith('margin-left', 'unset');
                expect(spies['.storefrontSmallButton.exit-button'].attr).toHaveBeenCalledWith('style');
                expect(spies['.storefrontSmallButton.exit-button'].attr).toHaveBeenCalledWith('style', 'fakeStyles;background-color: #611eb8 !important;');
            });
            it('should modify every state dependent on hybrid flag: true', function () {
                var angularElementSpy = jasmine.createSpyObj('angularElementSpy', ['css', 'addClass', 'attr']);
                spyOn(angular, 'element').and.returnValue(angularElementSpy);
                directive['modifyStateForRefresh']({ settings: { isHybrid: true } });
                expect(angular.element).toHaveBeenCalledWith('body');
                expect(angular.element).toHaveBeenCalledWith('#top-menu-container');
                expect(angular.element).toHaveBeenCalledWith('#footer-content-container > div');
                expect(angular.element).toHaveBeenCalledWith('#desktopUiViewRoot');
                expect(angular.element).toHaveBeenCalledWith('[device-type=\'desktop\'] .footerCopyright div p');
                expect(angularElementSpy.css).toHaveBeenCalledWith('background-color', '#ffffff');
                expect(angularElementSpy.css).toHaveBeenCalledWith('padding-bottom', '4px');
                expect(angularElementSpy.css).toHaveBeenCalledWith('color', '#ffffff');
                expect(angularElementSpy.addClass).toHaveBeenCalledWith('refresh-hybrid-background');
                expect(angularElementSpy.addClass).toHaveBeenCalledWith('refresh-hybrid-container');
                expect(angularElementSpy.addClass).toHaveBeenCalledWith('refresh-hybrid-container');
            });
            [
                { settings: { isHybrid: false } },
                { settings: {} },
                {}
            ].forEach(function (invalidSettings) {
                it('should modify every state dependent on hybrid flag: false', function () {
                    var angularElementSpy = jasmine.createSpyObj('angularElementSpy', ['css', 'removeClass', 'attr']);
                    spyOn(angular, 'element').and.returnValue(angularElementSpy);
                    directive['modifyStateForRefresh'](invalidSettings);
                    expect(angular.element).toHaveBeenCalledWith('body');
                    expect(angular.element).toHaveBeenCalledWith('#top-menu-container');
                    expect(angular.element).toHaveBeenCalledWith('#footer-content-container > div');
                    expect(angular.element).toHaveBeenCalledWith('#desktopUiViewRoot');
                    expect(angular.element).toHaveBeenCalledWith('[device-type=\'desktop\'] .footerCopyright div p');
                    expect(angularElementSpy.css).toHaveBeenCalledWith('background-color', '');
                    expect(angularElementSpy.css).toHaveBeenCalledWith('padding-bottom', '');
                    expect(angularElementSpy.css).toHaveBeenCalledWith('color', '');
                    expect(angularElementSpy.removeClass).toHaveBeenCalledWith('refresh-hybrid-background');
                    expect(angularElementSpy.removeClass).toHaveBeenCalledWith('refresh-hybrid-container');
                    expect(angularElementSpy.removeClass).toHaveBeenCalledWith('refresh-hybrid-container');
                });
            });
        });
        describe('mobileTopHeaderOnScroll', function () {
            it('should update previous scroll position', function () {
                var elementSpy = jasmine.createSpyObj('angularElementSpy', ['hasClass', 'removeClass', 'addClass']);
                spyOn(angular, 'element').and.returnValue(elementSpy);
                $window.pageYOffset = 0;
                directive['prevScrollPos'] = 1;
                directive['mobileTopHeaderOnScroll']();
                expect(angular.element).toHaveBeenCalledTimes(1);
                expect(directive['prevScrollPos']).toEqual(0);
            });
            it('should stick mobile header to the top AT TOP', function () {
                var elementSpy = jasmine.createSpyObj('angularElementSpy', ['hasClass', 'removeClass', 'addClass']);
                spyOn(angular, 'element').and.returnValue(elementSpy);
                $window.pageYOffset = -10;
                directive['prevScrollPos'] = 2;
                directive['mobileTopHeaderOnScroll']();
                expect(angular.element).toHaveBeenCalledWith('#hctra-header.header');
                expect(elementSpy.removeClass).toHaveBeenCalledWith('header--hidden');
            });
            [
                true,
                false
            ].forEach(function (elementHasClass) {
                it('should stick mobile header to the top SCROLLING UP', function () {
                    var elementSpy = jasmine.createSpyObj('angularElementSpy', ['hasClass', 'removeClass', 'addClass']);
                    elementSpy.hasClass.and.returnValue(elementHasClass);
                    spyOn(angular, 'element').and.returnValue(elementSpy);
                    $window.pageYOffset = 10;
                    directive['prevScrollPos'] = 15;
                    directive['mobileTopHeaderOnScroll']();
                    expect(angular.element).toHaveBeenCalledWith('#hctra-header.header');
                    if (elementHasClass) {
                        expect(elementSpy.removeClass).toHaveBeenCalledWith('header--hidden');
                    }
                    else {
                        expect(elementSpy.removeClass).not.toHaveBeenCalled();
                    }
                });
            });
            it('should hide mobile header above the top SCROLLING DOWN', function () {
                var elementSpy = jasmine.createSpyObj('angularElementSpy', ['hasClass', 'removeClass', 'addClass']);
                spyOn(angular, 'element').and.returnValue(elementSpy);
                $window.pageYOffset = 15;
                directive['prevScrollPos'] = 10;
                directive['mobileTopHeaderOnScroll']();
                expect(angular.element).toHaveBeenCalledWith('#hctra-header.header');
                expect(elementSpy.addClass).toHaveBeenCalledWith('header--hidden');
            });
        });
        describe('topHeaderOnResize', function () {
            it('should ensure mobile header shows if in mobile view', function () {
                var elementSpy = jasmine.createSpyObj('angularElementSpy', ['css', 'removeClass']);
                spyOn(angular, 'element').and.returnValue(elementSpy);
                $window.outerWidth = 1;
                directive['topHeaderOnResize']();
                expect(angular.element).toHaveBeenCalledWith('#hctra-header');
                expect(elementSpy.removeClass).toHaveBeenCalledWith('header--hidden');
                expect(angular.element).toHaveBeenCalledWith('#special-redesign');
                expect(elementSpy.css).toHaveBeenCalledWith('margin-top', '54px');
            });
            [
                768,
                4000
            ].forEach(function (windowWidth) {
                it('should ensure no extra top margin on the container in desktop view', function () {
                    var cssSpy = jasmine.createSpyObj('angularElementSpy', ['css', 'removeClass']);
                    spyOn(angular, 'element').and.returnValue(cssSpy);
                    $window.outerWidth = windowWidth;
                    directive['topHeaderOnResize']();
                    expect(angular.element).toHaveBeenCalledTimes(1);
                    expect(angular.element).toHaveBeenCalledWith('#special-redesign');
                    expect(cssSpy.css).toHaveBeenCalledTimes(1);
                    expect(cssSpy.css).toHaveBeenCalledWith('margin-top', '0');
                });
            });
        });
        // describe('throttle', () => {
        //     it('should allow for function throttling', () => {
        //         const spyObj = jasmine.createSpyObj('spyObj', ['foobar']);
        //         const throttleFunc = directive['throttle'](spyObj.foobar, 200);
        //         throttleFunc();
        //         expect(spyObj.foobar).toHaveBeenCalledTimes(1);
        //         return new Promise((resolve) => setTimeout(resolve, 100)).then(() => {
        //             throttleFunc();
        //             expect(spyObj.foobar).toHaveBeenCalledTimes(1);
        //             return new Promise((resolve) => setTimeout(resolve, 200)).then(() => {
        //                 // The foobar function would've been called once via the set delay already at this point
        //                 throttleFunc();
        //                 expect(spyObj.foobar).toHaveBeenCalledTimes(3);
        //             });
        //         });
        //     });
        // });
    });
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var DesktopUiDirective = /** @class */ (function () {
            function DesktopUiDirective(angularEnvironment, $window, $timeout, $transitions) {
                var _this = this;
                this.angularEnvironment = angularEnvironment;
                this.$window = $window;
                this.$timeout = $timeout;
                this.$transitions = $transitions;
                this.legacyMenuBreakpoint = 768;
                this.legacyMobileHeaderHeight = 54;
                this.eventThrottleDelay = 250;
                this.restrict = 'AE';
                this.scope = false;
                this.link = function (scope, element, attrs) {
                    var forceFullscreen = angular.isDefined(attrs.forceFullscreen);
                    if (forceFullscreen) {
                        angular.element(_this.$window).resize(function () { return _this.resize(element); });
                        _this.resize(element);
                    }
                    var unregisterStateChangeSuccess = _this.$transitions.onSuccess({}, function (transition) {
                        var currentState = transition.to();
                        _this.modifyStateForRefresh(currentState);
                    });
                    _this.modifySiteForRefresh();
                    scope.$on('$destroy', function () {
                        unregisterStateChangeSuccess();
                        angular.element(_this.$window).off('scroll', _this.mobileTopHeaderOnScroll);
                        angular.element(_this.$window).off('resize', _this.topHeaderOnResize);
                    });
                };
                this.modifySiteForRefresh = function () {
                    // These elements exist in this directive's template so they will already be on the DOM
                    var mainContainerElement = angular.element('#special-redesign');
                    if (_this.$window.outerWidth < _this.legacyMenuBreakpoint) {
                        mainContainerElement.css('margin-top', _this.legacyMobileHeaderHeight + "px");
                    }
                    _this.prevScrollPos = _this.$window.pageYOffset;
                    angular.element(_this.$window).on('scroll', _this.throttle(_this.mobileTopHeaderOnScroll, _this.eventThrottleDelay));
                    angular.element(_this.$window).on('resize', _this.throttle(_this.topHeaderOnResize, _this.eventThrottleDelay));
                };
                this.modifyStateForRefresh = function (state) {
                    // Refresh Hybrid view
                    var bodyElement = angular.element('body');
                    var topMenuContainerElement = angular.element('#top-menu-container');
                    var footerContentContainerElement = angular.element('#footer-content-container > div');
                    var desktopUiViewRootElement = angular.element('#desktopUiViewRoot');
                    var footerCopyrightElement = angular.element('[device-type=\'desktop\'] .footerCopyright div p');
                    if (state.settings && state.settings.isHybrid) {
                        bodyElement.addClass('refresh-hybrid-background');
                        topMenuContainerElement.css('background-color', '#ffffff');
                        footerContentContainerElement.addClass('refresh-hybrid-container');
                        footerContentContainerElement.css('padding-bottom', '4px');
                        desktopUiViewRootElement.addClass('refresh-hybrid-container');
                        footerCopyrightElement.css('color', '#ffffff');
                    }
                    else {
                        bodyElement.removeClass('refresh-hybrid-background');
                        topMenuContainerElement.css('background-color', '');
                        footerContentContainerElement.removeClass('refresh-hybrid-container');
                        footerContentContainerElement.css('padding-bottom', '');
                        desktopUiViewRootElement.removeClass('refresh-hybrid-container');
                        footerCopyrightElement.css('color', '');
                    }
                    bodyElement.css('margin-bottom', '0px');
                    desktopUiViewRootElement.css('margin-top', '0px');
                    desktopUiViewRootElement.css('background-color', '#ffffff');
                    var storefrontFullSite = angular.element('.storefrontFullSite');
                    if (storefrontFullSite) {
                        storefrontFullSite.css('padding-bottom', '0px');
                        storefrontFullSite.css('background-color', state.settings && state.settings.isHybrid ? '' : '#ffffff');
                    }
                    var exitButton = angular.element('.storefrontSmallButton.exit-button');
                    if (exitButton) {
                        exitButton.css('border', 'none');
                        exitButton.css('float', 'unset');
                        exitButton.css('margin-left', 'unset');
                        //@purple-heart-purple
                        exitButton.attr('style', exitButton.attr('style') + ';background-color: #611eb8 !important;');
                    }
                };
                this.mobileTopHeaderOnScroll = function () {
                    var mobileHeaderElement = angular.element('#hctra-header.header');
                    var hiddenClassName = 'header--hidden';
                    var currentScrollPos = _this.$window.pageYOffset;
                    var scrollDiff = _this.prevScrollPos - currentScrollPos;
                    if (currentScrollPos <= 0) {
                        // scrolled to the very top; element sticks to the top
                        mobileHeaderElement.removeClass(hiddenClassName);
                    }
                    else if (scrollDiff > 0 && mobileHeaderElement.hasClass(hiddenClassName)) {
                        // scrolled up; element slides in
                        mobileHeaderElement.removeClass(hiddenClassName);
                    }
                    else if (scrollDiff < 0) {
                        // scrolled down; element slides out
                        mobileHeaderElement.addClass(hiddenClassName);
                    }
                    _this.prevScrollPos = currentScrollPos;
                };
                this.topHeaderOnResize = function () {
                    var currentViewWidth = _this.$window.outerWidth;
                    // if we shrink the window, header must be displayed
                    if (currentViewWidth < _this.legacyMenuBreakpoint) {
                        angular.element('#hctra-header').removeClass('header--hidden');
                        angular.element('#special-redesign').css('margin-top', _this.legacyMobileHeaderHeight + "px");
                    }
                    // if we grow the window, we want to drop any margin-top that might've been added during scrolling in mobile window
                    if (currentViewWidth >= _this.legacyMenuBreakpoint) {
                        angular.element('#special-redesign').css('margin-top', '0');
                    }
                };
                this.resize = function (element) {
                    var win = angular.element(_this.$window);
                    element.outerHeight(win.height());
                    element.outerWidth(win.width());
                };
                // TODO: Replace with lodash throttle once this directive is migrated to Angular
                this.throttle = function (fn, delay) {
                    var last;
                    var timerPromise;
                    return function () {
                        var now = +new Date();
                        if (last && now < last + delay) {
                            _this.$timeout.cancel(timerPromise);
                            timerPromise = _this.$timeout(function () {
                                last = now;
                                fn();
                            }, delay);
                        }
                        else {
                            last = now;
                            fn();
                        }
                    };
                };
                this.templateUrl = "/app/directives/desktopUi/DesktopUiTemplateAlpha.html";
            }
            DesktopUiDirective.factory = function () {
                var directive = function (angularEnvironment, $window, $timeout, $transitions) {
                    return new DesktopUiDirective(angularEnvironment, $window, $timeout, $transitions);
                };
                directive.$inject = ['angularEnvironment', '$window', '$timeout', '$transitions'];
                return directive;
            };
            return DesktopUiDirective;
        }());
        Directive.DesktopUiDirective = DesktopUiDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('desktopUi', HCTRA.Directive.DesktopUiDirective.factory());
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("desktopViewMessage", ['toggleFullWebsiteService',
        function (toggleFullWebsiteService) {
            return {
                restrict: 'E',
                templateUrl: "/app/directives/desktopViewMessageTemplate.html",
                link: function (scope) {
                    scope.onMobileClick = toggleFullWebsiteService.onMobileClick;
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("donutChart", ['operatingSystemSnifferService',
        function (operatingSystemSnifferService) {
            var width, //width of box the chart is contained in.
            height, //height for radius
            svgHeight, //height of box the chart is contained in.
            translateHeight, //height used to position chart in box
            radius, innerRadius, outerRadius;
            // Label lines and label positioning assistant
            var pieChartRotation = 180, //Rotate chart so 0 is at the bottom
            pastOuterRadius = 10; //How far the line extends from the chart to the label
            // Graph Label Positoins
            var LABEL_11_TO_1 = 1, // Label is at the 11, 12 or 1 o'clock position
            LABEL_10_OR_2 = 2, // Label is in the 10 or 2 o'clock position
            LABEL_3_TO_9 = 3; // All labels are in the 3,4,5,6,7,8, or 9 o'clock 
            // Text Colors
            var innerArchBorderColor = "gray", outerArchBorderColor = "gray", currentLabel = "current", monthlyLabel = "monthly", minimum = "minimum", rebill = "rebill", bufferLabel = "buffer", startingpoint = "startingpoint", pointerLineColor = "#989898", currentBalanceRed = 0, minimumBalanceYellow = 1, currentBalanceGreen = 2, rebillWhite = 3, avgSpendGrey = 4;
            // Text Sizes
            var defaultAmountTextLength = 6, defaultAmountTextSize = 20, defaultAmountTextSizeForDesktop = 30, defaultAmountTextLengthForDesktop = 7, defaultLabelTextSize = 10, defaultLabelTextSizeForDesktop = 15, defaultCircularLabelSize = "12", defaultCircularLabelSizeForDesktop = "15";
            return {
                restrict: "E",
                replace: false,
                template: "<div class='chartBilling'></div>",
                scope: {
                    data: '='
                },
                link: function ($scope) {
                    $scope.isMobile = !operatingSystemSnifferService.isDesktopOs();
                    var setGraphParameters = function (data, isMobile) {
                        var amountObj = getAmountValues(data);
                        var graphLabelPosition = getGraphLabelPosition(amountObj.totalAmount, amountObj.minimumTotal, amountObj.rebillTotal);
                        if (isMobile) {
                            setMobileParameters(graphLabelPosition);
                        }
                        else {
                            setDesktopParameters(graphLabelPosition);
                        }
                    };
                    var setMobileParameters = function (graphLabelPosition) {
                        width = 295; //width of box the chart is contained in.
                        height = 375; //height for radius
                        radius = Math.min(width, height) / 2;
                        innerRadius = radius - 95;
                        outerRadius = radius - 65;
                        if (graphLabelPosition === LABEL_11_TO_1) {
                            svgHeight = 248;
                            translateHeight = 235;
                        }
                        else if (graphLabelPosition === LABEL_10_OR_2) {
                            svgHeight = 232;
                            translateHeight = 199;
                        }
                        else {
                            svgHeight = 275;
                            translateHeight = 280;
                        }
                    };
                    var setDesktopParameters = function (graphLabelPosition) {
                        width = 370; //width of box the chart is contained in.
                        height = 375; //height for radius
                        radius = Math.min(width, height) / 2;
                        innerRadius = radius - 110;
                        outerRadius = radius - 65;
                        if (graphLabelPosition === LABEL_11_TO_1) {
                            svgHeight = 375;
                            translateHeight = 390; // svgHeight + 5
                        }
                        else if (graphLabelPosition === LABEL_10_OR_2) {
                            svgHeight = 348;
                            translateHeight = 335; // svgHeight - 13
                        }
                        else {
                            svgHeight = 332;
                            translateHeight = 299; // svgHeight - 33
                        }
                    };
                    var getAmountValues = function (data) {
                        var amountObj = {};
                        for (var index = 0; index < data.length; index++) {
                            if (data[index].amountType == rebill) {
                                amountObj.rebillTotal = data[index].amount;
                            }
                            if (data[index].amountType == minimum) {
                                amountObj.minimumTotal = data[index].amount;
                            }
                        }
                        amountObj.totalAmount = data[data.length - 2].amount;
                        return amountObj;
                    };
                    var getGraphLabelPosition = function (totalAmount, minimumTotal, rebillTotal) {
                        if ((minimumTotal >= (totalAmount * .45) && minimumTotal <= (totalAmount * .65)) ||
                            (rebillTotal >= (totalAmount * .45) && rebillTotal <= (totalAmount * .65))) {
                            return LABEL_11_TO_1;
                        }
                        else if ((rebillTotal > (totalAmount * 0.4) && rebillTotal < (totalAmount * 0.7)) ||
                            (minimumTotal > (totalAmount * 0.4) && minimumTotal < (totalAmount * 0.7))) {
                            return LABEL_10_OR_2;
                        }
                        else {
                            return LABEL_3_TO_9;
                        }
                    };
                    var runChart = function (data, centerLabel, noLabels, currentBelowMinumum) {
                        setGraphParameters(data, $scope.isMobile);
                        var innerArcBorder = d3.svg.arc()
                            .innerRadius(innerRadius - 1)
                            .outerRadius(innerRadius);
                        var outerArcBorder = d3.svg.arc()
                            .innerRadius(outerRadius)
                            .outerRadius(outerRadius + 1);
                        var arc = d3.svg.arc()
                            .outerRadius(outerRadius)
                            .innerRadius(innerRadius);
                        var pie = d3.layout.pie()
                            .sort(null)
                            .value(function (d) { return d.calculatedAmount; });
                        var svg = d3.select(".chartBilling").append("svg")
                            .attr("width", width)
                            .attr("height", svgHeight)
                            .append("g")
                            .attr("transform", "translate(" + width / 2 + "," + translateHeight / 2 + ")");
                        data2(data, centerLabel, noLabels);
                        function data2(data, centerLabel, noLabels) {
                            var piedata = pie(data);
                            var g = svg.selectAll(".arc")
                                .data(piedata)
                                .enter()
                                .append("g")
                                .attr("class", "arc");
                            // ToDo: If client decides to change chart outline, here is where it would change
                            g.append("path")
                                .attr("fill", innerArchBorderColor)
                                .attr("d", innerArcBorder);
                            g.append("path")
                                .attr("fill", outerArchBorderColor)
                                .attr("d", outerArcBorder);
                            g.append("path")
                                .attr("d", arc)
                                .attr("transform", "rotate(" + pieChartRotation + ")")
                                .style("fill", function (d) {
                                //console.log(d.data.color);
                                switch (d.data.color) {
                                    case (currentBalanceRed): return "#c13e3e";
                                    case (minimumBalanceYellow): return "#faf4a3";
                                    case (currentBalanceGreen): return "#92cb7a";
                                    case (rebillWhite): return "#ffffff";
                                    case (avgSpendGrey): return "#e5e5e5";
                                    default: //console.log("Should not have reached here."); return "#ff69b4";
                                }
                            });
                            //console.log(!noLabels);
                            if (!noLabels) {
                                g.append("text")
                                    .attr("transform", function (d) {
                                    var a = (d.endAngle + 3.14159265) - Math.PI / 2;
                                    //console.log(a);
                                    var v = pointdot(a, outerRadius + pastOuterRadius);
                                    var degrees = d.endAngle * (180 / Math.PI) + pieChartRotation;
                                    var rotation = 0;
                                    //var startpoint = 0;
                                    if (degrees > 360) {
                                        rotation = degrees - 90;
                                    }
                                    else if (degrees >= 180) {
                                        rotation = degrees + 90;
                                    }
                                    else {
                                        rotation = degrees - 90;
                                    }
                                    //if (degrees > 180) {
                                    //    startpoint = rotation;
                                    //} else {
                                    //    startpoint = -rotation;
                                    //}
                                    var g = "translate(" + v.x + "," + v.y + ") , rotate(" + rotation + ")";
                                    //console.log(g);
                                    return g;
                                })
                                    .style("text-anchor", function (d) {
                                    var a = d.endAngle * (180 / Math.PI) + pieChartRotation;
                                    var l;
                                    if (a > 360) {
                                        l = "start";
                                    }
                                    else if (a >= 180) {
                                        l = "end";
                                    }
                                    else {
                                        l = "start";
                                    }
                                    return l;
                                })
                                    .text(function (d) {
                                    return d.data.label;
                                });
                                g.selectAll("text").attr("fill", "#666666");
                                g.selectAll("text").style("fill", "#666666");
                                g.selectAll("text").style("font-family", "'Avenir LT Std 45 Book Regular'");
                                if ($scope.isMobile) {
                                    g.selectAll("text").style("font-size", defaultCircularLabelSize + "px");
                                }
                                else {
                                    g.selectAll("text").style("font-size", defaultCircularLabelSizeForDesktop + "px");
                                }
                                var pointers = svg.append("defs")
                                    .append("marker")
                                    .attr("id", "circ")
                                    .attr("markerWidth", 6)
                                    .attr("markerHeight", 6)
                                    .attr("refX", 3)
                                    .attr("refY", 3)
                                    .append("circle")
                                    .attr("cx", 3)
                                    .attr("cy", 3)
                                    .attr("r", 3);
                                pointers = g.selectAll("path.pointer")
                                    .data(piedata);
                                //"stroke-dasharray"
                                pointers
                                    .enter()
                                    .append("path")
                                    .attr("class", "pointer")
                                    .style("stroke-dasharray", function (d) {
                                    if (d.data.amountType == startingpoint) {
                                        // making starting $0.00 a solid line
                                        return ("100, 100");
                                    }
                                    else {
                                        // making all other labels dashed
                                        return ("8, 8");
                                    }
                                })
                                    .style("fill", "none")
                                    .style("stroke", pointerLineColor)
                                    .attr("marker-end", "url(#circ)")
                                    .attr("d", function (d) {
                                    if (d.data.amountType !== currentLabel && d.data.amountType !== monthlyLabel && d.data.amountType !== bufferLabel) {
                                        var a = (d.endAngle + 3.14159265) - Math.PI / 2;
                                        var outerD = pointdot(a, outerRadius + pastOuterRadius);
                                        var innerD = pointdot(a, innerRadius);
                                        var s = "M" + innerD.x + "," + innerD.y + "L" + innerD.x + "," + innerD.y + " " + outerD.x + "," + outerD.y;
                                        //console.log(s);
                                        return s;
                                    }
                                    else {
                                        return "";
                                    }
                                });
                            }
                            var legend = svg.selectAll('.legend')
                                .data(centerLabel)
                                .enter()
                                .append('g')
                                .attr('class', function (d, i) {
                                //console.log(d);
                                var className;
                                if (i === 0) {
                                    // making center label containing the user's current balance adhere to the rules contained in Site.css
                                    className = currentBelowMinumum ? 'negative legendAmount' : 'legendAmount'; //for css coloring
                                }
                                else {
                                    // making center label containing the "current balance" text adhere to the rules contained in Site.css
                                    className = 'legendLabel'; //for css coloring
                                }
                                return className;
                            })
                                .attr('transform', function (d, i) {
                                //console.log(d);
                                //console.log(i);
                                var height = 20;
                                var offset = height * 1;
                                var vert = i * offset;
                                return 'translate(' + 0 + ',' + vert + ')';
                            })
                                // allowing for dynamic text adjustment for the current balance label
                                .style('font-size', function (d, i) {
                                var standardSize;
                                var standardLength;
                                if ($scope.isMobile) {
                                    standardSize = defaultAmountTextSize;
                                    standardLength = defaultAmountTextLength;
                                }
                                else {
                                    standardSize = defaultAmountTextSizeForDesktop;
                                    standardLength = defaultAmountTextLengthForDesktop;
                                }
                                if (i == 0) {
                                    if (d.length) {
                                        var adjustmentLength = d.length - standardLength;
                                        var adjustmentSize = standardSize;
                                        while (adjustmentLength != 0) {
                                            if (adjustmentLength > 0) {
                                                adjustmentLength--;
                                                adjustmentSize--;
                                            }
                                            else {
                                                adjustmentLength++;
                                                adjustmentSize++;
                                            }
                                        }
                                        return adjustmentSize + 'px';
                                    }
                                    else {
                                        return standardSize + 'px';
                                    }
                                }
                                else {
                                    if ($scope.isMobile) {
                                        return defaultLabelTextSize;
                                    }
                                    else {
                                        return defaultLabelTextSizeForDesktop;
                                    }
                                }
                            });
                            legend.append('text')
                                .attr('text-anchor', 'middle')
                                .text(function (centerLabel) {
                                return centerLabel;
                            });
                        }
                    };
                    var pointdot = function (angle, radius) {
                        var d = {};
                        d.x = radius * Math.cos(angle);
                        d.y = radius * Math.sin(angle);
                        //console.log(d);
                        return d;
                    };
                    $scope.$watch('data', function () {
                        if ($scope.data) {
                            d3.select(".chartBilling").select("svg").remove();
                            runChart($scope.data.chartData, $scope.data.centerLabel, $scope.data.noLabels, $scope.data.currentBelowMinumum);
                        }
                    }, true);
                }
            };
        }]);
}());
/* eslint-disable no-useless-escape */
angular.module('HCTRAModule').directive("emailValid", function () {
    return {
        restrict: 'A',
        require: "ngModel",
        link: function (scope, element, attributes, ngModel) {
            ngModel.$validators.emailValid = function (modelValue) {
                if (!modelValue) {
                    return true;
                }
                modelValue = modelValue.toString();
                var match = modelValue.match(/^(([^<>()[\]\\.,;:\s@&\*\"]+(\.[^<>()[\]\\.,;:\s@&\*\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
                if (!match) {
                    return false;
                }
                else {
                    return true;
                }
            };
        }
    };
});
angular.module('HCTRAModule').directive("enterKey", function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            element.bind('keypress', function (event) {
                if (event.which === 13) {
                    scope.$apply(function () {
                        scope.$eval(attrs.enterKey);
                    });
                    event.preventDefault();
                }
            });
            scope.$on('$destroy', function () {
                element.unbind('keypress');
            });
        }
    };
});
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
        var EntryDropdownConstants = /** @class */ (function () {
            function EntryDropdownConstants() {
            }
            Object.defineProperty(EntryDropdownConstants, "Default", {
                get: function () {
                    return {
                        entryDropdownItemIdPrefix: "#entryDropdownItem",
                        entryDropdownBoxId: "#inputDropdownBox",
                        preSubmitValidationErrorKey: "inputError",
                        postSubmitValidationErrorKey: "submissionError"
                    };
                },
                enumerable: true,
                configurable: true
            });
            return EntryDropdownConstants;
        }());
        Constant.EntryDropdownConstants = EntryDropdownConstants;
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").constant("entryDropdownConstants", HCTRA.Constant.EntryDropdownConstants.Default);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var EzTagRequestedDirective = /** @class */ (function () {
            function EzTagRequestedDirective() {
                this.transclude = true;
                this.restrict = "E";
                this.templateUrl = "/app/directives/ezTagRequestedTemplate.html";
                this.scope = {
                    vehicleList: "=data",
                    onEdit: "&" //TODO: Optional Attribute
                };
                // for logic
                this.controller = EzTagRequestedDirectiveController;
                // for DOM manipulation
                this.link = function ($scope, elem, attrs) {
                    $scope.showEdit = !!attrs.onEdit;
                    $scope.hideClassCode = "hideClassCode" in attrs;
                };
            }
            EzTagRequestedDirective.factory = function () {
                var directive = function () { return new EzTagRequestedDirective(); };
                directive.$inject = [];
                return directive;
            };
            return EzTagRequestedDirective;
        }());
        Directive.EzTagRequestedDirective = EzTagRequestedDirective;
        var EzTagRequestedDirectiveController = /** @class */ (function () {
            function EzTagRequestedDirectiveController($scope, localDataRepo) {
                this.$scope = $scope;
                this.localDataRepo = localDataRepo;
                $scope.classIdToLabel = function (id) {
                    var label;
                    localDataRepo.getClasses().forEach(function (elem) {
                        if (elem && parseInt(elem.value, 10) === parseInt(id, 10)) {
                            label = elem.label;
                            return;
                        }
                    });
                    return label;
                };
                var unwatch = $scope.$watch("vehicleList", function (vehicleList) {
                    if (angular.isArray(vehicleList) && vehicleList.length > 0) {
                        vehicleList.forEach(function (elem) {
                            if (elem && elem.nickname === (elem.licState + "-" + elem.licPlate)) {
                                elem.nickname = null;
                            }
                        });
                        unwatch();
                    }
                });
            }
            EzTagRequestedDirectiveController.$inject = ["$scope", "localDataRepo"];
            return EzTagRequestedDirectiveController;
        }());
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("ezTagRequested", HCTRA.Directive.EzTagRequestedDirective.factory());
})();
((function () {
    "use strict";
    angular.module("HCTRAModule").directive("filesUpload", [
        function () { return ({
            restrict: "E",
            templateUrl: "/app/directives/filesUploadTemplate.html",
            scope: {
                files: "=",
                validations: "=",
                form: "="
            },
            link: function ($scope) {
                var runningIdCount = 0;
                var idPrefix = "fileUploadIdentification";
                $scope.internalFiles = [];
                $scope.internalFiles.push(createNewInitialFileObj());
                $scope.updateFunc = function () {
                    if ($scope.validations.FileMaxUploads > $scope.internalFiles.length) {
                        addNewEntry();
                    }
                    assignCurrentFileSet();
                };
                $scope.processDelete = function (id) {
                    $scope.internalFiles = $scope.internalFiles.filter(function (file) {
                        return file.id !== id;
                    });
                    addNewEntry();
                    assignCurrentFileSet();
                };
                function assignCurrentFileSet() {
                    $scope.files = $scope.internalFiles.filter(function (file) {
                        return file.extension !== null;
                    });
                }
                function addNewEntry() {
                    var hasOpenEntry = false;
                    $scope.internalFiles.some(function (file) {
                        hasOpenEntry = file.extension === null;
                        return hasOpenEntry;
                    });
                    if (!hasOpenEntry) {
                        $scope.internalFiles.push(createNewInitialFileObj());
                    }
                }
                function createNewInitialFileObj() {
                    runningIdCount++;
                    var newFile = {
                        data: null,
                        extension: null,
                        id: idPrefix + runningIdCount
                    };
                    return newFile;
                }
            }
        }); }
    ]);
})());
((function () {
    "use strict";
    angular.module("HCTRAModule").directive("fileUpload", ["validationService",
        function (validationService) { return ({
            restrict: "E",
            templateUrl: "/app/directives/fileUploadTemplate.html",
            scope: {
                file: "=",
                validations: "=",
                form: "=",
                deleteFunc: "=?onDelete",
                shouldShowDelete: "=?",
                updateFunc: "&?onUpdate",
                id: "=?"
            },
            link: function ($scope) {
                var BYTES_PER_MEGABYTE = 1048576;
                var invalidKey = "AttachmentInvalid";
                $scope.showTypeValidationMessage = false;
                $scope.showSizeValidationMessage = false;
                $scope.showDeleteButton = false;
                if (!$scope.id)
                    $scope.id = "fileUploadIdentifier0";
                $scope.fileName = "";
                $scope.validation = validationService($scope.form);
                $scope.submitFile = function (file) {
                    if (!file) // this is needed because this function is triggered incorrectly after the first time a user hits upload and selects a file
                        return;
                    $scope.showDeleteButton = $scope.shouldShowDelete === true;
                    var indexOfExtension = file.name.lastIndexOf(".");
                    var extension = (indexOfExtension === -1 ? "" : file.name.substring(indexOfExtension)).toLowerCase();
                    $scope.fileName = file.name;
                    if (!isValid(file, extension))
                        return;
                    updateFile(file, extension);
                };
                function updateFile(file, extension) {
                    $scope.showTypeValidationMessage = false;
                    $scope.showSizeValidationMessage = false;
                    $scope.form[$scope.id].$setValidity(invalidKey, true);
                    var reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onloadend = function () {
                        $scope.$apply(function () {
                            $scope.file.data = reader.result;
                            $scope.file.extension = extension;
                            if ($scope.updateFunc)
                                $scope.updateFunc();
                        });
                    };
                }
                function isValid(file, extension) {
                    // FileUploadSize [megabytes] * BYTES_PER_MEGABYTE [bytes/megabytes]
                    var maxFileSizeInBytes = $scope.validations.FileUploadSize * BYTES_PER_MEGABYTE;
                    if ($scope.validations.FileExtensions.indexOf(extension) === -1) {
                        $scope.showSizeValidationMessage = false;
                        $scope.showTypeValidationMessage = true;
                        invalidateFile();
                        return false;
                    }
                    if (file.size > maxFileSizeInBytes) {
                        $scope.showTypeValidationMessage = false;
                        $scope.showSizeValidationMessage = true;
                        invalidateFile();
                        return false;
                    }
                    return true;
                }
                function invalidateFile() {
                    $scope.file.data = null;
                    $scope.file.extension = null;
                    $scope.form[$scope.id].$setValidity(invalidKey, false);
                }
                $scope.onDelete = function () {
                    $scope.form[$scope.id].$setValidity(invalidKey, true);
                    $scope.file.data = null;
                    $scope.file.extension = null;
                    $scope.deleteFunc($scope.id);
                };
            }
        }); }]);
})());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("firstFieldFocus", ['$timeout',
        function ($timeout) {
            return {
                restrict: "E",
                scope: {
                    remote: '='
                },
                link: function ($scope) {
                    $scope.remote.focusFirstField = function () {
                        $timeout(function () {
                            var jqFields = angular.element('input[required], input[required="required"], select[required], select[required="required"], textarea[required], textarea[required="required"]');
                            if (jqFields.length > 0) {
                                var jqFirst = jqFields.eq(0);
                                if (jqFirst.attr('id') === 'inputSearch') {
                                    jqFirst = jqFields.eq(1);
                                }
                                if (jqFirst.focus) {
                                    angular.element(jqFirst).focus();
                                }
                            }
                        }, 300);
                    };
                }
            };
        }]);
}());
// (function () {
//     'use strict';
//     angular.module('HCTRAModule').directive("footerDesktopView", ['toggleFullWebsiteService', 'desktopAutoRedirect',
//         function (toggleFullWebsiteService, desktopAutoRedirect) {
//             return {
//                 restrict: 'E',
//                 templateUrl: "/app/directives/footerDesktopViewTemplate.html",
//                 link: function (scope) {
//                     scope.forceDesktopView = desktopAutoRedirect.isForcedDesktopView();
//                     scope.onMobileClick = toggleFullWebsiteService.onMobileClick;
//                     scope.onDesktopClick = toggleFullWebsiteService.onDesktopClick;
//                 }
//             };
//         }
//     ]);
// }());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("forgotPasswordRemote", [
        function () {
            return {
                restrict: "E",
                scope: {
                    vm: '='
                },
                link: function ($scope) {
                    $scope.vm.init = function () {
                        angular.element('#accountInfo').focus();
                    };
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('genericPagingControl', [
        function () {
            return {
                scope: {
                    config: "=",
                    showRecordCount: "=?",
                    invoiceCount: "=?",
                    suspendedFlow: "=?"
                },
                templateUrl: '/app/directives/genericPagingControlTemplate.html',
                controller: GenericPagingControlController,
                controllerAs: 'vm'
            };
        }
    ]);
    function GenericPagingControlController($scope, $attrs) {
        var vm = this;
        var DEFAULT_PAGE_NUMBER = 1;
        var lastVisiblePageNumber = DEFAULT_PAGE_NUMBER;
        vm.$onInit = function () {
            vm.hideSelector = angular.isDefined($attrs.hideSelector);
            vm.showItemCount = angular.isDefined($attrs.showItemCount);
            vm.itemCountLabel = $attrs.itemCountLabel;
            var unwatch = $scope.$watch('config', function () {
                if ($scope.config) {
                    vm.visiblePageNumber = DEFAULT_PAGE_NUMBER;
                    vm.pageSize = $scope.config.initPageSize;
                    vm.numberOfPages = calculateNumberOfPages($scope.config.totalItems, vm.pageSize); //Math.ceil($scope.config.totalItems / vm.pageSize);
                    vm.totalItems = $scope.config.totalItems;
                    vm.showRecordCount = $scope.showRecordCount;
                    vm.invoiceCount = $scope.invoiceCount;
                    vm.suspendedFlow = $scope.suspendedFlow;
                    unwatch();
                }
            });
            vm.onBackAll = function () {
                //vm.visiblePageNumber = 1;
                setVisiblePageNumber(1);
                if ($scope.config && $scope.config.onBackAll) {
                    $scope.config.onBackAll(vm.visiblePageNumber);
                }
            };
            vm.onBack = function () {
                if (vm.visiblePageNumber > 1) {
                    //vm.visiblePageNumber--;
                    setVisiblePageNumber(vm.visiblePageNumber - 1);
                }
                if ($scope.config && $scope.config.onBack) {
                    $scope.config.onBack(vm.visiblePageNumber);
                }
            };
            vm.onForward = function () {
                if (vm.visiblePageNumber < vm.numberOfPages) {
                    //vm.visiblePageNumber++;
                    setVisiblePageNumber(vm.visiblePageNumber + 1);
                }
                if ($scope.config && $scope.config.onForward) {
                    $scope.config.onForward(vm.visiblePageNumber);
                }
            };
            vm.onForwardAll = function () {
                //vm.visiblePageNumber = vm.numberOfPages;
                setVisiblePageNumber(vm.numberOfPages);
                if ($scope.config && $scope.config.onForwardAll) {
                    $scope.config.onForwardAll(vm.visiblePageNumber);
                }
            };
            vm.onPageSizeChange = function () {
                vm.numberOfPages = calculateNumberOfPages($scope.config.totalItems, vm.pageSize);
                if (vm.visiblePageNumber > vm.numberOfPages) {
                    setVisiblePageNumber(vm.numberOfPages);
                }
                if ($scope.config && $scope.config.onPageSizeChange) {
                    $scope.config.onPageSizeChange(vm.visiblePageNumber, vm.pageSize);
                }
            };
            vm.onPageNumberEntered = function () {
                if (Math.floor(vm.visiblePageNumber) === vm.visiblePageNumber) { // if integer
                    if (vm.visiblePageNumber < 1) { // out of bound: below
                        vm.visiblePageNumber = 1;
                    }
                    else if (vm.visiblePageNumber > vm.numberOfPages) { // out of bounds: above
                        vm.visiblePageNumber = vm.numberOfPages;
                    }
                    lastVisiblePageNumber = vm.visiblePageNumber; // set lastVisiblePageNumber to the appropriate bound
                }
                else {
                    vm.visiblePageNumber = lastVisiblePageNumber;
                }
                if ($scope.config && $scope.config.onPageNumberEntered) {
                    $scope.config.onPageNumberEntered(vm.visiblePageNumber);
                }
            };
            vm.lowerItemIndex = function () {
                return (vm.visiblePageNumber - 1) * vm.pageSize + 1;
            };
            vm.upperItemIndex = function () {
                return Math.min(vm.visiblePageNumber * vm.pageSize, vm.totalItems);
            };
            function setVisiblePageNumber(inNumber) {
                lastVisiblePageNumber = vm.visiblePageNumber;
                vm.visiblePageNumber = inNumber;
            }
            function calculateNumberOfPages(totalItems, pageSize) {
                return Math.ceil(totalItems / pageSize);
            }
        };
    }
    GenericPagingControlController.$inject = ['$scope', '$attrs'];
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("faqBrowseCategory", function () {
        return {
            restrict: "E",
            templateUrl: "/app/directives/helpAndSupport/faqBrowseCategoryTemplate.html",
            scope: {
                onSearch: '&',
                categories: '='
            },
            link: function (scope) {
                scope.onSearch = scope.onSearch();
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("faqSearchBox", function () {
        return {
            restrict: "E",
            templateUrl: "/app/directives/helpAndSupport/faqSearchBoxTemplate.html",
            scope: {
                onSearch: '&'
            },
            link: function (scope) {
                scope.onSearch = scope.onSearch();
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("faqSearch", [
        function () {
            return {
                restrict: "E",
                templateUrl: "/app/directives/helpAndSupport/faqSearchTemplate.html",
                scope: {
                    goToFaq: '&',
                    searchFaqKeyword: '&',
                    searchFaqCategory: '&',
                    categories: '='
                },
                link: function (scope, elem, attrs) {
                    scope.hideViewAll = angular.isUndefined(attrs.hideViewAll);
                }
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var MostFaqDirective = /** @class */ (function () {
            function MostFaqDirective(routes, genericRepo, $location, linkLookupService) {
                var _this = this;
                this.routes = routes;
                this.genericRepo = genericRepo;
                this.$location = $location;
                this.linkLookupService = linkLookupService;
                this.restrict = "E";
                this.templateUrl = "/app/directives/helpAndSupport/mostFaqTemplate.html";
                this.scope = {};
                this.link = function ($scope) {
                    var requestTopFaq = {
                        itemId: _this.routes.faqTopFaqCms,
                        fields: "Query"
                    };
                    _this.genericRepo.dataFactory.getCmsPageById(requestTopFaq).then(function (res) {
                        var parsedRes = angular.fromJson(res.cmsResponse);
                        $scope.mostFaq = parsedRes.Query.Results.slice(0, 5);
                    });
                    $scope.searchMostFaq = function (article) {
                        if (angular.isObject(article)) {
                            _this.$location.url(_this.linkLookupService.articleLookupById(article.ItemID));
                        }
                    };
                };
            }
            MostFaqDirective.factory = function () {
                var directive = function (routes, genericRepo, $location, linkLookupService) { return new MostFaqDirective(routes, genericRepo, $location, linkLookupService); };
                directive.$inject = ["routes", "genericRepo", "$location", "linkLookupService"];
                return directive;
            };
            return MostFaqDirective;
        }());
        Directive.MostFaqDirective = MostFaqDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("mostFaq", HCTRA.Directive.MostFaqDirective.factory());
}());
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("homeCarousel", ["$interval",
        function ($interval) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/home/homeCarouselTemplate.html",
                scope: {
                    slides: "=",
                    interval: "="
                },
                link: function ($scope) {
                    var circularList;
                    var updateSlider = function () {
                        $scope.activeSlide = circularList.peekCurrent();
                        $scope.rightSlide = circularList.peekRight();
                        $scope.leftSlide = circularList.peekLeft();
                    };
                    $scope.cancelRotate = function () {
                        $interval.cancel($scope.autoRotate);
                    };
                    $scope.$watch("slides", function () {
                        if ($scope.slides) {
                            if ($scope.interval > 0) {
                                $scope.autoRotate = $interval($scope.rightClick, $scope.interval);
                            }
                            circularList = new HCTRA.Datastructure.CircularList($scope.slides);
                            updateSlider();
                        }
                    });
                    $scope.leftClick = function () {
                        circularList.moveHeadLeft();
                        updateSlider();
                    };
                    $scope.rightClick = function () {
                        circularList.moveHeadRight();
                        updateSlider();
                    };
                    $scope.$on("$destroy", function () {
                        $scope.cancelRotate();
                    });
                }
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var HomeClosuresController = /** @class */ (function () {
            function HomeClosuresController($location, routes, cmsUtilService, AuthService, marketingImageService, rssService, $window, momentService, genericRepo, stringUtilsService, $rootScope, AUTH_EVENTS, APP_LIFECYCLE_EVENTS) {
                var _this = this;
                this.$location = $location;
                this.routes = routes;
                this.cmsUtilService = cmsUtilService;
                this.AuthService = AuthService;
                this.marketingImageService = marketingImageService;
                this.rssService = rssService;
                this.$window = $window;
                this.momentService = momentService;
                this.genericRepo = genericRepo;
                this.stringUtilsService = stringUtilsService;
                this.$rootScope = $rootScope;
                this.AUTH_EVENTS = AUTH_EVENTS;
                this.APP_LIFECYCLE_EVENTS = APP_LIFECYCLE_EVENTS;
                this.maxSegments = 10000; // 10000 is basically unlimited
                this.shownClosures = [];
                this.shownMarketingImages = [];
                this.destroyLogoutSuccessListener = this.$rootScope.$on(this.AUTH_EVENTS.logoutSuccess, function () {
                    _this.useImagesByLoggedInState();
                });
                this.destroySessionTimedOutListener = this.$rootScope.$on(this.AUTH_EVENTS.sessionTimedOut, function () {
                    _this.useImagesByLoggedInState();
                });
                this.destroySecurityIssueListener = this.$rootScope.$on(this.AUTH_EVENTS.securityIssue, function () {
                    _this.useImagesByLoggedInState();
                });
                this.destroySetNavBarLoginListener = this.$rootScope.$on(this.APP_LIFECYCLE_EVENTS.setNavBarLogin, function () {
                    _this.useImagesByLoggedInState();
                });
                this.destroyRestoredUserStateListener = this.$rootScope.$on(this.APP_LIFECYCLE_EVENTS.restoredUserState, function () {
                    _this.useImagesByLoggedInState();
                });
                this.$postLink = function () {
                    if (_this.closures) {
                        var c = _this.closures;
                        var segmentCount = 0;
                        for (var _i = 0, c_1 = c; _i < c_1.length; _i++) {
                            var x = c_1[_i];
                            var segmentAddValue = 1; // the text itself counts as a segment
                            x.image = _this.cmsUtilService.generateFileSrc(x.Image);
                            x.alt = _this.cmsUtilService.parseAltText(x.Image);
                            x.closureDates = _this.momentService.moment(x.StartDate, 'YYYYMMDD').format('MMMM DD, YYYY');
                            if (x.EndDate) {
                                x.closureDates = x.closureDates + " - " + _this.momentService.moment(x.EndDate, 'YYYYMMDD').format('MMMM DD, YYYY');
                            }
                            if (x.image) // images count as two other segments
                                segmentAddValue += 2;
                            if ((segmentCount + segmentAddValue) <= _this.maxSegments) { // Lane closures not overflowing
                                _this.shownClosures.push(x);
                                segmentCount += segmentAddValue;
                            }
                            else // No room for more closures
                                break;
                        }
                    }
                    if (_this.closures && _this.marketingImages) {
                        //initialize object
                        _this.imageObj = angular.copy(_this.marketingImageService.processImagesToObj(_this.marketingImages));
                        //check for Transtar
                        if (angular.isDefined(_this.closures) && _this.closures.length > 0 && _this.closures[0].Title === "Transtar Map") {
                            _this.imageObj.startIndex = 1;
                        }
                        //set max articles before no images
                        _this.imageObj.articles = _this.closures.length;
                        _this.imageObj.maxArticles = _this.imageObj.startIndex + 2;
                        _this.imageObj.maxSmall = 2;
                        //check login state
                    }
                    _this.useImagesByLoggedInState();
                    _this.updateClosureTitle();
                };
                this.goToClosureArticle = function (articleID) {
                    _this.$window.open(_this.routes.closures + "#" + articleID, "_blank");
                };
                this.goToUrl = function (imageURL) {
                    _this.$location.url(imageURL);
                };
                this.goToRssFeedClosures = function () {
                    _this.rssService.goToRssFeed(_this.rssService.rssMajorClosuresKey);
                };
                this.updateClosureTitle = function () {
                    _this.genericRepo.dataFactory.getCmsPageById({
                        ItemId: _this.routes.majorClosureSection
                    }).then(_this.parseClosureTitle);
                };
                this.parseClosureTitle = function (response) {
                    var parsedRes = angular.fromJson(response.cmsResponse);
                    _this.closureTitle = parsedRes.ShortDescription;
                    var paramObjs = _this.stringUtilsService.getParameterObject(parsedRes.Parameters);
                    if (paramObjs.isRSSshow === "true") {
                        _this.showRSSClosure = true;
                    }
                };
                this.useImagesByLoggedInState = function () {
                    _this.shownMarketingImages = [];
                    if (_this.AuthService.isAuthenticated()) {
                        _this.shownMarketingImages = _this.marketingImageService.setImages('logIn', _this.imageObj);
                    }
                    else {
                        _this.shownMarketingImages = _this.marketingImageService.setImages('logOut', _this.imageObj);
                    }
                };
                this.$onDestroy = function () {
                    _this.destroyLogoutSuccessListener();
                    _this.destroySessionTimedOutListener();
                    _this.destroySecurityIssueListener();
                    _this.destroySetNavBarLoginListener();
                    _this.destroyRestoredUserStateListener();
                };
            }
            HomeClosuresController.$inject = [
                '$location',
                'routes',
                'cmsUtilService',
                'AuthService',
                'marketingImageService',
                'rssService',
                "$window",
                'momentService',
                'genericRepo',
                'stringUtilsService',
                '$rootScope',
                'AUTH_EVENTS',
                'APP_LIFECYCLE_EVENTS'
            ];
            return HomeClosuresController;
        }());
        Controller.HomeClosuresController = HomeClosuresController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').component("homeClosures", {
        templateUrl: '/app/directives/home/homeClosuresTemplate.html',
        bindings: {
            closures: "=",
            marketingImages: "="
        },
        controller: HCTRA.Controller.HomeClosuresController
    });
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("homeModule", ['$state', 'stateNames',
        function ($state, stateNames) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/home/homeModuleTemplate.html",
                //templateUrl: "/SitecoreViewRequestInterceptor_homeModuleTemplate",
                scope: {
                    moduleObject: "=",
                    onModuleClick: '&'
                },
                link: function ($scope) {
                    $scope.$watch('moduleObject', function () {
                        if ($scope.moduleObject) {
                            if ($scope.moduleObject.LinkTitle && $scope.moduleObject.LinkTitle.toLowerCase().indexOf('login') > -1
                                && $scope.moduleObject.TitleURL && $scope.moduleObject.TitleURL.toLowerCase().indexOf('login') > -1) {
                                $scope.isLoginModule = true;
                                $scope.goToFirstTimeLogin = function ($event) {
                                    // Prevents the ng-click of parent module
                                    $event.stopPropagation();
                                    $state.go(stateNames.setupOnlineAccessIdentification);
                                };
                            }
                            // Must watch when user logs out and is on Home Page
                            //unwatch();
                        }
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("homeNews", ["$location", "routes", "cmsUtilService", "AuthService", "$rootScope", "AUTH_EVENTS", "APP_LIFECYCLE_EVENTS", "marketingImageService", "rssService", "$window",
        function ($location, routes, cmsUtilService, AuthService, $rootScope, AUTH_EVENTS, APP_LIFECYCLE_EVENTS, marketingImageService, rssService, $window) {
            return {
                restrict: "E",
                transclude: true,
                templateUrl: "/app/directives/home/homeNewsTemplate.html",
                scope: {
                    newsList: "=",
                    marketingImages: "="
                    //maxSegments: "="
                },
                link: function ($scope) {
                    $scope.shownNews = [];
                    $scope.shownMarketingImages = [];
                    var imageObj;
                    var maxSegments = 10000; // 10000 is basically unlimited
                    $scope.goToNewsArticle = function (articleID) {
                        $window.open(routes.newsFeed + "#" + articleID, "_blank");
                    };
                    $scope.goToUrl = function (imageURL) {
                        $location.url(imageURL);
                    };
                    $scope.goToRssFeedNews = function () {
                        rssService.goToRssFeed(rssService.rssHomeNewsKey);
                    };
                    var unwatch = $scope.$watchGroup(["newsList", "marketingImages"], function () {
                        if ($scope.newsList) {
                            $scope.shownNews = $scope.newsList.slice(0, maxSegments);
                            for (var i = 0; i < $scope.newsList.length; i++) {
                                $scope.newsList[i].imageSrc = cmsUtilService.generateFileSrc($scope.newsList[i].Image);
                            }
                        }
                        if ($scope.newsList && $scope.marketingImages) {
                            //initialize object
                            imageObj = angular.copy(marketingImageService.processImagesToObj($scope.marketingImages));
                            //set max articles before no images
                            imageObj.articles = $scope.newsList.length;
                            //check login state
                            useImagesByLoggedInState();
                            unwatch();
                        }
                    });
                    var useImagesByLoggedInState = function () {
                        if (AuthService.isAuthenticated()) {
                            $scope.shownMarketingImages = marketingImageService.setImages('logIn', imageObj);
                        }
                        else {
                            $scope.shownMarketingImages = marketingImageService.setImages('logOut', imageObj);
                        }
                    };
                    var destroyLogoutSuccessListener = $rootScope.$on(AUTH_EVENTS.logoutSuccess, function () {
                        useImagesByLoggedInState();
                    });
                    var destroySessionTimedOutListener = $rootScope.$on(AUTH_EVENTS.sessionTimedOut, function () {
                        useImagesByLoggedInState();
                    });
                    var destroySecurityIssueListener = $rootScope.$on(AUTH_EVENTS.destroySecurityIssueListener, function () {
                        useImagesByLoggedInState();
                    });
                    var destroySetNavBarLoginListener = $rootScope.$on(APP_LIFECYCLE_EVENTS.setNavBarLogin, function () {
                        useImagesByLoggedInState();
                    });
                    var destroyRestoredUserStateListener = $rootScope.$on(APP_LIFECYCLE_EVENTS.restoredUserState, function () {
                        useImagesByLoggedInState();
                    });
                    $scope.$on("$destroy", function () {
                        destroyLogoutSuccessListener();
                        destroySessionTimedOutListener();
                        destroySecurityIssueListener();
                        destroySetNavBarLoginListener();
                        destroyRestoredUserStateListener();
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("homeQuickLinks", [
        function () {
            return {
                restrict: "E",
                templateUrl: "SitecoreViewRequestInterceptor_homeQuickLinksTemplate",
                scope: {
                    links: "="
                }
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Constant;
    (function (Constant) {
        "use strict";
        var InputDropdownConstants = /** @class */ (function () {
            function InputDropdownConstants() {
            }
            Object.defineProperty(InputDropdownConstants, "Default", {
                get: function () {
                    return {
                        inputDropdownItemIdPrefix: "#inputDropdownItem",
                        inputDropdownBoxId: "#inputDropdownBox",
                        preSubmitValidationErrorKey: "inputError",
                        postSubmitValidationErrorKey: "submissionError"
                    };
                },
                enumerable: true,
                configurable: true
            });
            return InputDropdownConstants;
        }());
        Constant.InputDropdownConstants = InputDropdownConstants;
    })(Constant = HCTRA.Constant || (HCTRA.Constant = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").constant("inputDropdownConstants", HCTRA.Constant.InputDropdownConstants.Default);
}());
((function () {
    "use strict";
    angular.module("HCTRAModule").directive("inputDropdown", ['validationService', 'inputDropdownHelper', 'inputDropdownConstants',
        function (validationService, inputDropdownHelper, inputDropdownConstants) { return ({
            restrict: "E",
            templateUrl: "/app/directives/inputDropdown/inputDropdownTemplate.html",
            scope: {
                requiredBindings: "=",
                optionalBindings: "="
            },
            link: function ($scope) {
                // local variables
                var upKeyFocus = {
                    boundaryType: "top",
                    comparisonSwitch: 1,
                    scrollType: true
                };
                var downKeyFocus = {
                    boundaryType: "bottom",
                    comparisonSwitch: -1,
                    scrollType: false
                };
                // Scope variable assignments
                $scope.validationService = validationService;
                $scope.isFocused = false;
                $scope.inputDropdownItemIdPrefix = inputDropdownConstants.inputDropdownItemIdPrefix.substring(1);
                $scope.inputDropdownBoxId = inputDropdownConstants.inputDropdownBoxId.substring(1);
                if ($scope.optionalBindings) {
                    $scope.placeholder = $scope.optionalBindings.placeholder ? $scope.optionalBindings.placeholder : null;
                    $scope.tabIndex = $scope.optionalBindings.tabIndex ? $scope.optionalBindings.tabIndex : null;
                    $scope.title = $scope.optionalBindings.title ? $scope.optionalBindings.title : null;
                }
                $scope.dropdownVisible = false;
                $scope.activeItemIndex = 0;
                $scope.userInput = "";
                $scope.keyActions = {
                    upAction: function () {
                        var prevIndex = $scope.activeItemIndex - 1;
                        if (prevIndex >= 0) {
                            inputDropdownHelper.ensureElementFocus(prevIndex, upKeyFocus);
                            $scope.setActive(prevIndex);
                        }
                    },
                    downAction: function () {
                        var nextIndex = $scope.activeItemIndex + 1;
                        if (nextIndex < $scope.filteredItems.length) {
                            inputDropdownHelper.ensureElementFocus(nextIndex, downKeyFocus);
                            $scope.setActive(nextIndex);
                        }
                    },
                    enterAction: function (event) {
                        if (!$scope.dropdownVisible) {
                            return;
                        }
                        event.preventDefault();
                        if ($scope.activeItemIndex >= 0 && $scope.activeItemIndex < $scope.filteredItems.length) {
                            $scope.selectItem($scope.filteredItems[$scope.activeItemIndex]);
                        }
                    }
                };
                // Watches
                var unWatchitems = $scope.$watch("requiredBindings.items", function () {
                    if (angular.isArray($scope.requiredBindings.items) && $scope.requiredBindings.items.length > 0) {
                        $scope.filteredItems = angular.copy($scope.requiredBindings.items);
                        $scope.requiredBindings.selectedItem = $scope.requiredBindings.getDefaultItem($scope.requiredBindings.items);
                        unWatchitems();
                    }
                    else {
                        $scope.filteredItems = [];
                    }
                });
                // Scope methods
                $scope.setWidth = function () {
                    var inputWidth = angular.element("#" + $scope.requiredBindings.id);
                    return { "width": inputWidth[0].getBoundingClientRect().width + "px" };
                };
                $scope.inputDropdownClass = function () {
                    var classes = "input-dropdown";
                    if ($scope.showValidation()) {
                        classes = classes + " " + validationService($scope.requiredBindings.form).getErrorStatusClassFastWithNullCheck($scope.requiredBindings.name);
                        $scope.dropdownVisible = false;
                    }
                    return classes;
                };
                $scope.selectedItemClass = function (index) {
                    return { "active": $scope.activeItemIndex === index };
                };
                $scope.setActive = function (itemIndex) {
                    $scope.activeItemIndex = itemIndex;
                };
                $scope.selectItem = function (item) {
                    $scope.requiredBindings.selectedItem = item;
                    $scope.userInput = $scope.requiredBindings.getItemDisplayName(item);
                    $scope.dropdownVisible = false;
                    $scope.filteredItems = [item];
                    inputDropdownHelper.setFormValidity(null, $scope);
                };
                $scope.inputFocus = function () {
                    $scope.isFocused = true;
                    if ($scope.filteredItems.length == 0 || $scope.requiredBindings.getExactItemMatch($scope.userInput, $scope.filteredItems)) {
                        $scope.dropdownVisible = false;
                        return;
                    }
                    $scope.dropdownVisible = true;
                    $scope.setActive(0);
                };
                $scope.inputChange = function () {
                    $scope.requiredBindings.selectedItem = null;
                    $scope.dropdownVisible = true;
                    if (!$scope.userInput) {
                        inputDropdownHelper.runProcessesWhenInputIsEmpty($scope);
                    }
                    else if ($scope.optionalBindings && $scope.optionalBindings.shouldValidate) {
                        inputDropdownHelper.runValidationProcesses($scope);
                    }
                    else {
                        inputDropdownHelper.runProcessesForInputChangeWithNoValidation($scope);
                    }
                };
                $scope.inputBlur = function () {
                    $scope.isFocused = false;
                    $scope.dropdownVisible = false;
                };
                $scope.showValidation = function () {
                    var innerValidationService = validationService($scope.requiredBindings.form);
                    return $scope.requiredBindings.form && innerValidationService.isInvalidWithNullCheck($scope.requiredBindings.name) &&
                        (innerValidationService.getErrorList($scope.requiredBindings.name)[inputDropdownConstants.preSubmitValidationErrorKey] ||
                            (innerValidationService.getErrorList($scope.requiredBindings.name)[inputDropdownConstants.postSubmitValidationErrorKey] &&
                                innerValidationService.hasSubmitted() && !$scope.isFocused));
                };
            }
        }); }]);
})());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var InputDropdownHelper = /** @class */ (function () {
            function InputDropdownHelper(inputDropdownConstants) {
                var _this = this;
                this.inputDropdownConstants = inputDropdownConstants;
                this.setFormValidityInternal = function (validationKey, directiveScope) {
                    directiveScope.requiredBindings.form[directiveScope.requiredBindings.name].$setValidity(_this.inputDropdownConstants.preSubmitValidationErrorKey, _this.inputDropdownConstants.preSubmitValidationErrorKey !== validationKey);
                    directiveScope.requiredBindings.form[directiveScope.requiredBindings.name].$setValidity(_this.inputDropdownConstants.postSubmitValidationErrorKey, _this.inputDropdownConstants.postSubmitValidationErrorKey !== validationKey);
                };
                this.assignPartialMatches = function (directiveScope) {
                    var matches = directiveScope.requiredBindings.getPartialItemMatches(directiveScope.userInput, directiveScope.requiredBindings.items);
                    if (!angular.isArray(matches))
                        matches = [];
                    directiveScope.filteredItems = matches;
                };
                this.preSubmitValidationIsValid = function (directiveScope) {
                    _this.assignPartialMatches(directiveScope);
                    if (directiveScope.filteredItems.length == 0) {
                        directiveScope.dropdownVisible = false;
                        _this.setFormValidityInternal(_this.inputDropdownConstants.preSubmitValidationErrorKey, directiveScope);
                        return false;
                    }
                    return true;
                };
                this.setFormValidity = function (validationKey, directiveScope) {
                    _this.setFormValidityInternal(validationKey, directiveScope);
                };
                this.runProcessesForInputChangeWithNoValidation = function (directiveScope) {
                    _this.setFormValidityInternal(null, directiveScope);
                    _this.assignPartialMatches(directiveScope);
                    if (directiveScope.filteredItems.length == 0)
                        directiveScope.dropdownVisible = false;
                    else if (directiveScope.filteredItems.length == 1 && directiveScope.requiredBindings.getExactItemMatch(directiveScope.userInput, directiveScope.filteredItems)) {
                        directiveScope.requiredBindings.selectedItem = directiveScope.requiredBindings.getExactItemMatch(directiveScope.userInput, directiveScope.filteredItems);
                        directiveScope.dropdownVisible = false;
                        return;
                    }
                    directiveScope.requiredBindings.selectedItem = directiveScope.optionalBindings.getItemFromNoList(directiveScope.userInput);
                };
                this.runProcessesWhenInputIsEmpty = function (directiveScope) {
                    _this.setFormValidityInternal(null, directiveScope);
                    directiveScope.requiredBindings.selectedItem = directiveScope.requiredBindings.getDefaultItem(directiveScope.requiredBindings.items);
                    directiveScope.filteredItems = angular.copy(directiveScope.requiredBindings.items);
                    directiveScope.setActive(0);
                };
                this.runValidationProcesses = function (directiveScope) {
                    if (!_this.preSubmitValidationIsValid(directiveScope))
                        return;
                    var exactMatch = directiveScope.requiredBindings.getExactItemMatch(directiveScope.userInput, directiveScope.filteredItems);
                    if (!exactMatch) {
                        _this.setFormValidityInternal(_this.inputDropdownConstants.postSubmitValidationErrorKey, directiveScope);
                    }
                    else if (directiveScope.filteredItems.length > 1) {
                        _this.setFormValidityInternal(_this.inputDropdownConstants.postSubmitValidationErrorKey, directiveScope);
                    }
                    else {
                        directiveScope.requiredBindings.selectedItem = exactMatch;
                        _this.setFormValidityInternal(null, directiveScope);
                        directiveScope.dropdownVisible = false;
                    }
                };
                this.ensureElementFocus = function (elementIndex, keyType) {
                    var findElementQuery = angular.element(_this.inputDropdownConstants.inputDropdownItemIdPrefix + elementIndex);
                    var findDropdownQuery = angular.element(_this.inputDropdownConstants.inputDropdownBoxId);
                    if (!findElementQuery || !findDropdownQuery || findElementQuery.length < 1 || findDropdownQuery.length < 1)
                        return;
                    var element = findElementQuery[0];
                    var elementBound = keyType.comparisonSwitch * element.getBoundingClientRect()[keyType.boundaryType];
                    var dropdownBound = keyType.comparisonSwitch * findDropdownQuery[0].getBoundingClientRect()[keyType.boundaryType];
                    if (dropdownBound - elementBound > 0) {
                        element.scrollIntoView(keyType.scrollType);
                    }
                };
            }
            InputDropdownHelper.$inject = ["inputDropdownConstants"];
            return InputDropdownHelper;
        }());
        Service.InputDropdownHelper = InputDropdownHelper;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("inputDropdownHelper", HCTRA.Service.InputDropdownHelper);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var LuhnAlgorithmDirective = /** @class */ (function () {
            function LuhnAlgorithmDirective() {
                this.require = "ngModel";
                this.link = function (scope, element, attributes, ngModel) {
                    ngModel.$validators.luhn = function (modelValue) {
                        if (!modelValue) {
                            return true;
                        }
                        else if (/^\*{12}-\d{4}$/.test(modelValue)) {
                            return true;
                        }
                        modelValue = modelValue.toString();
                        if (/[^0-9-\s]+/.test(modelValue))
                            return false;
                        var nCheck = 0;
                        var nDigit = 0;
                        var bEven = false;
                        modelValue = modelValue.replace(/\D/g, "");
                        for (var n = modelValue.length - 1; n >= 0; n--) {
                            var cDigit = modelValue.charAt(n);
                            nDigit = parseInt(cDigit, 10);
                            if (bEven) {
                                if ((nDigit *= 2) > 9)
                                    nDigit -= 9;
                            }
                            nCheck += nDigit;
                            bEven = !bEven;
                        }
                        return (nCheck % 10) == 0;
                    };
                };
            }
            LuhnAlgorithmDirective.factory = function () {
                var directive = function () { return new LuhnAlgorithmDirective(); };
                directive.$inject = [];
                return directive;
            };
            return LuhnAlgorithmDirective;
        }());
        Directive.LuhnAlgorithmDirective = LuhnAlgorithmDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("luhn", HCTRA.Directive.LuhnAlgorithmDirective.factory());
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("moduleButton", [
        function () {
            return {
                transclude: true,
                restrict: "E",
                templateUrl: "/app/directives/moduleButtonTemplate.html",
                scope: {
                    onModuleClick: '&'
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("newAlternateEmail", ['validationService', 'removeDoubleCharService',
        function (validationService, removeDoubleCharService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/newAlternateEmailTemplate.html",
                scope: {
                    alternateEmail: '=',
                    confirmAlternateEmail: '=',
                    parentForm: '=',
                    tabOrderingIndex: '='
                },
                link: function ($scope) {
                    $scope.removeDoubles = function (input, itm) {
                        var val = removeDoubleCharService.removeDoubleChar(input);
                        if (val) {
                            $scope[itm] = val;
                        }
                    };
                    $scope.validation = validationService($scope.parentForm);
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("newEmail", ['validationService', 'removeDoubleCharService',
        function (validationService, removeDoubleCharService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/newEmailTemplate.html",
                scope: {
                    email: '=',
                    confirmEmail: '=',
                    parentForm: '=',
                    tabOrderingIndex: '='
                },
                link: function ($scope) {
                    $scope.removeDoubles = function (input, itm) {
                        var val = removeDoubleCharService.removeDoubleChar(input);
                        if (val) {
                            $scope[itm] = val;
                        }
                    };
                    $scope.validation = validationService($scope.parentForm);
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("newPassword", ['validationService',
        function (validationService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/newPasswordTemplate.html",
                scope: {
                    password: '=',
                    confirmPassword: '=',
                    parentForm: '=',
                    tabOrderingIndex: '=',
                    currentPassword: '='
                },
                link: function ($scope, elem, attrs) {
                    $scope.showNewVerbiage = 'showNewVerbiage' in attrs;
                    $scope.validation = validationService($scope.parentForm);
                }
            };
        }]);
}());
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("newSecurityQuestion", ["validationService", "genericRepo", "responseErrorService", "serverErrorService",
        function (validationService, genericRepo, responseErrorService, serverErrorService) {
            return {
                restrict: "E",
                templateUrl: "/app/directives/newSecurityQuestionTemplate.html",
                scope: {
                    securityQuestionID: "=",
                    securityAnswer: "=",
                    confirmSecurityAnswer: "=",
                    parentForm: "=",
                    tabOrderingIndex: "="
                },
                link: function ($scope) {
                    $scope.validation = validationService($scope.parentForm);
                    genericRepo.dataFactory.getSecurityQuestions().then(function (response) {
                        var hasErrors = response.errors.length > 0;
                        if (hasErrors) {
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                        else { // Successful request
                            $scope.securityQuestions = response.securityQuestions;
                        }
                    }, function () {
                        serverErrorService.handleServerError();
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("notEqualTo", [
        function () {
            return {
                require: "ngModel",
                scope: {
                    otherModelValue: "=notEqualTo"
                },
                link: function (scope, element, attributes, ngModel) {
                    ngModel.$validators.notEqualTo = function (modelValue) {
                        if (angular.isUndefined(scope.otherModelValue) || scope.otherModelValue === "") {
                            return true;
                        }
                        else {
                            return (!(modelValue == scope.otherModelValue));
                        }
                    };
                    scope.$watch('otherModelValue', function () {
                        ngModel.$validate();
                    }, true);
                    scope.$watch('modelValue', function () {
                        ngModel.$validate();
                    });
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("optionalCompareTo", [
        function () {
            return {
                require: "ngModel",
                scope: {
                    otherModelValue: "=optionalCompareTo"
                },
                link: function (scope, element, attributes, ngModel) {
                    ngModel.$validators.optionalCompareTo = function (modelValue) {
                        if (angular.isUndefined(scope.otherModelValue) || scope.otherModelValue === "") {
                            return true;
                        }
                        else {
                            return ((modelValue == scope.otherModelValue));
                        }
                    };
                    scope.$watch('otherModelValue', function () {
                        ngModel.$validate();
                    });
                    scope.$watch('modelValue', function () {
                        ngModel.$validate();
                    });
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('paginatedList', [
        function () {
            return {
                scope: {
                    inList: '=flatList',
                    beforePageChange: '=',
                    afterPageChange: '=',
                    initPageSize: '<',
                    invoiceCount: '=?',
                    showRecordCount: '=?'
                },
                controller: PaginatedListController,
                templateUrl: function (tElement, tAttrs) {
                    return tAttrs.templateUrl;
                },
                controllerAs: 'vm',
                bindToController: true,
                transclude: true
            };
        }
    ]);
    function PaginatedListController($scope, genericPagingControlService) {
        var vm = this;
        vm.$onInit = function () {
            var unwatchInList = $scope.$watch('vm.inList', function () {
                if (vm.inList) {
                    vm.itemCount = vm.inList.length;
                    var initPageSize = vm.initPageSize || 25;
                    var paginator = new HCTRA.Datastructure.Paginator(vm.inList, initPageSize);
                    vm.config = genericPagingControlService.generateSimpleConfig(paginator, function (newPage) {
                        if (vm.beforePageChange)
                            vm.beforePageChange();
                        vm.currentPage = newPage;
                        if (vm.afterPageChange)
                            vm.afterPageChange();
                    });
                    vm.currentPage = paginator.getPage(1);
                    unwatchInList();
                }
            });
        };
    }
    PaginatedListController.$inject = ['$scope', 'genericPagingControlService'];
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('pagingControl', ['validationService', '$state', 'stateNames',
        function (validationService, $state, stateNames) {
            return {
                scope: {
                    data: '=',
                    searchFunction: '&',
                    form: '=',
                    navigationUrls: '=' // needed for prerender javascript timeout
                },
                templateUrl: '/app/directives/pagingControlTemplate.html',
                link: function (scope) {
                    // init
                    scope.userInputData = { visiblePageNumber: 1 };
                    // init
                    scope.validations = validationService(scope.form);
                    // watches
                    scope.$watch('data.currentPage', function () {
                        if (scope.data && angular.isNumber(scope.data.currentPage)) {
                            scope.userInputData.visiblePageNumber = ((scope.data.currentPage) + 1);
                        }
                    });
                    scope.$watch('data.pageSize', function () {
                        if (scope.data && scope.data.pageSize === "" && ($state.is(stateNames.faq) || $state.is(stateNames.faqChild))) {
                            scope.data.pageSize = 50;
                        }
                    });
                    // watches
                    // on change
                    scope.adjustPageSize = function () {
                        scope.data.currentPage = 0;
                        scope.searchFunction();
                    };
                    scope.lastPage = function () {
                        if ((scope.data.currentPage) === ((scope.data.numberOfPages) - 1)) {
                            return;
                        }
                        scope.data.currentPage = ((scope.data.numberOfPages) - 1);
                        scope.searchFunction();
                    };
                    scope.firstPage = function () {
                        if ((scope.data.currentPage) === 0) {
                            return;
                        }
                        scope.data.currentPage = 0;
                        scope.searchFunction();
                    };
                    scope.manualPageUpdate = function () {
                        if (scope.form.currentVisiblePageNumber.$valid) {
                            scope.data.currentPage = angular.copy(scope.userInputData.visiblePageNumber - 1);
                            scope.searchFunction();
                            angular.element(':focus').blur(); // the search function automatically sets the page back up to the title. focus needs to be manually removed from the
                            // input box becuase the input will no longer be visible after the search. if the user attempts to scroll after a successful search and focus is still on the input,
                            // then the number will change instead of the screen scrolling
                        }
                    };
                    // on change
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("pagingInfiniteScroll", function () {
        return {
            restrict: "E",
            templateUrl: "/app/directives/pagingInfiniteScrollTemplate.html",
            scope: {
                search: '&',
                infiniteScrollIsDisabled: '=',
                titleType: '=',
                totalItems: '=',
                articleArray: '=',
                pagingObject: '=',
                titleId: '=',
                archiveTypeChecker: '=',
                form: '=',
                articleNotFoundText: '=',
                navigationUrls: '=',
                mobileSearch: '&'
            },
            link: function ($scope) {
                var checkForArticles = function (items) {
                    return items === 0 ? false : true;
                };
                var unwatch = $scope.$watch('totalItems', function () {
                    if (angular.isDefined($scope.totalItems)) {
                        $scope.hasArticles = checkForArticles($scope.totalItems);
                        // Not sure why the line below exists
                        // eslint-disable-next-line no-self-assign
                        $scope.articleNotFoundText = $scope.articleNotFoundText;
                    }
                });
                $scope.$on('$destroy', function () {
                    unwatch();
                });
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("paymentMethod", function () {
        return {
            restrict: "E",
            templateUrl: "/app/directives/paymentMethod.html",
            scope: {
                billingtypeParent: '=',
                changeType: '&',
                lockType: '='
            },
            link: function ($scope) {
                $scope.isItalic = function () {
                    if (!$scope.billingtypeParent.billingType) {
                        return 'setItalic';
                    }
                    else {
                        return '';
                    }
                };
            }
        };
    });
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //directive for rendering a pdf inline onto a webpage
        var PdfViewerDirective = /** @class */ (function () {
            function PdfViewerDirective(pdfService, $window, $q) {
                var _this = this;
                this.pdfService = pdfService;
                this.$window = $window;
                this.$q = $q;
                this.restrict = "A";
                this.scope = {
                    pdfData: "=",
                    pdfLoaded: "=",
                    pdfError: "=" //event called if pdf rendering failed
                };
                this.link = function (scope, element) {
                    //watch when pdfData changes
                    scope.$watch("pdfData", function (oldVal, newVal, innerScope) {
                        if (!newVal) {
                            return;
                        }
                        //clear any previous renderings
                        element.empty();
                        if (angular.isUndefined(newVal.worker)) {
                            newVal.worker = _this.pdfService.createWorker();
                        }
                        //get document
                        _this.pdfService.getDocument(newVal)
                            //render into element
                            .then(function (doc) { return _this.renderPdfDocument(doc, element); })
                            .then(function (canvases) {
                            //if successful rendering, signal it with the generated data
                            if (innerScope.pdfLoaded) {
                                innerScope.pdfLoaded(canvases.map(function (c) {
                                    return {
                                        width: c.canvas.width,
                                        height: c.canvas.height,
                                        data: c.raw
                                    };
                                }));
                            }
                        })
                            //if something went wrong..
                            .catch(function (e) {
                            //..attempt to signal it
                            if (innerScope.pdfError) {
                                innerScope.pdfError(e);
                            }
                            return _this.$q.resolve([]);
                        })
                            .finally(function () {
                            if (newVal && newVal.worker) {
                                newVal.worker.destroy();
                            }
                        });
                    });
                };
                //calculate pixel density of screen
                this.backingScale = function (ctx) {
                    var dpr = _this.$window.devicePixelRatio || 1;
                    var bsr = ctx.webkitBackingStorePixelRatio ||
                        ctx.mozBackingStorePixelRatio ||
                        ctx.msBackingStorePixelRatio ||
                        ctx.oBackingStorePixelRatio ||
                        ctx.backingStorePixelRatio || 1;
                    return dpr / bsr;
                };
                this.renderPdfDocument = function (pdfDocument, element) {
                    var promises = [];
                    var width = element.width();
                    var _loop_1 = function (pageNum) {
                        var index = pageNum + 1;
                        //..get page..
                        promises.push(pdfDocument.getPage(index)
                            .then(function (page) {
                            //..then build a canvas element
                            var canvas = _this.$window.document.createElement("canvas");
                            //element.append(canvas);
                            var context = canvas.getContext('2d');
                            //set the proper scaling
                            var ratio = 2;
                            var viewPort = page.getViewport({ scale: ratio });
                            var elmRatio = viewPort.width ? width / viewPort.width : 0;
                            //set dimensions
                            canvas.width = Math.floor(viewPort.width * ratio);
                            canvas.height = Math.floor(viewPort.height * ratio);
                            canvas.style.width = Math.floor(viewPort.width * elmRatio) + "px";
                            canvas.style.height = Math.floor(viewPort.height * elmRatio) + "px";
                            context.setTransform(ratio, 0, 0, ratio, 0, 0);
                            //and render: once for the visable elements, the other a raw high res for printing
                            return (page.render({ canvasContext: context, viewport: viewPort }).promise
                                //when rendered return rendered canvas of original index of page
                                .then(function () { return ({ index: index, canvas: canvas, raw: canvas.toDataURL() }); }));
                        }));
                    };
                    //for each page..
                    for (var pageNum = 0; pageNum < pdfDocument.numPages; pageNum++) {
                        _loop_1(pageNum);
                    }
                    //wrap up all promises
                    return _this.$q.all(promises)
                        //when all have finished rendering
                        .then(function (canvases) {
                        //when correctly order them
                        canvases.sort(function (a, b) { return a.index - b.index; });
                        //append rendered canvas
                        canvases.forEach(function (c) { return element.append(c.canvas); });
                        return canvases;
                    })
                        .finally(function () {
                        pdfDocument.destroy();
                    });
                };
            }
            PdfViewerDirective.factory = function () {
                var directive = function (pdfService, $window, $q) { return new PdfViewerDirective(pdfService, $window, $q); };
                directive.$inject = ["PdfService", "$window", "$q"];
                return directive;
            };
            return PdfViewerDirective;
        }());
        Directive.PdfViewerDirective = PdfViewerDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("pdfViewer", HCTRA.Directive.PdfViewerDirective.factory());
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').directive("personalInfo", function () {
        return {
            transclude: true,
            restrict: "E",
            templateUrl: "/app/directives/personalInfoPartial.html",
            scope: {
                personalInfo: '=data',
                onEdit: '&',
                hideEdit: '=?',
                hideContactInfo: '=?',
                hideAddressInfo: '=?',
                isAccountInformation: '='
            },
            link: function ($scope, elem, attrs) {
                $scope.showEdit = !!attrs.onEdit;
                $scope.hideContactInfo = !!attrs.hideContactInfo;
                $scope.hideAddressInfo = !!attrs.hideAddressInfo;
                $scope.isFirstSection = 'isFirst' in attrs;
                var unwatch = $scope.$watch('personalInfo', function (personalInfo) {
                    if (angular.isDefined(personalInfo) && personalInfo.firstName) {
                        personalInfo.accountType = "Personal";
                        unwatch();
                    }
                });
            }
        };
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('printLink', ['$window', function ($window) {
            return {
                scope: {
                    printMessage: "="
                },
                templateUrl: '/app/directives/printLinkTemplate.html',
                link: function ($scope, elem, attrs) {
                    $scope.msg = attrs.printMessage ? $scope.printMessage : "Print";
                    $scope.clickedPrint = function () {
                        $window.print();
                    };
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('sameHeight', ['operatingSystemSnifferService', '$timeout',
        function (operatingSystemSnifferService, $timeout) {
            return {
                restrict: 'A',
                scope: {
                    containers: '=sameHeight'
                },
                link: function (scope, element) {
                    var jElem = angular.element(element);
                    scope.containers.push(jElem);
                    angular.element(window).resize(adjustContainerSize);
                    function adjustContainerSize() {
                        if (operatingSystemSnifferService.isDesktopOs()) {
                            var largestHeight = 0;
                            for (var i = 0; i < scope.containers.length; i++) {
                                scope.containers[i].removeAttr('style');
                                if (scope.containers[i].innerHeight() > largestHeight)
                                    largestHeight = scope.containers[i].innerHeight();
                            }
                            for (var j = 0; j < scope.containers.length; j++) {
                                scope.containers[j].css('height', largestHeight);
                            }
                        }
                        else {
                            jElem.removeAttr('style');
                        }
                    }
                    $timeout(function () {
                        adjustContainerSize();
                    }, 500);
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('selectOnClick', ['$window',
        function ($window) {
            return {
                restrict: 'A',
                link: function (scope, element) {
                    element.on('click', function () {
                        if (!$window.getSelection().toString()) {
                            this.setSelectionRange(0, this.value.length);
                        }
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('spinnerRemote', function () {
        return {
            scope: {
                remot: '='
            },
            link: function (scope) {
                angular.element('#spinnerBlock').show();
                var showing = false;
                if (scope.remot) {
                    scope.remot.openSpinnerBlock = function () {
                        // console.log("Spinner start called with " + showing + "!");
                        angular.element('#spinnerBlock').hide();
                        showing = true;
                    };
                    scope.remot.closeSpinnerBlock = function () {
                        // console.log("Spinner stop called with " + showing + "!");
                        if (showing) {
                            // console.log("Actually called the jQuery hide()");
                            angular.element('#spinnerBlock').show();
                        }
                    };
                }
            }
        };
    });
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define the store front directive, its template and controller
        var StorefrontAppConfigDirective = /** @class */ (function () {
            function StorefrontAppConfigDirective(storefrontService) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.restrict = "A";
                this.link = function () {
                    if (_this.storefrontService.isEnabled()) {
                        angular.element("html")
                            .addClass("storefrontView")
                            .removeAttr("storefront-app-config");
                        var viewport = angular.element("html > head > meta[name='viewport']");
                        viewport.attr("content", "");
                    }
                };
            }
            StorefrontAppConfigDirective.factory = function () {
                var directive = function (storefrontService) { return new StorefrontAppConfigDirective(storefrontService); };
                directive.$inject = ["StorefrontService"];
                return directive;
            };
            return StorefrontAppConfigDirective;
        }());
        Directive.StorefrontAppConfigDirective = StorefrontAppConfigDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontAppConfig", HCTRA.Directive.StorefrontAppConfigDirective.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define directive to hide transculded content if storefront is enabled
        var StorefrontHideIfEnabledDirective = /** @class */ (function () {
            function StorefrontHideIfEnabledDirective(storefrontService) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.restrict = "A";
                this.scope = {
                    storefrontHideIfEnabled: '='
                };
                this.transclude = true;
                this.template = "<div ng-transclude></div>";
                this.link = function (scope, element) {
                    var disableForAll = angular.isDefined(scope.storefrontHideIfEnabled) && scope.storefrontHideIfEnabled;
                    if (_this.storefrontService.isEnabled() && (!_this.storefrontService.fullSiteMode || disableForAll)) {
                        angular.element(element).remove();
                    }
                };
            }
            StorefrontHideIfEnabledDirective.factory = function () {
                var directive = function (storefrontService) { return new StorefrontHideIfEnabledDirective(storefrontService); };
                directive.$inject = ["StorefrontService"];
                return directive;
            };
            return StorefrontHideIfEnabledDirective;
        }());
        Directive.StorefrontHideIfEnabledDirective = StorefrontHideIfEnabledDirective;
        //define directive to hide transculded content if storefront is enabled
        var StorefrontShowIfEnabledDirective = /** @class */ (function () {
            function StorefrontShowIfEnabledDirective(storefrontService) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.restrict = "A";
                this.scope = {
                    storefrontShowIfEnabled: '='
                };
                this.transclude = true;
                this.template = "<div ng-transclude></div>";
                this.link = function (scope, element) {
                    var enableForAll = angular.isDefined(scope.storefrontShowIfEnabled) && scope.storefrontShowIfEnabled;
                    if (!_this.storefrontService.isEnabled() || (_this.storefrontService.fullSiteMode && !enableForAll)) {
                        angular.element(element).remove();
                    }
                };
            }
            StorefrontShowIfEnabledDirective.factory = function () {
                var directive = function (storefrontService) { return new StorefrontShowIfEnabledDirective(storefrontService); };
                directive.$inject = ["StorefrontService"];
                return directive;
            };
            return StorefrontShowIfEnabledDirective;
        }());
        Directive.StorefrontShowIfEnabledDirective = StorefrontShowIfEnabledDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontHideIfEnabled", HCTRA.Directive.StorefrontHideIfEnabledDirective.factory())
        .directive("storefrontShowIfEnabled", HCTRA.Directive.StorefrontShowIfEnabledDirective.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define navigation for storefront on storefront specific templates that require a custom navigation button
        var StorefrontLinkStripperDirective = /** @class */ (function () {
            function StorefrontLinkStripperDirective(storefrontEventService) {
                var _this = this;
                this.storefrontEventService = storefrontEventService;
                this.restrict = "A";
                this.transclude = false;
                this.link = function (scope, element) {
                    _this.storefrontEventService.addMutationObserver(element[0]);
                };
            }
            StorefrontLinkStripperDirective.factory = function () {
                var directive = function (storefrontEventService) { return new StorefrontLinkStripperDirective(storefrontEventService); };
                directive.$inject = ["StorefrontEventService"];
                return directive;
            };
            return StorefrontLinkStripperDirective;
        }());
        Directive.StorefrontLinkStripperDirective = StorefrontLinkStripperDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontLinkStripper", HCTRA.Directive.StorefrontLinkStripperDirective.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define the store front menu directive
        var StorefrontMenuDirective = /** @class */ (function () {
            function StorefrontMenuDirective(storefrontService, storefrontModalService, $q, $state, stateNames) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.storefrontModalService = storefrontModalService;
                this.$q = $q;
                this.$state = $state;
                this.stateNames = stateNames;
                this.restrict = "AE";
                this.templateUrl = "/app/directives/storefront/storefrontMenuTemplate.html";
                this.link = function (scope) {
                    scope.skipToItem = function (item) { return _this.skipToItem(item); };
                    scope.currentItem = function () { return _this.storefrontService.currentWorkItem(true); };
                    scope.workItems = _this.storefrontService.workItems;
                    scope.taskCompleteIcon = _this.storefrontService.getTaskCompleteIcon();
                    scope.taskNotCompleteIcon = _this.storefrontService.getTaskNotCompleteIcon();
                    scope.isItemCurrent = function (item) { return _this.isItemActive(item); };
                };
                //skips to the given workitem
                this.skipToItem = function (item) {
                    if (!_this.storefrontService.isWorkflowActive())
                        return;
                    if (!_this.storefrontService.currentWorkItem() || !_this.storefrontService.currentWorkItem().isSkippable || !item)
                        return;
                    if (_this.storefrontService.currentWorkItem().id === item.id || item.isCompleted)
                        return;
                    //show skip modal
                    _this.storefrontModalService
                        .skipTaskMessage()
                        .then(function (skip) { return skip ? _this.storefrontService.skip(item.id) : _this.$q.reject(null); })
                        .then(function (nextState) {
                        _this.$state.go(nextState || _this.stateNames.storefrontSurvey);
                    });
                };
            }
            StorefrontMenuDirective.factory = function () {
                var directive = function (storefrontService, storefrontModalService, $q, $state, stateNames) {
                    return new StorefrontMenuDirective(storefrontService, storefrontModalService, $q, $state, stateNames);
                };
                directive.$inject = ["StorefrontService", "StorefrontModalService", "$q", "$state", "stateNames"];
                return directive;
            };
            //determines if given item is the current workitem
            StorefrontMenuDirective.prototype.isItemActive = function (item) {
                var current = this.storefrontService.currentWorkItem(true);
                if (!current)
                    return false;
                return current.id === item.id;
            };
            return StorefrontMenuDirective;
        }());
        Directive.StorefrontMenuDirective = StorefrontMenuDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontMenu", HCTRA.Directive.StorefrontMenuDirective.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define the store front modal close directive
        var StorefrontModalCloseDirective = /** @class */ (function () {
            function StorefrontModalCloseDirective(storefrontService) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.restrict = "A";
                this.templateUrl = "/app/directives/storefront/storefrontModalCloseTemplate.html";
                this.scope = {};
                this.link = function (scope) {
                    scope.modalCloseIcon = _this.storefrontService.getCloseModalImg();
                };
            }
            StorefrontModalCloseDirective.factory = function () {
                var directive = function (storefrontService) { return new StorefrontModalCloseDirective(storefrontService); };
                directive.$inject = ["StorefrontService"];
                return directive;
            };
            return StorefrontModalCloseDirective;
        }());
        Directive.StorefrontModalCloseDirective = StorefrontModalCloseDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontModalClose", HCTRA.Directive.StorefrontModalCloseDirective.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define the store front modal close directive
        var StorefrontModalGoBackDirective = /** @class */ (function () {
            function StorefrontModalGoBackDirective(storefrontService) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.restrict = "A";
                this.templateUrl = "/app/directives/storefront/storefrontModalGoBackTemplate.html";
                this.scope = {
                    storefrontModalGoBack: "="
                };
                this.link = function (scope) {
                    scope.modalBackIcon = _this.storefrontService.getBackArrowImg();
                };
            }
            StorefrontModalGoBackDirective.factory = function () {
                var directive = function (storefrontService) { return new StorefrontModalGoBackDirective(storefrontService); };
                directive.$inject = ["StorefrontService"];
                return directive;
            };
            return StorefrontModalGoBackDirective;
        }());
        Directive.StorefrontModalGoBackDirective = StorefrontModalGoBackDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontModalGoBack", HCTRA.Directive.StorefrontModalGoBackDirective.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define navigation for storefront on storefront specific templates that require a custom navigation button
        var StorefrontNavigationDirective = /** @class */ (function () {
            function StorefrontNavigationDirective(storefrontService, $q, $state, storefrontModalService, stateNames) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.$q = $q;
                this.$state = $state;
                this.storefrontModalService = storefrontModalService;
                this.stateNames = stateNames;
                this.restrict = "AE";
                this.transclude = true;
                this.templateUrl = "/app/directives/storefront/storefrontNavigationTemplate.html";
                this.scope = {
                    onProceed: "&",
                    preserveWorkItem: "=",
                    onCancel: "&",
                    onPrevious: "&",
                    hideProceed: "=",
                    showCancel: '=',
                    showPrevious: '=',
                    isProceedDisabled: '=',
                    isFormCompletion: '=',
                    excludeGlobalDisable: '='
                };
                this.link = function (scope, element, attrs) {
                    // var proceedIncluded = angular.isDefined(attrs.onProceed);
                    //  var cancelIncluded = angular.isDefined(attrs.onCancel);
                    scope.showLoginHelp = angular.isDefined(attrs.showLoginHelp);
                    var blockActions = false;
                    var classes = attrs.transcludedClasses ? attrs.transcludedClasses.split(" ").filter(function (x) { return x; }) : [];
                    if (scope.excludeGlobalDisable) {
                        classes.push('exclude-global-disable');
                    }
                    scope.transcludedClasses = classes;
                    var containingForm = element.parents("form");
                    //only active if service is enabled and is not in full site mode
                    if (_this.storefrontService.isEnabled() && !_this.storefrontService.fullSiteMode) {
                        scope.showLoginHelpMessage = function () {
                            if (blockActions)
                                return _this.$q.reject();
                            blockActions = true;
                            return _this.storefrontModalService
                                .showGotoCsr()
                                .then(function (imDone) { return !imDone || _this.$state.go(_this.stateNames.storefrontSurvey); })
                                .finally(function () {
                                blockActions = false;
                            });
                        };
                        var currentItem = _this.storefrontService.currentWorkItem();
                        if (currentItem) {
                            scope.showCancel = scope.showCancel && currentItem.isSkippable;
                        }
                        scope.continueAction = function () {
                            if (containingForm.is(".ng-invalid")) {
                                blockActions = false;
                                return _this.$q.reject();
                            }
                            if (blockActions)
                                return _this.$q.reject();
                            blockActions = true;
                            var action = scope.isFormCompletion
                                ? _this.completeWorkItem(scope)
                                : _this.should(scope.onProceed && scope.onProceed());
                            return action.finally(function () {
                                blockActions = false;
                            });
                        };
                        scope.cancelAction = function () {
                            if (blockActions)
                                return _this.$q.reject();
                            blockActions = true;
                            return (scope.preserveWorkItem
                                ? _this.should(scope.onCancel && scope.onCancel())
                                : _this.cancelWorkItem(scope)).finally(function () { blockActions = false; });
                        };
                        scope.gotoPrevious = function () {
                            if (blockActions)
                                return _this.$q.reject();
                            blockActions = true;
                            return _this.should(scope.onPrevious && scope.onPrevious())
                                .finally(function () { blockActions = false; });
                        };
                    }
                    else {
                        //completely remove element if not needed
                        angular.element(element).remove();
                    }
                };
            }
            StorefrontNavigationDirective.factory = function () {
                var directive = function (storefrontService, $q, $state, storefrontModalService, stateNames) { return new StorefrontNavigationDirective(storefrontService, $q, $state, storefrontModalService, stateNames); };
                directive.$inject = ["StorefrontService", "$q", "$state", "StorefrontModalService", "stateNames"];
                return directive;
            };
            //rejects on falsy defined values, calls 'when' on truthy values. resolved undefined values
            StorefrontNavigationDirective.prototype.should = function (value) {
                //is 'thenable'
                if (value && 'then' in value) {
                    return this.$q.when(value);
                }
                else if (angular.isUndefined(value)) {
                    return this.$q.resolve();
                }
                else {
                    return value ? this.$q.resolve(value) : this.$q.reject(value);
                }
            };
            StorefrontNavigationDirective.prototype.completeWorkItem = function (scope) {
                var _this = this;
                return this.performAction(false, function () { return scope.onProceed(); }, function () { return _this.storefrontService.completeWorkItem(); });
            };
            StorefrontNavigationDirective.prototype.cancelWorkItem = function (scope) {
                var _this = this;
                var currentWorkItem = this.storefrontService.currentWorkItem();
                if (currentWorkItem) {
                    var initialState_1 = this.storefrontService.getWorkItemInitState(currentWorkItem);
                    //if cancelling on the initial state, it should cancel the whole work item, so don't perform cancel logic in this case
                    if (initialState_1 && this.$state.current.name !== initialState_1) {
                        return this.performAction(false, function () { return scope.onCancel(); }, function () {
                            //check to see if the 'cancel' already redirected to the init state, if so, don't do it again.
                            if (_this.$state.current.name !== initialState_1) {
                                return _this.$state.go(initialState_1, {}, { reload: true });
                            }
                            else {
                                return _this.$q.resolve();
                            }
                        });
                    }
                }
                return this.performAction(true, function () { return scope.onCancel(); }, function () { return _this.storefrontService.completeWorkItem(); });
            };
            StorefrontNavigationDirective.prototype.performAction = function (warnLeavingTask, action, postAction) {
                var _this = this;
                return this.$q
                    .when(!warnLeavingTask || this.storefrontModalService.skipTaskMessage())
                    .then(function (skip) {
                    if (skip) {
                        return _this.storefrontService.lockStateChanging(function () {
                            var result;
                            try {
                                result = action();
                            }
                            catch (e) {
                                result = _this.$q.reject(e);
                            }
                            return _this.should(result);
                        })
                            .catch(function (e) { return (e && e.detail && e.detail.storefrontTransitionBlocked)
                            ? _this.$q.resolve()
                            : _this.$q.reject(e); })
                            .then(postAction);
                    }
                });
            };
            return StorefrontNavigationDirective;
        }());
        Directive.StorefrontNavigationDirective = StorefrontNavigationDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontNavigation", HCTRA.Directive.StorefrontNavigationDirective.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        //define the store front directive, its template and controller
        var StorefrontUiDirective = /** @class */ (function () {
            function StorefrontUiDirective() {
                this.restrict = "AE";
                this.controller = "StorefrontController";
                this.templateUrl = "/app/directives/storefront/storefrontUiTemplate.html";
                //transclude = true;
                this.scope = false;
                this.priority = 400;
            }
            StorefrontUiDirective.factory = function () {
                var directive = function () { return new StorefrontUiDirective(); };
                directive.$inject = [];
                return directive;
            };
            return StorefrontUiDirective;
        }());
        Directive.StorefrontUiDirective = StorefrontUiDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .directive("storefrontUi", HCTRA.Directive.StorefrontUiDirective.factory());
})();
((function () {
    "use strict";
    angular.module("HCTRAModule").directive("upDownEnterInterceptor", [
        function () { return ({
            restrict: "A",
            scope: {
                actions: "=upDownEnterInterceptor"
            },
            link: function ($scope, element) {
                var UP = 38;
                var DOWN = 40;
                var RETURN = 13;
                element.bind("keydown keypress", function (event) {
                    switch (event.which) {
                        case UP: {
                            $scope.$apply($scope.actions.upAction);
                            break;
                        }
                        case DOWN: {
                            $scope.$apply($scope.actions.downAction);
                            break;
                        }
                        case RETURN: {
                            $scope.$apply(function () { $scope.actions.enterAction(event); });
                            break;
                        }
                        default: break;
                    }
                });
            }
        }); }
    ]);
})());
/* eslint-disable no-useless-escape */
(function () {
    "use strict";
    angular.module('HCTRAModule').directive("doubles", [
        function () {
            return {
                require: "ngModel",
                link: function (scope, element, attributes, ngModel) {
                    ngModel.$validators.doubles = function (modelValue) {
                        // console.log("Inside remove doubles directive");
                        // console.log("Model value: " + modelValue);
                        var regexChecks = [/@@/g, /\s\s/g, /\.\./g, /\-\-/g, /\_\_/g, /\s\s/g, /[\<\>\'\"]/g];
                        // make sure the model is not empty and thus not a string
                        if (modelValue.match) {
                            var thisCheck;
                            for (var x = 0; x < regexChecks.length; x++) {
                                thisCheck = modelValue.match(regexChecks[x]);
                                if (thisCheck) {
                                    //failing characters found
                                    return false;
                                }
                            }
                            // no failing double characters found
                            return true;
                        }
                        else {
                            return true;
                        }
                    };
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').directive('validateDriverLicense', [function () {
            return {
                restrict: 'A',
                require: 'ngModel',
                scope: {
                    driverLicenseState: '=validateDriverLicense'
                },
                link: function (scope, elem, attrs, ngModel) {
                    scope.$watch('driverLicenseState', function () {
                        ngModel.$validate();
                    });
                    ngModel.$validators.alphaNumeric = function (value) {
                        return /^[a-zA-Z0-9]*$/.test(value || '');
                    };
                    ngModel.$validators.numericTexasDl = function (value) {
                        return scope.driverLicenseState !== 'TX' || /^[0-9]*$/.test(value || '');
                    };
                    ngModel.$validators.firstDigitLessThanFiveTexasDl = function (value) {
                        return scope.driverLicenseState !== 'TX' || /^$|^[0-4]/.test(value || '');
                    };
                    ngModel.$validators.eightDigitTexasDl = function (value) {
                        return scope.driverLicenseState !== 'TX' || /^$|^[0-9]{8}$/.test(value || '');
                    };
                }
            };
        }]);
})();
(function () {
    'use strict';
    //TODO: duplicated in Angular. remove this when migration complete
    angular.module('HCTRAModule').directive("validationFocus", [
        function () {
            return {
                restrict: "A",
                link: function ($scope, elem) {
                    // set up event handler on the form element
                    elem.on('submit', function () {
                        // find the first invalid element
                        var firstInvalid = elem[0].querySelector('.ng-invalid');
                        // if we find one, set focus
                        if (firstInvalid) {
                            firstInvalid.focus();
                        }
                    });
                }
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Directive;
    (function (Directive) {
        var VehicleInformationDirective = /** @class */ (function () {
            function VehicleInformationDirective(validationService, responseErrorService, genericRepo, localDataRepo, manageVehiclesPaperPlateService, environmentConfig) {
                var _this = this;
                this.validationService = validationService;
                this.responseErrorService = responseErrorService;
                this.genericRepo = genericRepo;
                this.localDataRepo = localDataRepo;
                this.manageVehiclesPaperPlateService = manageVehiclesPaperPlateService;
                this.environmentConfig = environmentConfig;
                this.transclude = true;
                this.restrict = "E";
                this.templateUrl = "/app/directives/vehicleInformationTemplate.html";
                this.scope = {
                    vehicleInfo: "=",
                    parentForm: "=",
                    tabOrderingIndex: "=",
                    isEdit: "=",
                    hideTempPlate: "=?"
                };
                this.link = function ($scope) {
                    Object.defineProperty($scope.vehicleInfo, 'isPaperPlate', {
                        get: function () { return this.temporaryLicPlate; },
                        set: function (value) { this.temporaryLicPlate = value; }
                    });
                    if (!$scope.vehicleInfo) {
                        $scope.vehicleInfo = {};
                    }
                    var oldLicPlate = $scope.vehicleInfo.licPlate;
                    // TODO: Cleanup so vehicleClassCode is a string
                    $scope.vehicleInfo.vehicleClassCode = Number($scope.vehicleInfo.vehicleClassCode);
                    $scope.validation = _this.validationService($scope.parentForm);
                    $scope.classList = _this.localDataRepo.getClasses(); // Axle classifications
                    $scope.yearsList = _this.localDataRepo.getModelYears(); // Years from 1900 to present year + 1
                    $scope.allDataHasBeenLoaded = false;
                    $scope.hasSelectedTwoAxle = function () {
                        return $scope.vehicleInfo.vehicleClassCode.toString() === "2";
                    };
                    $scope.classChange = function () {
                        $scope.disableMotorcycle = ($scope.vehicleInfo.vehicleClassCode.toString() !== "2");
                        if ($scope.disableMotorcycle)
                            $scope.vehicleInfo.motorcycle = false;
                    };
                    $scope.classChange(); // Run once on controller creation
                    if (!$scope.hideTempPlate) {
                        $scope.onBlur = function () {
                            if (oldLicPlate !== $scope.vehicleInfo.licPlate) {
                                oldLicPlate = $scope.vehicleInfo.licPlate;
                                $scope.vehicleInfo.temporaryLicPlate = null;
                            }
                        };
                    }
                    else {
                        $scope.onBlur = angular.noop;
                    }
                    _this.genericRepo.dataFactory.getEditEzTagData().then(function (response) {
                        if (_this.responseErrorService.isErrorFree(response)) {
                            $scope.statesList = response.states;
                            $scope.makesList = response.vehicleMakes;
                        }
                        _this.responseErrorService.displayAlertsFromResponse(response);
                        $scope.allDataHasBeenLoaded = true;
                    });
                    _this.manageVehiclesPaperPlateService.getPaperPlateCms().then(function (cms) {
                        $scope.paperPlateAcknowledgement = cms.paperPlateAcknowledgement;
                        $scope.paperPlateQuestion = cms.paperPlateQuestion;
                        $scope.paperPlateValidationText = cms.paperPlateValidationText;
                    });
                };
            }
            VehicleInformationDirective.factory = function () {
                var directive = function (validationService, responseErrorService, genericRepo, localDataRepo, manageVehiclesPaperPlateService, environmentConfig) {
                    return new VehicleInformationDirective(validationService, responseErrorService, genericRepo, localDataRepo, manageVehiclesPaperPlateService, environmentConfig);
                };
                directive.$inject = ["validationService", "responseErrorService", "genericRepo", "localDataRepo", "manageVehiclesPaperPlateService", "environmentConfig"];
                return directive;
            };
            return VehicleInformationDirective;
        }());
        Directive.VehicleInformationDirective = VehicleInformationDirective;
    })(Directive = HCTRA.Directive || (HCTRA.Directive = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("vehicleInformation", HCTRA.Directive.VehicleInformationDirective.factory());
}());
(function () {
    "use strict";
    angular.module("HCTRAModule").directive("addressEntry", ["validationService", "countryConversionService", "billingInfoUtilitiesService",
        function (validationService, countryConversionService, billingInfoUtilitiesService) {
            return {
                transclude: true,
                scope: {
                    address: "=",
                    stateList: "=",
                    countryList: "=",
                    paymentsform: "=",
                    billingtype: "=",
                    mailingAddress: "=",
                    validate: "=",
                    international: "=",
                    billingOrMailing: "@",
                    isRefund: "=?"
                },
                restrict: "E",
                templateUrl: "/app/directives/violations/step2/addressEntryTemplate.html",
                link: function ($scope, elem, attrs) {
                    if (!angular.isObject($scope.address)) {
                        $scope.address = {};
                    }
                    if (!$scope.address.state) {
                        $scope.address.state = "TX";
                    }
                    if ($scope.isRefund && $scope.international && !$scope.address.city && !$scope.address.zip) {
                        $scope.address.state = "";
                    }
                    if (!billingInfoUtilitiesService.isInternationalAddress($scope.address)) {
                        $scope.address.country = "";
                    }
                    else if ($scope.address.country && angular.isArray($scope.countryList) && $scope.countryList.length > 0) { // exisiting Ws Issue prevents sometimes assigns countryCode a countryName. Have to manually assign the countryCode. See Bug 7484.
                        $scope.address.country = countryConversionService.countryNameToCode($scope.countryList, $scope.address.country) || $scope.address.country;
                        $scope.address.displayCountry = countryConversionService.countryCodeToName($scope.countryList, $scope.address.country);
                    }
                    //$scope.international = $scope.international;
                    $scope.noTransHeader = false;
                    $scope.defaultHeaderText = {
                        blank: "Billing Address",
                        credit: "Credit Card Billing Address",
                        eft: "Bank Account Billing Address"
                    };
                    $scope.showSameAddress = !!attrs["mailingAddress"];
                    $scope.checkSameAddress = function (checkStatus) {
                        if (checkStatus) {
                            if (!$scope.address) {
                                $scope.address = {};
                            }
                            if (!$scope.billingAddressSaved) {
                                $scope.billingAddressSaved = {};
                            }
                            if (!$scope.international) {
                                $scope.international = false;
                            }
                            saveTempBillingAddress($scope.international);
                            //uncheck international box if domestic
                            if ($scope.mailingAddress.city) {
                                $scope.international = false;
                                $scope.address.address1 = $scope.mailingAddress.address1;
                                $scope.address.address2 = $scope.mailingAddress.address2;
                                $scope.address.city = $scope.mailingAddress.city;
                                $scope.address.state = $scope.mailingAddress.state;
                                $scope.address.zip = $scope.mailingAddress.zip;
                                $scope.address.plus4 = $scope.mailingAddress.plus4;
                                $scope.address.country = $scope.mailingAddress.country;
                            }
                            else if ($scope.mailingAddress.country) {
                                $scope.international = true;
                                $scope.address.address1 = $scope.mailingAddress.address1;
                                $scope.address.address2 = $scope.mailingAddress.address2;
                                $scope.address.address3 = $scope.mailingAddress.address3;
                                $scope.address.address4 = $scope.mailingAddress.address4;
                                $scope.address.country = $scope.mailingAddress.country;
                            }
                        }
                        else {
                            loadTempBillingAddress();
                        }
                    };
                    var saveTempBillingAddress = function (isInternational) {
                        $scope.billingAddressSaved.international = $scope.international;
                        $scope.billingAddressSaved.address1 = $scope.address.address1;
                        $scope.billingAddressSaved.address2 = $scope.address.address2;
                        if (isInternational) {
                            $scope.billingAddressSaved.address3 = $scope.address.address3;
                            $scope.billingAddressSaved.address4 = $scope.address.address4;
                            $scope.billingAddressSaved.country = $scope.address.country;
                        }
                        else {
                            $scope.billingAddressSaved.city = $scope.address.city;
                            $scope.billingAddressSaved.state = $scope.address.state;
                            $scope.billingAddressSaved.zip = $scope.address.zip;
                            $scope.billingAddressSaved.plus4 = $scope.address.plus4;
                        }
                    };
                    var loadTempBillingAddress = function () {
                        $scope.international = $scope.billingAddressSaved.international;
                        $scope.address.address1 = $scope.billingAddressSaved.address1;
                        $scope.address.address2 = $scope.billingAddressSaved.address2;
                        if ($scope.billingAddressSaved.international) {
                            $scope.address.address3 = $scope.billingAddressSaved.address3;
                            $scope.address.address4 = $scope.billingAddressSaved.address4;
                            $scope.address.country = $scope.billingAddressSaved.country;
                        }
                        else {
                            $scope.address.city = $scope.billingAddressSaved.city;
                            $scope.address.state = $scope.billingAddressSaved.state;
                            $scope.address.zip = $scope.billingAddressSaved.zip;
                            $scope.address.plus4 = $scope.billingAddressSaved.plus4;
                        }
                    };
                    $scope.clearReq = function (obj, prop, field) {
                        if ($scope[obj][prop]) {
                            $scope.paymentsform[field].$setValidity("required", true);
                        }
                    };
                    $scope.checkInternationalBox = function () {
                        $scope.checkStatus = false;
                        $scope.address.address1 = "";
                        $scope.address.address2 = "";
                        $scope.address.city = "";
                        $scope.address.state = ($scope.international && $scope.isRefund) ? "" : "TX";
                        $scope.address.zip = "";
                        $scope.address.plus4 = "";
                        $scope.address.country = "";
                        $scope.address.address3 = "";
                        $scope.address.address4 = "";
                    };
                    $scope.countryChanged = function () {
                        $scope.international = billingInfoUtilitiesService.isInternationalAddress($scope.address);
                        if ($scope.international && angular.isArray($scope.countryList) && $scope.countryList.length > 0) {
                            $scope.address.displayCountry = countryConversionService.countryCodeToName($scope.countryList, $scope.address.country);
                        }
                        else {
                            $scope.address.country = null;
                        }
                    };
                    $scope.validation = validationService($scope.paymentsform);
                    var unwatch = $scope.$watch("billingtype", function (billingtype) {
                        if (billingtype) {
                            var transHeaders = angular.element("#addressEntryTransclude > :header").first();
                            if (transHeaders.length > 0) { // They included a header tag
                                if (transHeaders.text() === "") { // If empty header tag
                                    if (billingtype === "")
                                        transHeaders.text($scope.defaultHeaderText.blank);
                                    else if (billingtype === "CREDIT")
                                        transHeaders.text($scope.defaultHeaderText.credit);
                                    else if (billingtype === "EFT")
                                        transHeaders.text($scope.defaultHeaderText.eft);
                                }
                            }
                            else { // No header tag
                                $scope.noTransHeader = true;
                            }
                            unwatch();
                        }
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('bankAccount', [
        function () {
            return function (bankAccountInput) {
                if (!bankAccountInput) {
                    return '';
                }
                var accountLength = bankAccountInput.length;
                var calclength;
                if (accountLength <= 6)
                    calclength = accountLength - 2;
                else
                    calclength = accountLength - 4;
                var value = bankAccountInput.substring(calclength, accountLength);
                var asterix = '';
                for (var i = 0; i < calclength; i++) {
                    asterix = asterix + '*';
                }
                return asterix + value;
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('capitalize', [
        function () {
            return function (input) {
                var inputBool = !!input;
                if (inputBool) {
                    return input.replace(/([^\W_]+[^\s-]*) */g, function (txt) {
                        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                    });
                }
                else {
                    return '';
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('charReplace', [
        function () {
            return function (input, charReplaced, charReplacer) {
                if (!input) {
                    return '';
                }
                return input.toString().trim().replace(charReplaced, charReplacer);
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('cmsTextInsert', ['cmsTextInsertionService',
        function (cmsTextInsertionService) {
            return function (cmsString, insertionValues) {
                if (!cmsString) {
                    return '';
                }
                return cmsTextInsertionService.insertValues(insertionValues, cmsString);
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('creditCard', [
        function () {
            return function (creditCardInput, creditCardType) {
                if (!creditCardInput) {
                    return '';
                }
                var value = creditCardInput.toString().trim().replace(/\D/g, '');
                value = value.substring(value.length - 4, value.length);
                var maskedCard;
                switch (creditCardType.toLowerCase().replace(' ', '')) {
                    case 'visa': // ****-****-****-####
                    case 'v':
                    case 'mastercard':
                    case 'm':
                    case 'discover':
                    case 'd':
                        maskedCard = '****-****-****-' + value;
                        break;
                    case 'americanexpress': //****-******-*####
                    case 'a':
                        maskedCard = '****-******-*' + value;
                        break;
                    default:
                        break;
                }
                return maskedCard;
            };
        }
    ]);
    angular.module('HCTRAModule').filter('creditCardCode', [
        function () {
            return function (creditCardInput, creditCardCode) {
                if (!creditCardInput) {
                    return '';
                }
                var value = creditCardInput.toString().trim().replace(/\D/g, '');
                value = value.substring(value.length - 4, value.length);
                var maskedCard;
                switch (creditCardCode.toLowerCase()) {
                    case 'v': // ****-****-****-####
                    case 'm':
                    case 'd':
                        maskedCard = '****-****-****-' + value;
                        break;
                    case 'a': //****-******-*####
                        maskedCard = '****-******-*' + value;
                        break;
                    default:
                        break;
                }
                return maskedCard;
            };
        }
    ]);
    //CreditCardType is convereted to enum in Angular
    angular.module('HCTRAModule').filter('creditCardCodeToName', ["creditCardTypes",
        function (creditCardTypes) {
            return function (code) {
                switch (code) {
                    case "V":
                        return creditCardTypes.visa;
                    case "M":
                        return creditCardTypes.mastercard;
                    case "D":
                        return creditCardTypes.discover;
                    case "A":
                        return creditCardTypes.amex;
                }
            };
        }
    ]);
}());
//migrated to Angular
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('driversLicense', [
        function () {
            return function (driversLicenseInput) {
                if (!driversLicenseInput) {
                    return '';
                }
                var value = driversLicenseInput.toString().trim();
                value = value.substring(value.length - 3, value.length);
                var maskedNumber = "***-" + value;
                return maskedNumber;
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('ellipses', ['$filter',
        function ($filter) {
            return function (inString, cutoff) {
                if (!inString) {
                    return '';
                }
                var suffix = '';
                if (inString.length > cutoff) {
                    suffix = '...';
                }
                return "" + $filter('limitTo')(inString, cutoff) + suffix;
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('expDate', [
        function () {
            return function (expDate) {
                if (!expDate) {
                    return '';
                }
                var dateArr = expDate.split("/");
                var monthDigits = dateArr[0].length;
                if (monthDigits == 1)
                    expDate = "0" + expDate;
                return expDate;
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('fileSize', [
        function () {
            return function (fileSizeInput) {
                if (!fileSizeInput || !(!isNaN(parseFloat(fileSizeInput)) && isFinite(fileSizeInput))) {
                    return '';
                }
                var sizeValue = parseFloat(fileSizeInput);
                var kilobytes = sizeValue / 1024;
                var megabytes = kilobytes / 1024;
                var gigabytes = megabytes / 1024;
                var fileSize;
                if (gigabytes >= 1) {
                    fileSize = Math.floor(gigabytes) + ' GB';
                }
                else if (megabytes >= 1) {
                    fileSize = Math.floor(megabytes) + ' MB';
                }
                else if (kilobytes >= 1) {
                    fileSize = Math.floor(kilobytes) + ' KB';
                }
                else {
                    fileSize = sizeValue + ' B';
                }
                return fileSize;
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('homeNewsDate', ['momentDateFilter',
        function (momentDateFilter) {
            return function (dateInput) {
                if (!dateInput) {
                    return '';
                }
                var outDate = momentDateFilter(dateInput, 'MMMM DD[,] YYYY', 'YYYYMMDD[T]HHmmssZ');
                return outDate;
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('insertion', ['cmsTextInsertionService', 'environments', function (cmsTextInsertionService, environments) {
            return function (input, insertionValues, optional) {
                if (!environments.isSitecore) {
                    if (optional) {
                        return input ? cmsTextInsertionService.checkOptional(insertionValues, input) : '';
                    }
                    else {
                        return input ? cmsTextInsertionService.insertValues(insertionValues, input) : '';
                    }
                }
                else {
                    return input || ''; // do not go through insertion service if in Sitecore
                }
            };
        }]);
}());
(function () {
    "use strict";
    angular.module("HCTRAModule").filter("momentDate", ["momentService",
        function (momentService) {
            return function (dateInput, outFormat, inFormat) {
                if (!dateInput) {
                    return "";
                }
                var outDate = momentService.moment(dateInput, inFormat).format(outFormat);
                return outDate;
            };
        }
    ]);
}());
(function () {
    "use strict";
    angular.module("HCTRAModule").filter('secondsToDateTime', [function () { return function (seconds) { return new Date(1970, 0, 1).setSeconds(seconds); }; }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('spaceReplace', [
        function () {
            return function (input, charReplacer) {
                if (!input) {
                    return '';
                }
                if (!charReplacer) {
                    charReplacer = '';
                }
                return input.toString().trim().replace(/\s/g, charReplacer);
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('taxId', [
        function () {
            return function (taxIdInput) {
                if (!taxIdInput) {
                    return '';
                }
                var value = taxIdInput.toString().trim();
                value = value.substring(value.length - 3, value.length);
                var maskedNumber = "******" + value;
                return maskedNumber;
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('telephone', [
        function () {
            return function (telephoneInput) {
                if (!telephoneInput) {
                    return '';
                }
                var value = telephoneInput.toString().trim().replace(/^\+/, '');
                if (value.match(/[^0-9]/)) {
                    return telephoneInput;
                }
                var country, city, number;
                switch (value.length) {
                    case 10: // PPP####### -> (PPP) ###-####
                        country = 1;
                        city = value.slice(0, 3);
                        number = value.slice(3);
                        break;
                    case 11: // +CPPP####### -> C (PPP) ###-#### unless C is 1
                        country = value[0];
                        city = value.slice(1, 4);
                        number = value.slice(4);
                        break;
                    case 12: // +CCCPP####### -> CCC (PP) ###-####
                        country = value.slice(0, 3);
                        city = value.slice(3, 5);
                        number = value.slice(5);
                        break;
                    default:
                        return telephoneInput;
                }
                if (country == 1) {
                    country = "";
                }
                number = number.slice(0, 3) + '-' + number.slice(3);
                return (country + " (" + city + ") " + number).trim();
            };
        }
    ]);
}());
(function () {
    "use strict";
    angular.module("HCTRAModule").
        filter("telephoneWithExt", ["$filter", function ($filter) {
            return function (numberWithExt) {
                if (!numberWithExt) {
                    return "";
                }
                var captureArr = /(.*)(\sext.*)/g.exec(numberWithExt);
                var numberWithoutExt, extension;
                if (angular.isDefined(captureArr) && captureArr !== null) {
                    numberWithoutExt = captureArr[1];
                    extension = captureArr[2];
                }
                else {
                    numberWithoutExt = numberWithExt;
                    extension = "";
                }
                var maskedNumber = $filter("telephone")(numberWithoutExt);
                return maskedNumber + extension;
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('trusted', ['$sce',
        function ($sce) {
            return function (html) {
                if (angular.isString(html)) {
                    if (html.startsWith("https"))
                        return $sce.trustAsResourceUrl(html);
                    return $sce.trustAsHtml(html);
                }
                else {
                    return html;
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').filter('usPhone', [
        function () {
            return function (telephoneInput) {
                if (!telephoneInput) {
                    return '';
                }
                var value = telephoneInput.toString().trim().replace(/-/g, '');
                if (value.match(/[^0-9]/)) {
                    return telephoneInput;
                }
                var city = value.slice(0, 3);
                var number = value.slice(3);
                var outNumber = city + '-' + number.slice(0, 3) + '-' + number.slice(3);
                return outNumber.trim();
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ForgotPasswordAccountController", ['$scope', '$location', 'genericRepo', 'responseErrorService', 'routes', 'validationService', '$timeout',
        function ($scope, $location, genericRepo, responseErrorService, routes, validationService, $timeout) {
            $scope.validations = {};
            var unwatch = $scope.$watch('forgotpwform', function () {
                if ($scope.forgotpwform) {
                    $scope.validations = validationService($scope.forgotpwform);
                    unwatch();
                }
            });
            $scope.vm = {};
            $scope.vm.remote = {};
            $scope.forgot = {};
            $scope.forgot.option = 'account';
            $scope.changePage = function () {
                //$scope.$parent.logAction('ForgotPW-PageChange', 'Change to email entry');
                $location.url(routes.forgotPasswordEmail);
            };
            //Fix for bug 8172: Need to move cursor to first field after selections
            $scope.init = function () {
                $scope.$parent.initializeForgotPasswordProcess();
                $timeout(function () {
                    if ($scope.vm.remote.init) {
                        $scope.vm.remote.init();
                    }
                }, 25);
            };
            $scope.submitInfo = function (formIsValid) {
                if (formIsValid) {
                    storeUnusedFields();
                    //$scope.$parent.logAction('ForgotPW-submitAccount()', 'Send account info to api', $scope.forgot, ['driversLicense', 'taxIdNumber']);
                    genericRepo.dataFactory.submitAccount(angular.toJson($scope.forgot)).then(function (response) {
                        if (response.errors.length == 0) {
                            //$scope.$parent.logAction('ForgotPW-submitAccount()', 'Receive api response', response);
                            $scope.$parent.setSessionInformation({
                                securityQuestionId: response.securityQuestionID,
                                dbSessionId: response.dbSessionId,
                                userName: response.loginId,
                                securityQuestion: response.securityQuestion,
                                accountId: response.acctId,
                                emailAddress: response.emailAddress
                            });
                            $location.url(routes.forgotPasswordValidateAccount);
                        }
                        else {
                            //$scope.$parent.logAction('ForgotPW-submitAccount()', 'Receive api error response', response);
                            refillUnusedFields();
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                }
            };
            // Consider refactoring with the same set of code from SetupOnlineAccessIdentificationController
            var idValue1, idValue2;
            var storeUnusedFields = function () {
                if ($scope.forgot.accountInfo === 'account') {
                    idValue1 = $scope.forgot.tagNumber;
                    $scope.forgot.tagNumber = '';
                }
                else if ($scope.forgot.accountInfo === 'tag') {
                    idValue1 = $scope.forgot.accountNumber;
                    $scope.forgot.accountNumber = '';
                }
                if ($scope.forgot.personalInfo === 'driversLicense') {
                    idValue2 = $scope.forgot.taxIdNumber;
                    $scope.forgot.taxIdNumber = '';
                }
                else if ($scope.forgot.personalInfo === 'taxId') {
                    idValue2 = $scope.forgot.driversLicense;
                    $scope.forgot.driversLicense = '';
                }
            };
            var refillUnusedFields = function () {
                if (idValue1 != null) {
                    if ($scope.forgot.accountInfo === 'account') {
                        $scope.forgot.tagNumber = idValue1;
                    }
                    else if ($scope.forgot.accountInfo === 'tag') {
                        $scope.forgot.accountNumber = idValue1;
                    }
                }
                if (idValue2 != null) {
                    if ($scope.forgot.personalInfo === 'driversLicense') {
                        $scope.forgot.taxIdNumber = idValue2;
                    }
                    else if ($scope.forgot.personalInfo === 'taxId') {
                        $scope.forgot.driversLicense = idValue2;
                    }
                }
            };
            $scope.init();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ForgotPasswordController", ['$location', '$scope', 'routes', 'validationService',
        function ($location, $scope, routes, validationService) {
            $scope.validations = {};
            $scope.validations = validationService($scope.forgotpwform);
            $scope.forgot = {};
            $scope.forgot.option = 'waterm';
            $scope.changePage = function () {
                //$scope.$parent.logAction('ForgotPwCtrl-changePage', 'Switching between email and account');
                if ($scope.forgot.option === 'email') {
                    $location.url(routes.forgotPasswordEmail);
                }
                else if ($scope.forgot.option === 'account') {
                    $location.url(routes.forgotPasswordAccount);
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller("ForgotPasswordEmailController", ['$location', '$scope', 'responseErrorService', 'genericRepo', 'routes', 'removeDoubleCharService', 'validationService',
        function ($location, $scope, responseErrorService, genericRepo, routes, removeDoubleCharService, validationService) {
            init();
            function init() {
                $scope.$parent.initializeForgotPasswordProcess();
            }
            $scope.validations = {};
            var unwatch = $scope.$watch('forgotpwform', function () {
                if ($scope.forgotpwform) {
                    $scope.validations = validationService($scope.forgotpwform);
                    unwatch();
                }
            });
            $scope.forgot = {};
            $scope.forgot.option = 'email';
            $scope.removeDoubles = function (input, itm) {
                var val = removeDoubleCharService.removeDoubleChar(input);
                if (val) {
                    $scope.forgot[itm] = val;
                }
            };
            $scope.changePage = function () {
                //$scope.$parent.logAction('ForgotPW-PageChange', 'Change to account entry');
                $location.url(routes.forgotPasswordAccount);
            };
            $scope.submitEmail = function (formIsValid) {
                if (formIsValid) {
                    //$scope.$parent.logAction('ForgotPW-submitEmail()', 'Send email to api', $scope.forgot);
                    genericRepo.dataFactory.submitEmail(angular.toJson($scope.forgot)).then(function (response) {
                        if (response.errors.length == 0) {
                            //$scope.$parent.logAction('ForgotPW-submitEmail()', 'Receive api response', response);
                            $scope.$parent.setSessionInformation({ emailAddress: response.emailAddress });
                            $location.url(routes.forgotPasswordEmailSent);
                        }
                        else {
                            //$scope.$parent.logAction('ForgotPW-submitEmail()', 'Receive error api response', response);
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ForgotPasswordEmailSentController", ['$scope', '$location', 'routes',
        function ($scope, $location, routes) {
            init();
            function init() {
                if ($scope.$parent.redirectOccurredDueToInvalidState()) {
                    return;
                }
                $scope.email = $scope.$parent.getSessionInformation().emailAddress;
            }
            $scope.goToHelpAndSupport = function () {
                //$scope.$parent.logAction('ForgotPwEmailSent-helpSupport', 'Going to help and support');
                $location.url(routes.contactUs);
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var ForgotPasswordParentController = /** @class */ (function () {
            function ForgotPasswordParentController($scope, $state, stateNames) {
                this.$scope = $scope;
                this.$state = $state;
                this.stateNames = stateNames;
                var _sessionInformation = null;
                var _lastStep = null;
                var stateIsValid = {}; // register state-is-valid functions here
                stateIsValid[stateNames.forgotPasswordEmailSent] = function () {
                    return (_sessionInformation && _sessionInformation.emailAddress && _lastStep === stateNames.forgotPasswordEmail);
                };
                stateIsValid[stateNames.forgotPasswordValidateAccount] = function () {
                    if (!_sessionInformation || !_sessionInformation.dbSessionId || !_lastStep) {
                        return false;
                    }
                    switch (_lastStep) {
                        case (stateNames.forgotPasswordAccount): return true;
                        case (stateNames.forgotPasswordReset): return true;
                        default: return false;
                    }
                };
                stateIsValid[stateNames.forgotPasswordValidateAccountEmail] = function () {
                    return true;
                };
                stateIsValid[stateNames.forgotPasswordReset] = function () {
                    if (!_sessionInformation || !_sessionInformation.dbSessionId || !_lastStep) {
                        return false;
                    }
                    switch (_lastStep) {
                        case (stateNames.forgotPasswordValidateAccountEmail): return true;
                        case (stateNames.forgotPasswordValidateAccount): return true;
                        default: return false;
                    }
                };
                $scope.setSessionInformation = function (sessionInfo) {
                    _sessionInformation = angular.copy(sessionInfo);
                };
                $scope.getSessionInformation = function () {
                    return angular.copy(_sessionInformation);
                };
                $scope.redirectOccurredDueToInvalidState = function () {
                    var attemptedState = $state.current.name;
                    if (stateIsValid[attemptedState]()) {
                        _lastStep = attemptedState;
                        return false;
                    }
                    else {
                        $state.go(stateNames.forgotPassword);
                        return true;
                    }
                };
                $scope.initializeForgotPasswordProcess = function () {
                    _lastStep = $state.current.name;
                    _sessionInformation = null;
                };
            }
            ForgotPasswordParentController.$inject = ["$scope",
                "$state",
                "stateNames"];
            return ForgotPasswordParentController;
        }());
        Controller.ForgotPasswordParentController = ForgotPasswordParentController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").controller("ForgotPasswordParentController", HCTRA.Controller.ForgotPasswordParentController);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("PasswordResetController", ['$scope', 'accountOverviewRoutes', '$location', 'responseErrorService', '$timeout', 'genericRepo', 'routes', 'hctraSessionLogin', '$rootScope', 'AUTH_EVENTS', 'validationService', '$state', 'SessionService', 'USER_ROLES', 'AuthService', 'suspendedAccountService', 'CurrentUser', 'isInvoicedService', 'accountBlockPopupService', 'linkLookupService',
        function ($scope, accountOverviewRoutes, $location, responseErrorService, $timeout, genericRepo, routes, hctraSessionLogin, $rootScope, AUTH_EVENTS, validationService, $state, SessionService, USER_ROLES, AuthService, suspendedAccountService, CurrentUser, isInvoicedService, accountBlockPopupService, linkLookupService) {
            var waitTimeToNextPageLoad = 4000;
            $scope.forgot = {};
            $scope.secRequired = false;
            var unwatch = $scope.$watch('forgotpwform', function () {
                if ($scope.forgotpwform) {
                    $scope.violations = validationService($scope.forgotpwform);
                    unwatch();
                }
            });
            $scope.secAnswerSet = function () {
                if ($scope.forgot.securityQuestionAnswer && $scope.forgot.securityQuestionID === "-1" && $scope.forgotpwform.$submitted) {
                    $scope.forgotpwform.secQuestion.$setValidity('required', false);
                }
                else {
                    $scope.forgotpwform.secQuestion.$setValidity('required', true);
                }
            };
            $scope.isItalic = function (member) {
                if ($scope.forgot[member] !== '-1') {
                    return '';
                }
                else {
                    return 'setItalic';
                }
            };
            $scope.init = function () {
                if ($scope.$parent.redirectOccurredDueToInvalidState()) {
                    return;
                }
                $scope.forgot.user = $scope.$parent.getSessionInformation().userName;
                //$scope.$parent.logAction('PWReset-getSecurityQuestions()', 'In init');
                genericRepo.dataFactory.getSecurityQuestions().then(function (response) {
                    //check to see if system error
                    if (response.errors.length === 0) {
                        //$scope.$parent.logAction('PWReset-getSecurityQuestions()', 'Receive response', response);
                        //no system error or exception     
                        $scope.securityQuestions = response.securityQuestions;
                        //set the default
                        $scope.forgot.securityQuestionID = "-1";
                    }
                    else {
                        //$scope.$parent.logAction('PWReset-getSecurityQuestions()', 'Receive error response', response);
                        responseErrorService.displayErrorsFromResponse(response);
                    }
                });
                var request = {
                    itemId: $state.current.cms.itemId,
                    fields: $state.current.cms.fields
                };
                genericRepo.dataFactory.getCmsPageById(request).then(function (res) {
                    if (res.errors.length === 0) {
                        var parsedRes = angular.fromJson(res.cmsResponse);
                        accountBlockPopupService.savePopupMessages(parsedRes.Popups);
                    }
                    else {
                        responseErrorService.displayErrorsFromResponse(res);
                    }
                });
            };
            $scope.submitInfo = function (formIsValid) {
                $scope.forgotpwform.$submitted = true;
                $scope.secAnswerSet();
                if (formIsValid && $scope.forgotpwform.$valid) {
                    //keep error messages from popping up
                    $scope.violations = {};
                    var obj = {};
                    obj.password = $scope.forgot.password;
                    obj.password2 = $scope.forgot.password2;
                    var sessionInformation = $scope.$parent.getSessionInformation();
                    obj.dbSessionId = sessionInformation.dbSessionId;
                    obj.userName = sessionInformation.userName;
                    obj.accountId = sessionInformation.accountId;
                    obj.email = sessionInformation.emailAddress;
                    //if security question ID and answer not changed, send current
                    if (!$scope.forgot.securityQuestionAnswer) {
                        //$scope.$parent.logAction('PWReset-submit', 'Submitting pw change - No sec question/answer change');
                        obj.securityQuestionAnswer = sessionInformation.securityAnswer;
                        obj.securityQuestionID = sessionInformation.securityQuestionId;
                    }
                    else {
                        //$scope.$parent.logAction('PWReset-submit', 'Submitting pw change - Update sec question/answer');
                        obj.securityQuestionAnswer = $scope.forgot.securityQuestionAnswer;
                        obj.securityQuestionID = $scope.forgot.securityQuestionID;
                    }
                    //$scope.$parent.logAction('PWReset-resetPassword()', 'call pw reset api', obj, ['password', 'password2', 'securityQuestionAnswer']);
                    genericRepo.dataFactory.resetPassword(angular.toJson(obj)).then(function (response) {
                        if (response.errors.length === 0) {
                            //$scope.$parent.logAction('PWReset-resetPassword()', 'receive api response', response);
                            if (!response.fromMobileApp) {
                                //set the session for login in angular
                                hctraSessionLogin.login(response.acctId, response.acctActivity, response.newAccountStep.currentStep);
                                //set if account invoiced
                                isInvoicedService.setAccountInvoiced(response.isInvoiced);
                                CurrentUser.updateCurrentUser(response);
                                //set login for system
                                $rootScope.$broadcast(AUTH_EVENTS.loginSuccess, response);
                                responseErrorService.displayToast("Info updated successfully. Logging in...", 'info', false);
                                $timeout(function () {
                                    if (response.acctActivity === "P") {
                                        $state.go(SessionService.stepToStateName(response.newAccountStep.currentStep));
                                    }
                                    else if (AuthService.isAuthorized(USER_ROLES.suspended)) {
                                        suspendedAccountService.getFirstSuspendedAccountState().then($state.go);
                                    }
                                    else {
                                        $location.url(accountOverviewRoutes.Frame);
                                    }
                                }, waitTimeToNextPageLoad);
                            }
                            else {
                                $location.url(linkLookupService.articleLookupById(response.isExpressAccount
                                    ? routes.mobileExpressAppPasswordReset
                                    : routes.mobileAppPasswordReset));
                            }
                        }
                        else {
                            //$scope.$parent.logAction('PWReset-resetPassword()', 'receive error api response', response);
                            //re-add the validations to allow 2nd attempt
                            $scope.violations = validationService($scope.forgotpwform);
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                }
            };
            $scope.init();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ValidateAccountController", ['$scope', '$location', 'responseErrorService', 'genericRepo', 'routes', 'validationService',
        function ($scope, $location, responseErrorService, genericRepo, routes, validationService) {
            $scope.forgot = {};
            init();
            function init() {
                if ($scope.$parent.redirectOccurredDueToInvalidState()) {
                    return;
                }
                var sessionInformation = $scope.$parent.getSessionInformation();
                $scope.question = sessionInformation.securityQuestion;
                if (sessionInformation && sessionInformation.securityAnswer) {
                    $scope.forgot.answer = sessionInformation.securityAnswer;
                }
            }
            var unwatch = $scope.$watch('forgotpwform', function () {
                if ($scope.forgotpwform) {
                    $scope.validations = validationService($scope.forgotpwform);
                    unwatch();
                }
            });
            $scope.submitAnswer = function (formIsValid) {
                if (formIsValid) {
                    var sessionInformation = $scope.$parent.getSessionInformation();
                    $scope.forgot.dbSessionId = sessionInformation.dbSessionId;
                    $scope.forgot.accountId = sessionInformation.accountId;
                    //$scope.$parent.logAction('ValidateAcct-submitSecurityAnswer()', 'make api call', $scope.forgot, ['answer']);
                    genericRepo.dataFactory.submitSecurityAnswer(angular.toJson($scope.forgot)).then(function (response) {
                        if (response.errors.length == 0) {
                            //$scope.$parent.logAction('ValidateAcct-submitSecurityAnswer()', 'receive api response', response, ['secAns']);
                            sessionInformation.securityAnswer = response.securityAnswer;
                            $scope.$parent.setSessionInformation(sessionInformation);
                            $location.url(routes.forgotPasswordReset);
                        }
                        else {
                            //$scope.$parent.logAction('ValidateAcct-submitSecurityAnswer()', 'receive error api response', response);
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                }
            };
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("ValidateAccountEmailController", ['$scope', 'loginRoutes', '$location', 'responseErrorService', 'genericRepo', 'routes', 'validationService', 'objectUtilService', '$state', 'stateNames',
        function ($scope, loginRoutes, $location, responseErrorService, genericRepo, routes, validationService, objectUtilService, $state, stateNames) {
            $scope.forgot = {};
            var unwatch = $scope.$watch('forgotpwform', function () {
                if ($scope.forgotpwform) {
                    $scope.validations = validationService($scope.forgotpwform);
                    unwatch();
                }
            });
            $scope.init = function () {
                if ($scope.$parent.redirectOccurredDueToInvalidState()) {
                    return;
                }
                var sessionInformation = $scope.$parent.getSessionInformation();
                if (sessionInformation && sessionInformation.securityAnswer) {
                    $scope.forgot.answer = sessionInformation.securityAnswer;
                }
                var id = objectUtilService.toLowerCaseKeys($location.search()).id;
                $scope.sentEmailId = id;
                //if the ID is not present, reject from page
                if ((id.length < 20) || (!id) || (id === true)) {
                    $location.url(loginRoutes.Login);
                    return;
                }
                //$scope.$parent.logAction('ValidateAcctEmail-emailSecurityQuestion()', 'make api call for id ' + id);
                genericRepo.dataFactory.emailSecurityQuestion(angular.toJson({ sentId: id }))
                    .then($scope.processEmaiSecurityQuestionResponse);
            };
            $scope.processEmaiSecurityQuestionResponse = function (response) {
                if (angular.isArray(response.errors) && response.errors.length === 0) {
                    //$scope.$parent.logAction('ValidateAcctEmail-emailSecurityQuestion()', 'get api call', response);
                    $scope.question = response.securityQuestion + '?';
                    $scope.$parent.setSessionInformation({
                        securityQuestionId: response.securityQuestionId,
                        dbSessionId: response.dbSessionId,
                        emailAddress: response.emailAddress,
                        accountId: response.acctId,
                        userName: response.loginId
                    });
                }
                else {
                    $state.go(stateNames.forgotPasswordEmail);
                    responseErrorService.displayErrorsFromResponse(response, true);
                }
            };
            $scope.submitAnswer = function (formIsValid) {
                if (formIsValid) {
                    var sessionInformation = $scope.$parent.getSessionInformation();
                    $scope.forgot.dbSessionId = sessionInformation.dbSessionId;
                    $scope.forgot.accountId = sessionInformation.accountId;
                    //$scope.$parent.logAction('ValidateAcctEmail-submitSecurityAnswer', 'make api call', $scope.forgot, ['answer']);
                    genericRepo.dataFactory.submitSecurityAnswer(angular.toJson($scope.forgot)).then(function (response) {
                        if (response.errors.length == 0) {
                            //$scope.$parent.logAction('ValidateAcctEmail-submitSecurityAnswer', 'get api response', response, ['secAns']);
                            sessionInformation.securityAnswer = response.securityAnswer;
                            $scope.$parent.setSessionInformation(sessionInformation);
                            $location.url(routes.forgotPasswordReset);
                        }
                        else {
                            //$scope.$parent.logAction('ValidateAcctEmail-submitSecurityAnswer', 'get api error response', response);
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                }
            };
            $scope.init();
        }
    ]);
}());
describe("GoogleSearchComponent test", function () {
    var component;
    var $rootScope;
    var $window;
    var $location;
    var routes;
    var homeRoutes;
    beforeEach(angular.mock.module("HCTRAModule"));
    beforeEach(angular.mock.inject(function ($injector) {
        $rootScope = jasmine.createSpyObj("$rootScope", ["$on", "$broadcast"]);
        $window = {
            google: {
                search: {
                    cse: {
                        element: jasmine.createSpyObj("element", ["render"])
                    }
                }
            },
            location: {
                hash: "TO BE MOCKED"
            }
        };
        $location = jasmine.createSpyObj("$location", ["path", "hash"]);
        routes = $injector.get('routes');
        homeRoutes = $injector.get('homeRoutes');
        component = new HCTRA.Controller.GoogleSearchController($rootScope, $window, $location, routes, homeRoutes);
    }));
    it("can create a component", function () {
        expect(component).toBeDefined();
    });
});
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var GoogleSearchController = /** @class */ (function () {
            function GoogleSearchController($rootScope, $window, $location, routes, homeRoutes) {
                var _this = this;
                this.$rootScope = $rootScope;
                this.$window = $window;
                this.$location = $location;
                this.routes = routes;
                this.homeRoutes = homeRoutes;
                this.componentConfig = {
                    div: "searchfield",
                    tag: "searchbox",
                    gname: "generalSearch",
                    attributes: {
                        queryParameterName: "searchQuery",
                        autoSearchOnLoad: true,
                        enableAutoComplete: true,
                        autoCompleteMatchType: "any",
                        autoCompleteMaxCompletions: 10,
                        filter: "1"
                    }
                };
                this.optComponentConfig = {
                    div: "searchResults",
                    tag: "searchresults",
                    gname: "generalSearch",
                    attributes: {
                        enableOrderBy: true,
                        noResultsString: "Please try searching again with different key words."
                    }
                };
                this.$onInit = function () {
                    _this.startUrlListener();
                    _this.$rootScope.$broadcast("showGlobalSearchBar", { shouldShow: false });
                };
                this.$postLink = function () {
                    _this.$window["google"].search.cse.element.render(_this.componentConfig, _this.optComponentConfig);
                };
                this.$onDestroy = function () {
                    _this.deregisterUrlListener();
                    _this.$rootScope.$broadcast("showGlobalSearchBar", { shouldShow: true });
                };
                this.startUrlListener = function () {
                    _this.deregisterUrlListener = _this.$rootScope.$on("$locationChangeStart", _this.handleAutomaticUrlChange);
                };
                this.handleAutomaticUrlChange = function (event, next, current) {
                    if (next.indexOf(_this.homeRoutes.Frame) > -1 && current.indexOf(_this.routes.search) <= -1) {
                        var urlHash = decodeURIComponent(_this.$window.location.hash.replace("#", ""));
                        _this.$location.path(_this.routes.search);
                        _this.$location.hash(urlHash);
                        event.preventDefault();
                    }
                };
            }
            GoogleSearchController.$inject = [
                "$rootScope",
                "$window",
                "$location",
                "routes",
                "homeRoutes"
            ];
            return GoogleSearchController;
        }());
        Controller.GoogleSearchController = GoogleSearchController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").component("googleSearchComponent", {
        templateUrl: "/app/googleSearch/googleSearch.html",
        bindings: {},
        controller: HCTRA.Controller.GoogleSearchController
    });
})();
describe("EmailUsConfirmationSlidingPanelComponent tests", function () {
    var component;
    var ezTagAppRedirectLinkService;
    var $window;
    beforeEach(angular.mock.module('HCTRAModule'));
    beforeEach(angular.mock.inject(function ($injector) {
        ezTagAppRedirectLinkService = jasmine.createSpyObj("ezTagAppRedirectLinkService", ["getEzTagAppLink"]);
        $window = jasmine.createSpyObj("$window", ["location"]);
        component = new HCTRA.Controller.EmailUsConfirmationSlidingPanelController(ezTagAppRedirectLinkService, $window);
        component["resolve"] = {
            faqContent: {
                Title: "Title",
                ShortDescription: "random Text",
                LongDescription: "Long text"
            },
            comingFromEzTagMobileApp: false
        };
        component.close = function () { };
        spyOn(component, "redirect").and.callThrough();
        spyOn(component, "close");
    }));
    it("component created", function () {
        expect(component).toBeDefined();
    });
    describe("$onInit", function () {
        it("should set mappEzTagRedirectLink to true and redirectText is 'Return to mobile app'", function () {
            //Assemble
            ezTagAppRedirectLinkService.getEzTagAppLink.and.returnValue("a string");
            component.resolve.comingFromEzTagMobileApp = true;
            //Act
            component.$onInit();
            //Assert
            expect(component.mappEzTagRedirectLink).toEqual("a string");
            expect(component.redirectText).toEqual("Return to mobile app");
        });
        it("should keep mappEzTagRedirectLink to null and redirectText is 'Back to Help & Support page'", function () {
            //Assemble
            ezTagAppRedirectLinkService.getEzTagAppLink.and.returnValue("a string");
            component.resolve.comingFromEzTagMobileApp = false;
            //Act
            component.$onInit();
            //Assert
            expect(component.mappEzTagRedirectLink).toEqual(false);
            expect(component.redirectText).toEqual("Back to Help & Support page");
        });
    });
    describe("redirect", function () {
        it("should set $window.location.href", function () {
            //Assemble
            component.mappEzTagRedirectLink = true;
            //Act
            component.redirect();
            //Assert
            expect(component.$window.location.href).toEqual(component.mappEzTagRedirectLink);
        });
        it("should not set $window.location.href and call close()", function () {
            //Assemble
            component.mappEzTagRedirectLink = false;
            //Act
            component.redirect();
            //Assert
            expect(component.$window.location.href).not.toEqual(component.mappEzTagRedirectLink);
            expect(component.close).toHaveBeenCalledTimes(1);
            expect(component.close).toHaveBeenCalledWith({ $value: true });
        });
    });
    describe("onClose", function () {
        it("should call close with $value", function () {
            //Act
            component.onClose();
            //Assert
            expect(component.close).toHaveBeenCalledTimes(1);
            expect(component.close).toHaveBeenCalledWith({ $value: true });
        });
    });
});
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var EmailUsConfirmationSlidingPanelController = /** @class */ (function () {
            function EmailUsConfirmationSlidingPanelController(ezTagAppRedirectLinkService, $window) {
                var _this = this;
                this.ezTagAppRedirectLinkService = ezTagAppRedirectLinkService;
                this.$window = $window;
                this.mappEzTagRedirectLink = null;
                this.redirect = function () {
                    if (_this.mappEzTagRedirectLink) {
                        _this.$window.location.href = _this.mappEzTagRedirectLink;
                    }
                    else {
                        _this.close({ $value: true });
                    }
                };
                this.onClose = function () {
                    _this.close({ $value: true });
                };
            }
            EmailUsConfirmationSlidingPanelController.prototype.$onInit = function () {
                this.mappEzTagRedirectLink = this.resolve.comingFromEzTagMobileApp && this.ezTagAppRedirectLinkService.getEzTagAppLink();
                this.redirectText = this.mappEzTagRedirectLink ? "Return to mobile app" : "Back to Help & Support page";
            };
            EmailUsConfirmationSlidingPanelController.$inject = ["ezTagAppRedirectLinkService", "$window"];
            return EmailUsConfirmationSlidingPanelController;
        }());
        Controller.EmailUsConfirmationSlidingPanelController = EmailUsConfirmationSlidingPanelController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module('HCTRAModule')
        .component("emailUsConfirmationSlidingPanel", {
        templateUrl: '/app/helpAndSupport/emailUsConfirmationSlidingPanel.html',
        bindings: {
            close: "&",
            dismiss: "&",
            resolve: "<"
        },
        controller: HCTRA.Controller.EmailUsConfirmationSlidingPanelController
    });
})();
describe("emailUsSlidingPanelComponent", function () {
    var component;
    var $location;
    var $filter;
    var AuthService;
    var validationService;
    var genericRepo;
    var responseErrorService;
    var removeDoubleCharService;
    var bowserService;
    var modalService;
    var helpAndSupportService;
    var $q;
    var usPhone;
    beforeEach(angular.mock.module("HCTRAModule"));
    beforeEach(angular.mock.inject(function ($injector) {
        $location = jasmine.createSpyObj("$location", ["host"]);
        $filter = $injector.get("$filter");
        AuthService = jasmine.createSpyObj("AuthService", ["isAuthenticated"]);
        validationService = $injector.get("validationService");
        genericRepo = {
            dataFactory: jasmine.createSpyObj("dataFactory", ['getHelpAndSupportInformation', 'sendHelpAndSupportEmail'])
        };
        responseErrorService = jasmine.createSpyObj("responseErrorService", ["isErrorFree", "displayToast", "displayErrorsFromResponse"]);
        removeDoubleCharService = $injector.get('removeDoubleCharService');
        bowserService = $injector.get('bowserService');
        modalService = jasmine.createSpyObj("modalService", ["showSlidingModal"]);
        helpAndSupportService = jasmine.createSpyObj("helpAndSupportService", ["createFormMapping", "mapFields"]);
        $q = $injector.get("replacementQService");
        component = new HCTRA.Controller.EmailUsSlidingPanelController($location, $filter, AuthService, validationService, genericRepo, responseErrorService, removeDoubleCharService, bowserService, modalService, helpAndSupportService, $q);
        component.resolve = {
            helpAndSupportFullCMS: {
                Children: [
                    {
                        FieldSelection: "Email Us",
                        ItemName: "ItemNameFAKE",
                        Children: [
                            {
                                ItemName: "Topics",
                                Children: [
                                    {
                                        ItemName: "Email Us",
                                        Form: "Email Us",
                                        Fields: {}
                                    },
                                    {
                                        ItemName: "Please Select Topic",
                                        Form: "Please Select Topic",
                                        Fields: []
                                    },
                                    {
                                        ItemName: "FakeForm",
                                        Form: "FakeForm",
                                        Fields: []
                                    }
                                ]
                            },
                            {
                                ItemName: "Forms",
                                Children: [
                                    {
                                        ItemName: "Please Select Topic",
                                        Form: "Please Select Topic",
                                        Fields: [
                                            {
                                                ItemName: "Field1"
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                ItemName: "FieldTypes"
                            },
                            {
                                ItemName: "Fields"
                            },
                            {
                                ItemName: "AboveFormContent"
                            },
                            {
                                ItemName: "BelowFormContent"
                            },
                            {
                                ItemName: "Forms",
                                Children: [
                                    {
                                        ItemName: "Please Select Topic",
                                        Children: [
                                            {
                                                ItemName: "Fields",
                                                Children: []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                ItemName: "Shared Forms",
                                Children: [
                                    {
                                        ItemName: "Email Us",
                                        Form: "Email Us",
                                        Children: [
                                            {
                                                ItemName: "Fields",
                                                Children: []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            emailTopicFromURLSearchQuery: null
        };
        helpAndSupportService.createFormMapping.and.returnValue({
            aboveFormContent: { ItemName: "AboveFormContent" },
            belowFormContent: { ItemName: "BelowFormContent" },
            FakeFormName: { Fields: [] },
            "Please Select Topic": { Fields: [] },
            FakeFormWithRequiredField: {
                ItemName: "FakeFormWithRequiredField",
                Form: "FakeFormWithRequiredField",
                Fields: [
                    {
                        Field: "RequiredField",
                        IsRequired: true
                    }
                ]
            },
            FakeFormWithNoRequiredField: {
                ItemName: "FakeFormWithNoRequiredField",
                Form: "FakeFormWithNoRequiredField",
                Fields: [
                    {
                        Field: "NotARequiredField",
                        IsRequired: false
                    }
                ]
            }
        });
        helpAndSupportService.mapFields.and.returnValue([]);
        spyOn(component, "getEmailTopicObj").and.callThrough();
        spyOn(component, "parseEmailUs").and.callThrough();
        spyOn(component, "fieldsContent").and.callThrough();
        spyOn(component, "formHasField").and.callThrough();
        spyOn(component, "setAccountDetails").and.callThrough();
        spyOn(component, "changeTopic").and.callThrough();
        spyOn(component, "submitFormItems").and.callThrough();
        genericRepo.dataFactory.getHelpAndSupportInformation
            .and.returnValue(new Promise(function (resolve) { return resolve({ errors: [] }); }));
        component.webFormFields = { HCTRAAccount: 9887654321 };
        usPhone = $filter('usPhone');
    }));
    it("can create a component", function () {
        //assert
        expect(component).toBeDefined();
        expect(component.helpAndSupportDetails).toBeDefined();
        expect(component.helpAndSupportDetails.Files).toBeDefined();
        expect(component.helpAndSupportDetails.Files.length).toBe(0);
    });
    describe("onInit()", function () {
        it("calls parseEmailUs()", function () {
            //Assemble
            AuthService.isAuthenticated.and.returnValue(false);
            //Act
            component.$onInit();
            //Assert
            expect(component["parseEmailUs"]).toHaveBeenCalledTimes(1);
        });
    });
    describe("$postLink()", function () {
        it("calls getEmailTopicObj()", function () {
            //Assemble
            AuthService.isAuthenticated.and.returnValue(false);
            component.$onInit();
            //Act
            component.$postLink();
            //Assert
            expect(component["getEmailTopicObj"]).toHaveBeenCalledTimes(1);
        });
        it("calls fieldsContent()", function () {
            //Assemble
            AuthService.isAuthenticated.and.returnValue(false);
            component.$onInit();
            //Act
            component.$postLink();
            //Assert
            expect(component["fieldsContent"]).toHaveBeenCalledTimes(2);
        });
        it("calls genericRepo.dataFactory.getHelpAndSupportInformation() 1 time when AuthService.isAuthenticated() is TRUE", function () {
            //Assemble
            AuthService.isAuthenticated.and.returnValue(true);
            component.$onInit();
            //Act
            component.$postLink();
            //Assert
            expect(genericRepo.dataFactory.getHelpAndSupportInformation).toHaveBeenCalledTimes(1);
        });
        it("calls genericRepo.dataFactory.getHelpAndSupportInformation() 0 times when AuthService.isAuthenticated() is FALSE", function () {
            //Assemble
            AuthService.isAuthenticated.and.returnValue(false);
            component.$onInit();
            //Act
            component.$postLink();
            //Assert
            expect(genericRepo.dataFactory.getHelpAndSupportInformation).toHaveBeenCalledTimes(0);
        });
        it("calls getEmailTopicObjn() 1 times when this.resolve.emailTopicFromURLSearchQuery no matter if it exists", function () {
            //Assemble
            component.$onInit();
            //Act
            component.$postLink();
            //Assert
            expect(component.getEmailTopicObj).toHaveBeenCalledTimes(1);
        });
    });
    describe("parseEmailUs()", function () {
        it("should set emailUsSection", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsSection).toEqual(component.resolve.helpAndSupportFullCMS.Children.find(function (x) { return x.FieldSelection === 'Email Us'; }));
        });
        it("should set emailUsTopics", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsTopics).toEqual(component.emailUsSection.Children.find(function (x) { return x.ItemName === "Topics"; }).Children);
        });
        it("should set emailUsForms", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsForms).toEqual({
                aboveFormContent: { ItemName: "AboveFormContent" },
                belowFormContent: { ItemName: "BelowFormContent" },
                FakeFormName: { Fields: [] },
                "Please Select Topic": { Fields: [] },
                FakeFormWithRequiredField: {
                    ItemName: "FakeFormWithRequiredField",
                    Form: "FakeFormWithRequiredField",
                    Fields: [
                        {
                            Field: "RequiredField",
                            IsRequired: true
                        }
                    ]
                },
                FakeFormWithNoRequiredField: {
                    ItemName: "FakeFormWithNoRequiredField",
                    Form: "FakeFormWithNoRequiredField",
                    Fields: [
                        {
                            Field: "NotARequiredField",
                            IsRequired: false
                        }
                    ]
                }
            });
        });
        it("should set emailUsFields", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsFields).toEqual([]);
        });
        it("should set aboveFormContent", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsForms.aboveFormContent).toEqual(component.emailUsSection.Children.find(function (x) { return x.ItemName === "AboveFormContent"; }));
        });
        it("should set belowFormContent", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsForms.belowFormContent).toEqual(component.emailUsSection.Children.find(function (x) { return x.ItemName === "BelowFormContent"; }));
        });
        it("should set emailUsThankYouContent", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsThankYouContent).toEqual(component.emailUsSection.Children.find(function (x) { return x.ItemName === "ThankYouContent"; }));
        });
        it("should set emailUsSharedFormFields", function () {
            //Act
            component.parseEmailUs();
            //Assert
            expect(component.emailUsSharedFormFields).toEqual(component.emailUsSection.Children.find(function (x) { return x.ItemName === "Shared Forms"; }).Children.find(function (x) { return x.ItemName === "Email Us"; }).Children.find(function (x) { return x.ItemName === "Fields"; }).Children);
        });
    });
    describe("formHasField()", function () {
        it("should return false when field does not exist", function () {
            //Assemble
            component.helpAndSupportDetails = { emailTopic: { Form: "FakeFormWithRequiredField" } };
            component.parseEmailUs();
            //Act
            var result = component.formHasField("nonexistent field");
            //Assert
            expect(result).toEqual(false);
        });
        it("should return true when field exists and isRequired equals true", function () {
            //Assemble
            component.helpAndSupportDetails = { emailTopic: { Form: "FakeFormWithRequiredField" } };
            component.emailUsForms = {
                FakeFormWithRequiredField: {
                    Fields: [
                        {
                            Field: "testing"
                        }
                    ]
                }
            };
            //Act
            var result = component.formHasField("testing");
            //Assert
            expect(result).toEqual(true);
        });
        it("should return true when field exists and isRequired equals false", function () {
            //Assemble
            component.helpAndSupportDetails = { emailTopic: { Form: "NotARequiredField" } };
            component.emailUsForms = {
                NotARequiredField: {
                    Fields: [
                        {
                            Field: "testing",
                            IsRequired: false
                        }
                    ]
                }
            };
            //Act on false
            var result = component.formHasField("testing", false);
            //Assert
            expect(result).toEqual(true);
            //Act on true
            var result2 = component.formHasField("testing", true);
            //Assert
            expect(result2).toEqual(false);
        });
        it("should return false when field exists and isRequired equals false", function () {
            //Assemble
            component.helpAndSupportDetails = { emailTopic: { Form: "FakeFormWithNoRequiredField" } };
            component.parseEmailUs();
            //Act
            var result = component.formHasField("NotARequiredField", true);
            //Assert
            expect(result).toEqual(false);
        });
    });
    describe("openConfirmationSlidingPanel()", function () {
        it("calls modalService.showSlidingModal() 1 time", function () {
            //Assemble
            component.parseEmailUs();
            //Act
            component.openConfirmationSlidingPanel();
            //Assert
            expect(modalService.showSlidingModal).toHaveBeenCalledTimes(1);
        });
        it("calls modalService.showSlidingModal() with correct parameters", function () {
            //Assemble
            component.parseEmailUs();
            //Act
            component.openConfirmationSlidingPanel();
            //Assert
            expect(modalService.showSlidingModal).toHaveBeenCalledWith("emailUsConfirmationSlidingPanel", {
                emailUsThankYouContent: jasmine.any(Function),
                comingFromEzTagMobileApp: jasmine.any(Function)
            });
        });
    });
    describe("openFaqSlidingPanel()", function () {
        it("calls modalService.showSlidingModal() 1 time", function () {
            //Act
            component.openFaqSlidingPanel("fakeFAQ");
            //Assert
            expect(modalService.showSlidingModal).toHaveBeenCalledTimes(1);
        });
        it("calls modalService.showSlidingModal() with correct parameters", function () {
            //Assemble
            component.helpAndSupportDetails = { emailTopic: { Form: "fakeForm" } };
            //Act
            component.openFaqSlidingPanel("fakeFAQ");
            //Assert
            expect(modalService.showSlidingModal).toHaveBeenCalledWith("faqSlidingPanel", {
                faqContent: jasmine.any(Function)
            });
        });
    });
    describe("fieldIs()", function () {
        it("returns true", function () {
            //Assemble
            component.parseEmailUs();
            var fieldsArray = ["fakeField1", "fakeField2"];
            //Act
            var result = component.fieldIs("fakeField1", fieldsArray);
            //Assert
            expect(result).toEqual(true);
        });
        it("returns false", function () {
            //Assemble
            component.parseEmailUs();
            var fieldsArray = ["fakeField1", "fakeField2"];
            //Act
            var result = component.fieldIs("fieldThatDoesNotExist", fieldsArray);
            //Assert
            expect(result).toEqual(false);
        });
    });
    describe("fieldsContent()", function () {
        it("returns correct array", function () {
            //Assemble
            var formFieldsArray = [
                {
                    Field: "FakeFieldObj"
                }
            ];
            var allFieldsObj = { FakeFieldObj: { ItemName: "" } };
            //Act
            var result = component.fieldsContent(allFieldsObj, formFieldsArray);
            //Assert
            expect(result).toEqual({ FakeFieldObj: { ItemName: "" } });
        });
    });
    describe("typeIs()", function () {
        it("returns true", function () {
            //Assemble
            component.cmsFormFieldsInfo = { input: { Type: "input" } };
            //Act
            var result = component.typeIs("input", "input");
            //Assert
            expect(result).toEqual(true);
        });
        it("returns false", function () {
            //Assemble
            component.cmsFormFieldsInfo = { input: { Type: "input" } };
            //Act
            var result = component.typeIs("input", "notInput");
            //Assert
            expect(result).toEqual(false);
        });
    });
    describe("getEmailTopicObj()", function () {
        it("returns the correct object", function () {
            //Assemble
            component.parseEmailUs();
            var emailTopic = "FakeForm";
            //Act
            var result = component.getEmailTopicObj(emailTopic);
            //Assert
            expect(result).toEqual(component.emailUsTopics.find(function (x) { return x.ItemName === emailTopic; }));
        });
    });
    describe("changeTopic()", function () {
        it("calls fieldsContent 1 time", function () {
            //Assemble
            component.parseEmailUs();
            component.helpAndSupportDetails = { emailTopic: { Form: "FakeFormWithRequiredField" } };
            //Act
            component.changeTopic();
            //Assert
            expect(component.fieldsContent).toHaveBeenCalledTimes(1);
        });
    });
    describe("cancel()", function () {
        it("calls getEmailTopicObj 1 time", function () {
            //Assemble
            component.parseEmailUs();
            component.helpAndSupportDetails = { emailTopic: { Form: "FakeFormWithRequiredField" }, userAgentString: "my string" };
            //Act
            component.cancel();
            //Assert
            expect(component.getEmailTopicObj).toHaveBeenCalledTimes(1);
        });
        it("calls changeTopic 1 time", function () {
            //Assemble
            component.parseEmailUs();
            component.helpAndSupportDetails = { emailTopic: { Form: "FakeFormWithRequiredField" }, userAgentString: "my string" };
            //Act
            component.cancel();
            //Assert
            expect(component.changeTopic).toHaveBeenCalledTimes(1);
        });
    });
    describe("setAccountDetails()", function () {
        it("should set component.userDefaultData[field] to responseField", function () {
            //Assemble
            component.userDefaultData = { Hello: "thisShouldChange" };
            var fieldParam = "Hello";
            var responseFieldParam = 1;
            var modelParam = "webFormFields";
            component.webFormFields = { Hello: null };
            //Act
            component.setAccountDetails(fieldParam, responseFieldParam, modelParam);
            //Assert
            expect(component.userDefaultData[fieldParam]).toEqual(responseFieldParam);
        });
        it("should set component[model][field] to responseField", function () {
            //Assemble
            var fieldParam = "Hello";
            var responseFieldParam = 1;
            var modelParam = "webFormFields";
            component.webFormFields = { Hello: null };
            //Act
            component.setAccountDetails(fieldParam, responseFieldParam, modelParam);
            //Assert
            expect(component[modelParam][fieldParam]).toEqual(responseFieldParam);
        });
    });
    describe("isBold()", function () {
        it("sets dropDownHasSections to true  and function returns true", function () {
            //Assemble
            var optionParam = { Bold: "1" };
            component.dropdownHasSections = null;
            //Act
            var result = component.isBold(optionParam);
            //Assert
            expect(component.dropdownHasSections).toEqual(true);
            expect(result).toEqual(true);
        });
        it("does not change dropDownHasSections and function returns false", function () {
            //Assemble
            var optionParam = { Bold: 123456789 };
            component.dropdownHasSections = null;
            //Act
            var result = component.isBold(optionParam);
            //Assert
            expect(component.dropdownHasSections).toEqual(null);
            expect(result).toEqual(false);
        });
    });
    describe("displayName()", function () {
        it("sets dropDownHasSections to true  and function returns true", function () {
            //Assemble
            var optionParam = { Bold: 123456789, Name: "theName" };
            component.dropdownHasSections = true;
            //Act
            var result = component.displayName(optionParam);
            //Assert
            expect(result).toEqual("-" + optionParam["Name"]);
        });
        it("does not change dropDownHasSections and function returns false", function () {
            //Assemble
            var optionParam = { Bold: 123456789, Name: "theName" };
            component.dropdownHasSections = false;
            //Act
            var result = component.displayName(optionParam);
            //Assert
            expect(result).toEqual(optionParam["Name"]);
        });
    });
    describe("onBlurOrChangePhone()", function () {
        it("should set webFormFields[field} to be new filtered string", function () {
            //Assemble
            component.webFormFields = { Hello: 1234567890 };
            var fieldName = "Hello";
            var filteredString = usPhone(component.webFormFields[fieldName]);
            //Act
            var result = component.onBlurOrChangePhone(fieldName);
            //Assert
            expect(component.webFormFields[fieldName]).toEqual(filteredString);
        });
        it("should set helpAndSupportDetails[fieldName] to be new filtered string", function () {
            //Assemble
            component.webFormFields = { FieldWillNotBeFound: 1234567890 };
            component.helpAndSupportDetails = { Hello: 2222222222 };
            var fieldName = "Hello";
            var filteredString = usPhone(component.helpAndSupportDetails[fieldName]);
            //Act
            var result = component.onBlurOrChangePhone(fieldName);
            //Assert
            expect(component.helpAndSupportDetails[fieldName]).toEqual(filteredString);
        });
        it("should not alter helpAndSupportDetails or webformfields", function () {
            //Assemble
            component.webFormFields = { FieldWillNotBeFound: 1234567890 };
            component.helpAndSupportDetails = { FieldWillNotBeFound: 2222222222 };
            var fieldName = "Hello";
            var filteredString = usPhone(component.helpAndSupportDetails[fieldName]);
            //Act
            var result = component.onBlurOrChangePhone(fieldName);
            //Assert
            expect(component.helpAndSupportDetails[fieldName]).toBeUndefined();
            expect(component.webFormFields[fieldName]).toBeUndefined();
            expect(component.helpAndSupportDetails).toEqual({ FieldWillNotBeFound: 2222222222 });
            expect(component.webFormFields).toEqual({ FieldWillNotBeFound: 1234567890 });
        });
    });
    describe("removeDoubles()", function () {
        it("should call removeDoubleCharService.removeDoubleChar()", function () {
            //Assemble
            var member = "Hello";
            var inputParam = { Hello: "abbc" };
            spyOn(removeDoubleCharService, "removeDoubleChar").and.callFake(function () { });
            //Act
            var result = component.removeDoubles(inputParam, member);
            //Assert
            expect(removeDoubleCharService.removeDoubleChar).toHaveBeenCalledTimes(1);
        });
    });
    describe("assembleUserBrowserInfoMessage()", function () {
        it("should change detailsObj.userBrowserInfo", function () {
            //Assemble
            var detailsObj = { userBrowserInfo: "thisWillBechanged" };
            //Act
            component.assembleUserBrowserInfoMessage(detailsObj);
            //Assert
            expect(detailsObj.userBrowserInfo).not.toEqual("thisWillBechanged");
        });
        it("should add string '(may not be accurate for mobile browsers)' to  detailsObj.userBrowserInfo", function () {
            //Assemble
            component["bowserService"].bowser.mobile = true;
            var detailsObj = { userBrowserInfo: "thisWillBechanged" };
            //Act
            component.assembleUserBrowserInfoMessage(detailsObj);
            //Assert
            expect(detailsObj.userBrowserInfo).toContain("(may not be accurate for mobile browsers)");
        });
    });
    describe("submitFormItems()", function () {
        it("should call genericRepo with helpAndSupportDetails", function () {
            //Assemble
            component.isSendingEmail = false;
            component.helpAndSupportDetails = {};
            component.webFormFields = {
                Location: {
                    LocationID: 12345
                },
                Dropdown: 12345,
                Random: 'random'
            };
            component.cmsFormFieldsInfo = {
                Location: {
                    Label: "Location",
                    ItemName: "Location"
                },
                Dropdown: {
                    Label: "Dropdown",
                    ItemName: "Dropdown"
                },
                Random: {
                    Label: "Random",
                    ItemName: "Random"
                }
            };
            $location.host.and.callFake(function () { return "something"; });
            genericRepo.dataFactory.sendHelpAndSupportEmail
                .and.returnValue(new Promise(function (resolve) { return resolve({ errors: [] }); }));
            //Act
            component.submitFormItems();
            //Assert
            expect(genericRepo.dataFactory.sendHelpAndSupportEmail).toHaveBeenCalledTimes(1);
            expect(genericRepo.dataFactory.sendHelpAndSupportEmail).toHaveBeenCalledWith({
                host: 'something',
                userBrowserInfo: jasmine.any(String),
                Fields: [
                    {
                        Name: 'Location',
                        Label: 'Location',
                        Value: 12345
                    },
                    {
                        Name: 'Dropdown',
                        Label: 'Dropdown',
                        Value: 12345
                    },
                    {
                        Name: 'Random',
                        Label: 'Random',
                        Value: 'random'
                    }
                ]
            });
        });
        it("should call genericRepo with helpAndSupportDetails that have fields only in both web and cms fields", function () {
            //Assemble
            component.isSendingEmail = false;
            component.helpAndSupportDetails = {};
            component.webFormFields = {
                Location: {
                    LocationID: 12345
                },
                Random: "random"
            };
            component.cmsFormFieldsInfo = {
                Location: {
                    Label: "Location",
                    ItemName: "Location",
                    LocationID: 12345
                },
                Dropdown: {
                    Label: "Dropdown",
                    ItemName: "Dropdown",
                    LocationID: 12345
                }
            };
            $location.host.and.callFake(function () { return "something"; });
            genericRepo.dataFactory.sendHelpAndSupportEmail
                .and.returnValue(new Promise(function (resolve) { return resolve({ errors: [] }); }));
            //Act
            component.submitFormItems();
            //Assert
            expect(genericRepo.dataFactory.sendHelpAndSupportEmail).toHaveBeenCalledTimes(1);
            expect(genericRepo.dataFactory.sendHelpAndSupportEmail).toHaveBeenCalledWith({
                host: 'something',
                userBrowserInfo: jasmine.any(String),
                Fields: [
                    {
                        Name: 'Location',
                        Label: 'Location',
                        Value: 12345
                    }
                ]
            });
        });
    });
    describe("onSubmit()", function () {
        it("should call submitFormItems", function () {
            //Assemble
            var isValid = true;
            component.submitFormItems.and.callFake(function () { });
            //Act
            var result = component.onSubmit(isValid);
            //Assert
            expect(component.submitFormItems).toHaveBeenCalledTimes(1);
        });
        it("should not call submitFormItems", function () {
            //Assemble
            var isValid = false;
            component.submitFormItems.and.callFake(function () { });
            //Act
            var result = component.onSubmit(isValid);
            //Assert
            expect(component.submitFormItems).toHaveBeenCalledTimes(0);
        });
    });
    describe("formHasFieldRequired()", function () {
        it("should call submitFormItems", function () {
            //Assemble
            var field = "myField";
            component.formHasField.and.callFake(function () { });
            //Act
            var result = component.formHasFieldRequired(field);
            //Assert
            expect(component.formHasField).toHaveBeenCalledTimes(1);
        });
    });
    describe("onClose()", function () {
        it("should call component.close()", function () {
            //Assemble
            component.close = function () { };
            spyOn(component, "close");
            //Act
            var result = component.onClose();
            //Assert
            expect(component.close).toHaveBeenCalledTimes(1);
            expect(component.close).toHaveBeenCalledWith({
                $value: true
            });
        });
    });
    describe('onFileUploadRead', function () {
        it('flags component as attaching is starting', function () {
            component.isAttaching = false;
            component.onFileUploadRead({
                status: 'reading'
            });
            expect(component.isAttaching).toBeTrue();
        });
        it('clears any previous errors for upload when starting', function () {
            component.fileUploadErrors = {
                fileType: true,
                fileSize: true,
                fileRead: true
            };
            component.onFileUploadRead({ status: 'reading' });
            expect(component.fileUploadErrors).toEqual({});
        });
        it('flags component as no longer attaching when complete', function () {
            component.isAttaching = true;
            component.onFileUploadRead({ status: 'complete' });
            expect(component.isAttaching).toBeFalse();
        });
        it('adds an error type for uploads', function () {
            expect(component.fileUploadErrors).toEqual({});
            component.onFileUploadRead({
                status: 'error',
                errors: {
                    fileType: true,
                    fileSize: true,
                    fileRead: true
                }
            });
            expect(component.fileUploadErrors).toEqual({
                fileType: true,
                fileSize: true,
                fileRead: true
            });
        });
    });
});
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        "use strict";
        var EmailUsSlidingPanelController = /** @class */ (function () {
            function EmailUsSlidingPanelController($location, $filter, AuthService, validationService, genericRepo, responseErrorService, removeDoubleCharService, bowserService, modalService, helpAndSupportService, $q) {
                var _this = this;
                this.$location = $location;
                this.$filter = $filter;
                this.AuthService = AuthService;
                this.validationService = validationService;
                this.genericRepo = genericRepo;
                this.responseErrorService = responseErrorService;
                this.removeDoubleCharService = removeDoubleCharService;
                this.bowserService = bowserService;
                this.modalService = modalService;
                this.helpAndSupportService = helpAndSupportService;
                this.$q = $q;
                this.isSendingEmail = false;
                this.emailSent = false;
                this.userDefaultData = {
                    userAgentString: null,
                    YourName: null,
                    Email: null,
                    HCTRAAcct: null
                };
                this.fieldsToSpecify = ['Location', 'LicensePlate', 'State', 'TxTagAcct', 'FilesUpload', 'FirstName', 'LastName', 'Email', 'Comments'];
                this.dropdownHasSections = false;
                this.isAttaching = false;
                this.fileUploadErrors = {};
                this.onFileUploadRead = function (fileReadEvent) {
                    switch (fileReadEvent.status) {
                        case 'reading':
                            _this.isAttaching = true;
                            Object.keys(_this.fileUploadErrors).forEach(function (key) {
                                delete _this.fileUploadErrors[key];
                            });
                            break;
                        case 'complete':
                            _this.isAttaching = false;
                            break;
                        case 'error':
                            _this.isAttaching = false;
                            Object.keys(fileReadEvent.errors).forEach(function (key) {
                                _this.fileUploadErrors[key] = true;
                            });
                            break;
                    }
                };
                this.parseEmailUs = function () {
                    _this.emailUsSection = _this.resolve.helpAndSupportFullCMS.Children.find(function (x) { return x.FieldSelection === 'Email Us'; });
                    _this.emailUsTopics = _this.emailUsSection.Children.find(function (x) { return x.ItemName === "Topics"; }).Children;
                    _this.emailUsForms = _this.helpAndSupportService.createFormMapping(_this.emailUsSection.Children.find(function (x) { return x.ItemName === "Forms"; }).Children);
                    _this.emailUsFields = _this.helpAndSupportService.mapFields(_this.emailUsSection.Children.find(function (x) { return x.ItemName === "Fields"; }).Children);
                    _this.emailUsForms.aboveFormContent = _this.emailUsSection.Children.find(function (x) { return x.ItemName === "AboveFormContent"; });
                    _this.emailUsForms.belowFormContent = _this.emailUsSection.Children.find(function (x) { return x.ItemName === "BelowFormContent"; });
                    _this.emailUsThankYouContent = _this.emailUsSection.Children.find(function (x) { return x.ItemName === "ThankYouContent"; });
                    _this.emailUsSharedFormFields = _this.emailUsSection.Children.find(function (x) { return x.ItemName === "Shared Forms"; }).Children.find(function (x) { return x.ItemName === "Email Us"; }).Children.find(function (x) { return x.ItemName === "Fields"; }).Children;
                };
                this.formHasField = function (fieldName, requiredFlag) {
                    var formFields = _this.emailUsForms[_this.helpAndSupportDetails.emailTopic.Form].Fields;
                    return formFields.some(function (formField) { return (formField.Field === fieldName) && (!requiredFlag || formField.IsRequired); });
                };
                this.openConfirmationSlidingPanel = function () {
                    var resolveObj = {
                        emailUsThankYouContent: function () { return _this.emailUsThankYouContent; },
                        comingFromEzTagMobileApp: function () { return _this.comingFromEzTagMobileApp; }
                    };
                    return _this.modalService.showSlidingModal("emailUsConfirmationSlidingPanel", resolveObj);
                };
                this.openFaqSlidingPanel = function (question) {
                    var resolveObj = {
                        faqContent: function () { return _this.emailUsForms[_this.helpAndSupportDetails.emailTopic.Form].FAQs.find(function (x) { return x.Title === question; }); }
                    };
                    return _this.modalService.showSlidingModal("faqSlidingPanel", resolveObj);
                };
                this.fieldIs = function (itemName, fieldNames) {
                    return itemName && fieldNames.some(function (fieldName) { return fieldName.toUpperCase() === itemName.toUpperCase(); });
                };
                this.fieldsContent = function (allFields, formFields) {
                    var fieldContentObj = {};
                    formFields.forEach(function (formField) { return fieldContentObj[formField.Field] = allFields[formField.Field]; });
                    return fieldContentObj;
                };
                this.typeIs = function (fieldName, fieldType) {
                    return fieldName && _this.cmsFormFieldsInfo[fieldName].Type.toUpperCase() === fieldType.toUpperCase();
                };
                this.getEmailTopicObj = function (emailTopic) {
                    return _this.emailUsTopics.find(function (x) { return x.ItemName.toUpperCase() === emailTopic.toUpperCase(); });
                };
                this.changeTopic = function () {
                    _this.cmsFormFieldsInfo = _this.fieldsContent(_this.emailUsFields, _this.emailUsForms[_this.helpAndSupportDetails.emailTopic.Form].Fields);
                    if (_this.formHasField('RequestReply')) {
                        _this.webFormFields['RequestReply'] = true;
                    }
                    _this.dropdownHasSections = false;
                };
                this.cancel = function () {
                    _this.helpAndSupportDetails.userAgentString = _this.userDefaultData.userAgentString;
                    _this.dropdownHasSections = false;
                    _this.helpAndSupportDetails.emailTopic = _this.getEmailTopicObj("Please Select Topic");
                    _this.changeTopic();
                };
                this.isBold = function (option) {
                    if (option.Bold === "1") {
                        _this.dropdownHasSections = true;
                        return true;
                    }
                    return false;
                };
                this.displayName = function (option) {
                    if (option.Bold !== "1" && _this.dropdownHasSections) {
                        return "-" + option.Name;
                    }
                    else {
                        return option.Name;
                    }
                };
                this.onBlurOrChangePhone = function (fieldName) {
                    if (_this.webFormFields[fieldName]) {
                        _this.webFormFields[fieldName] = _this.$filter("usPhone")(_this.webFormFields[fieldName]);
                    }
                    else if (_this.helpAndSupportDetails[fieldName]) {
                        _this.helpAndSupportDetails[fieldName] = _this.$filter("usPhone")(_this.helpAndSupportDetails[fieldName]);
                    }
                };
                this.removeDoubles = function (input, member) {
                    var value = _this.removeDoubleCharService.removeDoubleChar(input[member]);
                    if (value) {
                        input[member] = value;
                    }
                };
                this.onSubmit = function (isValid) {
                    if (isValid && !_this.isAttaching) {
                        return _this.submitFormItems();
                    }
                };
                this.formHasFieldRequired = function (fieldName) {
                    return _this.formHasField(fieldName, true);
                };
                this.onClose = function () {
                    _this.close({ $value: true });
                };
                this.$postLink = function () {
                    _this.validation = _this.validationService(_this.helpAndSupportForm);
                    //Email Topic exists in URL query
                    if (_this.resolve.emailTopicFromURLSearchQuery && _this.emailUsForms[_this.resolve.emailTopicFromURLSearchQuery]) {
                        _this.helpAndSupportDetails.emailTopic = _this.getEmailTopicObj(_this.resolve.emailTopicFromURLSearchQuery);
                        _this.webFormFields.HCTRAAcct = _this.$location.search().AccountNumber;
                        _this.comingFromEzTagMobileApp = _this.resolve.emailTopicFromURLSearchQuery.toUpperCase().indexOf("EXPRESS") < 0;
                    }
                    else {
                        _this.helpAndSupportDetails.emailTopic = _this.getEmailTopicObj("Please Select Topic");
                    }
                    _this.cmsFormFields = _this.emailUsForms[_this.helpAndSupportDetails.emailTopic.Form].Fields;
                    _this.cmsFormFieldsInfo = _this.fieldsContent(_this.emailUsFields, _this.cmsFormFields);
                    _this.emailUsSharedFormFieldsInfo = _this.fieldsContent(_this.emailUsFields, _this.emailUsSharedFormFields);
                    if (_this.formHasField('RequestReply')) {
                        _this.webFormFields['RequestReply'] = true;
                    }
                    //pre-populating fields for logged-in user.
                    if (_this.AuthService.isAuthenticated()) {
                        return _this.genericRepo.dataFactory.getHelpAndSupportInformation()
                            .then(function (response) {
                            if (_this.responseErrorService.isErrorFree(response) && (!_this.webFormFields.HCTRAAcct || _this.webFormFields.HCTRAAcct === response.accountNumber)) {
                                _this.setAccountDetails('YourName', response.name, 'webFormFields');
                                _this.setAccountDetails('Email', response.email, 'helpAndSupportDetails');
                                _this.setAccountDetails('HCTRAAcct', response.accountNumber !== "0" ? response.accountNumber : null, 'webFormFields');
                            }
                        });
                    }
                    return _this.$q.resolve();
                };
                this.helpAndSupportDetails = { emailTopic: null, Email: null, Files: [] };
            }
            EmailUsSlidingPanelController.prototype.setAccountDetails = function (field, responseField, model) {
                this[model][field] = responseField;
                this.userDefaultData[field] = responseField;
            };
            EmailUsSlidingPanelController.prototype.assembleUserBrowserInfoMessage = function (detailsObj) {
                detailsObj.userBrowserInfo = "This is based on Bowser.js ";
                if (this.bowserService.bowser.mobile) {
                    detailsObj.userBrowserInfo += "(may not be accurate for mobile browsers)";
                }
                detailsObj.userBrowserInfo += ":\n\t" + this.bowserService.getUserBrowserInfo();
            };
            EmailUsSlidingPanelController.prototype.submitFormItems = function () {
                var _this = this;
                var originalCMSFormFieldsInfo = this.cmsFormFieldsInfo;
                this.cmsFormFieldsInfo = __assign({}, this.cmsFormFieldsInfo, this.emailUsSharedFormFieldsInfo);
                this.isSendingEmail = true;
                this.responseErrorService.displayToast("Sending email...", "wait");
                this.helpAndSupportDetails.host = this.$location.host();
                this.assembleUserBrowserInfoMessage(this.helpAndSupportDetails);
                this.helpAndSupportDetails.Fields = [];
                for (var field in this.webFormFields) {
                    if (this.webFormFields[field] && this.cmsFormFieldsInfo[field]) {
                        var object = {};
                        if (this.cmsFormFieldsInfo[field].ItemName === 'Location') {
                            object = {
                                'Name': field,
                                'Label': this.cmsFormFieldsInfo[field].Label,
                                'Value': this.webFormFields[field].LocationID
                            };
                        }
                        else {
                            object = {
                                'Name': field,
                                'Label': this.cmsFormFieldsInfo[field].Label,
                                'Value': this.webFormFields[field]
                            };
                        }
                        this.helpAndSupportDetails.Fields.push(object);
                    }
                }
                this.cmsFormFieldsInfo = originalCMSFormFieldsInfo;
                return this.genericRepo.dataFactory.sendHelpAndSupportEmail(this.helpAndSupportDetails)
                    .then(function (res) {
                    _this.responseErrorService.clearToasts();
                    if (_this.responseErrorService.isErrorFree(res)) {
                        _this.emailSent = true;
                        _this.close();
                        _this.openConfirmationSlidingPanel();
                    }
                })
                    .finally(function () {
                    _this.isSendingEmail = false;
                });
            };
            EmailUsSlidingPanelController.prototype.$onInit = function () {
                this.webFormFields = { HCTRAAcct: null, YourName: null };
                this.parseEmailUs();
            };
            EmailUsSlidingPanelController.$inject = [
                "$location",
                "$filter",
                "AuthService",
                "validationService",
                "genericRepo",
                "responseErrorService",
                "removeDoubleCharService",
                "bowserService",
                "modalService",
                "helpAndSupportService",
                "$q"
            ];
            return EmailUsSlidingPanelController;
        }());
        Controller.EmailUsSlidingPanelController = EmailUsSlidingPanelController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module('HCTRAModule')
        .component("emailUsSlidingPanel", {
        templateUrl: '/app/helpAndSupport/emailUsSlidingPanel.html',
        bindings: {
            close: "&",
            dismiss: "&",
            resolve: "<"
        },
        controller: HCTRA.Controller.EmailUsSlidingPanelController
    });
})();
describe("FaqSlidingPanelController tests", function () {
    var component;
    beforeEach(angular.mock.module('HCTRAModule'));
    beforeEach(angular.mock.inject(function ($injector) {
        component = new HCTRA.Controller.FaqSlidingPanelController();
        component["resolve"] = {
            emailUsThankYouContent: {
                Title: "Title",
                ShortDescription: "random Text"
            },
        };
        component["close"] = function () { };
        component["dismiss"] = function () { };
    }));
    it("component created", function () {
        expect(component).toBeDefined();
    });
    describe("onClose", function () {
        it("should call close with $value", function () {
            //Assemble
            spyOn(component, "close");
            //Act
            component.onClose();
            //Assert
            expect(component["close"]).toHaveBeenCalledTimes(1);
            expect(component["close"]).toHaveBeenCalledWith({ $value: true });
        });
    });
});
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var FaqSlidingPanelController = /** @class */ (function () {
            function FaqSlidingPanelController() {
                var _this = this;
                this.onClose = function () {
                    _this.close({ $value: true });
                };
            }
            FaqSlidingPanelController.prototype.$onInit = function () { };
            return FaqSlidingPanelController;
        }());
        Controller.FaqSlidingPanelController = FaqSlidingPanelController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module('HCTRAModule')
        .component("faqSlidingPanel", {
        templateUrl: '/app/helpAndSupport/faqSlidingPanel.html',
        bindings: {
            close: "&",
            dismiss: "&",
            resolve: "<"
        },
        controller: HCTRA.Controller.FaqSlidingPanelController
    });
})();
describe("HelpAndSupportComponent tests", function () {
    var component;
    var helpAndSupportService;
    var modalService;
    var $location;
    var $timeout;
    var $anchorScroll;
    var $q;
    beforeEach(angular.mock.module('HCTRAModule'));
    beforeEach(angular.mock.inject(function ($injector) {
        helpAndSupportService = jasmine.createSpyObj("helpAndSupportService", ["mapLocations"]);
        modalService = jasmine.createSpyObj("modalService", ["showSlidingModal"]);
        $location = jasmine.createSpyObj("$location", ["search"]);
        $timeout = jasmine.createSpy("$timeout");
        $anchorScroll = jasmine.createSpy("$anchorScroll");
        $q = $injector.get("replacementQService");
        component = new HCTRA.Controller.HelpAndSupportController(helpAndSupportService, modalService, $location, $timeout, $anchorScroll);
        component.onContinue = function () { };
    }));
    it("component created", function () {
        expect(component).toBeDefined();
    });
    describe("$postLink()", function () {
        it("should call onto $location hash", function () {
            //Assemble
            $timeout.and.callFake(function () { return $q.resolve({}); });
            //Act
            var result = component.$postLink();
            //Assert
            return result.then(function () {
                expect($timeout).toHaveBeenCalledTimes(1);
                expect($anchorScroll).toHaveBeenCalledTimes(1);
            });
        });
    });
    describe("onInit()", function () {
        it("calls setCMSData 1 time", function () {
            //Assemble
            $location.search.and.returnValue({ EmailTopic: "123" });
            spyOn(component, "setCMSData");
            //Act
            component.$onInit();
            //Assert
            expect(component.setCMSData).toHaveBeenCalledTimes(1);
        });
        it("calls modalService.showSlidingModal() 1 time", function () {
            //Assemble
            $location.search.and.returnValue({ EmailTopic: "123" });
            //Act
            component.$onInit();
            //Assert
            expect(modalService.showSlidingModal).toHaveBeenCalledTimes(1);
        });
    });
    beforeEach(function () {
        component.cmsContent = {
            Title: "something",
            Children: [
                {
                    FieldSelection: component.sectionList.faq,
                    Children: [{}]
                },
                {
                    FieldSelection: component.sectionList.location,
                    Children: [{}]
                },
            ]
        };
    });
    describe("setCMSData", function () {
        it("setCMSData should initialize variable", function () {
            component.setCMSData();
            expect(component.pageTitle).toEqual(component.cmsContent.Title);
            expect(component.pageSubText).toEqual(component.cmsContent.LongDescription);
            expect(component.helpAndSupportCMSSections).toEqual(component.cmsContent.Children);
        });
        it("setCMSData should invoke parse functions", function () {
            spyOn(component, "parseFAQSection");
            spyOn(component, "parseLocationList");
            component.setCMSData();
            expect(component.parseFAQSection).toHaveBeenCalledTimes(1);
            expect(component.parseLocationList).toHaveBeenCalledTimes(1);
        });
    });
    describe("parseFAQSection", function () {
        it("parseFAQSection should initialize FAQCollapseFlagList", function () {
            component.faqCollapseFlagList = [];
            var param = { Children: ["something1", "something2"] };
            component.parseFAQSection(param);
            var testResult = [{ "flag": true }, { "flag": true }];
            expect(component.faqCollapseFlagList).toBeDefined();
            expect(component.faqCollapseFlagList).toEqual(testResult);
        });
    });
    describe("parseLocationList", function () {
        it("parseLocationList should initialize LocationList", function () {
            var param = { Children: ["something1", "something2"] };
            helpAndSupportService.mapLocations.and.returnValue(["object1", "object2"]);
            component.parseLocationList(param);
            expect(component.locationList).toBeDefined();
            expect(component.locationList).toEqual(["object1", "object2"]);
        });
    });
    describe("toggleCollapse", function () {
        it("toggleCollapse should turns FALSE flag if it's TRUE", function () {
            var result = component.toggleCollapse({ flag: true });
            expect(result.flag).toEqual(false);
        });
        it("toggleCollapse should turns TRUE flag if it's FALSE", function () {
            var result = component.toggleCollapse({ flag: false });
            expect(result.flag).toEqual(true);
        });
    });
    describe("parseHeaderToggle", function () {
        it("parseHeaderToggle should parse all header collapsable with same CMS header ammount", function () {
            component.headerToggleFlag = [];
            component.parseHeaderToggle();
            expect(component.headerToggleFlag).toEqual([{ flag: true }, { flag: true }]);
        });
    });
    describe("openEmailUsSlidingPanel", function () {
        it("openEmailUsSlidingPanel should invoke modal with correct params", function () {
            $location.search.and.returnValue(null);
            component.cmsContent = { data: "something" };
            component.openEmailUsSlidingPanel();
            expect(modalService.showSlidingModal).toHaveBeenCalledTimes(1);
            expect(modalService.showSlidingModal).toHaveBeenCalledWith("emailUsSlidingPanel", {
                helpAndSupportFullCMS: jasmine.any(Function),
                emailTopicFromURLSearchQuery: jasmine.any(Function)
            });
        });
    });
});
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var HelpAndSupportController = /** @class */ (function () {
            function HelpAndSupportController(helpAndSupportService, modalService, $location, $timeout, $anchorScroll) {
                var _this = this;
                this.helpAndSupportService = helpAndSupportService;
                this.modalService = modalService;
                this.$location = $location;
                this.$timeout = $timeout;
                this.$anchorScroll = $anchorScroll;
                //Variables List
                this.headerToggleFlag = [];
                this.faqCollapseFlagList = [];
                this.locationList = [];
                this.sectionList = {
                    faq: "FAQ Section",
                    location: "Location Map Section",
                    callUs: "Call Us Section",
                    emailUs: "Email Us"
                };
                this.toggleCollapse = function (toggleFlag) {
                    if (toggleFlag.flag) {
                        toggleFlag.flag = false;
                    }
                    else {
                        toggleFlag.flag = true;
                    }
                    return toggleFlag;
                };
                this.parseHeaderToggle = function () {
                    _this.cmsContent.Children.forEach(function (element) {
                        _this.headerToggleFlag.push({ flag: true });
                    });
                };
                this.setCMSData = function () {
                    _this.parseFAQSection(_this.cmsContent.Children.find(function (child) { return child.FieldSelection === _this.sectionList.faq && child.Children && child.Children.length > 0; }));
                    _this.parseLocationList(_this.cmsContent.Children.find(function (child) { return child.FieldSelection === _this.sectionList.location && child.Children && child.Children.length > 0; }));
                    _this.pageTitle = _this.cmsContent.Title;
                    _this.pageSubText = _this.cmsContent.LongDescription;
                    _this.helpAndSupportCMSSections = _this.cmsContent.Children;
                };
                this.parseFAQSection = function (cmsChild) {
                    if (cmsChild) {
                        cmsChild.Children.forEach(function (FAQSection) {
                            _this.faqCollapseFlagList.push({ flag: true });
                        });
                    }
                };
                this.parseLocationList = function (cmsChild) {
                    if (cmsChild) {
                        _this.locationList = _this.helpAndSupportService.mapLocations(cmsChild.Children);
                    }
                };
                this.openEmailUsSlidingPanel = function (emailTopicFromURLSearchQuery) {
                    var resolveObj = {
                        helpAndSupportFullCMS: function () { return _this.cmsContent; },
                        emailTopicFromURLSearchQuery: function () { return emailTopicFromURLSearchQuery; }
                    };
                    return _this.modalService.showSlidingModal("emailUsSlidingPanel", resolveObj);
                };
                this.$postLink = function () {
                    return _this.$timeout().then(function () {
                        _this.$anchorScroll();
                    });
                };
            }
            HelpAndSupportController.prototype.$onInit = function () {
                this.setCMSData();
                this.parseHeaderToggle();
                //Email Topic will be pre-selected based on URL search query
                var emailTopic = this.$location.search().EmailTopic;
                if (emailTopic) {
                    return this.openEmailUsSlidingPanel(emailTopic);
                }
            };
            HelpAndSupportController.$inject = [
                "helpAndSupportService",
                "modalService",
                "$location",
                "$timeout",
                "$anchorScroll"
            ];
            return HelpAndSupportController;
        }());
        Controller.HelpAndSupportController = HelpAndSupportController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module('HCTRAModule')
        .component("helpAndSupportComponent", {
        templateUrl: '/app/helpAndSupport/helpAndSupport.html',
        bindings: {
            resolve: "<",
            cmsContent: "<"
        },
        controller: HCTRA.Controller.HelpAndSupportController
    });
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var HelpAndSupportService = /** @class */ (function () {
            function HelpAndSupportService(stringUtilsService) {
                var _this = this;
                this.stringUtilsService = stringUtilsService;
                this.mapLocationTitle = function (title) {
                    var openParen = title.indexOf("(");
                    return {
                        region: openParen > -1 ? title.slice(0, openParen).trim() : title,
                        subregion: openParen > -1 ? title.slice(openParen, title.length) : ""
                    };
                };
                this.mapLocations = function (locationsArray) {
                    return locationsArray.map(function (location) {
                        var mappedTitle = _this.mapLocationTitle(location.Title);
                        var ariaText = location.ShortDescription;
                        var address = location.LongDescription.replace("&nbsp;", " ").split(" ");
                        var addressStreet = address.slice(0, address.length - 3).join(" ").replace(",", "");
                        var addressCity = address.slice(address.length - 3, address.length).join(" ");
                        var googleMapSrc = "https://www.google.com/maps?q=" + addressStreet + ", " + addressCity + "&amp;output=embed";
                        var mapEmbed = "<iframe src=\"" + googleMapSrc + "\"  width=\"320\" height=\"160\" frameborder=\"0\" style=\"border:0\" allowfullscreen=\"\"></iframe>";
                        return {
                            ariaAddressStreet: ariaText,
                            addressStreet: addressStreet,
                            addressCity: addressCity,
                            mapLink: mapEmbed,
                            region: mappedTitle.region,
                            subregion: mappedTitle.subregion
                        };
                    });
                };
                this.transformKeyValuePair = function (key, field) {
                    var transformationFunctions = {
                        FieldValidationRegex: function () { return new RegExp(field.FieldValidationRegex); },
                        FileTypes: function () { return _this.stringUtilsService.getParameterObject(field.FileTypes); },
                        FileExtensions: function () { return field.FileExtensions.toLowerCase(); }
                    };
                    if (field.Children && field.Type === 'Dropdown') {
                        if (key === "Children") {
                            return {
                                key: "Options",
                                value: field.Children
                            };
                        }
                        else {
                            return {
                                key: key,
                                value: field[key]
                            };
                        }
                    }
                    else {
                        return {
                            key: key,
                            value: transformationFunctions[key] ? transformationFunctions[key](key) : field[key]
                        };
                    }
                };
                this.mapFields = function (fieldArray) {
                    return fieldArray
                        .map(function (field) { return ({
                        itemName: field.ItemName,
                        obj: Object.keys(field)
                            .filter(function (key) { return key !== "ItemID"; })
                            .filter(function (key) { return field[key]; })
                            .map(function (key) { return _this.transformKeyValuePair(key, field); })
                            .reduce(function (acc, cur) {
                            var _a;
                            return angular.extend(acc, (_a = {}, _a[cur.key] = cur.value, _a));
                        }, {})
                    }); })
                        .reduce(function (acc, cur) {
                        var _a;
                        return angular.extend(acc, (_a = {}, _a[cur.itemName] = cur.obj, _a));
                    }, {});
                };
                this.createFormMapping = function (formsArray) {
                    return formsArray
                        .map(function (form) { return ({
                        itemName: form.ItemName,
                        obj: {
                            ShortDescription: form.ShortDescription,
                            LongDescription: form.LongDescription,
                            Title: form.Title,
                            Fields: form.Children.filter(function (x) { return x.ItemName === "Fields"; })[0].HasChildren === "True"
                                ? form.Children
                                    .filter(function (x) { return x.ItemName === "Fields"; })[0]
                                    .Children
                                    .map(function (field) { return ({
                                    Field: field.Field,
                                    IsRequired: field.IsRequired === "1" ? true : false
                                }); })
                                : [],
                            FAQs: form.Children.filter(function (x) { return x.ItemName === "FAQs"; })[0].HasChildren === "True"
                                ? form.Children
                                    .filter(function (x) { return x.ItemName === "FAQs"; })[0]
                                    .Children
                                    .map(function (question) { return ({
                                    Title: question.Title,
                                    ItemName: question.ItemName,
                                    Purpose: question.Purpose,
                                    ShortDescription: question.ShortDescription,
                                    LongDescription: question.LongDescription,
                                    LastUpdate: question.LastUpdate
                                }); })
                                : []
                        }
                    }); })
                        .reduce(function (acc, cur) {
                        var _a;
                        return angular.extend(acc, (_a = {}, _a[cur.itemName] = cur.obj, _a));
                    }, {});
                };
            }
            HelpAndSupportService.$inject = ["stringUtilsService"];
            return HelpAndSupportService;
        }());
        Service.HelpAndSupportService = HelpAndSupportService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("helpAndSupportService", HCTRA.Service.HelpAndSupportService);
})();
(function () {
    "use strict";
    //TODO: fix these tests!
    var Color;
    (function (Color) {
        Color[Color["Green"] = 1] = "Green";
        Color[Color["Yellow"] = 2] = "Yellow";
        Color[Color["Red"] = 3] = "Red";
        Color[Color["Error"] = -1] = "Error";
    })(Color || (Color = {}));
    describe("lynchburgFerryComponent", function () {
        var component;
        var cmsUtilService;
        var dateWithTimeZoneService;
        var momentService;
        var featureToggleResolver = {
            isResolvedFeatureToggle: function (x) { },
        };
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.inject(function ($injector) {
            cmsUtilService = jasmine.createSpyObj("cmsUtilService", ["parseAllImageAttributes"]);
            dateWithTimeZoneService = jasmine.createSpyObj("dateWithTimeZoneService", ["withOffsetToCentral"]);
            momentService = { moment: jasmine.createSpyObj("moment", ["format"]) };
            component = new HCTRA.Controller.LynchburgFerryController(cmsUtilService, dateWithTimeZoneService, momentService, featureToggleResolver);
            component.cmsContent = {
                Children: [
                    { Title: '2-Ferry', ShortDescription: '2 Ferry Short Description', TemplateName: 'Section' },
                    { Title: '1-Ferry', ShortDescription: '1 Ferry Short Description', TemplateName: 'Section' },
                    { Title: 'Closed', ShortDescription: 'Closed Short Description', TemplateName: 'Section' },
                    { Title: 'img1', ShortDescription: 'Img1 Description', TemplateName: 'Slide' },
                    { Title: 'img2', ShortDescription: 'Img2 Description', TemplateName: 'Slide' }
                ]
            };
            spyOn(featureToggleResolver, 'isResolvedFeatureToggle').and.returnValue(Promise.resolve(false));
            cmsUtilService.parseAllImageAttributes.and.returnValue({ image: "test" });
        }));
        it("can create a component", function () {
            expect(component).toBeDefined();
        });
        it('should set shortDescriptions to variables', function () {
            component.cmsContent.imageInterval = '2000';
            component.$onInit();
            expect(component.twoFerryMessage).toEqual('2 Ferry Short Description');
            expect(component.oneFerryMessage).toEqual('1 Ferry Short Description');
            expect(component.closedFerryMessage).toEqual('Closed Short Description');
        });
        it('should set message variables to blank', function () {
            component.cmsContent = {
                imageInterval: '2000',
                Children: []
            };
            component.$onInit();
            expect(component.twoFerryMessage).toEqual('');
            expect(component.oneFerryMessage).toEqual('');
            expect(component.closedFerryMessage).toEqual('');
        });
        it("interval set to 5000 if enter error input", function () {
            component.cmsContent.imageInterval = "random";
            component.$onInit();
            expect(component.interval).toEqual(5000);
        });
        it("interval set to correct input if enter correct input", function () {
            component.cmsContent.imageInterval = "2000";
            component.$onInit();
            expect(component.interval).toEqual(2000);
        });
        describe("parseSliderImages", function () {
            beforeEach(function () {
                component.currIndex = 0;
            });
            it("2 images should be load with the slider if 2 CMS items were input ", function () {
                var res = [
                    {
                        Image: 'something1',
                        SlideURL: 'something1'
                    },
                    {
                        Image: 'something2',
                        SlideURL: 'something2'
                    }
                ];
                cmsUtilService.parseAllImageAttributes.and.returnValue({ image: "test" });
                component.parseSliderImages(res);
                expect(component.sliderImageURL).toEqual([
                    { "url": "test", "id": 0, "urlLinkOn": true, "urlLink": "something1" },
                    { "url": "test", "id": 1, "urlLinkOn": true, "urlLink": "something2" }
                ]);
            });
            it("5 images should be load with the slider if 5 CMS items were input ", function () {
                component.cmsContent = {
                    hasVideo: "someFlaseInput",
                    videoURL: "someURL"
                };
                cmsUtilService.parseAllImageAttributes.and.returnValue({ image: "test" });
                var res = [
                    {
                        Image: 'something1',
                        SlideURL: 'https://hctra.org/FAQ/Lynchburg%20Ferry/0'
                    },
                    {
                        Image: 'something2',
                        SlideURL: ''
                    },
                    {
                        Image: 'something3',
                        SlideURL: ''
                    },
                    {
                        Image: 'something4',
                        SlideURL: ''
                    },
                    {
                        Image: 'something5',
                        SlideURL: ''
                    }
                ];
                component.parseSliderImages(res);
                expect(component.sliderImageURL).toEqual([
                    { url: "test", id: 0, urlLinkOn: true, urlLink: "https://hctra.org/FAQ/Lynchburg%20Ferry/0" },
                    { url: "test", id: 1, urlLinkOn: false, urlLink: null },
                    { url: "test", id: 2, urlLinkOn: false, urlLink: null },
                    { url: "test", id: 3, urlLinkOn: false, urlLink: null },
                    { url: "test", id: 4, urlLinkOn: false, urlLink: null }
                ]);
            });
        });
        describe("getFerryStatusColor", function () {
            var testCases = [
                {
                    dayOfWeek: 'Monday',
                    minuteOfDay: 1120,
                    result: Color.Yellow
                },
                {
                    dayOfWeek: 'Tuesday',
                    minuteOfDay: 1,
                    result: Color.Red
                },
                {
                    dayOfWeek: 'Wednesday',
                    minuteOfDay: 420,
                    result: Color.Yellow
                },
                {
                    dayOfWeek: 'Thursday',
                    minuteOfDay: 960,
                    result: Color.Green
                },
                {
                    dayOfWeek: 'Saturday',
                    minuteOfDay: 1,
                    result: Color.Red
                },
                {
                    dayOfWeek: 'Saturday',
                    minuteOfDay: 780,
                    result: Color.Yellow
                },
                {
                    dayOfWeek: 'Sunday',
                    minuteOfDay: 1140,
                    result: Color.Red
                }
            ];
            testCases.forEach(function (test) {
                it("On " + test.dayOfWeek + " at " + test.minuteOfDay + " should return " + test.result + ")", function () {
                    var result = component.getFerryStatusColor(test.dayOfWeek, test.minuteOfDay);
                    expect(result).toEqual(test.result);
                });
            });
        });
    });
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var Color;
        (function (Color) {
            Color[Color["Green"] = 1] = "Green";
            Color[Color["Yellow"] = 2] = "Yellow";
            Color[Color["Red"] = 3] = "Red";
            Color[Color["Error"] = -1] = "Error";
        })(Color || (Color = {}));
        var LynchburgFerryController = /** @class */ (function () {
            function LynchburgFerryController(cmsUtilService, dateWithTimeZoneService, momentService, featureToggleResolver) {
                var _this = this;
                this.cmsUtilService = cmsUtilService;
                this.dateWithTimeZoneService = dateWithTimeZoneService;
                this.momentService = momentService;
                this.featureToggleResolver = featureToggleResolver;
                this.currIndex = 0;
                this.$onInit = function () {
                    _this.featureToggleResolver.isResolvedFeatureToggle('LynchburgFerryShowOperation')
                        .then(function (res) {
                        if (res === true) {
                            _this.ferryOperationToggle = res;
                            var dateString = _this.momentService.moment().format();
                            _this.dateOfWeek = _this.dateWithTimeZoneService.withOffsetToCentral(dateString, 'dddd');
                            _this.hour = parseInt(_this.dateWithTimeZoneService.withOffsetToCentral(dateString, 'HH'), 10);
                            _this.minute = parseInt(_this.dateWithTimeZoneService.withOffsetToCentral(dateString, 'mm'), 10);
                            _this.minuteOfDay = (_this.hour * 60) + _this.minute;
                            _this.ferryCurrentStatusCode = _this.getFerryStatusColor(_this.dateOfWeek, _this.minuteOfDay);
                        }
                        else {
                            _this.ferryOperationToggle = false;
                        }
                    });
                    if (_this.cmsContent.imageInterval.match(/^\d+$/)) {
                        _this.interval = parseInt(_this.cmsContent.imageInterval, 10);
                    }
                    else {
                        _this.interval = 5000;
                    }
                    var slides = _this.cmsContent.Children.filter(function (x) { return x.TemplateName === 'Slide'; });
                    if (slides.length > 0) {
                        _this.parseSliderImages(slides);
                    }
                    _this.twoFerryMessage = (_this.cmsContent.Children.filter(function (x) { return x.Title === '2-Ferry'; })[0] || {}).ShortDescription || '';
                    _this.oneFerryMessage = (_this.cmsContent.Children.filter(function (x) { return x.Title === '1-Ferry'; })[0] || {}).ShortDescription || '';
                    _this.closedFerryMessage = (_this.cmsContent.Children.filter(function (x) { return x.Title === 'Closed'; })[0] || {}).ShortDescription || '';
                };
                this.parseSliderImages = function (res) {
                    _this.sliderImageURL = [];
                    angular.forEach(res, function (child) {
                        _this.sliderImageURL.push({
                            url: _this.cmsUtilService.parseAllImageAttributes(child.Image).image,
                            id: _this.currIndex++,
                            urlLinkOn: (angular.isString(child.SlideURL) && child.SlideURL !== ""),
                            urlLink: (angular.isString(child.SlideURL) && child.SlideURL !== "") ? child.SlideURL : null
                        });
                    });
                    return;
                };
            }
            LynchburgFerryController.prototype.getFerryStatusColor = function (dayOfWeek, minuteOfDay) {
                var weekDayCheck = this.isWeekday(dayOfWeek);
                if (weekDayCheck === null) {
                    return Color.Error;
                }
                else if (weekDayCheck) {
                    //WEEKDAYs
                    //IF from 12 am  4:30 am return RED (between 0 and 270)
                    //IF from 8 pm  11:59 am return RED (between 1200 and 1440)
                    if ((0 <= minuteOfDay && minuteOfDay < 270) ||
                        (1200 <= minuteOfDay && minuteOfDay <= 1440)) {
                        return Color.Red;
                    }
                    //IF from 4:30 am  3:30 pm return YELLOW (between 270 and 930)
                    //IF from 6:30 pm  8 pm return YELLOW (between 1110 and 1200)
                    else if ((270 <= minuteOfDay && minuteOfDay < 930) ||
                        (1110 <= minuteOfDay && minuteOfDay < 1200)) {
                        return Color.Yellow;
                    }
                    //IF from 3:30 pm  6:30 pm return GREEN (between 930 and 1110)
                    else if (930 <= minuteOfDay && minuteOfDay < 1110) {
                        return Color.Green;
                    }
                }
                else {
                    //WEEKEND
                    //IF from 12 am  11:00 am return RED (between 0 and 660)
                    //IF from 6:30 pm  11:59 pm return RED (between 1110 and 1440)
                    if ((0 <= minuteOfDay && minuteOfDay < 660) ||
                        (1110 <= minuteOfDay && minuteOfDay <= 1440)) {
                        return Color.Red;
                    }
                    //IF from 11:00 am  6:30 pm return YELLOW (between 660 and 1110)
                    else if (660 <= minuteOfDay && minuteOfDay < 1110) {
                        return Color.Yellow;
                    }
                }
            };
            LynchburgFerryController.prototype.isWeekday = function (dayOfWeek) {
                if (dayOfWeek === 'Monday' ||
                    dayOfWeek === 'Tuesday' ||
                    dayOfWeek === 'Wednesday' ||
                    dayOfWeek === 'Thursday' ||
                    dayOfWeek === 'Friday') {
                    return true;
                }
                else if (dayOfWeek === 'Saturday' || dayOfWeek === 'Sunday') {
                    return false;
                }
                return null;
            };
            LynchburgFerryController.$inject = [
                "cmsUtilService",
                "dateWithTimeZoneService",
                "momentService",
                "featureToggleResolver"
            ];
            return LynchburgFerryController;
        }());
        Controller.LynchburgFerryController = LynchburgFerryController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .component("lynchburgFerryComponent", {
        templateUrl: '/app/microSites/lynchburgFerry.html',
        bindings: {
            cmsContent: '<'
        },
        controller: HCTRA.Controller.LynchburgFerryController
    });
})();
(function () {
    "use strict";
    //TODO: fix these tests!
    xdescribe("washburnTunnelComponent", function () {
        var component;
        var $document, vimeoPlayer, $timeout, genericRepo, cmsUtilService, responseErrorService;
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.inject(function ($injector) {
            vimeoPlayer = $injector.get("vimeoPlayer");
            $document = $injector.get("$document");
            $timeout = $injector.get("$timeout");
            genericRepo = { dataFactory: {} }; //not used?!
            cmsUtilService = $injector.get("cmsUtilService");
            responseErrorService = $injector.get("responseErrorService");
            component = new HCTRA.Controller.WashburnTunnelController($document, vimeoPlayer, $timeout, genericRepo, cmsUtilService, responseErrorService);
            component.cmsContent = {};
        }));
        it("can create a component", function () {
            expect(component).toBeDefined();
        });
        it("interval set to 5000 if enter error input", function () {
            component.cmsContent.imageInterval = "random";
            component.$onInit();
            expect(component.interval).toEqual(5000);
        });
        it("interval set to correct input if enter correct input", function () {
            component.cmsContent.imageInterval = "2000";
            component.$onInit();
            expect(component.interval).toEqual(2000);
        });
        describe("parseSliderImages", function () {
            beforeEach(function () {
                component.currIndex = 0;
                component.sliderImageURL = [];
            });
            it("video should be load with the slider is hasVideo is TRUE ", function () {
                component.cmsContent = {
                    hasVideo: "true",
                    videoURL: "someURL"
                };
                var res = { "errors": [], "cmsResponse": "{ \"ItemID\":\"e34c304e-6ed0-4f0e-82c6-6deb53251d06\",\"ItemName\":\"Washburn Tunnel Slider Images\",\"ItemPath\":\"/sitecore/media library/Images/HCTRA/About HCTRA/aboutUs/Washburn Tunnel Slider Images\",\"ParentID\":\"5394d401-915e-417a-999e-b6de3d39209a\",\"TemplateID\":\"fe5dd826-48c6-436d-b87a-7c4210c7413b\",\"TemplateName\":\"Media folder\",\"CloneSource\":null,\"ItemLanguage\":\"en\",\"ItemVersion\":\"1\",\"DisplayName\":\"Washburn Tunnel Slider Images\",\"HasChildren\":\"True\",\"ItemIcon\":\"/temp/iconcache/applications/16x16/folder.png\",\"ItemMedialUrl\":\"/temp/iconcache/applications/48x48/folder.png\",\"ItemUrl\":\"~/link.aspx?_id=E34C304E6ED04F0E82C66DEB53251D06&amp;_z=z\",\"Children\":[{\"ItemID\":\"eb508eec-07fb-4399-97c9-0c626a383f15\",\"ItemName\":\"tunnel1\",\"ItemPath\":\"/sitecore/media library/Images/HCTRA/About HCTRA/aboutUs/Washburn Tunnel Slider Images/tunnel1\",\"ParentID\":\"e34c304e-6ed0-4f0e-82c6-6deb53251d06\",\"TemplateID\":\"f1828a2c-7e5d-4bbd-98ca-320474871548\",\"TemplateName\":\"Image\",\"CloneSource\":null,\"ItemLanguage\":\"en\",\"ItemVersion\":\"1\",\"DisplayName\":\"tunnel1\",\"HasChildren\":\"False\",\"ItemIcon\":\"/sitecore/shell/themes/standard/-/media/EB508EEC07FB439997C90C626A383F15.ashx?h=16&thn=1&w=16&db=web\",\"ItemMedialUrl\":\"/-/media/images/hctra/about-hctra/aboutus/washburn-tunnel-slider-images/tunnel1.ashx?bc=transparent&db=web&h=130&thn=1&w=130\",\"ItemUrl\":\"~/link.aspx?_id=EB508EEC07FB439997C90C626A383F15&amp;_z=z\",\"Keywords\":\"\",\"Asset 3\":\"\",\"Dimensions\":\"1010 x 565\",\"Mime Type\":\"image/png\",\"Alt\":\"\",\"Latitude\":\"\",\"Asset 2\":\"\",\"ZipCode\":\"\",\"File Path\":\"\",\"Blob\":\"{AAD2DDAE-3802-4939-BC21-8FCD18E90F19}\",\"Width\":\"1010\",\"CountryCode\":\"\",\"Extension\":\"png\",\"Marketing asset\":\"\",\"Size\":\"354022\",\"Title\":\"\",\"LocationDescription\":\"\",\"Longitude\":\"\",\"Height\":\"565\",\"Format\":\"\",\"Asset 1\":\"\",\"Description\":\"\"},{\"ItemID\":\"30da96e9-ceeb-4904-9771-8fddad361b04\",\"ItemName\":\"tunnel2\",\"ItemPath\":\"/sitecore/media library/Images/HCTRA/About HCTRA/aboutUs/Washburn Tunnel Slider Images/tunnel2\",\"ParentID\":\"e34c304e-6ed0-4f0e-82c6-6deb53251d06\",\"TemplateID\":\"f1828a2c-7e5d-4bbd-98ca-320474871548\",\"TemplateName\":\"Image\",\"CloneSource\":null,\"ItemLanguage\":\"en\",\"ItemVersion\":\"1\",\"DisplayName\":\"tunnel2\",\"HasChildren\":\"False\",\"ItemIcon\":\"/sitecore/shell/themes/standard/-/media/30DA96E9CEEB490497718FDDAD361B04.ashx?h=16&thn=1&w=16&db=web\",\"ItemMedialUrl\":\"/-/media/images/hctra/about-hctra/aboutus/washburn-tunnel-slider-images/tunnel2.ashx?bc=transparent&db=web&h=130&thn=1&w=130\",\"ItemUrl\":\"~/link.aspx?_id=30DA96E9CEEB490497718FDDAD361B04&amp;_z=z\",\"Keywords\":\"\",\"Asset 3\":\"\",\"Dimensions\":\"1010 x 565\",\"Mime Type\":\"image/png\",\"Alt\":\"\",\"Latitude\":\"\",\"Asset 2\":\"\",\"ZipCode\":\"\",\"File Path\":\"\",\"Blob\":\"{FC64F707-C43B-46BA-B37C-1DA7DDDCE9B8}\",\"Width\":\"1010\",\"CountryCode\":\"\",\"Extension\":\"png\",\"Marketing asset\":\"\",\"Size\":\"396650\",\"Title\":\"\",\"LocationDescription\":\"\",\"Longitude\":\"\",\"Height\":\"565\",\"Format\":\"\",\"Asset 1\":\"\",\"Description\":\"\"}]}", "webVersion": "1.0.0.7376.17636", "alerts": [] };
                component.parseSliderImages(res);
                expect(component.sliderImageURL).toBe([
                    { "url": "https://player.vimeo.com/video/394464887", "id": 0, "isVideo": true },
                    { "url": "-/media/EB508EEC07FB439997C90C626A383F15.ashx", "id": 1, "isVideo": false },
                    { "url": "-/media/30DA96E9CEEB490497718FDDAD361B04.ashx", "id": 2, "isVideo": false }
                ]);
            });
            it("video should be load with the slider is hasVideo is TRUE ", function () {
                component.cmsContent = {
                    hasVideo: "someFlaseInput",
                    videoURL: "someURL"
                };
                var res = { "errors": [], "cmsResponse": "{ \"ItemID\":\"e34c304e-6ed0-4f0e-82c6-6deb53251d06\",\"ItemName\":\"Washburn Tunnel Slider Images\",\"ItemPath\":\"/sitecore/media library/Images/HCTRA/About HCTRA/aboutUs/Washburn Tunnel Slider Images\",\"ParentID\":\"5394d401-915e-417a-999e-b6de3d39209a\",\"TemplateID\":\"fe5dd826-48c6-436d-b87a-7c4210c7413b\",\"TemplateName\":\"Media folder\",\"CloneSource\":null,\"ItemLanguage\":\"en\",\"ItemVersion\":\"1\",\"DisplayName\":\"Washburn Tunnel Slider Images\",\"HasChildren\":\"True\",\"ItemIcon\":\"/temp/iconcache/applications/16x16/folder.png\",\"ItemMedialUrl\":\"/temp/iconcache/applications/48x48/folder.png\",\"ItemUrl\":\"~/link.aspx?_id=E34C304E6ED04F0E82C66DEB53251D06&amp;_z=z\",\"Children\":[{\"ItemID\":\"eb508eec-07fb-4399-97c9-0c626a383f15\",\"ItemName\":\"tunnel1\",\"ItemPath\":\"/sitecore/media library/Images/HCTRA/About HCTRA/aboutUs/Washburn Tunnel Slider Images/tunnel1\",\"ParentID\":\"e34c304e-6ed0-4f0e-82c6-6deb53251d06\",\"TemplateID\":\"f1828a2c-7e5d-4bbd-98ca-320474871548\",\"TemplateName\":\"Image\",\"CloneSource\":null,\"ItemLanguage\":\"en\",\"ItemVersion\":\"1\",\"DisplayName\":\"tunnel1\",\"HasChildren\":\"False\",\"ItemIcon\":\"/sitecore/shell/themes/standard/-/media/EB508EEC07FB439997C90C626A383F15.ashx?h=16&thn=1&w=16&db=web\",\"ItemMedialUrl\":\"/-/media/images/hctra/about-hctra/aboutus/washburn-tunnel-slider-images/tunnel1.ashx?bc=transparent&db=web&h=130&thn=1&w=130\",\"ItemUrl\":\"~/link.aspx?_id=EB508EEC07FB439997C90C626A383F15&amp;_z=z\",\"Keywords\":\"\",\"Asset 3\":\"\",\"Dimensions\":\"1010 x 565\",\"Mime Type\":\"image/png\",\"Alt\":\"\",\"Latitude\":\"\",\"Asset 2\":\"\",\"ZipCode\":\"\",\"File Path\":\"\",\"Blob\":\"{AAD2DDAE-3802-4939-BC21-8FCD18E90F19}\",\"Width\":\"1010\",\"CountryCode\":\"\",\"Extension\":\"png\",\"Marketing asset\":\"\",\"Size\":\"354022\",\"Title\":\"\",\"LocationDescription\":\"\",\"Longitude\":\"\",\"Height\":\"565\",\"Format\":\"\",\"Asset 1\":\"\",\"Description\":\"\"},{\"ItemID\":\"30da96e9-ceeb-4904-9771-8fddad361b04\",\"ItemName\":\"tunnel2\",\"ItemPath\":\"/sitecore/media library/Images/HCTRA/About HCTRA/aboutUs/Washburn Tunnel Slider Images/tunnel2\",\"ParentID\":\"e34c304e-6ed0-4f0e-82c6-6deb53251d06\",\"TemplateID\":\"f1828a2c-7e5d-4bbd-98ca-320474871548\",\"TemplateName\":\"Image\",\"CloneSource\":null,\"ItemLanguage\":\"en\",\"ItemVersion\":\"1\",\"DisplayName\":\"tunnel2\",\"HasChildren\":\"False\",\"ItemIcon\":\"/sitecore/shell/themes/standard/-/media/30DA96E9CEEB490497718FDDAD361B04.ashx?h=16&thn=1&w=16&db=web\",\"ItemMedialUrl\":\"/-/media/images/hctra/about-hctra/aboutus/washburn-tunnel-slider-images/tunnel2.ashx?bc=transparent&db=web&h=130&thn=1&w=130\",\"ItemUrl\":\"~/link.aspx?_id=30DA96E9CEEB490497718FDDAD361B04&amp;_z=z\",\"Keywords\":\"\",\"Asset 3\":\"\",\"Dimensions\":\"1010 x 565\",\"Mime Type\":\"image/png\",\"Alt\":\"\",\"Latitude\":\"\",\"Asset 2\":\"\",\"ZipCode\":\"\",\"File Path\":\"\",\"Blob\":\"{FC64F707-C43B-46BA-B37C-1DA7DDDCE9B8}\",\"Width\":\"1010\",\"CountryCode\":\"\",\"Extension\":\"png\",\"Marketing asset\":\"\",\"Size\":\"396650\",\"Title\":\"\",\"LocationDescription\":\"\",\"Longitude\":\"\",\"Height\":\"565\",\"Format\":\"\",\"Asset 1\":\"\",\"Description\":\"\"}]}", "webVersion": "1.0.0.7376.17636", "alerts": [] };
                component.parseSliderImages(res);
                expect(component.sliderImageURL).toBe([
                    { "url": "-/media/EB508EEC07FB439997C90C626A383F15.ashx", "id": 1, "isVideo": false },
                    { "url": "-/media/30DA96E9CEEB490497718FDDAD361B04.ashx", "id": 2, "isVideo": false }
                ]);
            });
        });
    });
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        var WashburnTunnelController = /** @class */ (function () {
            function WashburnTunnelController($document, vimeoPlayer, $timeout, genericRepo, cmsUtilService, responseErrorService) {
                var _this = this;
                this.$document = $document;
                this.vimeoPlayer = vimeoPlayer;
                this.$timeout = $timeout;
                this.genericRepo = genericRepo;
                this.cmsUtilService = cmsUtilService;
                this.responseErrorService = responseErrorService;
                this.currIndex = 0;
                this.sliderLoaded = function () {
                    if (!_this.isSliderLoaded) {
                        _this.iframe = _this.$document[0].getElementById("videoDesktop");
                        _this.player = new _this.vimeoPlayer.Player(_this.iframe);
                        _this.isSliderLoaded = true;
                    }
                    _this.player.on('play', function () { return _this.$timeout(_this.videoOnPlay); });
                    _this.player.on('pause', function () { return _this.$timeout(_this.videoOnPause); });
                    _this.player.on('ended', function () { return _this.$timeout(_this.videoOnEnd); });
                    angular.element("#mySlides .carousel-control").on("click", function () {
                        _this.player.pause().then(_this.videoOnPause);
                    });
                };
                this.$onInit = function () {
                    _this.isSliderLoaded = false;
                    if (_this.cmsContent.imageInterval.match(/^\d+$/)) {
                        _this.interval = parseInt(_this.cmsContent.imageInterval);
                    }
                    else {
                        _this.cmsContent.imageInterval = 5000;
                        _this.interval = _this.cmsContent.imageInterval;
                    }
                    _this.parseSliderImages(_this.cmsContent.Children);
                };
                this.videoOnPlay = function () {
                    if (!_this.isVideoPlay) {
                        _this.isVideoPlay = true;
                        _this.interval = false;
                    }
                };
                this.videoOnPause = function () {
                    _this.isVideoPlay = false;
                    _this.interval = _this.cmsContent.imageInterval;
                };
                this.videoOnEnd = function () {
                    _this.isVideoPlay = false;
                    _this.interval = _this.cmsContent.imageInterval;
                };
                this.parseSliderImages = function (res) {
                    _this.sliderImageURL = [];
                    if (_this.cmsContent.hasVideo === "true") {
                        _this.sliderImageURL.push({
                            url: _this.cmsContent.videoURL,
                            id: _this.currIndex++,
                            isVideo: true,
                            urlLinkOn: false,
                            urlLink: null
                        });
                    }
                    angular.forEach(res, function (child) {
                        _this.sliderImageURL.push({
                            url: _this.cmsUtilService.parseAllImageAttributes(child.Image).image,
                            id: _this.currIndex++,
                            isVideo: false,
                            urlLinkOn: (angular.isString(child.SlideURL) && child.SlideURL !== ""),
                            urlLink: (angular.isString(child.SlideURL) && child.SlideURL !== "") ? child.SlideURL : null
                        });
                    });
                    return;
                };
            }
            WashburnTunnelController.$inject = [
                "$document",
                "vimeoPlayer",
                "$timeout",
                "genericRepo",
                "cmsUtilService",
                "responseErrorService"
            ];
            return WashburnTunnelController;
        }());
        Controller.WashburnTunnelController = WashburnTunnelController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').component("washburnTunnelComponent", {
        templateUrl: '/app/microSites/washburnTunnel.html',
        bindings: {
            cmsContent: '<'
        },
        controller: HCTRA.Controller.WashburnTunnelController
    });
})();
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var AccountActivityDTO = /** @class */ (function () {
            function AccountActivityDTO() {
            }
            return AccountActivityDTO;
        }());
        Model.AccountActivityDTO = AccountActivityDTO;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var UnformattedAccountActivityDTO = /** @class */ (function () {
            function UnformattedAccountActivityDTO() {
            }
            return UnformattedAccountActivityDTO;
        }());
        Model.UnformattedAccountActivityDTO = UnformattedAccountActivityDTO;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var Alert = /** @class */ (function () {
            function Alert() {
            }
            return Alert;
        }());
        Model.Alert = Alert;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var BaseResponse = /** @class */ (function () {
            function BaseResponse() {
                this.errors = [];
                this.alerts = [];
            }
            return BaseResponse;
        }());
        Model.BaseResponse = BaseResponse;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var BaseCmsResponse = /** @class */ (function () {
            function BaseCmsResponse() {
            }
            return BaseCmsResponse;
        }());
        Model.BaseCmsResponse = BaseCmsResponse;
        var ListBaseCmsResponse = /** @class */ (function (_super) {
            __extends(ListBaseCmsResponse, _super);
            function ListBaseCmsResponse() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return ListBaseCmsResponse;
        }(BaseCmsResponse));
        Model.ListBaseCmsResponse = ListBaseCmsResponse;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var CmsRequest = /** @class */ (function () {
            // this is a class and not an interface because the new CMS migration strategy
            //  requires the website to check for this object at run-time
            function CmsRequest(Path, ItemId, Fields) {
                this.Path = Path;
                this.ItemId = ItemId;
                this.Fields = Fields;
            }
            return CmsRequest;
        }());
        Model.CmsRequest = CmsRequest;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var SitecoreItem = /** @class */ (function () {
            function SitecoreItem() {
            }
            return SitecoreItem;
        }());
        Model.SitecoreItem = SitecoreItem;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var Country = /** @class */ (function () {
            function Country() {
            }
            return Country;
        }());
        Model.Country = Country;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var IUpDownEnterInterceptorActions = /** @class */ (function () {
            function IUpDownEnterInterceptorActions() {
            }
            return IUpDownEnterInterceptorActions;
        }());
        Model.IUpDownEnterInterceptorActions = IUpDownEnterInterceptorActions;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var FeatureToggleResponse = /** @class */ (function (_super) {
            __extends(FeatureToggleResponse, _super);
            function FeatureToggleResponse() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return FeatureToggleResponse;
        }(Model.BaseResponse));
        Model.FeatureToggleResponse = FeatureToggleResponse;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var HelpAndSupportEmailTopic = /** @class */ (function () {
            function HelpAndSupportEmailTopic() {
            }
            return HelpAndSupportEmailTopic;
        }());
        Model.HelpAndSupportEmailTopic = HelpAndSupportEmailTopic;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var HelpAndSupportFaqCategory = /** @class */ (function () {
            function HelpAndSupportFaqCategory() {
            }
            return HelpAndSupportFaqCategory;
        }());
        Model.HelpAndSupportFaqCategory = HelpAndSupportFaqCategory;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var HelpAndSupportDetails = /** @class */ (function () {
            function HelpAndSupportDetails() {
            }
            return HelpAndSupportDetails;
        }());
        Model.HelpAndSupportDetails = HelpAndSupportDetails;
        var HelpAndSupportLocationId = /** @class */ (function () {
            function HelpAndSupportLocationId() {
            }
            return HelpAndSupportLocationId;
        }());
        Model.HelpAndSupportLocationId = HelpAndSupportLocationId;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var Listener = /** @class */ (function () {
            function Listener() {
            }
            return Listener;
        }());
        Model.Listener = Listener;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var CmsBlockMessages = /** @class */ (function () {
            function CmsBlockMessages() {
            }
            return CmsBlockMessages;
        }());
        Model.CmsBlockMessages = CmsBlockMessages;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        // THIS MUST MATCH WITH MaintenanceFeatureEnum.cs
        // todo: duplicated in Angular; remove this when migration is complete
        var MaintenanceFeature;
        (function (MaintenanceFeature) {
            MaintenanceFeature[MaintenanceFeature["MobileApp"] = 0] = "MobileApp";
            MaintenanceFeature[MaintenanceFeature["MobileAppEzTag"] = 1] = "MobileAppEzTag";
            MaintenanceFeature[MaintenanceFeature["Account"] = 2] = "Account";
            MaintenanceFeature[MaintenanceFeature["Violations"] = 3] = "Violations";
            MaintenanceFeature[MaintenanceFeature["MultipleVehicleUpload"] = 4] = "MultipleVehicleUpload";
            MaintenanceFeature[MaintenanceFeature["CA"] = 5] = "CA";
        })(MaintenanceFeature = Model.MaintenanceFeature || (Model.MaintenanceFeature = {}));
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var MaintenanceResponse = /** @class */ (function (_super) {
            __extends(MaintenanceResponse, _super);
            function MaintenanceResponse() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return MaintenanceResponse;
        }(Model.BaseResponse));
        Model.MaintenanceResponse = MaintenanceResponse;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var CreditCardType = /** @class */ (function () {
            function CreditCardType() {
            }
            return CreditCardType;
        }());
        Model.CreditCardType = CreditCardType;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var PaymentCalculation = /** @class */ (function () {
            function PaymentCalculation() {
            }
            return PaymentCalculation;
        }());
        Model.PaymentCalculation = PaymentCalculation;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var AddPaymentAccountDetails = /** @class */ (function () {
            function AddPaymentAccountDetails() {
            }
            return AddPaymentAccountDetails;
        }());
        Model.AddPaymentAccountDetails = AddPaymentAccountDetails;
        var AddPaymentCreditCard = /** @class */ (function () {
            function AddPaymentCreditCard() {
            }
            return AddPaymentCreditCard;
        }());
        Model.AddPaymentCreditCard = AddPaymentCreditCard;
        var AddPaymentBankDetails = /** @class */ (function () {
            function AddPaymentBankDetails() {
            }
            return AddPaymentBankDetails;
        }());
        Model.AddPaymentBankDetails = AddPaymentBankDetails;
        var AddPaymentMailingAddress = /** @class */ (function () {
            function AddPaymentMailingAddress() {
            }
            return AddPaymentMailingAddress;
        }());
        Model.AddPaymentMailingAddress = AddPaymentMailingAddress;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var State = /** @class */ (function () {
            function State() {
            }
            return State;
        }());
        Model.State = State;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var StateListResponse = /** @class */ (function (_super) {
            __extends(StateListResponse, _super);
            function StateListResponse() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return StateListResponse;
        }(Model.BaseResponse));
        Model.StateListResponse = StateListResponse;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var CmsDbId = /** @class */ (function () {
            function CmsDbId() {
            }
            return CmsDbId;
        }());
        Model.CmsDbId = CmsDbId;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var CmsState = /** @class */ (function () {
            function CmsState() {
            }
            return CmsState;
        }());
        Model.CmsState = CmsState;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var EndStorefrontSessionRequest = /** @class */ (function () {
            function EndStorefrontSessionRequest() {
            }
            return EndStorefrontSessionRequest;
        }());
        Model.EndStorefrontSessionRequest = EndStorefrontSessionRequest;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var PushStorefrontRequest = /** @class */ (function () {
            function PushStorefrontRequest() {
            }
            return PushStorefrontRequest;
        }());
        Model.PushStorefrontRequest = PushStorefrontRequest;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var SelectedOptions;
        (function (SelectedOptions) {
            SelectedOptions[SelectedOptions["Unknown"] = 0] = "Unknown";
            SelectedOptions[SelectedOptions["MTOLL"] = 1] = "MTOLL";
            SelectedOptions[SelectedOptions["GINV"] = 2] = "GINV";
            SelectedOptions[SelectedOptions["OACC"] = 3] = "OACC";
            SelectedOptions[SelectedOptions["UBI"] = 4] = "UBI";
            SelectedOptions[SelectedOptions["UCI"] = 5] = "UCI";
            SelectedOptions[SelectedOptions["UAC"] = 6] = "UAC";
            SelectedOptions[SelectedOptions["URAMT"] = 7] = "URAMT";
            SelectedOptions[SelectedOptions["ARTAG"] = 8] = "ARTAG";
            SelectedOptions[SelectedOptions["MKPAY"] = 9] = "MKPAY";
            SelectedOptions[SelectedOptions["WEBST"] = 10] = "WEBST";
            SelectedOptions[SelectedOptions["CSR"] = 11] = "CSR";
            //shadow ids
            SelectedOptions[SelectedOptions["SUSACCT"] = 12] = "SUSACCT";
            SelectedOptions[SelectedOptions["SUSVIOL"] = 13] = "SUSVIOL";
            SelectedOptions[SelectedOptions["MISSINFO"] = 14] = "MISSINFO";
            SelectedOptions[SelectedOptions["LOGIN"] = 15] = "LOGIN";
            SelectedOptions[SelectedOptions["FINISHSETUP"] = 16] = "FINISHSETUP";
            SelectedOptions[SelectedOptions["EO"] = 17] = "EO";
        })(SelectedOptions = Model.SelectedOptions || (Model.SelectedOptions = {}));
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var ServiceType;
        (function (ServiceType) {
            ServiceType[ServiceType["Unknown"] = 0] = "Unknown";
            ServiceType[ServiceType["MTOLL"] = 1] = "MTOLL";
            ServiceType[ServiceType["GINV"] = 2] = "GINV";
            ServiceType[ServiceType["OACC"] = 3] = "OACC";
            ServiceType[ServiceType["UBI"] = 4] = "UBI";
            ServiceType[ServiceType["UCI"] = 5] = "UCI";
            ServiceType[ServiceType["UAC"] = 6] = "UAC";
            ServiceType[ServiceType["URAMT"] = 7] = "URAMT";
            ServiceType[ServiceType["ARTAG"] = 8] = "ARTAG";
            ServiceType[ServiceType["MKPAY"] = 9] = "MKPAY";
            ServiceType[ServiceType["WEBST"] = 10] = "WEBST";
            ServiceType[ServiceType["CSR"] = 11] = "CSR";
        })(ServiceType = Model.ServiceType || (Model.ServiceType = {}));
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var StartStorefrontSessionRequest = /** @class */ (function () {
            function StartStorefrontSessionRequest() {
            }
            return StartStorefrontSessionRequest;
        }());
        Model.StartStorefrontSessionRequest = StartStorefrontSessionRequest;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var Status;
        (function (Status) {
            Status[Status["Unknown"] = 0] = "Unknown";
            Status[Status["InProgress"] = 1] = "InProgress";
            Status[Status["Success"] = 2] = "Success";
            Status[Status["Need"] = 3] = "Need";
        })(Status = Model.Status || (Model.Status = {}));
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var StorefrontLogOffType;
        (function (StorefrontLogOffType) {
            StorefrontLogOffType[StorefrontLogOffType["Manual"] = 0] = "Manual";
            StorefrontLogOffType[StorefrontLogOffType["Auto"] = 1] = "Auto";
            StorefrontLogOffType[StorefrontLogOffType["Forced"] = 2] = "Forced";
        })(StorefrontLogOffType = Model.StorefrontLogOffType || (Model.StorefrontLogOffType = {}));
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var StorefrontSurveyRequest = /** @class */ (function () {
            function StorefrontSurveyRequest() {
            }
            return StorefrontSurveyRequest;
        }());
        Model.StorefrontSurveyRequest = StorefrontSurveyRequest;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var StoreLocations;
        (function (StoreLocations) {
            StoreLocations[StoreLocations["UKN"] = 0] = "UKN";
            StoreLocations[StoreLocations["TNO"] = 1] = "TNO";
            StoreLocations[StoreLocations["TWS"] = 2] = "TWS";
            StoreLocations[StoreLocations["TNE"] = 3] = "TNE";
            StoreLocations[StoreLocations["TEA"] = 4] = "TEA";
            StoreLocations[StoreLocations["TSW"] = 5] = "TSW";
            StoreLocations[StoreLocations["DATS"] = 6] = "DATS";
        })(StoreLocations = Model.StoreLocations || (Model.StoreLocations = {}));
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        //defines the template 'keys' workitems can use for their completion templates
        var StorefrontModalTemplatesEnum;
        (function (StorefrontModalTemplatesEnum) {
            StorefrontModalTemplatesEnum[StorefrontModalTemplatesEnum["ThankYouViolationsPayment"] = 0] = "ThankYouViolationsPayment";
            StorefrontModalTemplatesEnum[StorefrontModalTemplatesEnum["ThankYouNewAccount"] = 1] = "ThankYouNewAccount";
            StorefrontModalTemplatesEnum[StorefrontModalTemplatesEnum["VehicalViolationSuspendedAccountMessage"] = 2] = "VehicalViolationSuspendedAccountMessage";
            StorefrontModalTemplatesEnum[StorefrontModalTemplatesEnum["None"] = 3] = "None";
            StorefrontModalTemplatesEnum[StorefrontModalTemplatesEnum["FinishSetup"] = 4] = "FinishSetup";
        })(StorefrontModalTemplatesEnum = Model.StorefrontModalTemplatesEnum || (Model.StorefrontModalTemplatesEnum = {}));
        //defines static definition for a workitem defined in sitecore
        var StorefrontCmsWorkItem = /** @class */ (function () {
            function StorefrontCmsWorkItem() {
            }
            return StorefrontCmsWorkItem;
        }());
        Model.StorefrontCmsWorkItem = StorefrontCmsWorkItem;
        //defines properties of a workitem's active fields
        var WorkItem = /** @class */ (function (_super) {
            __extends(WorkItem, _super);
            function WorkItem() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return WorkItem;
        }(StorefrontCmsWorkItem));
        Model.WorkItem = WorkItem;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var VantivDto = /** @class */ (function () {
            function VantivDto(lastFour, paypageRegistrationId) {
                this.lastFour = lastFour;
                this.paypageRegistrationId = paypageRegistrationId;
            }
            return VantivDto;
        }());
        Model.VantivDto = VantivDto;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var VantivRequestLog = /** @class */ (function () {
            function VantivRequestLog() {
            }
            return VantivRequestLog;
        }());
        Model.VantivRequestLog = VantivRequestLog;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var VantivResponse = /** @class */ (function () {
            function VantivResponse() {
            }
            return VantivResponse;
        }());
        Model.VantivResponse = VantivResponse;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var VantivResponseLog = /** @class */ (function () {
            function VantivResponseLog() {
            }
            return VantivResponseLog;
        }());
        Model.VantivResponseLog = VantivResponseLog;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var VantivTriPosConfiguration = /** @class */ (function (_super) {
            __extends(VantivTriPosConfiguration, _super);
            function VantivTriPosConfiguration() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return VantivTriPosConfiguration;
        }(HCTRA.Model.BaseResponse));
        Model.VantivTriPosConfiguration = VantivTriPosConfiguration;
        var VantivTriPosStatus = /** @class */ (function (_super) {
            __extends(VantivTriPosStatus, _super);
            function VantivTriPosStatus() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return VantivTriPosStatus;
        }(HCTRA.Model.BaseResponse));
        Model.VantivTriPosStatus = VantivTriPosStatus;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var VantivTriPosRequest = /** @class */ (function () {
            function VantivTriPosRequest() {
            }
            return VantivTriPosRequest;
        }());
        Model.VantivTriPosRequest = VantivTriPosRequest;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var VantivTriPosCreateOmniTokenResponse = /** @class */ (function () {
            function VantivTriPosCreateOmniTokenResponse() {
            }
            return VantivTriPosCreateOmniTokenResponse;
        }());
        Model.VantivTriPosCreateOmniTokenResponse = VantivTriPosCreateOmniTokenResponse;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var CoreViolationsData = /** @class */ (function () {
            function CoreViolationsData() {
            }
            return CoreViolationsData;
        }());
        Model.CoreViolationsData = CoreViolationsData;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var Invoice = /** @class */ (function () {
            function Invoice() {
            }
            return Invoice;
        }());
        Model.Invoice = Invoice;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var PaymentPageSetupOut = /** @class */ (function () {
            function PaymentPageSetupOut() {
            }
            return PaymentPageSetupOut;
        }());
        Model.PaymentPageSetupOut = PaymentPageSetupOut;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var ReceiptPageSetupOut = /** @class */ (function () {
            function ReceiptPageSetupOut() {
            }
            return ReceiptPageSetupOut;
        }());
        Model.ReceiptPageSetupOut = ReceiptPageSetupOut;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var TotalsDisplayContainer = /** @class */ (function () {
            function TotalsDisplayContainer() {
                this.amountBeingPaidNow = 0;
                this.originalAmountOwedForAll = new TotalsDisplayContainer.SelectionStatuses();
                this.amountPreviouslyPaidForAll = new TotalsDisplayContainer.SelectionStatuses();
                this.amountOwed = {
                    beforePaymentForAll: new TotalsDisplayContainer.SelectionStatuses(),
                    afterPaymentForAll: new TotalsDisplayContainer.SelectionStatuses()
                };
            }
            TotalsDisplayContainer.SelectionStatuses = /** @class */ (function () {
                function class_1() {
                    this.selectedInvoices = 0;
                    this.unselectedInvoices = 0;
                    this.invoices = 0;
                }
                return class_1;
            }());
            return TotalsDisplayContainer;
        }());
        Model.TotalsDisplayContainer = TotalsDisplayContainer;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var Violation = /** @class */ (function () {
            function Violation() {
            }
            return Violation;
        }());
        Model.Violation = Violation;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var ViolationsData = /** @class */ (function () {
            function ViolationsData() {
            }
            return ViolationsData;
        }());
        Model.ViolationsData = ViolationsData;
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
/*** Array.prototype.find ***/
(function () {
    'use strict';
    // https://tc39.github.io/ecma262/#sec-array.prototype.find
    if (!Array.prototype.find) {
        Object.defineProperty(Array.prototype, 'find', {
            value: function (predicate) {
                // 1. Let O be ? ToObject(this value).
                if (this == null) {
                    throw new TypeError('"this" is null or not defined');
                }
                var o = Object(this);
                // 2. Let len be ? ToLength(? Get(O, "length")).
                var len = o.length >>> 0;
                // 3. If IsCallable(predicate) is false, throw a TypeError exception.
                if (typeof predicate !== 'function') { // eslint-disable-line angular/typecheck-function
                    throw new TypeError('predicate must be a function');
                }
                // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
                var thisArg = arguments[1];
                // 5. Let k be 0.
                var k = 0;
                // 6. Repeat, while k < len
                while (k < len) {
                    // a. Let Pk be ! ToString(k).
                    // b. Let kValue be ? Get(O, Pk).
                    // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
                    // d. If testResult is true, return kValue.
                    var kValue = o[k];
                    if (predicate.call(thisArg, kValue, k, o)) {
                        return kValue;
                    }
                    // e. Increase k by 1.
                    k++;
                }
                // 7. Return undefined.
                return undefined;
            }
        });
    }
}());
/*** Array.prototype.findIndex ***/
(function () {
    'use strict';
    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
    if (!Array.prototype.findIndex) {
        Object.defineProperty(Array.prototype, 'findIndex', {
            value: function (predicate) {
                // 1. Let O be ? ToObject(this value).
                if (this == null) {
                    throw new TypeError('"this" is null or not defined');
                }
                var o = Object(this);
                // 2. Let len be ? ToLength(? Get(O, "length")).
                var len = o.length >>> 0;
                // 3. If IsCallable(predicate) is false, throw a TypeError exception.
                if (typeof predicate !== 'function') { // eslint-disable-line angular/typecheck-function
                    throw new TypeError('predicate must be a function');
                }
                // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
                var thisArg = arguments[1];
                // 5. Let k be 0.
                var k = 0;
                // 6. Repeat, while k < len
                while (k < len) {
                    // a. Let Pk be ! ToString(k).
                    // b. Let kValue be ? Get(O, Pk).
                    // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
                    // d. If testResult is true, return k.
                    var kValue = o[k];
                    if (predicate.call(thisArg, kValue, k, o)) {
                        return k;
                    }
                    // e. Increase k by 1.
                    k++;
                }
                // 7. Return -1.
                return -1;
            }
        });
    }
}());
(function () {
    'use strict';
    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function (search, pos) {
            return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        };
    }
}());
(function () {
    'use strict';
    if (!String.prototype.endsWith) {
        String.prototype.endsWith = function (search, this_len) {
            if (this_len === undefined || this_len > this.length) { // eslint-disable-line angular/definedundefined
                this_len = this.length;
            }
            return this.substring(this_len - search.length, this_len) === search;
        };
    }
}());
(function () {
    "use strict";
    describe("asyncActionsProvider", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var asyncActionsProvider;
        beforeEach(function () {
            asyncActionsProvider = new HCTRA.Service.AsyncActionsProvider();
        });
        describe('tests', function () {
            it('has $q as first dep in $get', function () {
                expect(asyncActionsProvider.$get[0]).toBe('$q');
            });
            it('registers new provider dep', function () {
                asyncActionsProvider.register('test');
                expect(asyncActionsProvider.$get.length).toBe(3);
                expect(asyncActionsProvider.$get[0]).toBe('$q');
                expect(asyncActionsProvider.$get[1]).toBe('test');
            });
            it('always has factory method at end of resolution array', function () {
                expect(asyncActionsProvider.$get.length).toBe(2);
                expect(typeof asyncActionsProvider.$get[asyncActionsProvider.$get.length - 1]).toBe('function');
                asyncActionsProvider.register('test1');
                expect(asyncActionsProvider.$get.length).toBe(3);
                expect(typeof asyncActionsProvider.$get[asyncActionsProvider.$get.length - 1]).toBe('function');
                asyncActionsProvider.register('test2');
                expect(asyncActionsProvider.$get.length).toBe(4);
                expect(typeof asyncActionsProvider.$get[asyncActionsProvider.$get.length - 1]).toBe('function');
            });
            it('factory method calles $q.all for all arguments', function () {
                var $q = jasmine.createSpyObj('$q', ['all']);
                var factoryMethodRaw = asyncActionsProvider.$get[1];
                var a = { then: function () { } };
                var b = { then: function () { } };
                var c = { then: function () { } };
                var r = { then: function () { } };
                $q.all.and.returnValue(r);
                var result = factoryMethodRaw($q, a, b, c);
                expect(result).toBe(r);
                expect($q.all).toHaveBeenCalled();
                var args = $q.all.calls.argsFor(0);
                expect(args).toEqual([[a, b, c]]);
            });
        });
    });
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        //this provider allows other angularjs providers to register async actions
        //that Angular will wait to complete before completing bootstrapping.
        var AsyncActionsProvider = /** @class */ (function () {
            function AsyncActionsProvider() {
                this.$get = ['$q', function ($q) {
                        var promises = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            promises[_i - 1] = arguments[_i];
                        }
                        return $q.all(promises);
                    }];
            }
            //register a provider; the provider must define it's $get method to return a promise        
            AsyncActionsProvider.prototype.register = function (asyncActionProviderName) {
                //adds to resolution array
                this.$get.splice(-1, 0, asyncActionProviderName);
            };
            return AsyncActionsProvider;
        }());
        Service.AsyncActionsProvider = AsyncActionsProvider;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    angular.module('HCTRAModule').provider('asyncActions', HCTRA.Service.AsyncActionsProvider);
})();
(function () {
    'use strict';
    //This follows http://www.bennadel.com/blog/2542-logging-client-side-errors-with-angularjs-and-stacktrace-js.htm
    // By default, AngularJS will catch errors and log them to
    // the Console. We want to keep that behavior; however, we
    // want to intercept it so that we can also log the errors
    // to the server for later analysis.
    angular.module('HCTRAModule').provider("$exceptionHandler", {
        $get: ["errorLogService", function (errorLogService) {
                return (errorLogService);
            }]
    });
}());
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
(function () {
    'use strict';
    angular.module('HCTRAModule').provider('dynamicRouteDefinition', ['routes', 'environmentConfig',
        function (routes, environmentConfig) {
            this.$get = [function () {
                    return (environmentConfig.refreshCMSSimplePage ? [] : [{
                            url: routes.nonSectionalCms,
                            templateUrl: '/app/cms/templates/genericNonSectionalCmsTemplate.html',
                            controller: 'GenericNonSectionalCmsController'
                        }]).concat((environmentConfig.refreshCMSSimplePage ? [] : [{
                            url: routes.sectionalCms,
                            templateUrl: '/app/cms/templates/genericSectionalCmsTemplate.html',
                            controller: 'GenericSectionalCmsController'
                        }]), (environmentConfig.useNewsRefresh ? [] : [
                        {
                            url: routes.singleArticle,
                            templateUrl: '/app/cms/templates/singleArticle.html',
                            controller: 'SingleArticleController'
                        },
                    ]), [
                        {
                            url: routes.genericJobCms,
                            templateUrl: '/app/cms/templates/aboutUs/employment/genericJobPage.html',
                            controller: 'GenericJobPageController'
                        }
                    ]).map(function (config) { return ({ config: config }); });
                }];
        }]);
    angular.module('HCTRAModule').provider('router', [
        '$stateProvider',
        'routes', 'stateNames',
        'USER_ROLES',
        'quickLinkNav',
        'cavveStates',
        'cavveRoutes',
        'angularEnvironment',
        'accountActivityStates',
        'accountActivityRoutes',
        'forgotPasswordStates',
        'forgotPasswordRoutes',
        'firstTimeLoginStates',
        'firstTimeLoginRoutes',
        'environmentConfig',
        function RouterProvider($stateProvider, routes, stateNames, USER_ROLES, quickLinkNav, cavveStates, cavveRoutes, angularEnvironment, accountActivityStates, accountActivityRoutes, forgotPasswordStates, forgotPasswordRoutes, firstTimeLoginStates, firstTimeLoginRoutes, environmentConfig) {
            //TODO: these resolves are duplicated in Angular. delete these once all routing is migrated over    
            var authResolve = ['AuthResolver', "$transition$", function (AuthResolver, $transition$) {
                    return AuthResolver.resolve($transition$.$to().data.authorizedRoles);
                }];
            var desktopAutoRedirect = ['desktopAutoRedirect', function (desktopAutoRedirectParam) {
                    return desktopAutoRedirectParam.forceAutoRedirectDesktopView();
                }];
            var maintenanceResolve = ['maintenanceService', "$transition$", function (maintenanceService, $transition$) {
                    return maintenanceService.resolveMaintenanceStatus($transition$.$to().data.maintenanceFeaturePool, $transition$.$from().name);
                }];
            var featureToggleResolve = ['featureToggleResolver', "$transition$", function (featureToggleResolver, $transition$) {
                    return featureToggleResolver.resolveFeatureToggle($transition$.$to().data.toggle);
                }];
            var cmsResolver = function (options) {
                //set default selector. selector selects which property to deserialize from.
                var selector = (options && options.selector) || (function (r) { return angular.fromJson(r.cmsResponse); });
                //set default lookup. lookup is a map function that chooses how to read from the cms settings obj.
                var lookup = (options && options.lookup) || (function (state) { return state["cms"]; });
                //set merge params option. mergeParams allows merging URL parameters defined in the parameters property to
                //be merged directly in to the base object, removing the need to parse this field later.
                var mergeParams = options && options.mergeParams;
                return ['genericRepo', '$q', '$transition$', 'stringUtilsService', function (genericRepo, $q, $transition$, stringUtilsService) {
                        var spreadAndMerge = function (obj) {
                            var Children = obj.Children, baseObj = __rest(obj, ["Children"]);
                            return __assign({}, baseObj, stringUtilsService.getParameterObject(baseObj.Parameters), { Children: (Children || []).map(spreadAndMerge) });
                        };
                        var request = lookup($transition$.$to());
                        if (request) {
                            //send request for cms data
                            return genericRepo.dataFactory
                                .getCmsPageById(request)
                                .then(selector) //map to the desired data
                                .then(mergeParams ? spreadAndMerge : function (i) { return i; }); //merge data or return data
                        }
                        return $q.resolve(null);
                    }];
            };
            var booleanResolver = function (flag) {
                return [function () {
                        return flag;
                    }];
            };
            var suspendedRedirect = [
                'authResolve', 'USER_ROLES', 'suspendedAccountService', 'SessionService', '$state', '$q',
                function (authResolveParam, USER_ROLES_PARAM, suspendedAccountService, SessionService, $state, $q) {
                    return $q(function (resolve, reject) {
                        if (SessionService.userRole === USER_ROLES_PARAM.suspended) {
                            suspendedAccountService.getFirstSuspendedAccountState().then(function (res) {
                                $state.go(res);
                                reject();
                            });
                        }
                        else {
                            resolve();
                        }
                    });
                }
            ];
            var resolveUpdateBillingInformation = ['manageBillingInformationResolver', function (manageBillingInformationResolver) {
                    return manageBillingInformationResolver.resolveUpdateBillingInformation();
                }];
            var resolveManagePayment = ['manageBillingInformationResolver', function (manageBillingInformationResolver) {
                    return manageBillingInformationResolver.resolveManagePayment();
                }];
            //HCTRA.ORG defined routes.
            function createRoutes() {
                var urls = routes;
                var states = stateNames;
                var userRoles = USER_ROLES;
                //Example
                //{
                //	name: 'AccountActivity', ---- used to match up with children
                //	config: {
                //		templateUrl: '/app/templates/accountActivity/accountActivity.html', ---- associated html
                //		controller: 'AccountActivityController', ---- associated controller
                //		resolve: {
                //			authResolve: authResolve, ---- check for authentication and authorization
                //          maintenanceResolve: maintenanceResolve ---- check to see if feature is in maintenance mode
                //		},
                //      onEnter: desktopAutoRedirect ---- redirects to desktop view if desktop only page on mobile
                //		url: urls.accountActivity, ---- url
                //		settings: {
                //			parent: states.eZTagAccount, ---- parent in menu dropdown
                //			navlevel: 1, ---- level in menu, 0 = top level; 1 = submenu under 0; 2 = submenu under 1
                //			nav: 2, ---- order in menu
                //			content: 'Account Activity' ---- display on menu
                //			external: true, ---- external link outside of the mobile site
                //			phone: 1-800-000-0000, ---- phone number to call
                //			traveltools: true, ---- if traveltools link to map,
                //          useName: true, ---- set to true if you want to use the state name instead of url
                //          defaultOpenId: string,  ---- used by hamburger menu to open menu items on login by default
                //          linkGroupKey: string, ---- used by megamenu to highlight correct links; should match CMS megamenu link "Wizard State Name" property
                //          isHybrid: boolean ---- used by DesktopUiDirective to modify the legacy pages for Refresh website
                //		},
                //		data: {
                //			authorizedRoles: [userRoles.active, userRoles.suspended, userRoles.pendingClosure],
                //          maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                //		},
                //		quickLink: {
                //			nav: 2, ---- order in quick links
                //			content: 'View EZ TAG Account Activity' ---- display on quick links
                //          external: true, ---- external link outside of the mobile site
                //          pdf: true, ---- for pdf's that are hosted on mobile site
                //		},
                //      cms: {
                //		    path: urls.ratesInformation,
                //		    fields: "Title,ShortDescription,LongDescription,DisplayName,TollingLocations,LocationType,2Axles-Cash,2Axles,3Axles,4Axles,5Axles,6Axles,Bold,Position"
                //      }
                //	}
                //},
                var t = [
                    {
                        name: states.accountSummaryCollapser,
                        config: {
                            abstract: true,
                            settings: {
                                parent: states.eZTagAccount,
                                navlevel: 1,
                                nav: 1,
                                content: "Account Summary",
                                defaultOpenId: 'accountsummary',
                                currentBalance: true,
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active, userRoles.suspended, userRoles.pendingClosure]
                            }
                        }
                    }, {
                        name: states.eZTagAccount,
                        config: {
                            settings: {
                                navlevel: 0,
                                nav: 2,
                                content: "<img src='../Content/icons/menu/hm_ez_tag_acct.png' alt='Click to see account options'>   EZ TAG Account",
                                defaultOpenId: 'eztagaccount',
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            }
                        }
                    }, {
                        name: states.activityGraph,
                        config: {
                            url: urls.activityGraph,
                            templateUrl: '/app/templates/account/activityGraph.html',
                            controller: 'ActivityGraphController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active, userRoles.pendingClosure, userRoles.suspended],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            cms: {
                                id: urls.viewActivityGraphPage
                            },
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve,
                                //redirects user to appropriate suspended page from Account Summary if they're suspended
                                suspendedRedirect: suspendedRedirect
                            }
                        }
                    }, {
                        name: states.accountSummary,
                        config: {
                            abstract: true,
                            url: urls.accountSummary,
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active, userRoles.pendingClosure, userRoles.suspended],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve,
                                //redirects user to appropriate suspended page from Account Summary if they're suspended
                                suspendedRedirect: suspendedRedirect
                            }
                        }
                    },
                    {
                        name: states.accountActivityCollapser,
                        config: {
                            abstract: true,
                            settings: {
                                parent: states.eZTagAccount,
                                navlevel: 1,
                                nav: 2,
                                content: "Account Activity",
                                defaultOpenId: 'accountactivity',
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active, userRoles.suspended, userRoles.pendingClosure]
                            }
                        }
                    }
                ].concat((environmentConfig.twoFactorAuth.enableForgotPassword ? [] : [
                    {
                        name: states.forgotPasswordEmail,
                        config: {
                            url: urls.forgotPasswordEmail,
                            templateUrl: '/app/templates/forgotPassword/forgotPasswordEmail.html',
                            controller: 'ForgotPasswordEmailController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.forgotPassword,
                        config: {
                            url: urls.forgotPassword,
                            templateUrl: '/app/templates/forgotPassword/forgotPassword.html',
                            controller: 'ForgotPasswordController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.forgotPasswordAccount,
                        config: {
                            url: urls.forgotPasswordAccount,
                            templateUrl: '/app/templates/forgotPassword/forgotPasswordAccount.html',
                            controller: 'ForgotPasswordAccountController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.forgotPasswordEmailSent,
                        config: {
                            url: urls.forgotPasswordEmailSent,
                            templateUrl: '/app/templates/forgotPassword/forgotPasswordEmailSent.html',
                            controller: 'ForgotPasswordEmailSentController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous] //Protected as intra-process request w/ webStorage
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.forgotPasswordValidateAccount,
                        config: {
                            url: urls.forgotPasswordValidateAccount,
                            templateUrl: '/app/templates/forgotPassword/validateAccount.html',
                            controller: 'ValidateAccountController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }
                ]), [
                    {
                        name: states.forgotPasswordParent,
                        config: {
                            template: "<div ui-view></div>",
                            controller: 'ForgotPasswordParentController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous] //Protected as intra-process request w/ webStorage
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.forgotPasswordValidateAccountEmail,
                        config: {
                            url: (urls.forgotPasswordValidateAccountEmail),
                            templateUrl: '/app/templates/forgotPassword/validateAccount.html',
                            controller: 'ValidateAccountEmailController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.forgotPasswordReset,
                        config: {
                            url: urls.forgotPasswordReset,
                            templateUrl: '/app/templates/forgotPassword/passwordReset.html',
                            controller: 'PasswordResetController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            },
                            cms: {
                                itemId: urls.loginCms
                                //fields: 'Image'
                            }
                        }
                    },
                    {
                        name: states.flexbooker,
                        config: {
                            url: urls.flexbooker,
                            component: 'flexbookerCreateAccountController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active, userRoles.pendingClosure]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }
                ], (environmentConfig.useActivateEZTagRefresh ? [] : [
                    {
                        name: states.activateEzTagParent,
                        config: {
                            abstract: true,
                            templateUrl: '/app/templates/activateEzTag/activateEzTagHeaderPartial.html',
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                                //maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            resolve: {
                                authResolve: authResolve
                                //maintenanceResolve: maintenanceResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    },
                    {
                        name: states.activateEzTag,
                        config: {
                            url: urls.activateEzTag,
                            controller: 'ActivateEzTagController',
                            templateUrl: '/app/templates/activateEzTag/activateEzTag.html',
                            settings: {
                                nav: 2,
                                navlevel: 2,
                                parent: states.vehicleEzTags,
                                content: 'Activate EZ TAG',
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve
                            },
                            quickLink: {
                                nav: quickLinkNav.activateEzTag,
                                content: 'Activate EZ TAG'
                            }
                        }
                    }, {
                        name: states.confirmTagActivation,
                        config: {
                            url: urls.confirmTagActivation,
                            controller: 'ConfirmTagActivationController',
                            templateUrl: '/app/templates/activateEzTag/confirmTagActivation.html',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve
                            }
                        }
                    }
                ]), [
                    {
                        name: states.tagActivationGratitude,
                        config: {
                            url: urls.tagActivationGratitude,
                            controller: 'TagActivationGratitudeController',
                            templateUrl: '/app/templates/activateEzTag/tagActivationGratitude.html',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve
                            }
                        }
                    }, {
                        name: states.EZTAGAgreement,
                        config: {
                            url: urls.EZTAGAgreement,
                            title: 'EZ TAG Agreement',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            quickLink: {
                                nav: quickLinkNav.EZTAGAgreement,
                                content: 'EZ TAG Agreement',
                                pdf: true
                            }
                        }
                    }
                ], (environmentConfig.useNewsRefresh ? [] : [
                    {
                        name: states.News,
                        config: {
                            url: urls.news,
                            title: 'News',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }
                ]), [
                    {
                        name: states.EZTAGExpressApp,
                        config: {
                            url: urls.cmsEZTAGExpressAppPage,
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            quickLink: {
                                nav: quickLinkNav.EZTAGExpressApp,
                                content: 'EZ TAG Express App',
                                hideWhenAuthenticated: true,
                                isCmsUrl: true
                            },
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.accountInformationParent,
                        config: {
                            abstract: true,
                            template: "<div ui-view></div>",
                            controller: 'AccountInformationParentController',
                            settings: {
                                navlevel: 1,
                                nav: 3,
                                parent: states.eZTagAccount,
                                content: 'Account Information',
                                defaultOpenId: 'accountinformation',
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active, userRoles.pendingClosure],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve
                            }
                        }
                    }, {
                        // TODO: Prefix all ManagePayment stateNames and urls 
                        name: states.managePaymentParent,
                        config: {
                            abstract: true,
                            template: "<div ui-view></div>",
                            controller: 'ManagePaymentParentController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.managePayment,
                        config: {
                            url: urls.managePayment,
                            title: 'Update Billing Information',
                            templateUrl: '/app/templates/account/managePayment.html',
                            controller: 'ManagePaymentController',
                            settings: {
                                navlevel: 2,
                                nav: 6,
                                parent: states.accountInformationParent,
                                content: 'Update Billing Information',
                                linkGroupKey: 'UpdateBillingInformation',
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            quickLink: {
                                nav: quickLinkNav.managePayment,
                                content: 'Update Billing Information'
                            },
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve,
                                resolveManagePayment: resolveManagePayment
                            }
                        }
                    }, {
                        name: states.updateBillingInformation,
                        config: {
                            url: urls.managePaymentUpdateBilling,
                            title: 'Update Payment',
                            templateUrl: '/app/templates/account/updateBillingInformation.html',
                            controller: 'UpdateBillingInformationController',
                            settings: {
                                linkGroupKey: 'UpdateBillingInformation',
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                resolveManagePayment: resolveManagePayment
                            }
                        }
                    }, {
                        name: states.addSecondaryCreditCard,
                        config: {
                            url: urls.managePaymentAddSecondaryCreditCard,
                            title: 'Add Secondary Credit Card',
                            templateUrl: '/app/templates/account/addSecondaryCreditCard.html',
                            controller: 'AddSecondaryCreditCardController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                resolveManagePayment: resolveManagePayment
                            }
                        }
                    }, {
                        name: states.updateSecondaryCreditCard,
                        config: {
                            url: urls.managePaymentUpdateSecondaryCreditCard,
                            title: 'Update Secondary Credit Card',
                            templateUrl: '/app/templates/account/updateSecondaryCreditCard.html',
                            controller: 'UpdateSecondaryCreditCardController',
                            settings: {
                                linkGroupKey: 'UpdateBillingInformation',
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                resolveManagePayment: resolveManagePayment
                            }
                        }
                    }, {
                        name: states.saveBillingInformation,
                        config: {
                            url: urls.managePaymentSaveBillingInformation,
                            title: 'Save Billing Information',
                            templateUrl: '/app/templates/account/saveBillingInformation.html',
                            controller: 'SaveBillingInformationController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.active]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                resolveManagePayment: resolveManagePayment
                            }
                        }
                    }
                ], (environmentConfig.useHelpAndSupportRefresh ? [] : [
                    {
                        name: states.helpAndSupport,
                        config: {
                            url: urls.helpAndSupport,
                            title: 'Help & Support',
                            component: 'helpAndSupportComponent',
                            settings: {
                                isHybrid: true
                            },
                            cms: {
                                ItemId: urls.helpAndSupportPageCms,
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve,
                                cmsContent: cmsResolver({ mergeParams: false })
                            }
                        }
                    }
                ]), (environmentConfig.twoFactorAuth.enableFirstTimeLogin ? [] : [
                    {
                        name: states.setupOnlineAccess,
                        config: {
                            abstract: true,
                            title: 'Setup Online Access',
                            templateUrl: '/app/templates/setupOnlineAccess/setupOnlineAccess.html',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.notAuthenticated]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.setupOnlineAccessIdentification,
                        config: {
                            url: urls.setupOnlineAccess,
                            title: 'Setup Online Access',
                            templateUrl: '/app/templates/setupOnlineAccess/setupOnlineAccessIdentification.html',
                            controller: 'SetupOnlineAccessIdentificationController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.notAuthenticated]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }, {
                        name: states.setupOnlineAccessLoginInfo,
                        config: {
                            url: urls.setupOnlineAccessLoginInfo,
                            title: 'Setup Online Access',
                            templateUrl: '/app/templates/setupOnlineAccess/setupOnlineAccessLoginInfo.html',
                            controller: 'SetupOnlineAccessLoginInfoController',
                            data: {
                                authorizedRoles: [userRoles.notAuthenticated]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    }, {
                        name: states.setupOnlineAccessConfirmation,
                        config: {
                            url: urls.setupOnlineAccessConfirmation,
                            title: 'Setup Online Access',
                            templateUrl: '/app/templates/setupOnlineAccess/setupOnlineAccessConfirmation.html',
                            controller: 'SetupOnlineAccessConfirmationController',
                            data: {
                                authorizedRoles: [userRoles.notAuthenticated]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    }
                ]), [
                    {
                        name: states.vehicleEzTags,
                        config: {
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            settings: {
                                navlevel: 1,
                                parent: states.eZTagAccount,
                                nav: 4,
                                content: 'Vehicles and EZ TAGs',
                                defaultOpenId: 'vehicleEzTags',
                                isHybrid: true
                            }
                        }
                    },
                    {
                        name: states.travelTools,
                        config: {
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            settings: {
                                navlevel: 0,
                                nav: 6,
                                content: "<img src='../Content/icons/menu/hm_travel_tools.png' alt='Click for travel tools'>   Travel Tools",
                                isHybrid: true
                            }
                        }
                    }, {
                        name: states.CALLROADSIDEASSISTANCE,
                        config: {
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            settings: {
                                navlevel: 0,
                                nav: 7,
                                content: "<img src='../Content/icons/menu/hm_roadside_assistance.png' alt='Click to call roadside assistance'>   Call Roadside Assistance",
                                phone: 'tel: ' + urls.roadSideAssistPhoneNumber,
                                isHybrid: true
                            }
                        }
                    }, {
                        name: states.validatePrimaryEmail,
                        config: {
                            url: urls.validatePrimaryEmail,
                            controller: 'ValidatePrimaryEmailController',
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    }, {
                        name: states.sendEmailConfirmation,
                        config: {
                            url: urls.sendEmailConfirmation,
                            controller: 'SendEmailConfirmationController',
                            template: '<div></div>',
                            data: {
                                authorizedRoles: [userRoles.active, userRoles.pendingClosure]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    },
                    {
                        name: states.closeAccountParentFrame,
                        config: {
                            abstract: true,
                            templateUrl: '/app/templates/account/closeAccount/closeAccountParentFrame.html',
                            data: {
                                authorizedRoles: [userRoles.active],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    }, {
                        name: states.closeAccountCreditInformation,
                        config: {
                            url: urls.closeAccountCreditInformation,
                            templateUrl: '/app/templates/account/updateBillingInformation.html',
                            controller: 'CloseAccountUpdateBillingInformationController',
                            data: {
                                authorizedRoles: [userRoles.active]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    }, {
                        name: states.closeAccountSaveBillingInformation,
                        config: {
                            url: urls.closeAccountSaveBillingInformation,
                            templateUrl: '/app/templates/account/saveBillingInformation.html',
                            controller: 'CloseAccountSaveBillingInformationController',
                            data: {
                                authorizedRoles: [userRoles.active]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            settings: {
                                isHybrid: true
                            }
                        }
                    }, {
                        name: states.employment,
                        config: {
                            url: urls.employment,
                            title: 'Employment',
                            templateUrl: '/app/cms/templates/aboutUs/employment/employmentPage.html',
                            controller: 'EmploymentPageController',
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            cms: {
                                itemId: urls.employmentContent,
                                fields: 'Title,LongDescription,Image,File,Location,Department,File,Hours,Salary,JobRequirements,Closing,Contact,Document,ItemName,ItemPath'
                            }
                        }
                    }
                ], (environmentConfig.useNewsRefresh ? [] : [
                    {
                        name: states.newsFeed,
                        config: {
                            url: urls.newsFeed,
                            title: 'News Feed',
                            templateUrl: '/app/cms/templates/article.html',
                            controller: 'ArticleController',
                            reloadOnSearch: false,
                            settings: {
                                navlevel: 1,
                                nav: 1,
                                parent: states.travelTools,
                                content: "News",
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            quickLink: {
                                nav: quickLinkNav.newsFeed,
                                content: 'News'
                            },
                            cms: {
                                pageTitleId: urls.newsFeedTitleCmsId,
                                allSearchQueryId: urls.allNewsArticles,
                                archive: states.newsArchive,
                                archiveName: "News"
                            }
                        }
                    }
                ]), (environmentConfig.useNewsRefresh ? [] : [
                    {
                        name: states.newsArchive,
                        config: {
                            url: urls.newsArchive,
                            title: 'News Archive',
                            templateUrl: '/app/cms/templates/searchArchive.html',
                            controller: 'SearchArticleController',
                            parentState: states.newsArchive,
                            reloadOnSearch: false,
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    }
                ]), [
                    {
                        name: states.newsArchiveChild,
                        config: {
                            url: urls.archiveUrlPattern,
                            controller: 'SearchArticleChildController',
                            title: 'News Archive Child',
                            params: {
                                category: null,
                                page: {
                                    value: null,
                                    squash: true
                                },
                                size: {
                                    value: null,
                                    squash: true
                                }
                            },
                            template: "<div ui-view></div>",
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            cms: {
                                pageTitleId: urls.newsArchiveCmsTitleId,
                                pageTitleFields: "Title",
                                categoriesId: urls.newsArchiveCmsCategoriesAllId,
                                categoriesFolderId: urls.newsArchiveCmsCategoriesFolderId,
                                categoriesFields: "Title,QueryId,DisplayName,ItemPath,ItemName",
                                titleType: "News"
                            }
                        }
                    }, {
                        name: states.closures,
                        config: {
                            url: urls.closures,
                            title: 'Closures',
                            settings: {
                                nav: 2,
                                parent: states.travelTools,
                                content: "Closures",
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            cms: {},
                            quickLink: {
                                nav: quickLinkNav.closures,
                                content: 'Closures',
                                external: true
                            }
                        }
                    }
                ], (environmentConfig.useFaqRefresh ? [] : [
                    {
                        name: states.faq,
                        config: {
                            url: urls.faq,
                            title: 'Frequently Asked Questions',
                            templateUrl: '/app/cms/templates/helpAndSupport/faq.html',
                            controller: 'SearchArticleController',
                            parentState: states.faq,
                            reloadOnSearch: false,
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            }
                        }
                    },
                    {
                        name: states.faqChild,
                        config: {
                            url: urls.archiveUrlPattern,
                            controller: 'SearchArticleChildController',
                            title: 'Frequently Asked Questions Child',
                            params: {
                                category: null,
                                page: {
                                    value: null,
                                    squash: true
                                },
                                size: {
                                    value: null,
                                    squash: true
                                }
                            },
                            template: "<div ui-view></div>",
                            settings: {
                                isHybrid: true
                            },
                            data: {
                                authorizedRoles: [userRoles.anonymous]
                            },
                            resolve: {
                                authResolve: authResolve
                            },
                            cms: {
                                pageTitleId: urls.faqPageTitleId,
                                pageTitleFields: "Title",
                                categoriesId: urls.faqCategoriesAllId,
                                categoriesFolderId: urls.faqCategoriesFolderId,
                                categoriesFields: "Title,QueryId,DisplayName,ItemPath,ItemName",
                                titleType: "FAQ",
                                topSearch: urls.faqTopSearchId,
                                topFields: "title,shortdescription,longdescription,category,image,__publish,ItemID&includeStandardTemplatefields=true"
                            }
                        }
                    }
                ]));
                var mobileAppRedirectRoutes = (function () { return [
                    "mobileRedirect",
                    "ezTagMobileRedirect"
                ]; })()
                    .map(function (state) { return ({
                    name: states[state],
                    config: {
                        url: urls[state],
                        title: states[state].replace(".", " -").split(/(?=[A-Z])/).join(" "),
                        template: '<div></div>',
                        controller: 'MobileAppRedirectController',
                        settings: {
                            isHybrid: true
                        },
                        data: {
                            authorizedRoles: [userRoles.anonymous]
                        },
                        resolve: {
                            authResolve: authResolve
                        }
                    }
                }); });
                var manageBillingInformationRoutes = (function () { return [
                    "editCreditCardInformation",
                    "editBankAccountInformation",
                    "editCreditCardAddress",
                    "addCreditCardInformation",
                    "addBankAccountInformation",
                    "makePaymentMethodPrimary"
                    //,
                    //"deletePaymentMethod"
                ]; })()
                    .map(function (state) { return ({
                    name: states[state],
                    config: {
                        url: urls[state],
                        template: '',
                        controller: "ManageBillingInformationSubController",
                        title: states[state].replace(".", " -").split(/(?=[A-Z])/).join(" "),
                        settings: {
                            isHybrid: true
                        },
                        data: {
                            authorizedRoles: [userRoles.active]
                        },
                        quickLink: {},
                        resolve: {
                            authResolve: authResolve,
                            resolveUpdateBillingInformation: resolveUpdateBillingInformation
                        }
                    }
                }); });
                var storefrontRoutes = [
                    {
                        name: states.storefrontSelection,
                        config: {
                            url: urls.storefrontSelection,
                            views: {
                                "storefront": {
                                    templateUrl: "/app/templates/storefront/StorefrontOptionSelectionTemplate.html",
                                    controller: 'StorefrontOptionSelectionController'
                                }
                            },
                            settings: {},
                            data: {
                                authorizedRoles: [userRoles.anonymous],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve
                            },
                            cms: {
                                taskSelectionPageId: urls.storefrontTaskSelectionPageId,
                                hoverIconId: urls.storefrontHoverIconId,
                                defaultIconId: urls.storefrontDefaultIconId,
                                selectedIconId: urls.storefrontSelectedIconId
                            }
                        }
                    },
                    {
                        name: states.storefrontSurvey,
                        config: {
                            url: urls.storefrontSurvey,
                            views: {
                                "storefront": {
                                    templateUrl: '/app/templates/storefront/StorefrontSurveyTemplate.html',
                                    controller: 'StorefrontSurveyController'
                                }
                            },
                            settings: {},
                            data: {
                                authorizedRoles: [userRoles.anonymous],
                                maintenanceFeaturePool: [HCTRA.Model.MaintenanceFeature.Account]
                            },
                            quickLink: {},
                            resolve: {
                                authResolve: authResolve,
                                maintenanceResolve: maintenanceResolve
                            },
                            cms: {
                                surveyId: urls.storefrontSurveyId,
                                surveyFields: '',
                                surveyThankYouModalId: urls.storefrontThankYouSurveyModal,
                                surveyThankYouModalFields: ''
                            }
                        }
                    }
                ];
                var storefrontVersion = environmentConfig.storefrontConfigs.version || '1.0.0';
                var rawRoutes = t
                    .concat((+storefrontVersion.split('.')[0]) > 1 ? [] : storefrontRoutes)
                    .concat(manageBillingInformationRoutes)
                    .concat(mobileAppRedirectRoutes);
                rawRoutes.forEach(function (r) {
                    r.config['angularjs'] = true;
                    $stateProvider.state(r.name, r.config);
                });
                return rawRoutes;
            }
            //define provider factory 'get' method
            this.$get = [function () {
                    return createRoutes();
                }
            ];
        }
    ]);
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var DynamicRoutesAsyncActionProvider = /** @class */ (function () {
            function DynamicRoutesAsyncActionProvider(asyncActionsProvider) {
                this.$get = ['router', 'urlManagerService', '$urlRouter', 'templateCacheHelper', 'linkLookupService', 'responseErrorService', '$state', 'futureRoutes', 'dynamicRouteDefinition',
                    function (router, urlManagerService, $urlRouter, templateCacheHelper, linkLookupService, responseErrorService, $state, futureRoutes, dynamicRouteDefinition) {
                        if (!this.readyPromise) {
                            var authResolve_1 = ['AuthResolver', "$transition$", function (AuthResolver, $transition$) {
                                    return AuthResolver.resolve($transition$.$to().data.authorizedRoles);
                                }];
                            this.readyPromise = urlManagerService
                                .getStartingRoutes({ angularStates: dynamicRouteDefinition })
                                .then(function (response) {
                                if (!response.errors && response.states.length !== 0) {
                                    response.states.forEach(function (element) {
                                        element.config.resolve.authResolve = authResolve_1;
                                        element.config.settings = __assign({}, (element.config.settings || {}), { isHybrid: true });
                                        var newState = __assign({}, element.config, { name: element.name, angularjs: true });
                                        $state.router.stateRegistry.register(newState);
                                    });
                                    linkLookupService.cmsPathDictionary = response.articleLookupByPath;
                                    linkLookupService.cmsIdDictionary = response.articleLookupById;
                                }
                                else {
                                    responseErrorService.displayErrorsFromResponse(response, true);
                                }
                                // $urlRouter.sync();
                                // $urlRouter.listen();
                            })
                                .then(function () {
                                templateCacheHelper.constructUncachedList();
                            });
                        }
                        return this.readyPromise;
                    }];
                asyncActionsProvider.register(DynamicRoutesAsyncActionProvider.angularJsRegistrationName);
            }
            DynamicRoutesAsyncActionProvider.$inject = ['asyncActionsProvider'];
            DynamicRoutesAsyncActionProvider.angularJsRegistrationName = 'routerBootstrapReady';
            return DynamicRoutesAsyncActionProvider;
        }());
        Service.DynamicRoutesAsyncActionProvider = DynamicRoutesAsyncActionProvider;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    angular.module('HCTRAModule')
        .provider(HCTRA.Service.DynamicRoutesAsyncActionProvider.angularJsRegistrationName, HCTRA.Service.DynamicRoutesAsyncActionProvider);
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').provider('urlAlias', function () {
        var aliases = function () {
            return [
                { url: '/about_locations', redirectTo: '/HelpAndSupport#customer-service' },
                { url: '/about_locations/', redirectTo: '/HelpAndSupport#customer-service' },
                // 
                { url: '/FrequentlyAskedQuestions/:param/:param2/:param3?', redirectTo: '/FAQ/:param/:param2/:param3' },
                { url: '/FrequentlyAskedQuestions/:param/:param2?', redirectTo: '/FAQ/:param/:param2' },
                { url: '/FrequentlyAskedQuestions/:param?', redirectTo: '/FAQ/:param' },
                { url: '/FrequentlyAskedQuestions', redirectTo: '/FAQ/' },
                //
                { url: '/AccountSummary', redirectTo: '/AccountOverview' },
                { url: '/AccountSummary/', redirectTo: '/AccountOverview' }
            ];
        };
        return {
            $get: aliases
        };
    });
})();
//Migrated
//(function () {
//    "use strict";
//
//    angular.module("HCTRAModule").factory("stateChangeStartChannel", ["$rootScope","$transitions",
//		function ($rootScope,$transitions) {
//
//		    //event is published by UI-Router
//
//		    // subscribe to event		    
//		    var onStateChangeStart = function ($scope, handler) {
//		        var destroyStateChangeStart = $rootScope.$on("$stateChangeStart", function (event, toState, toParams, fromState, options) {
//		            handler(event, toState, toParams, fromState, options);
//		        });
//
//		        $rootScope.$on("$destroy", function () {
//		            destroyStateChangeStart();
//		        });
//
//		        return destroyStateChangeStart;
//		    };
//
//		    return {
//		        onStateChangeStart: onStateChangeStart
//		    };
//		}]);
//}());
//
////http://eburley.github.io/2013/01/31/angularjs-watch-pub-sub-best-practices.html
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var AccountBlockPopupService = /** @class */ (function () {
            function AccountBlockPopupService(stringUtilsService, modalService, osSniffer) {
                var _this = this;
                this.stringUtilsService = stringUtilsService;
                this.modalService = modalService;
                this.osSniffer = osSniffer;
                this.savePopupMessages = function (queryString) {
                    _this.messages.android = _this.stringUtilsService.getUrlParameter("MAPP_Login_Android", queryString);
                    _this.messages.ios = _this.stringUtilsService.getUrlParameter("MAPP_Login_IOS", queryString);
                    _this.messages.other = _this.stringUtilsService.getUrlParameter("MAPP_Login_Other", queryString);
                    _this.messages.browser = _this.stringUtilsService.getUrlParameter("MAPP_Login_Browser", queryString);
                };
                this.getPopupMessages = function () {
                    return _this.messages;
                };
                this.displayBlockPopup = function () {
                    var currentOs = _this.osSniffer.getOsFull();
                    var currentDevice = _this.osSniffer.getDeviceFull();
                    var popupMessage;
                    switch (currentOs) {
                        case "android":
                            popupMessage = _this.messages.android;
                            break;
                        case "ios":
                            popupMessage = _this.messages.ios;
                            break;
                        case "windows":
                        case "macos":
                        case "linux":
                            if (currentDevice === "Unknown") {
                                popupMessage = _this.messages.browser; // desktop browser
                                break;
                            }
                        // falls through
                        default:
                            popupMessage = _this.messages.other;
                    }
                    _this.showModal(popupMessage);
                };
                this.showModal = function (message) {
                    _this.modalService.showModal({
                        backdrop: true,
                        keyboard: true,
                        modalFade: true,
                        templateUrl: '/app/templates/common/modalAlert.html'
                    }, {
                        closeButtonText: 'Close',
                        headerText: null,
                        bodyText: message //'Accounts created in the EZ Toll app cannot be used to log into the website'
                    });
                };
                this.messages = new HCTRA.Model.CmsBlockMessages();
            }
            AccountBlockPopupService.$inject = ["stringUtilsService", "modalService", "operatingSystemSnifferService"];
            return AccountBlockPopupService;
        }());
        Service.AccountBlockPopupService = AccountBlockPopupService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('accountBlockPopupService', HCTRA.Service.AccountBlockPopupService);
}());
(function () {
    'use strict';
    // angular.module('HCTRAModule').factory('accountSummaryAlertFilterService', [ 'webStorage',
    // 	function (webStorage) {
    // 	    var storeInStorage = function (key, val) {
    // 	        var storeObject = webStorage.getValue('alertStore') || {};
    // 	        storeObject[key] = val;
    // 	        webStorage.setKeyValue('alertStore', storeObject);
    // 	    };
    // 	    var getFromStorage = function (key) {
    // 	        var val = webStorage.getValue('alertStore');
    // 	        if (!val) {
    // 	            return false;
    // 	        } else {
    // 	            if (key in val) {
    // 	                return true;
    // 	            }
    // 	        }
    // 	    };
    // 	    var removeAlerts = function () {
    // 	        webStorage.removeEntry('alertStore');
    // 	    };
    // 	    return {
    // 	        filterAccountSummaryAlerts: function (inAlertArr) {
    // 	            for (var x = 0; x < inAlertArr.length; x++) {
    // 	                if (getFromStorage(inAlertArr[x].alertMsg)) {
    // 	                    //this alert is stored so it has been shown; remove it
    // 	                    inAlertArr.splice(x, 1);
    // 	                    x--;
    // 	                } else {
    //                         //the alert is not stored, so store it
    // 	                    storeInStorage(inAlertArr[x].alertMsg, inAlertArr[x].alertId);
    // 	                }
    // 	            }
    // 	        },
    // 	        filterEmailConfirmationAlert: function (emailAddress, status) { 
    // 	            if (!getFromStorage('emailConfirm:' + emailAddress + ':' + status)) {
    // 	                //return true if the email confirmation should be shown and store the email address
    // 	                storeInStorage('emailConfirm:' + emailAddress + ':' + status, 'true');
    // 	                return true;
    // 	            } else {
    // 	                return false;
    // 	            }
    // 	        },
    // 	        removeAccountSummaryAlerts: function () {
    // 	            removeAlerts();
    // 	        }
    // 	    };
    // 	}]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var ApiDateStringToJsObjectService = /** @class */ (function () {
            function ApiDateStringToJsObjectService($filter) {
                var _this = this;
                this.$filter = $filter;
                this.convertApiDateToJsObject = function (records, propIn, propOut) {
                    angular.forEach(records, function (record) {
                        if (angular.isString(record[propIn])) {
                            record[propOut] = _this.$filter("dateWithTimeZone")(record[propIn], "dateTimeFull");
                        }
                    });
                    return records;
                };
            }
            ApiDateStringToJsObjectService.$inject = ["$filter"];
            return ApiDateStringToJsObjectService;
        }());
        Service.ApiDateStringToJsObjectService = ApiDateStringToJsObjectService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("apiDateStringToJsObjectService", HCTRA.Service.ApiDateStringToJsObjectService);
})();
(function () {
    "use strict";
    angular.module('HCTRAModule').factory("applicationLoggingService", ["$log", "loggingService",
        function ($log, loggingService) {
            var log = function (message, type) {
                // preserve default behaviour
                $log.log.apply($log, arguments);
                loggingService.logMessage(message, null, type);
            };
            return ({
                error: function (message) {
                    log(message, "error");
                },
                debug: function (message) {
                    log(message, "debug");
                },
                interceptorError: function (message) {
                    loggingService.logMessage(message, null, "InterceptorError");
                }
            });
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var ArrayUtilService = /** @class */ (function () {
            function ArrayUtilService() {
                this.intersect = function (arr1, arr2, predicateFunc) {
                    return arr1.filter(function (elem1) { return arr2.some(function (elem2) { return predicateFunc(elem1, elem2); }); });
                };
                this.difference = function (arr1, arr2, predicateFunc) {
                    return arr1.filter(function (elem1) { return !arr2.some(function (elem2) { return predicateFunc(elem1, elem2); }); });
                };
                this.find = function (inArr, predicateFunc) {
                    for (var _i = 0, inArr_1 = inArr; _i < inArr_1.length; _i++) {
                        var item = inArr_1[_i];
                        if (predicateFunc(item)) {
                            return item;
                        }
                    }
                };
                this.toDictionary = function (inArr, cb) {
                    var outObj = {};
                    for (var _i = 0, inArr_2 = inArr; _i < inArr_2.length; _i++) {
                        var elem = inArr_2[_i];
                        outObj[cb(elem).toString()] = elem;
                    }
                    return outObj;
                };
            }
            return ArrayUtilService;
        }());
        Service.ArrayUtilService = ArrayUtilService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('arrayUtilService', HCTRA.Service.ArrayUtilService);
}());
(function () {
    "use strict";
    angular.module("HCTRAModule").factory("bowserService", ["bowserjs",
        function (bowserjs) {
            var bowserFactory = {};
            bowserFactory.bowser = bowserjs;
            bowserFactory.getUserBrowserInfo = function () {
                var browserSummary = "";
                for (var property in bowserjs) {
                    // eslint-disable-next-line no-prototype-builtins
                    if (bowserjs.hasOwnProperty(property)) {
                        if (!angular.isFunction(bowserjs[property])) {
                            browserSummary = browserSummary + property + "=" + bowserjs[property] + "; ";
                        }
                    }
                }
                return browserSummary;
            };
            return bowserFactory;
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var BroadcastSubmissionService = /** @class */ (function () {
            function BroadcastSubmissionService($q, $rootScope) {
                var _this = this;
                this.$q = $q;
                this.$rootScope = $rootScope;
                this.broadcast = function (submissionIdentifier) {
                    var deferred = _this.$q.defer();
                    _this.$rootScope.$broadcast(submissionIdentifier, deferred);
                    return deferred.promise;
                };
            }
            BroadcastSubmissionService.$inject = ["$q", "$rootScope"];
            return BroadcastSubmissionService;
        }());
        Service.BroadcastSubmissionService = BroadcastSubmissionService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('broadcastSubmissionService', HCTRA.Service.BroadcastSubmissionService);
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('changePaymentMethodService', ['responseErrorService', '$filter',
        function (responseErrorService, $filter) {
            var direction = function (first, second) {
                if (first > second) {
                    return "decrease";
                }
                else {
                    return "increase";
                }
            };
            var serviceFactory = {};
            serviceFactory.displayEftToast = function (reqMinRebillAmtForCC, reqMinRebillAmtForEFT, reqLowBalLevelForEFT) {
                responseErrorService.displayToast("Updating the payment method will " + direction(reqMinRebillAmtForCC, reqMinRebillAmtForEFT) + " the minimum payment from " + $filter('currency')(reqMinRebillAmtForCC, '$') + " to " + $filter('currency')(reqMinRebillAmtForEFT, '$') + " and the rebill limit to  " + $filter('currency')(reqLowBalLevelForEFT, '$'), 'warning');
            };
            serviceFactory.displayCreditCardToast = function (reqMinRebillAmtForEFT, reqMinRebillAmtForCC, reqLowBalLevelForCC) {
                responseErrorService.displayToast("Updating the payment method will " + direction(reqMinRebillAmtForEFT, reqMinRebillAmtForCC) + " the minimum payment from  " + $filter('currency')(reqMinRebillAmtForEFT, '$') + " to  " + $filter('currency')(reqMinRebillAmtForCC, '$') + " and the rebill limit to  " + $filter('currency')(reqLowBalLevelForCC, '$'), 'warning');
            };
            return serviceFactory;
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('conditionalStylesService', [
        function () {
            var factory = {};
            factory.formWidth = function (isHidden) {
                return isHidden ? "" : "form-entry-width";
            };
            return factory;
        }
    ]);
}());
(function () {
    //do not downgrade. Switch to CreditCardTypeService.cardCodeToName
    'use strict';
    angular.module('HCTRAModule').factory('creditCardConversionService', ['creditCardTypes',
        //CreditCardType is convereted to enum in Angular
        function (creditCardTypes) {
            var serviceFactory = {};
            serviceFactory.convertCodeToString = function (creditCardCode) {
                switch (creditCardCode) {
                    case "V":
                        return creditCardTypes.visa;
                    case "M":
                        return creditCardTypes.mastercard;
                    case "D":
                        return creditCardTypes.discover;
                    case "A":
                        return creditCardTypes.amex;
                    default:
                        return "";
                }
            };
            return serviceFactory;
        }]);
}());
/* eslint-disable no-unused-vars */
var HCTRA;
(function (HCTRA) {
    var Model;
    (function (Model) {
        var CreditCardInputStrategyEnum;
        (function (CreditCardInputStrategyEnum) {
            CreditCardInputStrategyEnum[CreditCardInputStrategyEnum["Tripos"] = 0] = "Tripos";
            CreditCardInputStrategyEnum[CreditCardInputStrategyEnum["Iframe"] = 1] = "Iframe";
            CreditCardInputStrategyEnum[CreditCardInputStrategyEnum["Litel"] = 2] = "Litel";
        })(CreditCardInputStrategyEnum = Model.CreditCardInputStrategyEnum || (Model.CreditCardInputStrategyEnum = {}));
        var CreditCardPromptEnum;
        (function (CreditCardPromptEnum) {
            CreditCardPromptEnum[CreditCardPromptEnum["Wait"] = 0] = "Wait";
            CreditCardPromptEnum[CreditCardPromptEnum["Success"] = 1] = "Success";
            CreditCardPromptEnum[CreditCardPromptEnum["Failure"] = 2] = "Failure";
        })(CreditCardPromptEnum = Model.CreditCardPromptEnum || (Model.CreditCardPromptEnum = {}));
    })(Model = HCTRA.Model || (HCTRA.Model = {}));
})(HCTRA || (HCTRA = {}));
/* eslint-enable no-unused-vars */ 
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var CreditCardInputService = /** @class */ (function () {
            function CreditCardInputService($q, vantivIFrameStrategy, litelStrategy, triPosStrategy) {
                var _this = this;
                this.$q = $q;
                this.vantivIFrameStrategy = vantivIFrameStrategy;
                this.litelStrategy = litelStrategy;
                this.triPosStrategy = triPosStrategy;
                this.getStrategy = function ($scope, strategies) {
                    return _this.$q(function (resolve, reject) {
                        var strat = strategies[0];
                        if (strat) {
                            strat
                                .canUse($scope)
                                .then(function () { return strat; })
                                .catch(function () { return _this.getStrategy($scope, strategies.slice(1)); })
                                .then(resolve, reject);
                        }
                        else {
                            reject();
                        }
                    });
                };
                //don't ever ever change this. order is super important!!!
                this.chainOfResponsibility = [triPosStrategy, vantivIFrameStrategy, litelStrategy];
            }
            CreditCardInputService.prototype.setup = function ($scope) {
                var _this = this;
                return this.getStrategy($scope, this.chainOfResponsibility)
                    .then(function (strategy) { return (_this.seletedInputStrategy = strategy).setup($scope); })
                    .then(function () { return $scope.autoUpdate && _this.seletedInputStrategy.update($scope); });
            };
            CreditCardInputService.prototype.update = function ($scope) {
                return this.seletedInputStrategy ? this.seletedInputStrategy.update($scope) : this.$q.reject();
            };
            CreditCardInputService.prototype.submit = function ($scope) {
                return this.seletedInputStrategy ? this.seletedInputStrategy.submit($scope) : this.$q.reject();
            };
            CreditCardInputService.$inject = ["$q", "vantivIFrameStrategy", "litelStrategy", "triPosStrategy"];
            return CreditCardInputService;
        }());
        Service.CreditCardInputService = CreditCardInputService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule")
        .service("creditCardInputService", HCTRA.Service.CreditCardInputService);
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var LitelStrategy = /** @class */ (function () {
            function LitelStrategy(pciInfoService, vantivPaymentService, creditCardConversionService, $q) {
                this.pciInfoService = pciInfoService;
                this.vantivPaymentService = vantivPaymentService;
                this.creditCardConversionService = creditCardConversionService;
                this.$q = $q;
            }
            LitelStrategy.prototype.canUse = function () {
                return this.$q(function (resolve) { return resolve(); });
            };
            LitelStrategy.prototype.setup = function ($scope) {
                return this.$q(function (res) {
                    angular.extend($scope, {
                        visaImage: "../../../Content/icons/visa.png",
                        mastercardImage: "../../../Content/icons/mastercard.png",
                        amexImage: "../../../Content/icons/amex.png",
                        discoverImage: "../../../Content/icons/discover.png",
                        strategyUsed: HCTRA.Model.CreditCardInputStrategyEnum.Litel,
                        creditCardNameDisabled: false,
                        creditCardNumberDisabled: false,
                        creditCardExpYearDisabled: false,
                        creditCardExpMothDisabled: false
                    });
                    var unwatchCreditCard = $scope.$watch("creditCard", function (creditCard) {
                        if (!creditCard) {
                            return;
                        }
                        if ($scope.creditCard.expMonth === null) {
                            $scope.creditCard.expMonth = 1;
                            $scope.creditCard.selectedYear = new Date().getFullYear();
                        }
                        unwatchCreditCard();
                    });
                    $scope.$watch("creditCard.cardCode", function (cardCode) {
                        if (cardCode) {
                            $scope.isVisa = $scope.creditCard.cardCode === "V";
                            $scope.isMastercard = $scope.creditCard.cardCode === "M";
                            $scope.isDiscover = $scope.creditCard.cardCode === "D";
                            $scope.isAmex = $scope.creditCard.cardCode === "A";
                        }
                    });
                    if ($scope.creditCard.cardNbr) {
                        $scope.creditCard.cardNbr = "************-" + $scope.creditCard.cardNbr.slice(-4);
                    }
                    res();
                });
            };
            LitelStrategy.prototype.update = function () {
                return this.$q(function (resolve) { return resolve(); });
            };
            LitelStrategy.prototype.submit = function ($scope) {
                var _this = this;
                return this.$q(function (resolve, reject) {
                    if (_this.pciInfoService.isMasked($scope.creditCard.cardNbr)) {
                        resolve();
                    }
                    else {
                        _this.vantivPaymentService.vantivPay($scope.creditCard.cardNbr)
                            .then(function (response) {
                            angular.extend($scope.creditCard, {
                                cardNbr: "************-" + response.lastFour,
                                paypageRegistrationId: response.paypageRegistrationId,
                                cardTypeDisplay: _this.creditCardConversionService.convertCodeToString($scope.creditCard.cardCode),
                                isNewCard: true
                            });
                            resolve();
                        })
                            .catch(reject);
                    }
                });
            };
            LitelStrategy.$inject = ["pciInfoService", "vantivPaymentService", "creditCardConversionService", "$q"];
            return LitelStrategy;
        }());
        Service.LitelStrategy = LitelStrategy;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule")
        .service("litelStrategy", HCTRA.Service.LitelStrategy);
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var TriPosStrategy = /** @class */ (function () {
            function TriPosStrategy(vantivPaymentService, $q, storefrontUtilityService, modalService, responseErrorService, genericRepo, $timeout, routes, environmentConfig, creditCardConversionService) {
                this.vantivPaymentService = vantivPaymentService;
                this.$q = $q;
                this.storefrontUtilityService = storefrontUtilityService;
                this.modalService = modalService;
                this.responseErrorService = responseErrorService;
                this.genericRepo = genericRepo;
                this.$timeout = $timeout;
                this.routes = routes;
                this.environmentConfig = environmentConfig;
                this.creditCardConversionService = creditCardConversionService;
            }
            TriPosStrategy.prototype.canUse = function () {
                var _this = this;
                return this.$q(function (resolve, reject) {
                    //this logic will need to be updated if we allow cc input devices at machines other than kiosks
                    if (!_this.storefrontUtilityService.isRunningAsKiosk) {
                        reject();
                        return;
                    }
                    //if this is a default config machine
                    if (_this.storefrontUtilityService.machineName === _this.storefrontUtilityService.defaultMachineName) {
                        var config = _this.environmentConfig.storefrontConfigs.KioskConfigs[_this.storefrontUtilityService.defaultMachineName];
                        _this.isActive = false;
                        _this.allowCcInput = config.AllowCreditCardInputWhenDeviceDisabled;
                        _this.getCardNameFromTriPos = false;
                        _this.allowCcInput ? reject() : resolve();
                        return;
                    }
                    _this.genericRepo.dataFactory
                        .TriPosStatus(_this.storefrontUtilityService.machineName || _this.environmentConfig.storefrontConfigs.DefaultMachineName)
                        .then(function (vantiveConfig) {
                        _this.isActive = vantiveConfig.active;
                        _this.allowCcInput = vantiveConfig.allowCreditCardInputWhenDeviceDisabled;
                        _this.getCardNameFromTriPos = vantiveConfig.getCardNameFromTriPos;
                        !vantiveConfig.active && vantiveConfig.allowCreditCardInputWhenDeviceDisabled ? reject() : resolve();
                    });
                });
            };
            TriPosStrategy.prototype.setup = function ($scope) {
                var _this = this;
                return this.$q(function (res) {
                    angular.extend($scope, {
                        strategyUsed: HCTRA.Model.CreditCardInputStrategyEnum.Tripos,
                        creditCardNameDisabled: false,
                        creditCardNumberDisabled: true,
                        creditCardExpYearDisabled: true,
                        creditCardExpMothDisabled: true,
                        editPencilId: _this.routes.triposEditCreditCardId,
                        useExistingCard: true,
                        detectedCreditCardNameChange: false
                    });
                    //detects pre-swipe change in name to not allow tripos response to override it
                    var cancelNameWatcher = $scope.$watch("creditCard.nameOnCard", function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $scope.detectedCreditCardNameChange = true;
                            cancelNameWatcher();
                        }
                    });
                    //detect change in card number to signal card has changed to the scope
                    var cancelCcNumberWatcher = $scope.$watch("creditCard.cardNbr", function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $scope.useExistingCard = false;
                            cancelCcNumberWatcher();
                        }
                    });
                    if (!_this.isActive && !_this.allowCcInput) {
                        _this.responseErrorService.displayToast("Credit card input is disabled", "warning", false);
                    }
                    _this.inUse = false;
                    res();
                });
            };
            TriPosStrategy.prototype.update = function ($scope) {
                var _this = this;
                return this.$q(function (resolve, reject) {
                    if (!_this.isActive) {
                        _this.inUse = false;
                        _this.responseErrorService.displayToast("Terminal cannot accept credit card info at this time", "warning", false);
                        reject();
                        return;
                    }
                    if (_this.inUse) {
                        reject();
                        return;
                    }
                    _this.inUse = true;
                    var modalTimeoutPromise = null;
                    var modalScope = _this.modalService.newModalScope({
                        readerState: HCTRA.Model.CreditCardPromptEnum.Wait,
                        successId: _this.routes.triposCreditCardSwipeSuccessId,
                        failureId: _this.routes.triposCreditCardSwipeFailId,
                        promptId: _this.routes.triposCreditCardSwipePromptId,
                        promptAltId: _this.routes.triposCreditCardSwipePromptAltId,
                        creditCardPromptStates: HCTRA.Model.CreditCardPromptEnum,
                        close: function () {
                            _this.inUse = false;
                            if (modalTimeoutPromise) {
                                _this.$timeout.cancel(modalTimeoutPromise);
                                modalTimeoutPromise = null;
                            }
                            _this.modalService.closeByName(_this.modalService.modalNames.CreditCardPrompt);
                        },
                        tryAgain: function () {
                            _this.inUse = false;
                            _this.modalService.closeByName(_this.modalService.modalNames.CreditCardPrompt);
                            _this.$timeout(function () {
                                _this.update($scope);
                            }, 250);
                        }
                    });
                    _this.modalService.creditCardPromptModal(modalScope);
                    _this.genericRepo.dataFactory
                        .TriPosConfiguration(_this.storefrontUtilityService.machineName ||
                        _this.environmentConfig.storefrontConfigs.DefaultMachineName)
                        .then(function (config) { return _this.vantivPaymentService.getTokenizedCreditCardData(config, false); })
                        .then(function (response) {
                        //if modal is closed before swipe is completed, throw away result
                        if (!_this.modalService.isModalOpen(_this.modalService.modalNames.CreditCardPrompt)) {
                            resolve();
                            return;
                        }
                        if (response.cancelledByUser) {
                            resolve();
                            if (modalTimeoutPromise) {
                                _this.$timeout.cancel(modalTimeoutPromise);
                                modalTimeoutPromise = null;
                            }
                            _this.modalService.closeByName(_this.modalService.modalNames.CreditCardPrompt);
                            return;
                        }
                        modalScope.readerState = HCTRA.Model.CreditCardPromptEnum.Success;
                        //splits the lastname/firstname input from vantiv and reverses order
                        var cardName = _this.getCardNameFromTriPos
                            ? (response.cardHolderName || "").split(/[\/\\]+/).reverse().join(" ")
                            : "";
                        angular.extend($scope.creditCard, {
                            omniToken: response.tokenId,
                            cardNbr: response.accountNumber,
                            cardCode: response.cardLogo.toUpperCase().slice(0, 1),
                            cardTypeDisplay: _this.creditCardConversionService.convertCodeToString(response.cardLogo.toUpperCase().slice(0, 1)),
                            isNewCard: true,
                            expMonth: +response.expirationMonth,
                            selectedYear: (response.expirationYear.length === 2 ? '20' : '').concat('' + response.expirationYear)
                        });
                        if (!$scope.detectedCreditCardNameChange) {
                            $scope.creditCard.nameOnCard = cardName;
                        }
                        //$scope.creditCardNameDisabled = (response.entryMode || "").toLowerCase() !== "keyed";
                        resolve();
                        modalTimeoutPromise =
                            _this.$timeout(function () { return _this.modalService.closeByName(_this.modalService.modalNames.CreditCardPrompt); }, _this.storefrontUtilityService.delay.long);
                    })
                        .catch(function (e) {
                        modalScope.readerState = HCTRA.Model.CreditCardPromptEnum.Failure;
                        reject();
                    })
                        .finally(function () { return _this.inUse = false; });
                });
            };
            TriPosStrategy.prototype.submit = function () {
                var _this = this;
                return this.$q(function (resolve, reject) { return _this.isActive ? resolve() : reject("terminal cannot accept credit card info at this time"); });
            };
            TriPosStrategy.$inject = ["vantivPaymentService", "$q", "StorefrontUtilityService", "modalService", "responseErrorService", "genericRepo", "$timeout", "routes", "environmentConfig", "creditCardConversionService"];
            return TriPosStrategy;
        }());
        Service.TriPosStrategy = TriPosStrategy;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule")
        .service("triPosStrategy", HCTRA.Service.TriPosStrategy);
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var VantivIFrameStrategy = /** @class */ (function () {
            function VantivIFrameStrategy($interval, $document, creditCardConversionService, $filter, environmentConfig, $q, iFrameService) {
                this.$interval = $interval;
                this.$document = $document;
                this.creditCardConversionService = creditCardConversionService;
                this.$filter = $filter;
                this.environmentConfig = environmentConfig;
                this.$q = $q;
                this.iFrameService = iFrameService;
                this.iframeInstance = iFrameService.getIFrameServiceInstance();
            }
            VantivIFrameStrategy.prototype.loadNewIframe = function ($scope) {
                $scope.creditCard.cardNbr = $scope.creditCard.cardNbr ? $scope.creditCard.cardNbr.slice(-4) : "";
                this.iframePlaceholder = $scope.creditCard.cardNbr ? this.$filter('creditCard')($scope.creditCard.cardNbr, $scope.creditCard.cardCode) : "";
                this.iframeInstance.loadIFrame("focusedplaceholdertransparent", "51", $scope.addSuffix("payframe"), this.iframePlaceholder);
            };
            VantivIFrameStrategy.prototype.canUse = function () {
                var _this = this;
                return this.$q(function (resolve, reject) { return _this.environmentConfig.vantivConfig.IFrameEnabled ? resolve() : reject(); });
            };
            VantivIFrameStrategy.prototype.setup = function ($scope) {
                var _this = this;
                return this.$q(function (res) {
                    angular.extend($scope, {
                        strategyUsed: HCTRA.Model.CreditCardInputStrategyEnum.Iframe,
                        creditCardNameDisabled: false,
                        creditCardNumberDisabled: false,
                        creditCardExpYearDisabled: false,
                        creditCardExpMothDisabled: false
                    });
                    var unwatchCreditCard = $scope.$watch("creditCard", function (creditCard) {
                        if (!creditCard) {
                            return;
                        }
                        var emptyCreditCardCheck = _this.$interval(function () {
                            return _this.iframePlaceholder && _this.iframeInstance.creditCardFieldEmpty()
                                .then(function (isEmpty) { return $scope.useExistingCard = isEmpty; });
                        }, 100);
                        $scope.$on("$destroy", function () {
                            _this.$interval.cancel(emptyCreditCardCheck);
                        });
                        var unwatch = $scope.$watch(function () {
                            if (_this.$document[0].getElementById($scope.addSuffix("payframe"))) {
                                _this.loadNewIframe($scope);
                                unwatch();
                            }
                            return true;
                        });
                        if ($scope.creditCard.expMonth === null) {
                            $scope.creditCard.expMonth = 1;
                            $scope.creditCard.selectedYear = new Date().getFullYear();
                        }
                        unwatchCreditCard();
                    });
                    res();
                });
            };
            VantivIFrameStrategy.prototype.update = function () {
                return this.$q(function (resolve) { return resolve(); });
            };
            VantivIFrameStrategy.prototype.submit = function ($scope) {
                var _this = this;
                return this.$q(function (resolve, reject) {
                    if ($scope.useExistingCard) {
                        resolve();
                    }
                    else {
                        _this.iframeInstance.getPaypageRegistrationId()
                            .then(function (response) {
                            angular.extend($scope.creditCard, {
                                cardNbr: response.lastFour,
                                paypageRegistrationId: response.paypageRegistrationId,
                                cardCode: response.type.slice(0, 1),
                                isNewCard: true
                            });
                            $scope.creditCard.cardTypeDisplay = _this.creditCardConversionService.convertCodeToString($scope.creditCard.cardCode);
                            _this.loadNewIframe($scope);
                            resolve();
                        })
                            .catch(reject);
                    }
                });
            };
            VantivIFrameStrategy.$inject = ["$interval", "$document", "creditCardConversionService", "$filter", "environmentConfig", "$q", "iFrameService"];
            return VantivIFrameStrategy;
        }());
        Service.VantivIFrameStrategy = VantivIFrameStrategy;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule")
        .service("vantivIFrameStrategy", HCTRA.Service.VantivIFrameStrategy);
})();
// module HCTRA.Service {
//     export interface IDateWithTimeZoneService {
//         //unexpected behavior when called with  date with an offset
//         withoutOffsetToCentral(date: string, format: string): string;
//         //unexpected behavior when called with a date without an offset
//         withOffsetToCentral(date: string, format: string): string;
//     }
// }
// module HCTRA.Service {
//     export class DateWithTimeZoneService implements IDateWithTimeZoneService {
//         static $inject = ["momentService"];
//         constructor(private momentService: HCTRA.Service.IMomentService, ) { }
//         private standardize = (date: string, format: string): string =>
//             this.momentService.moment(new Date(date)).format(format);
//         private toCentral = (date: string, format: string): string =>
//             this.momentService.moment.tz(date, "America/Chicago").format(format);
//         public withoutOffsetToCentral = (date: string, format: string):string =>
//             this.toCentral(this.standardize(date, "YYYY-MM-DDTHH:mm:ss"), format);
//         public withOffsetToCentral = (date: string, format: string): string =>
//             this.toCentral(this.standardize(date, "YYYY-MM-DDTHH:mm:ssZ"), format);   
//     }  
// }
(function () {
    'use strict';
    // angular.module('HCTRAModule').service('dateWithTimeZoneService', HCTRA.Service.DateWithTimeZoneService);
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var DesktopMenuRouteService = /** @class */ (function () {
            function DesktopMenuRouteService(accountActivityRoutes, profileRoutes, $rootScope, $q, $state, urlManagerService, MegaMenuCache, responseErrorService, AuthService, routes, isInvoicedService, USER_ROLES, paymentPlansRoutes, futureRoutes) {
                var _this = this;
                this.accountActivityRoutes = accountActivityRoutes;
                this.profileRoutes = profileRoutes;
                this.$rootScope = $rootScope;
                this.$q = $q;
                this.$state = $state;
                this.urlManagerService = urlManagerService;
                this.MegaMenuCache = MegaMenuCache;
                this.responseErrorService = responseErrorService;
                this.AuthService = AuthService;
                this.routes = routes;
                this.isInvoicedService = isInvoicedService;
                this.USER_ROLES = USER_ROLES;
                this.paymentPlansRoutes = paymentPlansRoutes;
                this.futureRoutes = futureRoutes;
                //The following 6 methods are responsible for returning authorized routes
                this.authorizeRoute = function (route) {
                    return _this.AuthService.isAuthorized(route.authorizedRoles) || route.authorizedRoles.indexOf(_this.USER_ROLES.anonymous) > -1;
                };
                this.isInvoicedAndLinkUpdateReplenishAmount = function (linkUrl) {
                    return _this.AuthService.isAuthenticated() && _this.isInvoicedService.isAccountInvoiced() && linkUrl === _this.profileRoutes.UpdateReplenishmentAmount;
                };
                this.notInvoicedAndLinkAccountActivityInvoices = function (linkUrl) {
                    return _this.AuthService.isAuthenticated() && !_this.isInvoicedService.isAccountInvoiced() && linkUrl === _this.accountActivityRoutes.accountActivityInvoices;
                };
                this.isAccountPaymentPlanUrlAndNoPaymentPlansAvailable = function (linkUrl) {
                    return _this.AuthService.isAuthenticated() && linkUrl === _this.paymentPlansRoutes.accountOverviewSummary && !_this.$rootScope.currentUser.hasPaymentPlans;
                };
                this.isLinkAuthorized = function (link) {
                    return _this.authorizeRoute(link) && !_this.isInvoicedAndLinkUpdateReplenishAmount(link.url) && !_this.notInvoicedAndLinkAccountActivityInvoices(link.url) && !_this.isAccountPaymentPlanUrlAndNoPaymentPlansAvailable(link.url);
                };
                this.getAuthorizedMegaMenuHelper = function (megaMenu) {
                    //callback passed to filter is invoked with three arguments:
                    //the value of the element
                    //the index of the element
                    //the Array object being traversed
                    //we only use the first for this.authorizeRoute and this.isLinkAuthorized
                    var authorizedMegaMenu = angular.copy(megaMenu.filter(_this.authorizeRoute));
                    angular.forEach(authorizedMegaMenu, function (megaMenuItem) {
                        angular.forEach(megaMenuItem.menuColumns, function (column) {
                            angular.forEach(column.subMenus, function (subMenu) {
                                subMenu.links = subMenu.links.filter(_this.isLinkAuthorized);
                            });
                            column.subMenus = column.subMenus.filter(function (subMenu) { return subMenu.links.length > 0; });
                        });
                        megaMenuItem.menuColumns = megaMenuItem.menuColumns.filter(function (column) { return column.subMenus.length > 0; });
                    });
                    return authorizedMegaMenu;
                };
                this.getAuthorizedMegaMenu = function (routesIn) {
                    if (!routesIn) {
                        return routesIn;
                    }
                    return _this.getAuthorizedMegaMenuHelper(routesIn);
                };
                //:category/:page /:size
                // Checkout
                // the following 4 methods add authorized roles to megaMenu
                this.getFullUrl = function (name, statesWithNames) {
                    var findUrl = function (namePart) { return (statesWithNames.find(function (potentialMatch) { return potentialMatch.name === namePart; }) || {}).url; };
                    var splitName = name.split('.');
                    var fullName = '';
                    var fullUrl = '';
                    for (var _i = 0, splitName_1 = splitName; _i < splitName_1.length; _i++) {
                        var part = splitName_1[_i];
                        fullName += part;
                        fullUrl += findUrl(fullName) || '';
                        fullName += '.';
                    }
                    return fullUrl;
                };
                this.getAuthorizedRoles = function (_a) {
                    var data = _a.data, resolve = _a.resolve;
                    var angularAuthRoles = angular.isArray(resolve)
                        && resolve
                            .map(function (x) { return x.authorizedRoles; })
                            .find(function (authorizedRoles) { return angular.isArray(authorizedRoles); });
                    var angularjsAuthRoles = angular.isObject(data)
                        && angular.isArray(data.authorizedRoles)
                        && data.authorizedRoles;
                    return angular.copy(angularAuthRoles || angularjsAuthRoles || []);
                };
                this.getFullUrlToAuthorizedRolesDictionary = function (statesWithNames) {
                    return statesWithNames
                        .filter(function (currentState) { return currentState.url; })
                        .map(function (currentState) { return ({
                        fullUrl: _this.getFullUrl(currentState.name, statesWithNames),
                        authorizedRoles: _this.getAuthorizedRoles(currentState)
                    }); })
                        .filter(function (urlRolesObject) { return urlRolesObject.authorizedRoles.length > 0; })
                        .map(function (_a) {
                        var fullUrl = _a.fullUrl, authorizedRoles = _a.authorizedRoles;
                        var _b;
                        return (_b = {},
                            _b[fullUrl] = authorizedRoles,
                            _b);
                    })
                        .reduce(function (acc, curr) { return angular.extend(acc, curr); }, {});
                };
                this.getMegaMenuNavRoutesWithAuthorizedRoles = function (megaMenuRoutes, fullUrlToAuthorizedRolesDictionary, routes) {
                    var megaMenuRoutesCopy = angular.copy(megaMenuRoutes);
                    angular.forEach(megaMenuRoutesCopy, function (topLevelRoute) {
                        topLevelRoute.authorizedRoles = fullUrlToAuthorizedRolesDictionary[topLevelRoute.url] || [_this.USER_ROLES.anonymous];
                        angular.forEach(topLevelRoute.menuColumns, function (currentMenuColumn) {
                            angular.forEach(currentMenuColumn.subMenus, function (currentSubMenu) {
                                angular.forEach(currentSubMenu.links, function (currentLink) {
                                    currentLink.target = currentLink.openNewTab ? routes.openTabTarget : routes.selfTarget;
                                    currentLink.authorizedRoles = fullUrlToAuthorizedRolesDictionary[currentLink.url] || [_this.USER_ROLES.anonymous];
                                });
                            });
                        });
                    });
                    return megaMenuRoutesCopy;
                };
                this.getMegaMenu = function (response) {
                    _this.responseErrorService.displayAlertsFromResponse(response);
                    if (!response.errors) {
                        return response.navBar;
                    }
                    else {
                        return [];
                    }
                };
                this.getMegaMenuNavRoutes = function () {
                    var deferred = _this.$q.defer();
                    var cachedMegaMenu = _this.MegaMenuCache.getCachedMegaMenu();
                    if (cachedMegaMenu.length === 0) {
                        _this.urlManagerService.getMegaMenu().then(function (response) {
                            var megaMenuFromUrlManagerService = _this.getMegaMenu(response);
                            var fullUrlToAuthorizedRolesDictionary = _this.getFullUrlToAuthorizedRolesDictionary(_this.$state.get().concat(_this.futureRoutes.get()));
                            var megaMenuNavRoutesWithAuthorizedRoles = _this.getMegaMenuNavRoutesWithAuthorizedRoles(megaMenuFromUrlManagerService, fullUrlToAuthorizedRolesDictionary, _this.routes);
                            cachedMegaMenu = _this.MegaMenuCache.cacheMegaMenu(megaMenuNavRoutesWithAuthorizedRoles);
                            deferred.resolve(_this.getAuthorizedMegaMenu(cachedMegaMenu));
                        });
                    }
                    else {
                        deferred.resolve(_this.getAuthorizedMegaMenu(cachedMegaMenu));
                    }
                    return deferred.promise;
                };
            }
            DesktopMenuRouteService.$inject = ['accountActivityRoutes', 'profileRoutes', '$rootScope', '$q', '$state', 'urlManagerService', 'MegaMenuCache', 'responseErrorService', 'AuthService', 'routes', 'isInvoicedService', 'USER_ROLES', 'paymentPlansRoutes', 'futureRoutes'];
            return DesktopMenuRouteService;
        }());
        Service.DesktopMenuRouteService = DesktopMenuRouteService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('desktopMenuRouteService', HCTRA.Service.DesktopMenuRouteService);
})();
(function () {
    "use strict";
    angular.module("HCTRAModule").factory("documentLocationService", ["$document",
        function ($document) {
            function goToHref(url) {
                $document[0].location.href = url;
            }
            return {
                goToHref: goToHref
            };
        }]);
}());
(function () {
    "use strict";
    // angular.module("HCTRAModule").service("domUtilService", HCTRA.Service.DomUtilService);
}());
(function () {
    'use strict';
    // angular.module('HCTRAModule').factory('editInvoicedMessageService', ['modalService',
    //     function (modalService) {
    //         return function (phoneNumberDisplay) {
    //             return {
    //                 invoicedMessage: function () {
    //                     modalService.showModal({
    //                         backdrop: true,
    //                         keyboard: true,
    //                         modalFade: true,
    //                         templateUrl: '/app/templates/common/modalAlert.html'
    //                     }, {
    //                         closeButtonText: 'Close',
    //                         headerText: 'Invoiced Account',
    //                         bodyText: 'Billing related information cannot be modified because the account is invoiced, please call ' + phoneNumberDisplay + ' for further assistance.'
    //                     });
    //                 }
    //             };
    //         };
    //     }]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var EprotectIframeClientService = /** @class */ (function () {
            function EprotectIframeClientService() {
                /*eslint-disable */
                this.EprotectIframeClient = EprotectIframeClient;
                /*eslint-enable */
            }
            EprotectIframeClientService.$inject = [];
            return EprotectIframeClientService;
        }());
        Service.EprotectIframeClientService = EprotectIframeClientService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('eprotectIframeClientService', HCTRA.Service.EprotectIframeClientService);
})();
(function () {
    "use strict";
    angular.module("HCTRAModule").service("errorInterceptorService", ["perfToggle",
        function (perfToggle) {
            var errorMessageDictionary = {};
            var init = function () {
                if (perfToggle.messagesToLogDictionary) {
                    errorMessageDictionary = angular.fromJson(perfToggle.messagesToLogDictionary);
                }
            };
            init();
            this.shouldMessageTriggerLogging = function (message) {
                return errorMessageDictionary[message] ? true : false;
            };
        }]);
}());
(function () {
    'use strict';
    //This follows http://www.bennadel.com/blog/2542-logging-client-side-errors-with-angularjs-and-stacktrace-js.htm
    // The error log service is our wrapper around the core error
    // handling ability of AngularJS. Notice that we pass off to
    // the native "$log" method and then handle our additional
    // server-side logging.
    angular.module('HCTRAModule').factory("errorLogService", ['$log', '$window', 'stacktraceService', 'environmentConfig', 'loggingService',
        function ($log, $window, stacktraceService, environmentConfig, loggingService) {
            var canLogError = true;
            // I log the given error to the remote server.
            function log(exception, cause) {
                // Pass off the error to the default error handler
                // on the AngualrJS logger. This will output the
                // error to the console (and let the application
                // keep running normally for the user).
                $log.error.apply($log, arguments);
                // Now, we need to try and log the error to the server.
                try {
                    //hack to fix uncatchable SecurityException in Chrome when all data setting is blocked
                    if (exception.message === "Failed to read the 'sessionStorage' property from 'Window': Access is denied for this document.") {
                        $window.location = '/app/indexNoCookieStorage.html';
                        return;
                    }
                    var errorMessage = exception.toString();
                    var stackTrace = stacktraceService.print({ e: exception });
                    if (canLogError) {
                        loggingService.logMessage(errorMessage, stackTrace, cause);
                        canLogError = false;
                        // eslint-disable-next-line angular/timeout-service
                        setTimeout(function () { canLogError = true; }, 10000);
                    }
                    if (environmentConfig.angularExPopUpEnabled === 'true') {
                        $window.alert(errorMessage + "\n" + stackTrace);
                    }
                }
                catch (loggingError) {
                    // For Developers - log the log-failure.
                    $log.warn("Error logging failed");
                    $log.log(loggingError);
                }
            }
            // Return the logging function.
            return (log);
        }]);
}());
(function () {
    'use strict';
    // angular.module('HCTRAModule').service('eventTrackingService', HCTRA.Service.EventTrackingService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var ExperienceEditorHelper = /** @class */ (function () {
            function ExperienceEditorHelper($rootScope, $window) {
                var _this = this;
                this.$rootScope = $rootScope;
                this.$window = $window;
                this.templateLoadStructs = [];
                this.onStateChangeStart = function () {
                    if (_this.isExperienceEditor) {
                        var editingBoxElem = angular.element('#scWebEditRibbon').contents().find('span[data-sc-command=EnableEditing] > input');
                        if (editingBoxElem)
                            editingBoxElem = editingBoxElem[0];
                        if (editingBoxElem && editingBoxElem.checked) {
                            editingBoxElem.click();
                        }
                    }
                };
                this.signalResolution = function (templateUrl) {
                    if (_this.isExperienceEditor) {
                        var foundIndex = _this.templateLoadStructs.findIndex(function (u) { return u.templateUrl === templateUrl; });
                        if (Number.isInteger(foundIndex) && foundIndex !== -1) {
                            var templateLoadStruct = _this.templateLoadStructs.splice(foundIndex, 1)[0];
                            templateLoadStruct.deferred.resolve();
                        }
                    }
                };
                this.anchorTagInterceptor = function () {
                    if (_this.isExperienceEditor) {
                        var anchorEvents = 'click dblclick keydown keypress keyup mousedown tap touchstart touchend'.replace(/(\S+)/g, "$1" + '.ExperienceEditor');
                        angular.element(_this.$window.document).on(anchorEvents, 'a[href]', function (ev) {
                            var elem = angular.element(ev.target);
                            var href = elem.attr('href');
                            if (angular.isDefined(href) && !_this.isExternalLink(href) && href.indexOf('#!') === -1) {
                                var superThing = _this.$window.location.origin + _this.$window.location.search + '#!' + href;
                                elem.attr('href', superThing);
                            }
                        });
                    }
                };
            }
            Object.defineProperty(ExperienceEditorHelper.prototype, "isExperienceEditor", {
                get: function () {
                    return !!this.$window.Sitecore; // if the Sitecore global object exists, we're in Experience Editor
                },
                enumerable: true,
                configurable: true
            });
            //determine if url is outside orgin
            ExperienceEditorHelper.prototype.isExternalLink = function (url) {
                //TODO: this needs to update to include api services once they are hosted outside of web project
                if (/^(http|https):\/\/.*/i.test(url)) {
                    return !url.startsWith(this.$window.location.origin);
                }
                else {
                    return false;
                }
            };
            ExperienceEditorHelper.$inject = ['$rootScope', '$window'];
            return ExperienceEditorHelper;
        }());
        Service.ExperienceEditorHelper = ExperienceEditorHelper;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("experienceEditorHelper", HCTRA.Service.ExperienceEditorHelper);
}());
//Migrated
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        'use strict';
        var GenericPagingControlService = /** @class */ (function () {
            function GenericPagingControlService() {
                this.generateSimpleConfig = function (paginator, vmAssignmentCb) {
                    var onPageChange = onPageChangeFactory(paginator, vmAssignmentCb);
                    var onPageSizeChange = onPageSizeChangeFactory(paginator, vmAssignmentCb);
                    return {
                        onBackAll: onPageChange,
                        onBack: onPageChange,
                        onForward: onPageChange,
                        onForwardAll: onPageChange,
                        onPageSizeChange: onPageSizeChange,
                        onPageNumberEntered: onPageChange,
                        initPageSize: paginator.pageSize,
                        totalItems: paginator.itemCount
                    };
                    function onPageChangeFactory(paginator, vmAssignmentCb) {
                        return function (visiblePageNumber) {
                            var newPageArray = paginator.getPage(visiblePageNumber);
                            vmAssignmentCb(newPageArray); // vm/$scope assignment must be done lexically, so we call a callback and pass in the info to assign
                        };
                    }
                    function onPageSizeChangeFactory(paginator, vmAssignmentCb) {
                        return function (visiblePageNumber, pageSize) {
                            paginator.setPageSize(pageSize);
                            var newPageArray = paginator.getPage(visiblePageNumber);
                            vmAssignmentCb(newPageArray); // vm/$scope assignment must be done lexically, so we call a callback and pass in the info to assign
                        };
                    }
                };
            }
            return GenericPagingControlService;
        }());
        Service.GenericPagingControlService = GenericPagingControlService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('genericPagingControlService', HCTRA.Service.GenericPagingControlService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var IFrameService = /** @class */ (function () {
            function IFrameService($q, responseErrorService, eprotectIframeClientService, environmentConfig, genericRepo, siteVerbiage, $timeout, toggleButtonsService) {
                var _this = this;
                this.$q = $q;
                this.responseErrorService = responseErrorService;
                this.eprotectIframeClientService = eprotectIframeClientService;
                this.environmentConfig = environmentConfig;
                this.genericRepo = genericRepo;
                this.siteVerbiage = siteVerbiage;
                this.$timeout = $timeout;
                this.toggleButtonsService = toggleButtonsService;
                this.getConfiguration = function (style, height, iFrameDiv, existingCreditCardNumber, payframeClientCallback, inputsEmptyCallback) { return ({
                    "paypageId": _this.environmentConfig.vantivConfig.PayPageID,
                    "reportGroup": _this.environmentConfig.vantivConfig.ReportGroup,
                    "style": style,
                    "height": height,
                    "timeout": _this.environmentConfig.vantivConfig.TimeoutMilliSeconds,
                    "div": iFrameDiv,
                    "callback": payframeClientCallback,
                    "inputsEmptyCallback": inputsEmptyCallback,
                    "showCvv": false,
                    "htmlTimeout": _this.environmentConfig.vantivConfig.TimeoutMilliSeconds,
                    "placeholderText": {
                        "accountNumber": existingCreditCardNumber
                    },
                    "enhancedUxFeatures": {
                        "inlineFieldValidations": true,
                        "numericInputsOnly": true
                    }
                }); };
                //Not testable
                this.generateSeedDate = function () { return new Date(); };
                this.generatePseudoRandomNumber = function (seedDate) {
                    return Date.UTC(seedDate.getUTCFullYear(), seedDate.getUTCMonth(), seedDate.getUTCDate(), seedDate.getUTCHours(), seedDate.getUTCMinutes(), seedDate.getUTCSeconds(), seedDate.getMilliseconds());
                };
                this.getMessage = function (randomNumber) { return ({
                    "id": "T" + randomNumber.toString(),
                    "orderId": randomNumber
                }); };
                this.logRequest = function (message) {
                    if (!_this.environmentConfig.vantivConfig.InfoToggle)
                        return;
                    _this.genericRepo.dataFactory.LogVantivRequest({
                        "paypageId": _this.environmentConfig.vantivConfig.PayPageID,
                        "reportGroup": _this.environmentConfig.vantivConfig.ReportGroup,
                        "requestId": message.id,
                        "orderId": message.orderId,
                        "url": _this.environmentConfig.vantivConfig.IFrameUrl
                    });
                };
                this.isSuccess = function (_a) {
                    var response = _a.response;
                    return response === "870";
                };
                this.isTimeoutError = function (response) {
                    return response.response === "884" || response.timeout || false;
                };
                this.isResponseToBeLogged = function (response) {
                    return _this.environmentConfig.vantivConfig.InfoToggle || _this.environmentConfig.vantivConfig.ErrorToggle && !_this.isSuccess(response) || false;
                };
                this.logResponse = function (response, message) {
                    if (!_this.isResponseToBeLogged(response))
                        return;
                    _this.genericRepo.dataFactory.LogVantivResponse({
                        "id": message.id,
                        "orderId": message.orderId,
                        "reportGroup": _this.environmentConfig.vantivConfig.ReportGroup,
                        "response": response.response,
                        "message": response.timeout ? "Request for Paypage Registration Id Timed Out" : response.message,
                        "responseTime": response.responseTime,
                        "vantivTxnId": response.vantivTxnId,
                        "paypageRegistrationId": response.paypageRegistrationId,
                        "targetServer": response.targetServer,
                        "type": response.type,
                        "isError": !_this.isSuccess(response),
                        "violationsData": null
                    });
                };
                this.getIFrameServiceInstance = function () {
                    var iFrameServiceInstance = {
                        isBlocked: true,
                        message: {},
                        deferGetPaypageRegistrationId: _this.$q.defer(),
                        deferInputsEmpty: undefined,
                        payframeClient: undefined,
                        inputsEmptyCallback: function (_a) {
                            var allInputsEmpty = _a.allInputsEmpty;
                            return iFrameServiceInstance.deferInputsEmpty.resolve(allInputsEmpty);
                        },
                        creditCardFieldEmpty: function () {
                            if (iFrameServiceInstance.isBlocked)
                                return _this.$q.defer().promise;
                            iFrameServiceInstance.deferInputsEmpty = _this.$q.defer();
                            iFrameServiceInstance.payframeClient.allInputsEmpty();
                            return iFrameServiceInstance.deferInputsEmpty.promise;
                        },
                        loadIFrame: function (style, height, iFrameDiv, existingCreditCardNumber) {
                            //iframe reload means the previous request for paypage registration will never be resolved, the old iframe window will be discarded so it can't return a message 
                            iFrameServiceInstance.isBlocked = false;
                            var configuration = _this.getConfiguration(style, height, iFrameDiv, existingCreditCardNumber, iFrameServiceInstance.callbackWithLogger, iFrameServiceInstance.inputsEmptyCallback);
                            iFrameServiceInstance.payframeClient = new _this.eprotectIframeClientService.EprotectIframeClient(configuration);
                        },
                        callbackWithLogger: function (response) {
                            _this.logResponse(response, iFrameServiceInstance.message);
                            if (_this.isTimeoutError(response) || ["875", "889"].indexOf(response.response) > 0)
                                _this.responseErrorService.displayToast(_this.siteVerbiage.genericErrorMsg, "error", false);
                            if (_this.isSuccess(response))
                                iFrameServiceInstance.deferGetPaypageRegistrationId.resolve(response);
                            else
                                iFrameServiceInstance.deferGetPaypageRegistrationId.reject();
                            iFrameServiceInstance.isBlocked = false;
                        },
                        getPaypageRegistrationId: function () {
                            if (iFrameServiceInstance.isBlocked)
                                return _this.$q.reject();
                            iFrameServiceInstance.isBlocked = true;
                            var seedDate = _this.generateSeedDate();
                            var randomNumber = _this.generatePseudoRandomNumber(seedDate);
                            iFrameServiceInstance.message = _this.getMessage(randomNumber);
                            _this.logRequest(iFrameServiceInstance.message);
                            iFrameServiceInstance.payframeClient.getPaypageRegistrationId(angular.copy(iFrameServiceInstance.message));
                            iFrameServiceInstance.deferGetPaypageRegistrationId = _this.$q.defer();
                            return _this.toggleButtonsService.disableUntilResolved(iFrameServiceInstance.deferGetPaypageRegistrationId.promise);
                        }
                    };
                    return iFrameServiceInstance;
                };
            }
            IFrameService.$inject = [
                "$q",
                "responseErrorService",
                "eprotectIframeClientService",
                "environmentConfig",
                "genericRepo",
                "siteVerbiage",
                "$timeout",
                "toggleButtonsService"
            ];
            return IFrameService;
        }());
        Service.IFrameService = IFrameService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('iFrameService', HCTRA.Service.IFrameService);
})();
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('inputCcDetectionService', [
        function () {
            return {
                nameIsCc: nameIsCc,
                zipIsCc: zipIsCc
            };
            function nameIsCc(name) {
                var patt = /\b\D*\d{6,}\D*\b/;
                return patt.test(name);
            }
            function zipIsCc(zip) {
                var patt = /\b\D*\d{10,}\D*\b/;
                return patt.test(zip);
            }
        }
    ]);
}());
(function () {
    'use strict';
    // angular.module('HCTRAModule').factory('isInvoicedService', ['webStorage',
    // 	function (webStorage) {
    // 	    var isInvoiced = '';
    // 	    var values = {
    // 	        invoiced: 'invoiced',
    // 	        uninvoiced: 'noninvoiced'
    // 	    };
    // 	    return {
    // 	        /**
    //              * returns true if the account is invoiced or false if not
    //              */
    // 	        isAccountInvoiced: function () {
    //                 //see if the browser has been refreshed, and grab from webstorage if it has
    // 	            if (isInvoiced === '') {
    // 	                var val = webStorage.getValue('inv');
    // 	                if (val) {
    // 	                    isInvoiced = val;
    // 	                } else {
    // 	                    isInvoiced = values.uninvoiced;
    // 	                }
    // 	            }
    // 	            return isInvoiced === values.invoiced;
    // 	        },
    // 	        setAccountInvoiced: function (invoiced) {
    // 	            isInvoiced = invoiced ? values.invoiced : values.uninvoiced;
    // 	            webStorage.setKeyValue('inv', isInvoiced);
    // 	        },
    // 	        removeAccountInvoiced: function () {
    // 	            isInvoiced = '';
    // 	            webStorage.removeEntry('inv');
    // 	        }
    // 	    };
    // 	}]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var LoggingService = /** @class */ (function () {
            function LoggingService(stateStackMemoryService, $window, sniffrjs, serverConstants) {
                var _this = this;
                this.stateStackMemoryService = stateStackMemoryService;
                this.$window = $window;
                this.sniffrjs = sniffrjs;
                this.serverConstants = serverConstants;
                this.MAX_STRING_LENGTH = 500;
                this.STRING_TOO_LONG_MESSAGE = "|| The rest of this string was cutoff to guard against overflow ||";
                this.logMessage = function (errorMessage, stackTrace, cause) {
                    var stateStack = _this.stateStackMemoryService.printStack();
                    var exceptionObject = {
                        url: _this.$window.location.href,
                        cause: (cause || ""),
                        opSystemName: _this.sniffrjs.os.name,
                        opSystemVersion: _this.sniffrjs.os.versionString,
                        browserName: _this.sniffrjs.browser.name,
                        browserVersion: _this.sniffrjs.browser.versionString,
                        deviceName: _this.sniffrjs.device.name,
                        deviceVersion: _this.sniffrjs.device.versionString,
                        stateStack: stateStack,
                        errorMessage: (errorMessage || "")
                    };
                    if (stackTrace) {
                        exceptionObject.stackTrace = stackTrace;
                    }
                    //having to use sessionStorage directly to avoid circular reference
                    var linfo;
                    if (sessionStorage) {
                        linfo = angular.fromJson(sessionStorage.getItem("linfo"));
                    }
                    if (linfo) {
                        exceptionObject.licPlate = linfo.licNumber;
                        exceptionObject.licState = linfo.licState;
                        exceptionObject.invoiceNumber = linfo.invNumber;
                    }
                    _this.checkStringLengthsAndEraseIfNeeded(exceptionObject);
                    ////cannot use Angular's $http or genericRepo for this call to prevent circular reference
                    var laststate = _this.stateStackMemoryService.getLastState();
                    var stateName = laststate ? laststate.name : "";
                    angular.element.ajax({
                        url: "api/sessions/AngularLog/LogAngularExceptions?angularState=" + stateName + "&clientVersion=" + _this.serverConstants.currentlyDownloadedWebUiVersion,
                        data: exceptionObject,
                        method: "POST",
                        beforeSend: function (request) {
                            request.setRequestHeader("X-XSRF-TOKEN", _this.getCookie("XSRF-TOKEN"));
                        }
                    });
                };
                this.checkStringLengthsAndEraseIfNeeded = function (exceptionObject) {
                    var endOfSubstringIndex = _this.MAX_STRING_LENGTH - _this.STRING_TOO_LONG_MESSAGE.length;
                    if (exceptionObject) {
                        if (exceptionObject.errorMessage && (angular.isString(exceptionObject.errorMessage)) && exceptionObject.errorMessage.length > _this.MAX_STRING_LENGTH) {
                            exceptionObject.errorMessage = exceptionObject.errorMessage.substring(0, endOfSubstringIndex) + _this.STRING_TOO_LONG_MESSAGE;
                        }
                        if (exceptionObject.stateStack && (angular.isString(exceptionObject.stateStack)) && exceptionObject.stateStack.length > _this.MAX_STRING_LENGTH) {
                            exceptionObject.stateStack = exceptionObject.stateStack.substring(0, endOfSubstringIndex) + _this.STRING_TOO_LONG_MESSAGE;
                        }
                        if (exceptionObject.cause && (angular.isString(exceptionObject.cause)) && exceptionObject.cause.length > _this.MAX_STRING_LENGTH) {
                            exceptionObject.cause = exceptionObject.cause.substring(0, endOfSubstringIndex) + _this.STRING_TOO_LONG_MESSAGE;
                        }
                    }
                };
            }
            // Copied from cookie.service.ts because AngularJS unit tests was having issues with the injection of CookieService
            LoggingService.prototype.getCookie = function (key) {
                if (!this.$window.document.cookie) {
                    return '';
                }
                var pairs = this.$window.document.cookie.split(/;\s*/);
                var prefix = encodeURIComponent(key) + "=";
                for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {
                    var pair = pairs_1[_i];
                    if (pair.indexOf(prefix) === 0) {
                        return decodeURIComponent(pair.substring(prefix.length));
                    }
                }
                return '';
            };
            LoggingService.$inject = ["stateStackMemoryService", "$window", "sniffrjs", "serverConstants"];
            return LoggingService;
        }());
        Service.LoggingService = LoggingService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule")
        .service("loggingService", HCTRA.Service.LoggingService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        // export interface IMaintenanceService {
        //     resolveMaintenanceStatus(navFeatures: Model.MaintenanceFeature[], previousStateName: string): angular.IPromise<any>;
        //     considerMaintenancePopup(): void;
        //     getMostRecentFeatureMainenanceList(): Model.FeatureState[];
        // }
        // export class MaintenanceService implements IMaintenanceService {
        //     static $inject = ["serverConstants",
        //         "responseErrorService",
        //         "$state",
        //         "homeStates",
        //         "$q",
        //         "arrayUtilService",
        //         "genericRepo",
        //         "modalService"];
        //     constructor(private serverConstants: any,
        //         private responseErrorService: HCTRA.Service.IResponseErrorService,
        //         private $state: ng.ui.IStateService,
        //         private homeStates,
        //         private $q: ng.IQService,
        //         private arrayUtilService: IArrayUtilService,
        //         private genericRepo: HCTRA.Service.IGenericRepo,
        //         private modalService: HCTRA.Service.IModalService) { }
        //     private mostRecentResolvedFeatures: Model.FeatureState[] = null;
        //     public getMostRecentFeatureMainenanceList(): Model.FeatureState[] {
        //         return (this.mostRecentResolvedFeatures || []).slice();
        //     }
        //     public resolveMaintenanceStatus = (navFeatures: Model.MaintenanceFeature[], previousStateName: string) => {
        //         return this.genericRepo.dataFactory.getMaintenanceDetails().then((response: HCTRA.Model.MaintenanceResponse) => {
        //             if (response.errors && response.errors.length === 0) {
        //                 const featuresInMaintenance: Model.FeatureState[] =
        //                     response.featureStates.filter((val: Model.FeatureState) => val.inMaintenance);
        //                 this.mostRecentResolvedFeatures = featuresInMaintenance;
        //                 // intersect of features-in-maintenance and features of the state we're navigating to
        //                 const blockedFeatures: Model.FeatureState[] =
        //                     this.arrayUtilService.intersect(featuresInMaintenance, navFeatures,
        //                         (m: Model.FeatureState, n: Model.MaintenanceFeature) => m.feature === n);
        //                 if (blockedFeatures && blockedFeatures.length > 0) {
        //                     const baseResponse: Model.IBaseResponse = this.featureStatesToBaseResponse(blockedFeatures);
        //                     let delayFlag = false;
        //                     // previous state's name is "" on reload, direct navigation to URL, bookmark, etc
        //                     if (angular.isString(previousStateName) && previousStateName !== "") {
        //                         this.$state.go(previousStateName);
        //                     } else {
        //                         this.$state.go(this.homeStates.Frame);
        //                         delayFlag = true;
        //                     }
        //                     this.responseErrorService.displayErrorsFromResponse(baseResponse, delayFlag);
        //                     return this.$q.reject();
        //                 }
        //             } else {
        //                 this.responseErrorService.displayErrorsFromResponse(response);
        //                 return this.$q.reject();
        //             }
        //         });
        //     };
        //     public considerMaintenancePopup = () => {
        //         this.genericRepo.dataFactory.getMaintenanceDetails().then((response: HCTRA.Model.MaintenanceResponse) => {
        //             if (response.showMaintenancePopup) {
        //                 this.modalService.showMaintenanceModal();
        //             }
        //         });
        //     };
        //     private featureStatesToBaseResponse = (features: Model.FeatureState[]): HCTRA.Model.IBaseResponse => {
        //         const newResponse: Model.IBaseResponse = new HCTRA.Model.BaseResponse();
        //         const errors: Model.ErrorMessage[] = features.map((val: Model.ErrorMessage) => {
        //             return {
        //                 key: this.serverConstants.maintenanceKey,
        //                 message: val.message
        //             };
        //         });
        //         newResponse.errors = errors;
        //         return newResponse;
        //     };
        // }
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    // angular.module("HCTRAModule").service("maintenanceService", HCTRA.Service.MaintenanceService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var ManageVehiclesPaperPlateService = /** @class */ (function () {
            function ManageVehiclesPaperPlateService(modalService, $q, genericRepo, stringUtilsService, responseErrorService, routes) {
                var _this = this;
                this.modalService = modalService;
                this.$q = $q;
                this.genericRepo = genericRepo;
                this.stringUtilsService = stringUtilsService;
                this.responseErrorService = responseErrorService;
                this.routes = routes;
                this.getPaperPlateCms = function () {
                    return _this.genericRepo.dataFactory.getCmsPageById({
                        path: null,
                        fields: 'Parameters',
                        itemId: _this.routes.addTagCms
                    }).then(function (res) {
                        if (_this.responseErrorService.isErrorFree(res)) {
                            var addEzTagItem = angular.fromJson(res.cmsResponse);
                            var params = _this.stringUtilsService.getParameterObject(addEzTagItem.Parameters);
                            var paperPlateQuestion = params.paperPlateQuestion;
                            var paperPlateAcknowledgement = params.paperPlateAcknowledgement;
                            var paperPlateValidationText = params.paperPlateValidationText;
                            return { paperPlateAcknowledgement: paperPlateAcknowledgement, paperPlateQuestion: paperPlateQuestion, paperPlateValidationText: paperPlateValidationText };
                        }
                    });
                };
            }
            ManageVehiclesPaperPlateService.$inject = ['modalService', '$q', 'genericRepo', 'stringUtilsService', 'responseErrorService', 'routes'
            ];
            return ManageVehiclesPaperPlateService;
        }());
        Service.ManageVehiclesPaperPlateService = ManageVehiclesPaperPlateService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('manageVehiclesPaperPlateService', HCTRA.Service.ManageVehiclesPaperPlateService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('marketingImageService', ['cmsUtilService',
        function (cmsUtilService) {
            return {
                processImagesToObj: function (array) {
                    var nonDefaultImages = [];
                    var defaultImages = [];
                    var obj = {
                        articles: 0,
                        startIndex: 0,
                        maxArticles: 1,
                        maxSmall: 1
                    };
                    for (var i = 0; i < array.length; i++) {
                        array[i].ImageAltText = cmsUtilService.parseAltText(array[i].Image);
                        array[i].Image = cmsUtilService.generateFileSrc(array[i].Image);
                        if (array[i].IsDefault) {
                            defaultImages.push(array[i]);
                        }
                        else {
                            nonDefaultImages.push(array[i]);
                        }
                    }
                    obj.logIn = this.getObj(true, nonDefaultImages);
                    obj.logOut = this.getObj(false, nonDefaultImages);
                    obj.defaultObj = this.getDefaultObj(defaultImages);
                    return obj;
                },
                getObj: function (loginObj, array) {
                    var obj = {
                        small: [],
                        large: []
                    };
                    for (var i = 0; i < array.length; i++) {
                        if (array[i].ShowInHomePage && (angular.isDefined(array[i].UserLoggedIn) || angular.isDefined(array[i].isLargeImage))) {
                            if (loginObj && array[i].UserLoggedIn && array[i].isLargeImage) {
                                obj.large.push(array[i]);
                            }
                            else if (loginObj && array[i].UserLoggedIn && !array[i].isLargeImage) {
                                obj.small.push(array[i]);
                            }
                            else if (!loginObj && !array[i].UserLoggedIn && array[i].isLargeImage) {
                                obj.large.push(array[i]);
                            }
                            else if (!loginObj && !array[i].UserLoggedIn && !array[i].isLargeImage) {
                                obj.small.push(array[i]);
                            }
                        }
                    }
                    return obj;
                },
                getDefaultObj: function (array) {
                    var obj = {
                        small: [],
                        large: []
                    };
                    for (var i = 0; i < array.length; i++) {
                        if (angular.isDefined(array[i].isLargeImage)) {
                            if (array[i].isLargeImage) {
                                obj.large.push(array[i]);
                            }
                            else {
                                obj.small.push(array[i]);
                            }
                        }
                    }
                    return obj;
                },
                setImages: function (state, obj) {
                    if (obj.articles === obj.startIndex) {
                        // zero articles
                        if (obj[state].large.length > 0) {
                            return [obj[state].large[0]];
                        }
                        else if (obj[state].small.length > 0) {
                            var array = [];
                            for (var i = 0; i < obj.maxSmall && i < obj[state].small.length; i++) {
                                array.push(obj[state].small[i]);
                            }
                            return array;
                        }
                    }
                    else if (obj.articles > obj.startIndex && obj.articles <= obj.maxArticles) {
                        // contains articles
                        if (obj[state].small.length > 0) {
                            return [obj[state].small[0]];
                        }
                    }
                    if (state === 'defaultObj') {
                        return [];
                    }
                    //else do not display image. full of articles
                    return this.setImages('defaultObj', obj);
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('MegaMenuCache', function () {
        var megaMenuRouteCache = [];
        return {
            cacheMegaMenu: function (megaMenu) {
                megaMenuRouteCache = megaMenu;
                return megaMenuRouteCache;
            },
            getCachedMegaMenu: function () {
                if (!megaMenuRouteCache)
                    megaMenuRouteCache = [];
                return megaMenuRouteCache;
            }
        };
    });
}());
// module HCTRA.Service {
//     export interface IMobileMenuRouteService {
//         //getNavRoutes(): any[]
// 		getNavRoutes(): angular.IPromise<any[]>;
//     }
// }
// (() => {
//     'use strict';
//     class MobileMenuRouteService implements HCTRA.Service.IMobileMenuRouteService {
//         static $inject = ['routes', '$rootScope', '$state', 'AuthService', 'featureToggleResolver', 'USER_ROLES', "$q", 'paymentPlansRoutes', 'desktopMenuRouteService', 'futureRoutes'];
//         constructor(private routes: HCTRA.Constant.IRoutes, private $rootScope: angular.IRootScopeService | any, private $state, private AuthService, private featureToggleResolver, private USER_ROLES, private $q: angular.IQService, private paymentPlansRoutes, private desktopMenuRouteService, private futureRoutes) { }
//         isAuthorized = ({ config }): boolean => {
//             const authorizedRoles = this.desktopMenuRouteService.getAuthorizedRoles(config);
//             return this.AuthService.isAuthorized(authorizedRoles) || authorizedRoles.indexOf(this.USER_ROLES.anonymous) > -1;
// 		}
//         isResolved = (route): angular.IPromise<any> => {		
//             if (route.config.url === this.paymentPlansRoutes.accountOverviewSummary) {
//                 return this.$q.resolve<any>(angular.extend(route, { toggleResolved: this.$rootScope.currentUser.hasPaymentPlans }));
//             }
//             if (angular.isUndefined(route.config.data) || angular.isUndefined(route.config.data.toggle)) {
//                 return this.$q.resolve<any>(angular.extend(route, { toggleResolved: true }));
//             }	
//             return this.featureToggleResolver.isResolvedFeatureToggle(route.config.data.toggle)
//                 .then(res => angular.extend(route, { toggleResolved: res }));
// 		}
//         getAuthorizedRoutes = (flatRoutes: any[]): any[] =>
// 			angular.copy(flatRoutes).filter(this.isAuthorized)
// 		getResolvedRoutes = (flatRoutes: any[]): angular.IPromise<[any, boolean]>[] =>
// 			angular.copy(flatRoutes).map(this.isResolved)
//         getHierarchicalRoutes = (theRouter: any[]): any[] => {
//             const routerCopy = angular.copy(theRouter.filter(x => x.config.settings));
//             //two separate forEach on same list to aid readability and simple code
//             angular.forEach(routerCopy, (currentRoute) => currentRoute.config.settings.children = []);
//             angular.forEach(routerCopy, (childRoute) => {
//                 const parent = (routerCopy as any).find((potentialParent) => potentialParent.name === childRoute.config.settings.parent);
//                 if (parent) {
//                     parent.config.settings.children.push(childRoute);
//                 }
//             });
//             return routerCopy;
//         }
//         compareNavOrder = (firstRoute, secondRoute) => firstRoute.config.settings.nav - secondRoute.config.settings.nav;
//         sortChildren = (routes) => {
//             const sortedRoutes = angular.copy(routes);
//             angular.forEach(sortedRoutes, (currentRoute) =>
//                 currentRoute.config.settings.children.sort(this.compareNavOrder));
//             return sortedRoutes;
//         }
//         mergeRoutes = (loadedRoutes, futureRoutes) => {
//             const missingFutureRoutes = futureRoutes.filter(route => !loadedRoutes.some(x => x.name === route.name));
//             return [...loadedRoutes, ...missingFutureRoutes];
//         }
// 		getNavRoutes = (): angular.IPromise<any[]> => {
// 			//let authorizedRoutes = this.getAuthorizedRoutes(this.router);
// 			//let hierarchicalRoutes = this.getHierarchicalRoutes(authorizedRoutes);
// 			//let withSortedChildren = this.sortChildren(hierarchicalRoutes);
// 			//return withSortedChildren
// 			//    .filter((currentRoute) => currentRoute.config.settings.navlevel === 0)
// 			//    .sort(this.compareNavOrder);
//             const mergedRoutes = this.mergeRoutes(this.$state.get(), this.futureRoutes.get());
//             const authorizedRoutes = this.getAuthorizedRoutes(mergedRoutes.map(state => ({ name: state.name, config: state })));
//             return this.$q.all<any>(this.getResolvedRoutes(authorizedRoutes))
//                 .then(routes =>
//                     routes
//                         .filter(x => angular.isDefined(x))
//                         .filter(x => x.toggleResolved))
//                 .then(this.getHierarchicalRoutes)
//                 .then(this.sortChildren)
//                 .then(routes =>
//                     routes
//                         .filter((currentRoute) => currentRoute.config.settings.navlevel === 0)
//                         .sort(this.compareNavOrder));
// 		}
//     }
//     angular.module('HCTRAModule').service('mobileMenuRouteService', MobileMenuRouteService);
// })();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var MomentService = /** @class */ (function () {
            function MomentService(momentjs) {
                this.momentjs = momentjs;
                this.moment = momentjs;
            }
            MomentService.$inject = ["momentjs"];
            return MomentService;
        }());
        Service.MomentService = MomentService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("momentService", HCTRA.Service.MomentService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('monthListService', [
        function () {
            var dataFactory = {};
            var monthList = {
                'January': 1,
                'February': 2,
                'March': 3,
                'April': 4,
                'May': 5,
                'June': 6,
                'July': 7,
                'August': 8,
                'September': 9,
                'October': 10,
                'November': 11,
                'December': 12
            };
            dataFactory.months = [
                { value: 1, label: 'January' },
                { value: 2, label: 'February' },
                { value: 3, label: 'March' },
                { value: 4, label: 'April' },
                { value: 5, label: 'May' },
                { value: 6, label: 'June' },
                { value: 7, label: 'July' },
                { value: 8, label: 'August' },
                { value: 9, label: 'September' },
                { value: 10, label: 'October' },
                { value: 11, label: 'November' },
                { value: 12, label: 'December' }
            ];
            dataFactory.getMonthNumber = function (monthString) {
                return monthList[monthString];
            };
            return dataFactory;
        }
    ]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('monthRangeService', [
        function () {
            return {
                /**
                 * Get a range of 3-letter month abbreviations starting from the current month and going backwards for
                 *  numberOfMonths months.
                 */
                getMonths: function (numberOfMonths) {
                    var months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
                    var monthNumArr = [];
                    var monthArr = [];
                    var date = new Date();
                    var currentMonth = date.getMonth();
                    currentMonth = 7;
                    for (var a = numberOfMonths; a > 0; a--) {
                        monthNumArr.push(currentMonth);
                        currentMonth--;
                        if (currentMonth < 0) {
                            currentMonth = 11;
                        }
                    }
                    for (var x = 0; x < monthNumArr.length; x++) {
                        monthArr.push(months[monthNumArr[x]]);
                    }
                    return monthArr;
                }
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var ObjectUtilService = /** @class */ (function () {
            function ObjectUtilService() {
                var _this = this;
                /**
                 * @deprecated
                 * import { isEqual } from 'lodash' instead of using this function
                 */
                this.areEqual = function (firstObj, secondObj) {
                    if ((firstObj == null) && (secondObj == null)) // neither exists
                        return true;
                    else if (!(firstObj && secondObj)) // one exists, the other does not
                        return false;
                    if (angular.isObject(firstObj) && angular.isObject(secondObj)) {
                        var localCount = Object.keys(secondObj).length;
                        var memCount = Object.keys(firstObj).length;
                        if (localCount !== memCount) // not the same number of properties
                            return false;
                        else if (localCount === 0 && memCount === 0) // both empty objects
                            return true;
                        if (!_this.deepCompare(firstObj, secondObj)) // if different
                            return false;
                    }
                    return true;
                };
                this.deepCompare = function (firstObj, secondObj) {
                    for (var key in firstObj) {
                        if (firstObj.hasOwnProperty(key)) {
                            if (angular.isObject(firstObj[key]) && angular.isObject(secondObj[key])) {
                                return _this.areEqual(firstObj[key], secondObj[key]);
                            }
                            else {
                                if (firstObj[key] !== secondObj[key]) {
                                    return false;
                                }
                            }
                        }
                    }
                    return true;
                };
                this.clearShallowObject = function (objIn) {
                    for (var prop in objIn) {
                        if (objIn.hasOwnProperty(prop)) {
                            delete objIn[prop];
                        }
                    }
                };
                this.toLowerCaseKeys = function (objIn) {
                    var objInCopy = angular.copy(objIn);
                    for (var prop in objInCopy) {
                        if (objInCopy.hasOwnProperty(prop)) {
                            objInCopy[prop.toLowerCase()] = objInCopy[prop];
                            if (prop.toLowerCase() !== prop) {
                                delete objInCopy[prop];
                            }
                        }
                    }
                    return objInCopy;
                };
                /**
                 * @deprecated
                 * This is actually a private function for toCapitalizedCaseKeys(objIn, keyArray)
                 */
                this.replaceKeyWithCapitalized = function (obj, prop) {
                    var propCap = prop.charAt(0).toUpperCase() + prop.slice(1);
                    obj[propCap] = obj[prop];
                    if (propCap !== prop) {
                        delete obj[prop];
                    }
                };
                /**
                 * @deprecated
                 * import { capitalizeKeys } from 'common/utilities' instead of using this function
                 */
                this.toCapitalizedCaseKeys = function (objIn, keyArray) {
                    var objInCopy = angular.copy(objIn);
                    if (keyArray) {
                        for (var _i = 0, keyArray_1 = keyArray; _i < keyArray_1.length; _i++) {
                            var key = keyArray_1[_i];
                            if (objInCopy.hasOwnProperty(key)) {
                                _this.replaceKeyWithCapitalized(objInCopy, key);
                            }
                        }
                    }
                    else {
                        for (var prop in objInCopy) {
                            if (objInCopy.hasOwnProperty(prop)) {
                                _this.replaceKeyWithCapitalized(objInCopy, prop);
                            }
                        }
                    }
                    return objInCopy;
                };
                this.hasAnyOfKeysInList = function (obj, keyArr) {
                    for (var _i = 0, keyArr_1 = keyArr; _i < keyArr_1.length; _i++) {
                        var key = keyArr_1[_i];
                        if (obj.hasOwnProperty(key)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            ObjectUtilService.$inject = [];
            return ObjectUtilService;
        }());
        Service.ObjectUtilService = ObjectUtilService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("objectUtilService", HCTRA.Service.ObjectUtilService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var OmnitureService = /** @class */ (function () {
            function OmnitureService($analytics, $location) {
                var _this = this;
                this.$analytics = $analytics;
                this.$location = $location;
                this.sendTag = function (toState, suffix) {
                    var path = _this.$location.absUrl();
                    if (path != "/") { // $routeChangeSuccess calls on url "/" at login
                        var trackTag = toState.name + "_" + path;
                        if (suffix)
                            trackTag += "[" + suffix + "]";
                        _this.$analytics.pageTrack(trackTag);
                    }
                };
            }
            OmnitureService.$inject = ['$analytics', '$location'];
            return OmnitureService;
        }());
        Service.OmnitureService = OmnitureService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').service('omnitureService', HCTRA.Service.OmnitureService);
}());
/*
(function () {

    'use strict';

    angular.module('HCTRAModule').factory('operatingSystemSnifferService', ['sniffrjs', 'bowserService',
        function (sniffrjs, bowserService) {

            var storedOS = '';

            var operatingSystem = {
                MOBILE: 'mobile',
                DESKTOP: 'desktop'
            };

            return {
                setupDesktopStyles: function () {
               
                },
                getOS: function () {
                    var op = sniffrjs.os.name.toLowerCase();
                    var device = sniffrjs.device.name.toLowerCase();
                    var isChromeBook = bowserService.bowser.chromeBook;
                    if (op === "windows" || op === "macos" || op === "linux" || device === "ipad" || isChromeBook) {
                        storedOS = operatingSystem.DESKTOP;
                        return operatingSystem.DESKTOP;
                    } else {
                        storedOS = operatingSystem.MOBILE;
                        return operatingSystem.MOBILE;
                    }
                },
                isDesktopOs: function () {
                    if ((storedOS === operatingSystem.DESKTOP) || (sessionStorage.getItem('FOOTER_FORCE_DESKTOP_VIEW') === 'true')) {
                        return true;
                    } else {
                        return false;
                    }
                },
                getOsFull: function () {
                    return sniffrjs.os.name;
                },
                getDeviceFull: function () {
                    return sniffrjs.device.name;
                }
            };

        }]);
}());
*/ 
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        //concrete class that wraps the globally defined PDFJS object
        var PdfService = /** @class */ (function () {
            function PdfService($window) {
                var _this = this;
                this.$window = $window;
                this.getDocument = function (params) {
                    return _this.pdfJs.getDocument(params.url || params).promise;
                };
                if ('pdfjsLib' in $window) {
                    this.pdfJs = $window["pdfjsLib"];
                }
                else if ('PDFJS' in $window) {
                    this.pdfJs = $window["PDFJS"];
                }
            }
            PdfService.prototype.createWorker = function () {
                return new this.pdfJs.PDFWorker('pdfWorker');
            };
            PdfService.$inject = ["$window"];
            return PdfService;
        }());
        Service.PdfService = PdfService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .service("PdfService", HCTRA.Service.PdfService);
})();
(function () {
    'use strict';
    // angular.module('HCTRAModule').service('readMoreOrLessService', HCTRA.Service.ReadMoreOrLessService);
})();
(function () {
    "use strict";
    angular.module("HCTRAModule").service("responsiveService", ["$window",
        function ($window) {
            this.isMobile = function () {
                return ($window.innerWidth < 768);
            };
            this.isDesktop = function () {
                return !this.isMobile();
            };
            this.isIPadPortrait = function () {
                return ($window.innerWidth === 768);
            };
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var RssService = /** @class */ (function () {
            function RssService(environmentConfig, documentLocationService, routes, $q) {
                var _this = this;
                this.environmentConfig = environmentConfig;
                this.documentLocationService = documentLocationService;
                this.routes = routes;
                this.$q = $q;
                this.goToRssFeed = function (locationId) {
                    var rssLink = _this.getRssLink(locationId);
                    if (angular.isDefined(rssLink)) {
                        _this.documentLocationService.goToHref(rssLink);
                    }
                };
                this.injectRssData = function () {
                    var rssLinkArray = [
                        _this.getRssLink(_this.rssHomeClosuresKey),
                        _this.getRssLink(_this.rssHomeNewsKey),
                        _this.getRssLink(_this.rssMajorClosuresKey),
                        _this.getRssLink(_this.rssLatestNewsKey)
                    ];
                    return _this.$q(function (fulfill) {
                        fulfill(rssLinkArray);
                    });
                };
                this.rssHomeClosuresKey = "inHomeClosures";
                this.rssHomeNewsKey = "inHomeNews";
                this.rssMajorClosuresKey = "inMajorClosures";
                this.rssLatestNewsKey = "inLatestNews";
                this.getRssLink = function (locationId) {
                    var rssConfig = _this.environmentConfig.rssConfig;
                    for (var rssLink in rssConfig) {
                        if (rssConfig.hasOwnProperty(rssLink)) {
                            if (rssConfig[rssLink].Locations.indexOf(locationId) !== -1) {
                                return _this.routes.rssFeed + rssLink;
                            }
                        }
                    }
                };
            }
            RssService.$inject = ["environmentConfig", "documentLocationService", "routes", "$q"];
            return RssService;
        }());
        Service.RssService = RssService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("rssService", HCTRA.Service.RssService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('safariPrivateService', ['errorDisplayService',
        function (errorDisplayService) {
            var dataFactory = {};
            dataFactory.checkIfSafariPrivateMode = function () {
                if ((!navigator.cookieEnabled) || (!sessionStorage)) {
                    errorDisplayService.displayToasts(['Current browser configuration is not supported. Both cookies and local storage need to be enabled to use this site'], 'Error');
                }
            };
            return dataFactory;
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var SaveBillingService = /** @class */ (function () {
            function SaveBillingService(genericRepo, responseErrorService, modalService, $state) {
                var _this = this;
                this.genericRepo = genericRepo;
                this.responseErrorService = responseErrorService;
                this.modalService = modalService;
                this.$state = $state;
                this.createSaveRequest = function (scope) {
                    var billingInfoCopy = angular.copy(scope.billingInfo);
                    return scope.billingType === "CREDIT" ?
                        (scope.billingInfo.cards[0].primary = true, _this.createCreditCardSaveRequest(billingInfoCopy)) :
                        _this.createEftSaveRequest(billingInfoCopy);
                };
                this.createEftSaveRequest = function (billingInfo) {
                    angular.extend(billingInfo, {
                        cards: null,
                        billingTypeCode: "E",
                        billingTypeDisplay: "EFT"
                    });
                    return {
                        billingInfo: billingInfo,
                        cards: null
                    };
                };
                this.getDate = function (year, month) {
                    var dateString = angular.toJson(new Date(Number(year), Number(month)));
                    return (dateString.slice(0, 1) === '"' && dateString.slice(-1) === '"') ?
                        dateString.slice(1, -1) :
                        dateString;
                };
                this.createCreditCardSaveRequest = function (billingInfo) {
                    billingInfo.cards[0].primary = true;
                    angular.forEach(billingInfo.cards, function (card) {
                        var zip = card.zip, international = card.international, cardExpiresDate = card.cardExpiresDate, country = card.country, selectedYear = card.selectedYear, expMonth = card.expMonth;
                        angular.extend(card, {
                            zipCode: zip,
                            country: international === false ? "USA" : country,
                            cardExpiresDate: angular.isString(card.cardExpiresDate) && card.cardExpiresDate !== "" ? cardExpiresDate : _this.getDate(selectedYear, expMonth)
                        });
                    });
                    angular.extend(billingInfo, {
                        eft: null,
                        billingTypeCode: "C",
                        billingTypeDisplay: "CREDIT"
                    });
                    return {
                        billingInfo: billingInfo,
                        cards: billingInfo.cards,
                        eft: null
                    };
                };
                this.saveCardOrEft = function (request, nextState) {
                    return _this.genericRepo.dataFactory.saveBillingInformation(request).then(function (response) {
                        return _this.processSaveResponse(response, nextState);
                    });
                };
                this.saveCreditCard = this.saveCardOrEft;
                this.saveEFT = this.saveCardOrEft;
                this.isErrorFree = function (response) { return !response.errors || response.errors.length === 0 ? true : (_this.responseErrorService.displayErrorsFromResponse(response), false); };
                this.processSaveResponse = function (response, nextState) {
                    if (_this.isErrorFree(response)) {
                        _this.responseErrorService.displayAlertsFromResponse(response, true);
                        _this.modalService.showUpdateSuccessModal("Billing Information Update", "billing information");
                        return _this.$state.go(nextState, {}, { reload: true });
                    }
                    return false;
                };
            }
            SaveBillingService.$inject = ["genericRepo", "responseErrorService", "modalService", "$state"];
            return SaveBillingService;
        }());
        Service.SaveBillingService = SaveBillingService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("saveBillingService", HCTRA.Service.SaveBillingService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory("stacktraceService", function () {
        // "StackTrace" is a global object.
        return ({
            //get: StackTrace.get,
            //fromError: StackTrace.fromError,
            //deinstrument : StackTrace.deinstrument,
            //instrument: StackTrace.instrument,
            //generateArtificially: StackTrace.generateArtificially,
            //report: StackTrace.report
            print: printStackTrace
        });
    });
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('stateStackMemoryService', [
        function () {
            var MAXIMUM_STATES_ON_STACK = 10;
            var newStateObject = function (stateName, type) {
                var o = {};
                o.name = stateName;
                o.type = type;
                o.time = new Date();
                return o;
            };
            // closure to keep track of the state stack and restrict its size
            var stateStack = (function () {
                var stack = [];
                return {
                    maxStates: MAXIMUM_STATES_ON_STACK,
                    addState: function (st) {
                        stack.push(st);
                        if (stack.length > this.maxStates) {
                            //remove the oldest state
                            stack = stack.slice(1);
                        }
                    },
                    getStates: function () {
                        return stack;
                    },
                    getLastState: function () {
                        return stack[stack.length - 1];
                    },
                    popState: function () {
                        return stack.pop();
                    }
                };
            }());
            var serviceFactory = {};
            serviceFactory.addStateToStackMemory = function (inState, type) {
                stateStack.addState(newStateObject(inState, type));
                //using session storage directly to prevent a circular reference in angularLogger
                sessionStorage.setItem && sessionStorage.setItem('stateStack', angular.toJson(stateStack.getStates()));
            };
            serviceFactory.getStateStack = function () {
                var stack1 = stateStack.getStates();
                if (sessionStorage) {
                    var stack2 = angular.fromJson(sessionStorage.getItem('stateStack'));
                    if (angular.isString(stack2)) {
                        stack2 = angular.fromJson(stack2);
                    }
                    if (angular.isArray(stack2) && (stack2.length > stack1.length)) {
                        stack1 = stack2;
                    }
                }
                return stack1;
            };
            serviceFactory.getLastState = function () {
                return stateStack.getLastState() || { name: "" };
            };
            serviceFactory.printStack = function () {
                var str = '';
                var stack = this.getStateStack();
                if (stack !== null) {
                    for (var x = 0; x < stack.length; x++) {
                        str += '(' + stack[x].name + ' :: ';
                        if (angular.isString(stack[x].time)) {
                            str += stack[x].time + ') ';
                        }
                        else {
                            str += (stack[x].time.getMonth() + 1) +
                                '/' + stack[x].time.getDate() + '/' + stack[x].time.getFullYear() +
                                "  " + stack[x].time.getHours() + ':' + stack[x].time.getMinutes() +
                                ':' + stack[x].time.getSeconds() + ') ';
                        }
                    }
                }
                return str;
            };
            serviceFactory.popState = function () {
                return stateStack.popState();
            };
            return serviceFactory;
        }
    ]);
}());
var HCTRA;
(function (HCTRA) {
    var Storefront;
    (function (Storefront) {
        var Service;
        (function (Service) {
            var StorefrontEventService = /** @class */ (function () {
                function StorefrontEventService(angularElementFunction, $window, $interval, documentLocationService, $q, $location, $timeout, storefrontService, storefrontModalService, $state, stateNames, $rootScope, errorDisplayService, genericRepo, maintenanceService, environmentConfig, $transitions //doh!
                ) {
                    var _this = this;
                    this.angularElementFunction = angularElementFunction;
                    this.$window = $window;
                    this.$interval = $interval;
                    this.documentLocationService = documentLocationService;
                    this.$q = $q;
                    this.$location = $location;
                    this.$timeout = $timeout;
                    this.storefrontService = storefrontService;
                    this.storefrontModalService = storefrontModalService;
                    this.$state = $state;
                    this.stateNames = stateNames;
                    this.$rootScope = $rootScope;
                    this.errorDisplayService = errorDisplayService;
                    this.genericRepo = genericRepo;
                    this.maintenanceService = maintenanceService;
                    this.environmentConfig = environmentConfig;
                    this.$transitions = $transitions;
                    this.windows = [];
                    this.isInMainenanceMode = false;
                    //tracks timestamp since last user interaction
                    this.activityTimestamp = StorefrontEventService.newTimestamp();
                    //flag for defering activity checks. used when the inactivity modal has opened and count down should start.
                    this.disableActivityCheck = false;
                    this.prtMsg = "\n<style>\n@media screen {\n    .prntMsg {\n        display: block;\n        width: 400px;\n        height: 400px;\n        background-color: white;\n        position: absolute;\n        top: 0px;\n        left: 0px;\n    }\n}\n@media print {\n    .prntMsg {\n        display: none;\n    }\n}\n</style>\n<div class='prntMsg'>Document sent to printer.</div>\n";
                    this.stripLinks = function (element) {
                        if (!_this.storefrontService.isEnabled()) {
                            return;
                        }
                        var elms = _this.angularElementFunction(element).find(":not(eft-ach-disclaimer *)>a[href]:not([href^='#']):not([href='']),a[ng-click].disable-for-storefront");
                        //stop listening for dom changes for a moment
                        _this.observer.disconnect();
                        /* tslint:disable-next-line */
                        for (var i = 0; i < elms.length; i++) {
                            var elm = _this.angularElementFunction(elms[i]);
                            elm.removeAttr('target');
                            if (!_this.possiblePdf(elm.attr('href')) && !_this.storefrontService.fullSiteMode) {
                                //strip anchors
                                elm.replaceWith(elm.contents());
                            }
                        }
                        //ok, start listening again
                        _this.observer.observe(element, {
                            childList: true,
                            subtree: true
                        });
                    };
                    //disables scrolling of main window
                    this.disableWindowScroll = function (evt) {
                        _this.angularElementFunction(evt.target).scrollTop(0);
                    };
                    //intercepts anchor(links, 'a') clicks and handles them
                    this.nonUiRouterLinkClickIntercepter = function (evt) {
                        var elm = _this.angularElementFunction(evt.currentTarget);
                        var href = elm.attr('href');
                        var baseURI = (new _this.$window.URL(_this.$location.absUrl())).origin;
                        elm.removeAttr('target');
                        if (angular.isUndefined(href)) {
                            return true;
                        }
                        else if (_this.isExternalLink(href)) {
                            evt.preventDefault();
                            evt.stopPropagation();
                            evt.stopImmediatePropagation();
                            return false;
                        }
                        else if (href !== "") {
                            //pdf first
                            href = href.toLowerCase();
                            if (_this.possiblePdf(href) && !elm.attr('not-pdf')) {
                                _this.storefrontModalService
                                    .showPdf(baseURI + '/' + href).then(function () { }).catch(function () {
                                    elm.attr('not-pdf', '1');
                                    _this.$location.url(href);
                                });
                                evt.preventDefault();
                                evt.stopPropagation();
                                evt.stopImmediatePropagation();
                                return false;
                            }
                        }
                        return true;
                    };
                    //intercepts window.open calls and handles them
                    this.windowDotOpenInterceptor = function (evt, args) {
                        //opening a window to write content into
                        if (args.href === '') {
                            //evt.preventDefault();
                            var win = _this.angularElementFunction(_this.$window);
                            var height = win.height();
                            var width = win.width();
                            //define the type of window storefront will allow
                            args.options = "status=no, toolbar=no, menubar=no, location=no, resizable=no, titlebar=no, directories=no, width=" + width + ", height=" + height;
                            var s_1 = _this;
                            var onOpen = function (newWin) {
                                s_1.windows.push(newWin);
                            };
                            args.onOpen = onOpen;
                        }
                        else if (_this.isExternalLink(args.href)) {
                            evt.preventDefault();
                        }
                        else {
                            evt.preventDefault();
                            //check if content might be a pdf
                            if (_this.possiblePdf(args.href)) {
                                //try to show pdf
                                _this.storefrontModalService
                                    .showPdf(args.href)
                                    .then(function () { })
                                    //if failed, then it wasn't a pdf, then just redirect to it
                                    .catch(function () { return _this.$location.url(args.href); });
                            }
                            else {
                                //just redirect to it.
                                _this.$location.url(args.href);
                            }
                        }
                    };
                    //intercepts document.location.href changes and handles them
                    this.locationHrefChanged = function (evt, arg) {
                        //stop rss links from opening
                        if (/^(\/rss)\/.*/i.test(arg.url)) {
                            evt.preventDefault();
                        }
                    };
                    //update the last time the user interacted with storefront
                    this.updateActivity = function () {
                        //only update activity timestamp if inactivity modal is not open
                        if (!_this.disableActivityCheck) {
                            _this.activityTimestamp = StorefrontEventService.newTimestamp();
                        }
                        //fix for elements appearing transparent
                        //            var doc = this.$window.document;
                        //                var textNode = doc.createTextNode(' ');
                        //                doc.body.appendChild(textNode);
                        //                this.$timeout(() => {
                        //                    textNode.parentNode.removeChild(textNode);
                        //                }, 15);//less then 1 frame at 60hz  
                        _this.angularElementFunction(_this.$window).trigger('resize');
                    };
                    //interval method called to determine if store has timed out
                    this.checkForUserTimeout = function () {
                        if (_this.$state.current.name === _this.stateNames.storefrontHome)
                            return _this.$q.reject();
                        var timeSpan = StorefrontEventService.newTimestamp() - _this.activityTimestamp;
                        //test for warning timelapse
                        if (timeSpan >= _this.environmentConfig.storefrontConfigs.StorefrontInactivityWarning && !_this.disableActivityCheck) {
                            _this.disableActivityCheck = true;
                            //open inactivity modal
                            return _this.storefrontModalService
                                .showInactivity()
                                .then(function () {
                                _this.disableActivityCheck = false;
                                _this.updateActivity();
                            });
                        }
                        return _this.$q.resolve();
                    };
                    //state change handler
                    this.onStateChange = function (transition) {
                        var toState = transition.to();
                        var fromState = transition.from();
                        var transAny = transition;
                        //redirect to store from home if not already there
                        if (!_this.storefrontService.isEnabled()) {
                            return _this.$q.reject();
                        }
                        return _this.storefrontService
                            .checkState(toState)
                            .then(function (result) {
                            var externalState = result.isExternal;
                            return _this.registeredEventHandler.onStartTransition(fromState, toState)
                                .then(function () {
                                if (externalState && !_this.storefrontModalService.isExternalTaskModalOpen()) {
                                    return _this.storefrontModalService
                                        .showExternalTask()
                                        .then(function () { return transAny.router.stateService.target(fromState.name); });
                                    //.then(() => this.registeredEventHandler.onEndTransition());
                                }
                            });
                        })
                            .then(function () { return _this.storefrontService.fullSiteMode
                            ? _this.$q.resolve()
                            : _this.$timeout(_this.environmentConfig.storefrontConfigs.StorefrontShortDelay); })
                            .catch(_this.handleCheckStateError);
                    };
                    this.handleCheckStateError = function (error) {
                        if (error.hasWorkItemRedirect && HCTRA.Model.SelectedOptions[error.workItemRedirect]) {
                            var isQueued = _this.storefrontService.isQueued(error.workItemRedirect);
                            if (isQueued) {
                                //we need to go back to this redirect state for some reason!
                                var redirectItem = _this.storefrontService.getWorkItemById(error.workItemRedirect);
                                redirectItem.isCompleted = false;
                            }
                            else {
                                _this.storefrontService.insertWorkItem(error.workItemRedirect);
                            }
                            return _this.storefrontService
                                .skip(error.workItemRedirect, false, false)
                                .then(function (stateName) { return _this.$state.go(stateName); });
                        }
                        if (error.restrictedAbort) {
                            return _this.$q.reject({ storefrontTransitionBlocked: true, storefrontTransitionBlockedStateName: error.restrictedStateName });
                        }
                        return _this.$q.reject(error);
                    };
                    this.onStateChangeSuccess = function (transition) {
                        var fromState = transition.from();
                        var toState = transition.to();
                        if (!_this.storefrontService.isEnabled()) {
                            return;
                        }
                        if (_this.storefrontService.fullSiteMode || !_this.storefrontModalService.isExternalTaskModalOpen()) {
                            _this.registeredEventHandler.onEndTransition();
                        }
                        if (!_this.storefrontService.fullSiteMode && _this.storefrontService.isCmsContent(toState)) {
                            _this.storefrontModalService.showCmsContent(toState, fromState.name);
                        }
                        _this.handleIfSiteEnteredMaintenanceMode();
                    };
                    this.onStateChangeError = function () {
                        _this.registeredEventHandler.onEndTransition();
                        _this.handleIfSiteEnteredMaintenanceMode();
                    };
                    this.handleIfSiteEnteredMaintenanceMode = function () {
                        _this.storefrontService
                            .isInMaintenanceMode()
                            .then(function () {
                            if (_this.isInMainenanceMode) {
                                return;
                            }
                            _this.isInMainenanceMode = true;
                            _this.disableActivityCheck = true;
                            _this.$timeout(function () {
                                _this.storefrontService
                                    .reset()
                                    .finally(function () {
                                    _this.storefrontModalService.showStorefrontMaintenanceMode();
                                    _this.errorDisplayService.clearToasts();
                                    if (_this.maintenanceModeIntervalToken) {
                                        _this.$interval.cancel(_this.maintenanceModeIntervalToken);
                                    }
                                    _this.maintenanceModeIntervalToken = _this.$interval(_this.checkForMaintenanceMode, _this.environmentConfig.storefrontConfigs.StorefrontMaintenanceModeIntervalDelay, 0, false);
                                });
                            }, 1000);
                        })
                            //ignore
                            .catch(function () { });
                    };
                    this.checkForMaintenanceMode = function () {
                        _this.storefrontService
                            .isInMaintenanceMode()
                            .then(function () { }) //ignore
                            .catch(function () {
                            _this.$interval.cancel(_this.maintenanceModeIntervalToken);
                            _this.maintenanceModeIntervalToken = null;
                            _this.disableActivityCheck = false;
                            _this.isInMainenanceMode = false;
                            return _this.storefrontService.reset();
                        })
                            .finally(function () { return _this.errorDisplayService.clearToasts(); });
                    };
                }
                StorefrontEventService.factory = function () {
                    var service = function (angularElementFunction, $window, $interval, documentLocationService, $q, $location, $timeout, storefrontService, storefrontModalService, $state, stateNames, $rootScope, errorDisplayService, genericRepo, maintenanceService, environmentConfig, $transitions) { return new StorefrontEventService(angularElementFunction, $window, $interval, documentLocationService, $q, $location, $timeout, storefrontService, storefrontModalService, $state, stateNames, $rootScope, errorDisplayService, genericRepo, maintenanceService, environmentConfig, $transitions); };
                    service.$inject = ["InjectableAngularElementFunction", "$window", "$interval", "documentLocationService", "$q", "$location", "$timeout", "StorefrontService", "StorefrontModalService", "$state", "stateNames", "$rootScope", "errorDisplayService", "genericRepo", "maintenanceService", "environmentConfig", "$transitions"];
                    return service;
                };
                StorefrontEventService.prototype.startListening = function (storefrontEvents) {
                    var _this = this;
                    if (!this.storefrontService.isEnabled())
                        return;
                    this.registeredEventHandler = storefrontEvents;
                    //ui events
                    this.angularElementFunction(this.$window.document)
                        //wire tracked user events
                        .on(StorefrontEventService.userInactivityEvents, this.updateActivity)
                        //disables the HTML and body tag from scrolling
                        .on(StorefrontEventService.eventName('scroll'), this.disableWindowScroll);
                    //ui events
                    this.angularElementFunction(this.$window.document.body)
                        //hijack links forcing page reload or 'new tab' calls
                        .on(StorefrontEventService.gotoLinkEvents, "a[href]", function (evt) { _this.nonUiRouterLinkClickIntercepter(evt); });
                    //interval to check inactivity time
                    this.intervalToken = this.$interval(this.checkForUserTimeout, this.environmentConfig.storefrontConfigs.StorefrontInactivityIntervalDelay, 0, false);
                    //registers events to the storefront service
                    this.storefrontService.registerEventHandlers(storefrontEvents);
                    //intercept state changes
                    this.deregisterStateSuccessWatcher = this.$transitions.onSuccess({}, this.onStateChangeSuccess);
                    this.deregisterStateErrorWatcher = this.$transitions.onError({}, this.onStateChangeError);
                    this.deregisterStateWatcher = this.$transitions.onStart({}, this.onStateChange);
                    //intercept window.open calls
                    this.deregisterWindowOpener = this.$window.open["listen"](this.windowDotOpenInterceptor);
                    //intercept href changes
                    this.deregisterHrefWatcher = this.documentLocationService.goToHref["listen"](this.locationHrefChanged);
                };
                StorefrontEventService.prototype.addMutationObserver = function (element) {
                    var _this = this;
                    if (this.observer) {
                        this.observer.disconnect();
                        this.observer = null;
                    }
                    if ("MutationObserver" in this.$window) {
                        this.observer = new this.$window["MutationObserver"](function () { return _this.stripLinks(element); });
                        this.observer.observe(element, {
                            childList: true,
                            subtree: true
                        });
                    }
                };
                StorefrontEventService.prototype.stopListening = function () {
                    /* tslint:disable */
                    this.deregisterStateWatcher && this.deregisterStateWatcher();
                    this.deregisterWindowOpener && this.deregisterWindowOpener();
                    this.deregisterHrefWatcher && this.deregisterHrefWatcher();
                    this.deregisterStateSuccessWatcher && this.deregisterStateSuccessWatcher();
                    this.deregisterStateErrorWatcher && this.deregisterStateErrorWatcher();
                    /* tslint:enable */
                    //turn off event listeners
                    this.angularElementFunction(this.$window.document).off(StorefrontEventService.eventNamespace);
                    //turn off inactivity interval
                    this.$interval.cancel(this.intervalToken);
                    //deregister storefront events
                    if (this.maintenanceModeIntervalToken) {
                        this.$interval.cancel(this.maintenanceModeIntervalToken);
                    }
                    if (this.observer) {
                        this.observer.disconnect();
                        this.observer = null;
                    }
                };
                StorefrontEventService.prototype.resetState = function () {
                    this.disableActivityCheck = false;
                    this.updateActivity();
                    this.clearWindows();
                };
                StorefrontEventService.prototype.clearWindows = function () {
                    while (this.windows[0]) {
                        var w = this.windows.pop();
                        try {
                            if (w && !w.closed) {
                                w.close();
                            }
                        }
                        catch (e) {
                            continue;
                        }
                    }
                };
                //try to determine if url is possibly a pdf by the url
                StorefrontEventService.prototype.possiblePdf = function (url) {
                    return (/^(-\/media|sitecore|content|api\/sessions\/pdf|\/api\/sessions\/pdf)\/.*/i.test(url));
                };
                //determine if url is outside orgin
                StorefrontEventService.prototype.isExternalLink = function (url) {
                    //TODO: this needs to update to include api services once they are hosted outside of web project
                    if (/^(http|https):\/\/.*/i.test(url)) {
                        return !url.startsWith(this.$window.location.origin);
                    }
                    else {
                        return false;
                    }
                };
                //namespace used for tracking UI events
                StorefrontEventService.eventNamespace = ".StoreFrontEvents";
                // namespaces user events to track for inactivity
                StorefrontEventService.userInactivityEvents = 'click dblclick keydown keypress keyup mousedown mousemove scroll tap swipe touchstart touchmove touchend'
                    .replace(/(\S+)/g, "$1" + StorefrontEventService.eventNamespace);
                StorefrontEventService.gotoLinkEvents = 'click dblclick keyup tap'
                    .replace(/(\S+)/g, "$1" + StorefrontEventService.eventNamespace);
                //generates a new timestamp
                StorefrontEventService.newTimestamp = function () { return Date.now(); };
                //creates ui event name
                StorefrontEventService.eventName = function (eventName) { return eventName + StorefrontEventService.eventNamespace; };
                return StorefrontEventService;
            }());
            Service.StorefrontEventService = StorefrontEventService;
        })(Service = Storefront.Service || (Storefront.Service = {}));
    })(Storefront = HCTRA.Storefront || (HCTRA.Storefront = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .value("InjectableAngularElementFunction", angular.element)
        .factory("StorefrontEventService", HCTRA.Storefront.Service.StorefrontEventService.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        //concrete service that implements the storefron modal service interface that wrapps the existing webisite modal service
        var StorefrontModalService = /** @class */ (function () {
            function StorefrontModalService(modalService, $q, storefrontService, stateNames, $state, $timeout, routes, errorDisplayService, storefrontModalServiceModalNames, storefrontMaterialDialogWrapper, homeStates, cavveStates, vehiclesStates, addMissingInformationService) {
                var _this = this;
                this.modalService = modalService;
                this.$q = $q;
                this.storefrontService = storefrontService;
                this.stateNames = stateNames;
                this.$state = $state;
                this.$timeout = $timeout;
                this.routes = routes;
                this.errorDisplayService = errorDisplayService;
                this.storefrontModalServiceModalNames = storefrontModalServiceModalNames;
                this.storefrontMaterialDialogWrapper = storefrontMaterialDialogWrapper;
                this.homeStates = homeStates;
                this.cavveStates = cavveStates;
                this.vehiclesStates = vehiclesStates;
                this.addMissingInformationService = addMissingInformationService;
                //shows a modals saying init has failed
                this.failedToInitMessage = function () {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontServiceInitFailed)
                        .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                        .actions({
                        "Reload": "Reload"
                    })
                        .header("Storefront failed to initialize.")
                        .body("The storefront failed to initialize properly. View logs for more information.")
                        .show(true);
                };
                this.skipTaskMessage = function () {
                    return _this.storefrontService.getCmsItemById(_this.routes.storefrontSkipTaskOrGoBackModal)
                        .then(function (response) {
                        return _this.createWithGenericMediumModal(_this.modalNames.StorefrontSkippTaskMessage)
                            .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                            .actions({
                            "stay": response.buttons["STAY"],
                            "leave": response.buttons["LEAVE"]
                        })
                            .header(response.Title)
                            .body(response.Message)
                            .inject("showModalClose", true)
                            .show(true)
                            .then(function (action) { return action === "leave"; });
                    });
                };
                this.blockModalsInRestrictedState = function (angularEvent, name) {
                    if (!_this.storefrontModalServiceModalNames[name] && _this.storefrontService.stateChangingRestricted) {
                        angularEvent.preventDefault();
                    }
                    return undefined;
                };
            }
            //factor method of creating service
            StorefrontModalService.factory = function () {
                var service = function (modalService, $q, storefrontService, stateNames, $state, $timeout, routes, errorDisplayService, storefrontModalServiceModalNames, storefrontMaterialDialogWrapper, homeStates, cavveStates, vehiclesStates, addMissingInformationService) {
                    return new StorefrontModalService(modalService, $q, storefrontService, stateNames, $state, $timeout, routes, errorDisplayService, storefrontModalServiceModalNames, storefrontMaterialDialogWrapper, homeStates, cavveStates, vehiclesStates, addMissingInformationService);
                };
                service.$inject =
                    ["modalService", "$q", "StorefrontService", "stateNames",
                        "$state", "$timeout", "routes", "errorDisplayService",
                        "StorefrontModalServiceModalNames", "storefrontMaterialDialogWrapper", "homeStates", "cavveStates",
                        "vehiclesStates",
                        "addMissingInformationService"];
                return service;
            };
            Object.defineProperty(StorefrontModalService.prototype, "modalNames", {
                get: function () {
                    return this.storefrontModalServiceModalNames;
                },
                enumerable: true,
                configurable: true
            });
            StorefrontModalService.prototype.setGlobalModalSettings = function () {
                var _this = this;
                this.modalService.clearListeners();
                this.modalService.onOpening(function (evt, name, settings, textOptions) { return _this.onOpening(evt, name, settings, textOptions); });
                this.modalService.onOpening(this.blockModalsInRestrictedState);
            };
            StorefrontModalService.prototype.restoreGlobalModalSettings = function () {
                this.modalService.resetSettings();
                this.modalService.onOpening(this.blockModalsInRestrictedState);
            };
            StorefrontModalService.prototype.create = function (name) {
                return new InternalStorefrontModalBuilder(name, this.modalService, this.$q);
            };
            StorefrontModalService.prototype.createWithGenericMediumModal = function (name) {
                return new InternalStorefrontModalBuilder(name, this.modalService, this.$q)
                    .controller('StorefrontGenericPromptController')
                    .classNames(['mediumModal', 'storefrontGenericPromptWindow']);
            };
            StorefrontModalService.prototype.isExternalTaskModalOpen = function () {
                return this.modalService.isModalOpen(this.modalNames.StorefrontExternalTask);
            };
            StorefrontModalService.prototype.closeExternalTaskModal = function () {
                this.modalService.closeByName(this.modalNames.StorefrontExternalTask);
            };
            StorefrontModalService.prototype.isMaintenanceModalOpen = function () {
                return this.modalService.isModalOpen(this.modalNames.StorefrontMaintenance);
            };
            StorefrontModalService.prototype.closeAll = function (dismiss) {
                this.modalService.closeAll(dismiss);
                this.storefrontMaterialDialogWrapper.closeAll();
                this.errorDisplayService.clearToasts();
            };
            StorefrontModalService.prototype.closeByName = function (name, dismiss) {
                this.modalService.closeByName(name, dismiss);
            };
            StorefrontModalService.prototype.getCmsContent = function (id) {
                return this.storefrontService.getCmsItemById(id);
            };
            StorefrontModalService.prototype.finishAccountSetup = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontfinishAccountSetupModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontFinishAccountSetup)
                        .template("/app/templates/storefront/StorefrontGenericPromptTemplate.html")
                        .actions({
                        "finish": response.buttons["FINISH"]
                    })
                        .header(response.Title)
                        .body(response.Message)
                        .show(true)
                        .then(function () {
                        var workItemId = HCTRA.Model.SelectedOptions.OACC;
                        return _this.storefrontService.softReset()
                            .then(function () {
                            _this.storefrontService.insertWorkItem(workItemId);
                            return _this.storefrontService.startWorkItems();
                        })
                            .then(function (state) {
                            return _this.$state.go(state);
                        });
                    });
                });
            };
            StorefrontModalService.prototype.showVehicalViolationMessage = function () {
                var _this = this;
                //remove any toasters that are opening or have just started...
                this.errorDisplayService.clearToasts();
                return this.storefrontService.getCmsItemById(this.routes.storefrontVehicleHasViolationModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontVehicalViolations)
                        .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                        .actions({
                        "finish": response.buttons["FINISH"]
                    })
                        .header(response.Title)
                        .body(response.Message)
                        .show(true)
                        .then(function () { return _this.storefrontService.softReset(); })
                        .then(function () { return _this.$state.go(_this.stateNames.storefrontSurvey); });
                });
            };
            StorefrontModalService.prototype.showVehicalViolationSuspendedAccountMessage = function () {
                var _this = this;
                //remove any toasters that are opening or have just started...
                this.errorDisplayService.clearToasts();
                return this.storefrontService.getCmsItemById(this.routes.storefrontVehicleHasViolationSuspendedAccountModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontSuspendedWithVehicalViolations)
                        .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                        .actions({
                        "finish": response.buttons["FINISH"],
                        "notFinished": response.buttons["NOTFINISHED"]
                    })
                        .header(response.Title)
                        .body(response.Message)
                        .show(true)
                        .then(function (action) {
                        if (action === "notFinished") {
                            return _this.doMoreMessage(function () { return _this.showVehicalViolationSuspendedAccountMessage(); });
                        }
                        return _this.$state.go(_this.stateNames.storefrontSurvey);
                    });
                });
            };
            StorefrontModalService.prototype.iDontSeeWhatINeedMessage = function (goBackCallback) {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontOtherOptionsModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontINeedTo)
                        .template("/app/templates/storefront/StorefrontINeedToTemplate.html")
                        .actions({
                        "talkToCsr": response.buttons["CSR"],
                        "fullSite": response.buttons["WEBSITE"],
                        "goback": response.buttons["TASKSELECTION"]
                    })
                        .header(response.Title)
                        .inject("showModalClose", true)
                        .inject("showGoBack", null)
                        .show(true)
                        .then(function (action) {
                        switch (action) {
                            case "talkToCsr":
                                return _this.showGotoCsr()
                                    .then(function (finished) { return finished ? _this.storefrontService.reset() : _this.iDontSeeWhatINeedMessage(function () { return goBackCallback(); }); });
                            case "fullSite":
                                _this.restoreGlobalModalSettings();
                                _this.storefrontService.fullSiteMode = true;
                                return _this.storefrontService
                                    .startNewSession()
                                    .then(function () { return _this.$state.go(_this.homeStates.Frame); });
                            default:
                                return goBackCallback ? goBackCallback() : _this.$q.resolve();
                        }
                    });
                });
            };
            StorefrontModalService.prototype.doMoreMessage = function (goBackCallback) {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontDoMoreModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontDoSomethingElse)
                        .template("/app/templates/storefront/StorefrontINeedToWithMoreTemplate.html")
                        .actions({
                        "anotherTask": response.buttons["ANOTHERTASK"],
                        "talkToCsr": response.buttons["CSR"],
                        "fullSite": response.buttons["FULLWEBSITE"],
                        "finish": response.buttons["FINISH"]
                    })
                        .header(response.Title)
                        .inject("showGoBack", response.buttons["BACK"])
                        .show(true)
                        .then(function (action) {
                        switch (action) {
                            case "anotherTask":
                                _this.modalService.closeAll();
                                return _this.storefrontService
                                    .softReset()
                                    .finally(function () { return _this.$state.go(_this.stateNames.storefrontSelection); });
                            case "talkToCsr":
                                return _this.showGotoCsr()
                                    .then(function (finished) {
                                    if (finished) {
                                        if (_this.storefrontService.isActiveSession()) {
                                            _this.modalService.closeAll();
                                            return _this.$state.go(_this.stateNames.storefrontSurvey);
                                        }
                                        else {
                                            return _this.storefrontService.reset();
                                        }
                                    }
                                    else {
                                        return _this.doMoreMessage(function () { return goBackCallback(); });
                                    }
                                });
                            case "fullSite":
                                _this.restoreGlobalModalSettings();
                                _this.storefrontService.fullSiteMode = true;
                                _this.modalService.closeAll();
                                return _this.$state.go(_this.homeStates.Frame);
                            case "finish":
                                if (_this.storefrontService.isActiveSession()) {
                                    _this.modalService.closeAll();
                                    return _this.$state.go(_this.stateNames.storefrontSurvey);
                                }
                                else {
                                    return _this.storefrontService.reset();
                                }
                            default:
                                return goBackCallback ? goBackCallback() : _this.$q.resolve();
                        }
                    });
                });
            };
            StorefrontModalService.prototype.showCompletionMessage = function (completedWorkItem) {
                var template = completedWorkItem && completedWorkItem.completionModal;
                var state = null;
                var completedItemInitState = this.storefrontService.getWorkItemInitState(completedWorkItem);
                if (this.storefrontService.hasIncompleteWorkItems()) {
                    var item = this.storefrontService.currentWorkItem();
                    state = this.storefrontService.getWorkItemInitState(item);
                }
                switch (template) {
                    case HCTRA.Model.StorefrontModalTemplatesEnum.ThankYouViolationsPayment:
                        //if workitem got signal to complete and the state is actuall the init state
                        if (completedItemInitState === this.$state.current.name) {
                            //.. then the item was ended early but successful, in this case, no violations and no payments
                            return this.handleDefaultTaskComplete(state);
                        }
                        else if (this.cavveStates.Receipt === this.$state.current.name) {
                            //if CAVVE flow then account is created at end of flow so show CAVVE signup modal
                            var removedWorkItem = this.storefrontService.removeWorkItem(HCTRA.Model.SelectedOptions.OACC); //This will remove the create account task if it exists
                            return (removedWorkItem) ? this.postCAVVESignup() : this.postSignup(); //if removedWorkItem is defined, that means it was removed from queue
                        }
                        else {
                            return this.postPaymentUpsale();
                        }
                    case HCTRA.Model.StorefrontModalTemplatesEnum.ThankYouNewAccount:
                        return this.postSignup();
                    case HCTRA.Model.StorefrontModalTemplatesEnum.VehicalViolationSuspendedAccountMessage:
                        return this.showVehicalViolationSuspendedAccountMessage();
                    case HCTRA.Model.StorefrontModalTemplatesEnum.None:
                        return state ? this.$state.go(state) : this.showAllTasksComplete();
                    case HCTRA.Model.StorefrontModalTemplatesEnum.FinishSetup:
                        return this.finishAccountSetup();
                    default:
                        return this.handleDefaultTaskComplete(state);
                }
            };
            StorefrontModalService.prototype.handleDefaultTaskComplete = function (stateName) {
                var _this = this;
                if (this.storefrontService.hasIncompleteWorkItems()) {
                    return this.showTaskComplete()
                        .then(function () { return stateName ? _this.$state.go(stateName) : _this.showAllTasksComplete(); });
                }
                else {
                    return this.showAllTasksComplete();
                }
            };
            StorefrontModalService.prototype.showStorefrontMaintenanceMode = function () {
                return this.createWithGenericMediumModal(this.modalNames.StorefrontMaintenance)
                    .template("/app/templates/storefront/StorefrontMaintenanceTemplate.html")
                    .classNames(['largeModal', 'storefrontGenericPromptWindow'])
                    .image(this.storefrontService.getMaintenanceImg())
                    .show(true);
            };
            StorefrontModalService.prototype.showTaskComplete = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontTaskCompleteModal)
                    .then(function (response) {
                    return _this.create(_this.modalNames.StorefrontWorkitemComplete)
                        .template("/app/templates/storefront/StorefrontGenericPromptTemplate.html")
                        .controller('StorefrontTaskCompleteController')
                        .header(response.Title)
                        .body(response.Message)
                        .actions({
                        "next": response.buttons["NEXT"]
                    })
                        .classNames(["mediumModal", "storefrontGenericPromptWindow"])
                        .show();
                });
            };
            StorefrontModalService.prototype.showAllTasksComplete = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontAllTasksCompleteModal)
                    .then(function (response) {
                    return _this.create(_this.modalNames.StorefrontAllWorkItemsComplete)
                        .header(response.Title)
                        .actions({
                        "finish": response.buttons["FINISH"],
                        "notFinished": response.buttons["NOTFINISHED"]
                    })
                        .template("/app/templates/storefront/StorefrontGenericPromptTemplate.html")
                        .controller('StorefrontAllTasksCompleteController')
                        .classNames(["mediumModal", "storefrontGenericPromptWindow"])
                        .show()
                        .then(function (action) {
                        if (action === "finish") {
                            return _this.forceGoToSurvey();
                        }
                        return _this.doMoreMessage(function () { return _this.showAllTasksComplete(); });
                    });
                });
            };
            StorefrontModalService.prototype.postPaymentUpsale = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontPaymentViolationsModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontWorkitemCompleteSignup)
                        .template("/app/templates/storefront/StorefrontMissedATollPaymentModalTemplate.html")
                        .image(response.ImageItem)
                        .header(response.Title)
                        .body(response.Message)
                        .actions({
                        "signUp": response.buttons["SIGNUP"],
                        "finish": response.buttons["FINISH"]
                    })
                        .show(true)
                        .then(function (action) {
                        if (action === "signUp") {
                            var workItemId = HCTRA.Model.SelectedOptions.OACC;
                            _this.storefrontService.insertWorkItem(workItemId);
                            return _this.storefrontService.skip(workItemId).then(function (funcState) { return _this.$state.go(funcState); });
                        }
                        else {
                            if (_this.storefrontService.hasIncompleteWorkItems()) {
                                var state = _this.storefrontService.getWorkItemInitState(_this.storefrontService.currentWorkItem());
                                return state ? _this.$state.go(state) : _this.forceGoToSurvey();
                            }
                            else {
                                return _this.forceGoToSurvey();
                            }
                        }
                    });
                });
            };
            StorefrontModalService.prototype.postSignup = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontThankYouNewAccountModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontWorkitemCompleteGoToCsr)
                        .template("/app/templates/storefront/StorefrontGenericPromptTemplate.html")
                        .header(response.Title)
                        .body(response.Message)
                        .actions({
                        "finish": response.buttons["FINISH"],
                        "notFinished": response.buttons["NOTFINISHED"]
                    })
                        .show(true)
                        .then(function (action) {
                        if (action === "notFinished") {
                            return _this.doMoreMessage(function () { return _this.postSignup(); });
                        }
                        else {
                            return _this.forceGoToSurvey();
                        }
                    });
                });
            };
            StorefrontModalService.prototype.genericPostSignup = function (cmsItemId) {
                var _this = this;
                return this.storefrontService.getCmsItemById(cmsItemId)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontWorkitemCompleteGoToCsr)
                        .template("/app/templates/storefront/StorefrontGenericPromptTemplate.html")
                        .header(response.Title)
                        .body(response.Message)
                        .actions(__assign({ "finish": response.buttons["FINISH"] }, (response.buttons["NOTFINISHED"] ? { "notFinished": response.buttons["NOTFINISHED"] } : {})))
                        .show(true)
                        .then(function (action) {
                        if (action === "notFinished") {
                            return _this.doMoreMessage(function () { return _this.postSignup(); });
                        }
                        else {
                            return _this.forceGoToSurvey();
                        }
                    });
                });
            };
            StorefrontModalService.prototype.postCAVVESignup = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontThankYouCAVVEModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontWorkitemCompleteCAVVE)
                        .template("/app/templates/storefront/StorefrontGenericPromptTemplate.html")
                        .header(response.Title)
                        .body(response.Message)
                        .actions({
                        "finish": response.buttons["FINISH"],
                        "notFinished": response.buttons["NOTFINISHED"]
                    })
                        .show(true)
                        .then(function (action) {
                        if (action === "notFinished") {
                            return _this.doMoreMessage(function () { return _this.postCAVVESignup(); });
                        }
                        else {
                            return _this.forceGoToSurvey();
                        }
                    });
                });
            };
            StorefrontModalService.prototype.showInactivity = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontSessionTimeoutModal)
                    .then(function (response) {
                    return _this.create(_this.modalNames.StorefrontInactivity)
                        .template("/app/templates/storefront/StorefrontInactivityTemplate.html")
                        .controller("StorefrontInactivityController")
                        .classNames(['mediumModal', 'storefrontGenericPromptWindow'])
                        .header(response.Title)
                        .body(response.Message)
                        .actions({
                        "ok": response.buttons["OK"]
                    })
                        .show();
                });
            };
            StorefrontModalService.prototype.showGotoCsr = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontAdditionalHelpModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontSeeCSR)
                        .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                        .header(response.Title)
                        .actions({
                        "finish": response.buttons["FINISH"]
                    })
                        .inject("showGoBack", response.buttons["BACK"])
                        .show(true)
                        .then(function (action) { return action === "finish"; });
                });
            };
            //show a modal with a rendered pdf
            StorefrontModalService.prototype.showPdf = function (href) {
                return this.create(this.modalNames.StorefrontPdfViewer)
                    .template('/app/templates/storefront/StorefrontPdfViewerTemplate.html')
                    .controller('StorefrontPdfViewerController')
                    .classNames(['largeModal', 'storefrontPdfWindow'])
                    .inject("pdfHref", href)
                    .show()
                    //This catch is very important: when modals are 'closed', the promises are resolved,
                    //however when modals are 'dismissed' they are rejected. If this method returns a rejected
                    //promise, the callee assumes the pdf didn't load, not that the modal was dismissed, like when
                    //the app is inactive. This catch allows the dismiss rejection to be ignored, allowing pdf modals
                    //to be dismissed without resulting in a url redirection.
                    .catch(function () { })
                    .then(function (e) {
                    if (e && e.name && e.name === "InvalidPDFException") {
                        throw e;
                    }
                });
            };
            //open modal for external task. promise resolves when closed, rejects when dismissed
            //return state is state to redirect to when closed/dismissed
            StorefrontModalService.prototype.showExternalTask = function () {
                return this.create(this.modalNames.StorefrontExternalTask)
                    .template('/app/templates/storefront/StorefrontExternalTaskModalTemplate.html')
                    .controller('StorefrontExternalTaskModalController')
                    .classNames(['largeModal', 'storefrontModalWindow'])
                    .show();
            };
            StorefrontModalService.prototype.skippedTasksMessage = function (workItem) {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontSkippedTasksModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontIncompleteWorkitemsWhileSkipping)
                        .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                        .actions({
                        "notFinished": response.buttons["NOTFINISHED"],
                        "finish": response.buttons["FINISH"]
                    })
                        .header(response.Title)
                        .body(response.Message)
                        .inject("showModalClose", true)
                        .show(true)
                        .then(function (action) {
                        if (action === "notFinished") {
                            _this.storefrontService.setCurrentWorkItem(workItem);
                            return workItem;
                        }
                        else {
                            return null;
                        }
                    });
                });
            };
            StorefrontModalService.prototype.exit = function () {
                var _this = this;
                return this.storefrontService.getCmsItemById(this.routes.storefrontExitSessionModal)
                    .then(function (response) {
                    return _this.createWithGenericMediumModal(_this.modalNames.StorefrontExitSession)
                        .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                        .actions({
                        "exit": response.buttons["EXIT"],
                        "stay": response.buttons["STAY"]
                    })
                        .header(response.Title)
                        .body(response.Message)
                        .inject("showModalClose", true)
                        .show(true)
                        .then(function (action) {
                        if (action === "exit" && _this.storefrontService.fullSiteMode) {
                            return _this.$q
                                .when(_this.storefrontService.isActiveSession() ||
                                _this.storefrontService.startNewSession())
                                .then(function () {
                                _this.storefrontService.fullSiteMode = false;
                                return _this.forceGoToSurvey();
                            });
                        }
                        if (action === "exit") {
                            if (_this.storefrontService.isActiveSession()) {
                                return _this.forceGoToSurvey();
                            }
                            else {
                                return _this.storefrontService.reset();
                            }
                        }
                        else {
                            return _this.$q.resolve();
                        }
                    });
                });
            };
            StorefrontModalService.prototype.showCmsContent = function (state, returnStateName) {
                var _this = this;
                return this.create(this.modalNames.StorefrontCmsContent)
                    .template('/app/templates/storefront/StorefrontCmsModalTemplate.html')
                    .controller("StorefrontCmsModalController")
                    .inject("controllerName", state.controller)
                    .inject("template", state.templateUrl)
                    .classNames(['largeModal', 'storefrontGenericPromptWindow'])
                    .show()
                    .then(function () { return _this.$state.go(returnStateName); });
            };
            StorefrontModalService.prototype.closeCmsContent = function () {
                this.modalService.closeByName(this.modalNames.StorefrontCmsContent, true);
            };
            StorefrontModalService.prototype.noViolationsFound = function (title, body) {
                var _this = this;
                return this.createWithGenericMediumModal(this.modalNames.StorefrontNoViolationsFound)
                    .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                    .actions({
                    "proceed": "Proceed",
                    "anotherPlate": "Try another plate"
                })
                    .header(title)
                    .body(body)
                    .show(true)
                    .then(function (action) {
                    if (action === "proceed") {
                        return _this.storefrontService.completeWorkItem();
                    }
                    else {
                        return _this.$q.resolve(null);
                    }
                });
            };
            StorefrontModalService.prototype.noViolationsWithInvoiceFound = function (title, body) {
                var _this = this;
                return this.createWithGenericMediumModal(this.modalNames.StorefrontNoViolationsWithInvoiceFound)
                    .template('/app/templates/storefront/StorefrontGenericPromptTemplate.html')
                    .actions({
                    "proceed": "Proceed",
                    "tryagain": "Try another plate or invoice number"
                })
                    .header(title)
                    .body(body)
                    .show(true)
                    .then(function (action) {
                    if (action === "proceed") {
                        return _this.storefrontService.completeWorkItem();
                    }
                    else {
                        return _this.$q.resolve(null);
                    }
                });
            };
            //overrides settings when opening modals
            StorefrontModalService.prototype.onOpening = function (angularEvent, name, modalSettings, modalTextOptions) {
                var _a;
                var leaveUnModified = (_a = {},
                    _a[this.modalService.modalNames.PaymentModal] = "paymentModal storefrontModalWindow",
                    _a[this.modalService.modalNames.VehicleInfoSlidingPanel] = "side-drawer",
                    _a[this.modalService.modalNames.CancelSlidingPanel] = "side-drawer",
                    _a[this.modalService.modalNames.MailingAddressInfoSlidingPanel] = "side-drawer",
                    _a[this.modalService.modalNames.InvoiceListSlidingPanel] = "side-drawer",
                    _a[this.modalService.modalNames.PhoneEmailInfoSlidingPanel] = "side-drawer",
                    _a[this.modalService.modalNames.EditBillingInfoSlidingPanel] = "side-drawer",
                    _a);
                if ((!name || !this.modalNames[name]) && !leaveUnModified[name]) {
                    var template = (modalSettings.templateUrl === "/app/templates/common/modalAlert.html")
                        ? "/app/templates/storefront/StorefrontModalAlertReplacementTemplate.html"
                        : "/app/templates/storefront/StorefrontModalReplacementTemplate.html";
                    angular.extend(modalSettings, {
                        backdrop: true,
                        keyboard: true,
                        modalFade: true,
                        templateUrl: template,
                        controller: 'StorefrontModalReplacementController',
                        windowClass: 'mediumModal storefrontModalWindow'
                    });
                }
                if (leaveUnModified[name]) {
                    angular.extend(modalSettings, {
                        backdrop: "static",
                        keyboard: true,
                        modalFade: true,
                        windowClass: leaveUnModified[name]
                    });
                }
                //add content overrides for specific modals by name
                switch (name) {
                    case this.modalService.modalNames.ViolationsCannotAddVehicle:
                        angularEvent.preventDefault();
                        var currentScope = angularEvent.currentScope;
                        if (currentScope.currentUser.acctActivity === "S") {
                            return this.showVehicalViolationSuspendedAccountMessage();
                        }
                        else {
                            return this.showVehicalViolationMessage();
                        }
                    case this.modalService.modalNames.ViolationsNoViolationFound:
                        angularEvent.preventDefault();
                        return this.noViolationsFound(modalTextOptions.headerText, modalTextOptions.bodyText);
                    case this.modalService.modalNames.ViolationsNoViolationFoundWithInvoice:
                        angularEvent.preventDefault();
                        return this.noViolationsWithInvoiceFound(modalTextOptions.headerText, modalTextOptions.bodyText);
                    case this.modalService.modalNames.CreditCardPrompt:
                        modalSettings.templateUrl = "/app/templates/storefront/StorefrontCreditCardPromptTemplate.html";
                        modalSettings.backdrop = "static";
                        break;
                    //disabled modals...
                    case this.modalService.modalNames.Maintenance:
                    case this.modalService.modalNames.UpdateSuccess:
                    case this.modalService.modalNames.InvoicePayment:
                    case this.modalService.modalNames.ViolationsLandingLogin:
                        angularEvent.preventDefault();
                        break;
                    default:
                        break;
                }
            };
            StorefrontModalService.prototype.forceGoToSurvey = function () {
                var _this = this;
                this.addMissingInformationService.destroyMissingInformationFlags();
                return this.storefrontService.lockStateChanging(function () { return _this.$state.go(_this.stateNames.storefrontSurvey); });
            };
            return StorefrontModalService;
        }());
        Service.StorefrontModalService = StorefrontModalService;
        //internal class defining a modal build, no need to export
        var InternalStorefrontModalBuilder = /** @class */ (function () {
            function InternalStorefrontModalBuilder(name, modalService, $q) {
                this.name = name;
                this.modalService = modalService;
                this.$q = $q;
                this.additionalResolves = {};
            }
            InternalStorefrontModalBuilder.prototype.actions = function (actions) {
                this.injectedActions = this.$q.when(actions);
                return this;
            };
            InternalStorefrontModalBuilder.prototype.header = function (text) {
                this.headerPromise = this.$q.when(text);
                return this;
            };
            InternalStorefrontModalBuilder.prototype.body = function (text) {
                this.bodyPromise = this.$q.when(text);
                return this;
            };
            InternalStorefrontModalBuilder.prototype.image = function (data) {
                this.imagePromise = this.$q.when(data);
                return this;
            };
            InternalStorefrontModalBuilder.prototype.template = function (templateLocation) {
                this.templateLocation = templateLocation;
                return this;
            };
            InternalStorefrontModalBuilder.prototype.controller = function (controllerDef) {
                this.controllerDef = controllerDef;
                return this;
            };
            InternalStorefrontModalBuilder.prototype.classNames = function (classNames) {
                this.classes = (classNames || []).filter(function (c) { return c; }).join(" ");
                return this;
            };
            InternalStorefrontModalBuilder.prototype.inject = function (key, obj) {
                this.additionalResolves[key] = function () { return obj; };
                return this;
            };
            InternalStorefrontModalBuilder.prototype.show = function (isGeneric) {
                var _this = this;
                if (isGeneric === void 0) { isGeneric = false; }
                return this.$q.all([this.headerPromise, this.bodyPromise, this.imagePromise, this.injectedActions]).then(function (promises) {
                    var headerText = promises[0];
                    var bodyText = promises[1];
                    var image = promises[2];
                    var actions = promises[3];
                    _this.additionalResolves["actions"] = function () { return actions; }; //TODO:investigate why having "actions after image and other additional resolves causes issues"
                    _this.additionalResolves["imageData"] = function () { return (image) ? image : null; };
                    if (isGeneric) {
                        _this.additionalResolves["showModalClose"] = (_this.additionalResolves["showModalClose"]) ? _this.additionalResolves["showModalClose"] : null;
                        _this.additionalResolves["showGoBack"] = (_this.additionalResolves["showGoBack"]) ? _this.additionalResolves["showGoBack"] : null;
                    }
                    return _this.modalService.showModal({
                        backdrop: true,
                        keyboard: true,
                        modalFade: true,
                        templateUrl: _this.templateLocation,
                        controller: _this.controllerDef,
                        windowClass: _this.classes,
                        //these will be passed to modal's contructor
                        resolve: _this.additionalResolves
                    }, _this.internalOptions ||
                        {
                            headerText: headerText,
                            actionButtonText: null,
                            bodyText: bodyText,
                            closeButtonText: null,
                            subText: null
                        }, _this.name);
                });
            };
            return InternalStorefrontModalBuilder;
        }());
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .factory("StorefrontModalService", HCTRA.Service.StorefrontModalService.factory())
        .constant("StorefrontModalServiceModalNames", {
        "StorefrontFinishAccountSetup": "StorefrontFinishAccountSetup",
        "StorefrontVehicalViolations": "StorefrontVehicalViolations",
        "StorefrontSuspendedWithVehicalViolations": "StorefrontSuspendedWithVehicalViolations",
        "StorefrontINeedTo": "StorefrontINeedTo",
        "StorefrontDoSomethingElse": "StorefrontDoSomethingElse",
        "StorefrontMaintenance": "StorefrontMaintenance",
        "StorefrontWorkitemComplete": "StorefrontWorkitemComplete",
        "StorefrontAllWorkItemsComplete": "StorefrontAllWorkItemsComplete",
        "StorefrontWorkitemCompleteSignup": "StorefrontWorkitemCompleteSignup",
        "StorefrontWorkitemCompleteGoToCsr": "StorefrontWorkitemCompleteGoToCsr",
        "StorefrontWorkitemCompleteCAVVE": "StorefrontWorkitemCompleteCAVVE",
        "StorefrontInactivity": "StorefrontInactivity",
        "StorefrontSeeCSR": "StorefrontSeeCSR",
        "StorefrontPdfViewer": "StorefrontPdfViewer",
        "StorefrontExternalTask": "StorefrontExternalTask",
        "StorefrontServiceInitFailed": "StorefrontServiceInitFailed",
        "StorefrontSkippTaskMessage": "StorefrontSkippTaskMessage",
        "StorefrontIncompleteWorkitemsWhileSkipping": "StorefrontIncompleteWorkitemsWhileSkipping",
        "StorefrontExitSession": "StorefrontExitSession",
        "StorefrontCmsContent": "StorefrontCmsContent",
        "StorefrontNoViolationsFound": "StorefrontNoViolationsFound",
        "StorefrontNoViolationsWithInvoiceFound": "StorefrontNoViolationsWithInvoiceFound"
    });
})();
var HCTRA;
(function (HCTRA) {
    var Storefront;
    (function (Storefront) {
        var Service;
        (function (Service) {
            //defines the concrete implementation of the store front service. Manages workflow of selected work items, cms related data, and
            //other storefront related activities. Please review the IStorefrontService for information concerning member usage.
            var StorefrontService = /** @class */ (function () {
                function StorefrontService($http, $rootScope, stateNames, missedATollStates, $q, genericRepo, routes, cmsUtilService, authService, webStorage, storefrontUtilityService, stringUtilsService, suspendedAccountService, angularEnvironment, environmentConfig, addMissingInformationService, violationsStateNames, violatorStateNames, loginStates, makePaymentStates, profileStates, cavveStates, vehiclesStates, suspendedAccountWithoutViolationStateNames, $window) {
                    var _a;
                    var _this = this;
                    this.$http = $http;
                    this.$rootScope = $rootScope;
                    this.stateNames = stateNames;
                    this.missedATollStates = missedATollStates;
                    this.$q = $q;
                    this.genericRepo = genericRepo;
                    this.routes = routes;
                    this.cmsUtilService = cmsUtilService;
                    this.authService = authService;
                    this.webStorage = webStorage;
                    this.storefrontUtilityService = storefrontUtilityService;
                    this.stringUtilsService = stringUtilsService;
                    this.suspendedAccountService = suspendedAccountService;
                    this.angularEnvironment = angularEnvironment;
                    this.environmentConfig = environmentConfig;
                    this.addMissingInformationService = addMissingInformationService;
                    this.violationsStateNames = violationsStateNames;
                    this.violatorStateNames = violatorStateNames;
                    this.loginStates = loginStates;
                    this.makePaymentStates = makePaymentStates;
                    this.profileStates = profileStates;
                    this.cavveStates = cavveStates;
                    this.vehiclesStates = vehiclesStates;
                    this.suspendedAccountWithoutViolationStateNames = suspendedAccountWithoutViolationStateNames;
                    this.$window = $window;
                    //index of currently executing work item
                    this.workFlowIndex = null;
                    //index that current shadow item is standing in for
                    this.shadowItemIndex = null;
                    //regex to parse guid
                    this.guidRegex = /[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}/ig;
                    this.isFullSiteMode = false;
                    this.workItemStateNames = (_a = {},
                        _a[HCTRA.Model.SelectedOptions.MTOLL] = [
                            this.missedATollStates.Landing,
                            this.missedATollStates.Grid,
                            this.missedATollStates.Billing,
                            this.missedATollStates.Confirm,
                            this.missedATollStates.Receipt
                        ],
                        _a[HCTRA.Model.SelectedOptions.GINV] = [
                            this.violationsStateNames.Landing,
                            this.violationsStateNames.Grid,
                            this.violationsStateNames.MakePayment,
                            this.violationsStateNames.Confirm,
                            this.violationsStateNames.Receipt,
                            this.cavveStates.Offer,
                            this.cavveStates.Root,
                            this.cavveStates.Billing,
                            this.cavveStates.Personal,
                            this.cavveStates.Receipt,
                            this.cavveStates.Confirm,
                            this.violationsStateNames.Grid,
                            this.violationsStateNames.MakePayment,
                            this.violationsStateNames.Confirm,
                            this.violationsStateNames.Receipt
                        ],
                        _a[HCTRA.Model.SelectedOptions.OACC] = this.createAccountStates(),
                        _a[HCTRA.Model.SelectedOptions.UBI] = [
                            this.stateNames.managePayment,
                            this.stateNames.updateBillingInformation,
                            this.stateNames.addSecondaryCreditCard,
                            this.stateNames.updateSecondaryCreditCard,
                            this.stateNames.saveBillingInformation,
                            this.profileStates.UpdateBillingInformation,
                            this.stateNames.editCreditCardInformation,
                            this.stateNames.editBankAccountInformation,
                            this.stateNames.editCreditCardAddress,
                            this.stateNames.addCreditCardInformation,
                            this.stateNames.addBankAccountInformation,
                            this.stateNames.makePaymentMethodPrimary
                        ],
                        _a[HCTRA.Model.SelectedOptions.UCI] = [
                            this.profileStates.UpdateContactInformation
                        ],
                        _a[HCTRA.Model.SelectedOptions.UAC] = [
                            this.profileStates.UpdateAuthorizedContacts
                        ],
                        _a[HCTRA.Model.SelectedOptions.URAMT] = [
                            this.profileStates.UpdateReplenishmentAmount,
                            this.profileStates.UpdateFlexpayBillingInformation
                        ],
                        _a[HCTRA.Model.SelectedOptions.ARTAG] = [
                            this.vehiclesStates.Root,
                            this.vehiclesStates.AddTag,
                            this.vehiclesStates.AddEzPlate,
                            this.vehiclesStates.PlateVehicleInformation,
                            this.vehiclesStates.PlateReviewOrder,
                            this.vehiclesStates.PlateReceipt,
                            this.vehiclesStates.TagVehicleInformation,
                            this.vehiclesStates.TagCart,
                            this.vehiclesStates.TagDeliveryMethod,
                            this.vehiclesStates.TagReviewOrder,
                            this.vehiclesStates.TagReceipt,
                            this.vehiclesStates.Replacement,
                            this.vehiclesStates.ReplacementDeliveryMethod,
                            this.vehiclesStates.ReplacementReviewOrder,
                            this.vehiclesStates.ReplacementReceipt,
                            this.stateNames.activateEzTag,
                            this.stateNames.activateEzTagConfirm,
                            this.stateNames.activateEzTagCompletion
                        ],
                        _a[HCTRA.Model.SelectedOptions.MKPAY] = [
                            this.makePaymentStates.Landing,
                            this.makePaymentStates.Root,
                            this.makePaymentStates.Checkout,
                            this.makePaymentStates.Receipt
                        ],
                        _a[HCTRA.Model.SelectedOptions.EO] = [
                            this.violatorStateNames.Landing,
                            this.violatorStateNames.Grid,
                            this.violatorStateNames.MakePayment,
                            this.violatorStateNames.Confirm,
                            this.violatorStateNames.Receipt,
                            this.cavveStates.Offer,
                            this.cavveStates.Root,
                            this.cavveStates.Billing,
                            this.cavveStates.Personal,
                            this.cavveStates.Receipt,
                            this.cavveStates.Confirm
                        ],
                        _a);
                    if (this.storefrontUtilityService.isRunningAsKiosk) {
                        this.serviceInitialized = this
                            .clearNamedCaches()
                            .then(function () { return _this.getCmsItemsAndBuildWorkItems(); });
                    }
                    else {
                        this.serviceInitialized = this.$q.resolve();
                    }
                }
                Object.defineProperty(StorefrontService.prototype, "workItems", {
                    //all available workitems
                    get: function () {
                        return this.internalWorkItems;
                    },
                    enumerable: true,
                    configurable: true
                });
                //factory method for instanciating service
                StorefrontService.factory = function () {
                    var service = function ($http, $rootScope, stateNames, missedATollStates, $q, genericRepo, routes, cmsUtilService, authService, webStorage, storefrontUtilityService, stringUtilsService, suspendedAccountService, angularEnvironment, environmentConfig, addMissingInformationService, violationsStateNames, violatorStateNames, loginStates, makePaymentStates, profileStates, cavveStates, vehiclesStates, suspendedAccountWithoutViolationStateNames, $window) {
                        return new StorefrontService($http, $rootScope, stateNames, missedATollStates, $q, genericRepo, routes, cmsUtilService, authService, webStorage, storefrontUtilityService, stringUtilsService, suspendedAccountService, angularEnvironment, environmentConfig, addMissingInformationService, violationsStateNames, violatorStateNames, loginStates, makePaymentStates, profileStates, cavveStates, vehiclesStates, suspendedAccountWithoutViolationStateNames, $window);
                    };
                    service.$inject = [
                        "$http", "$rootScope", "stateNames", "missedATollStates", "$q", "genericRepo",
                        "routes", "cmsUtilService", "AuthService", "webStorage",
                        "StorefrontUtilityService", "stringUtilsService", "suspendedAccountService", "angularEnvironment",
                        "environmentConfig", "addMissingInformationService", "violationsStateNames", "violatorStateNames",
                        "loginStates", "makePaymentStates", "profileStates", "cavveStates", "vehiclesStates", "suspendedAccountWithoutViolationStateNames",
                        "$window"
                    ];
                    return service;
                };
                StorefrontService.prototype.createAccountStates = function () {
                    if (this.environmentConfig.createAccountRefresh) {
                        return [
                            //  this.stateNames.NewAccount,
                            this.stateNames.Login,
                            this.stateNames.VehicleInfo,
                            this.stateNames.Cart,
                            this.stateNames.PaymentInfo,
                            this.stateNames.DeliveryMethod,
                            this.stateNames.Review,
                            this.stateNames.Receipt
                        ];
                    }
                    else {
                        return [
                            this.stateNames.createAccount,
                            this.stateNames.newAccount,
                            this.stateNames.createAccountDetails,
                            this.stateNames.addEZTag,
                            this.stateNames.vehicleInformation,
                            this.stateNames.addAdditionalVehicle,
                            this.stateNames.paymentMaster,
                            this.stateNames.choosePaymentMethod,
                            this.stateNames.enterBankAccount,
                            this.stateNames.creditCardEntry,
                            this.stateNames.createAccountSummary,
                            this.stateNames.checkout,
                            this.stateNames.createAccountReceipt,
                        ];
                    }
                };
                StorefrontService.prototype.clearNamedCaches = function () {
                    var _this = this;
                    return this.$window.caches
                        .keys()
                        .then(function (names) { return Promise.all(names.map(function (name) { return _this.$window.caches.delete(name); })); });
                };
                StorefrontService.prototype.registerEventHandlers = function (eventHandlers) {
                    this.eventHandlers = eventHandlers;
                };
                StorefrontService.prototype.getStorefrontLogo = function () {
                    return this.storefrontLogo;
                };
                StorefrontService.prototype.getBackArrowImg = function () {
                    return this.backArrowImg;
                };
                StorefrontService.prototype.getCloseModalImg = function () {
                    return this.closeModalImg;
                };
                StorefrontService.prototype.getMaintenanceImg = function () {
                    return this.maintenanceImg;
                };
                StorefrontService.prototype.getTaskCompleteIcon = function () {
                    return this.taskCompleteIcon;
                };
                StorefrontService.prototype.getTaskNotCompleteIcon = function () {
                    return this.taskNotCompleteIcon;
                };
                StorefrontService.prototype.getLocation = function () {
                    return this.storefrontUtilityService.storefrontLocation;
                };
                Object.defineProperty(StorefrontService.prototype, "fullSiteMode", {
                    get: function () {
                        return this.isFullSiteMode;
                    },
                    set: function (val) {
                        this.isFullSiteMode = val;
                        this.saveToStorage();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StorefrontService.prototype, "isShellAccountInitialized", {
                    get: function () {
                        return this.shellUserInitialized;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StorefrontService.prototype, "machineName", {
                    get: function () {
                        return this.storefrontUtilityService.machineName;
                    },
                    enumerable: true,
                    configurable: true
                });
                StorefrontService.prototype.isAuthenticated = function () { return this.authService.isAuthenticated(); };
                StorefrontService.prototype.isInMaintenanceMode = function () {
                    var _this = this;
                    return this.genericRepo.dataFactory
                        .getMaintenanceDetails()
                        .then(function (response) {
                        var flags = response.featureStates.reduce(function (acc, v) {
                            acc[v.feature] = v.inMaintenance;
                            return acc;
                        }, {});
                        var kioskShouldBeInMaintenanceMode = flags[HCTRA.Model.MaintenanceFeature.Account] ||
                            flags[HCTRA.Model.MaintenanceFeature.Violations];
                        return kioskShouldBeInMaintenanceMode ? _this.$q.resolve() : _this.$q.reject();
                    });
                };
                StorefrontService.prototype.isActiveSession = function () {
                    // session is active if session id is truthy
                    return !!this.sessionId;
                };
                StorefrontService.prototype.currentWorkItem = function (useShadowIndex) {
                    if (useShadowIndex === void 0) { useShadowIndex = false; }
                    if (this.workFlowIndex === null) {
                        return null;
                    }
                    return this.internalWorkItems[useShadowIndex && this.shadowItemIndex ? this.shadowItemIndex : this.workFlowIndex];
                };
                StorefrontService.prototype.getCmsMediaItem = function (itemId) {
                    return this.genericRepo.dataFactory.getCmsPageById({
                        ItemId: itemId,
                        Fields: ""
                    })
                        .then(function (res) {
                        var obj = angular.fromJson(res.cmsResponse);
                        if (!obj.Url) {
                            obj.Url = obj.ItemMedialUrl;
                        }
                        return obj;
                    });
                };
                StorefrontService.prototype.getCmsItemById = function (itemId) {
                    var _this = this;
                    return this.genericRepo.dataFactory
                        .getCmsPageById({
                        ItemId: itemId,
                        Fields: ""
                    })
                        .then(function (res) {
                        var item = angular.fromJson(res.cmsResponse);
                        if (item.Image) {
                            item.ImageItem = _this.convertToMediaItem(item.Image);
                        }
                        item.maxCommentCharacters = (item.maxCommentCharacters) ? Number(item.maxCommentCharacters) : null;
                        item.badRatingIconSelected = (item.badRatingIconSelected) ? _this.convertToMediaItem(item.badRatingIconSelected) : null;
                        item.badRatingIconUnselected = (item.badRatingIconUnselected) ? _this.convertToMediaItem(item.badRatingIconUnselected) : null;
                        item.neutralRatingIconSelected = (item.neutralRatingIconSelected) ? _this.convertToMediaItem(item.neutralRatingIconSelected) : null;
                        item.neutralRatingIconUnselected = (item.neutralRatingIconUnselected) ? _this.convertToMediaItem(item.neutralRatingIconUnselected) : null;
                        item.goodRatingIconSelected = (item.goodRatingIconSelected) ? _this.convertToMediaItem(item.goodRatingIconSelected) : null;
                        item.goodRatingIconUnselected = (item.goodRatingIconUnselected) ? _this.convertToMediaItem(item.goodRatingIconUnselected) : null;
                        item.buttons = (item.buttons) ? _this.stringUtilsService.getParameterObject(item.buttons) : null;
                        return item;
                    });
                };
                StorefrontService.prototype.convertToMediaItem = function (imageString) {
                    return this.cmsUtilService.parseAllImageAttributes(imageString);
                };
                StorefrontService.prototype.isEnabled = function () {
                    return this.storefrontUtilityService.isRunningAsKiosk;
                };
                StorefrontService.prototype.getWorkItemInitState = function (workItem) {
                    if (workItem.isShadowItem && (!workItem.states || workItem.states.length < 1)) {
                        return null;
                    }
                    return workItem.states[0];
                };
                StorefrontService.prototype.isInitStateOfSelectedWorkItem = function (stateName) {
                    return this.internalWorkItems
                        .filter(function (item) { return item.isSelected && !item.isCompleted; })
                        .map(this.getWorkItemInitState)
                        .filter(function (state) { return state; })
                        .indexOf(stateName) >= 0;
                };
                StorefrontService.prototype.isInternalStorefrontState = function (stateName) {
                    return stateName === this.stateNames.storefrontHome ||
                        stateName === this.stateNames.storefrontSelection ||
                        stateName === this.stateNames.storefrontSurvey ||
                        stateName === this.stateNames.storefrontSuppression;
                };
                StorefrontService.prototype.checkState = function (toState) {
                    var _this = this;
                    var toStateName = toState.name;
                    if (this.stateChangingRestricted && (!this.isInternalStorefrontState(toStateName) || this.stateChangingRestricted.all)) {
                        return this.$q.reject({
                            hasWorkItemRedirect: false,
                            restrictedAbort: true,
                            restrictedStateName: toStateName,
                            workItemRedirect: null
                        });
                    }
                    if (this.fullSiteMode || !this.isWorkflowActive() || this.isInternalStorefrontState(toStateName) || this.isCmsContent(toState)) {
                        return this.$q.resolve({
                            isExternal: false
                        });
                    }
                    var current = this.currentWorkItem();
                    var toWorkItem = this.isWorkitemState(current, toStateName);
                    var currentUser = this.$rootScope.currentUser;
                    var isSuspendedAccount = this.authService.isAuthenticated() && currentUser.acctActivity === "S";
                    var isMissingInformation = this.authService.isAuthenticated() && (this.addMissingInformationService.isMissingInfo(currentUser.passwordNeedsReset, currentUser.emailIsMissing, currentUser.securityQuestionIsMissing));
                    var isNotFinishedWithSetup = this.authService.isAuthenticated() &&
                        currentUser.newAccountStep &&
                        !currentUser.newAccountStep.accountComplete &&
                        current.id !== HCTRA.Model.SelectedOptions.OACC;
                    var requiresAuthentication = current.isShadowItem
                        ? this.currentWorkItem(true).requiresAuthentication && !this.authService.isAuthenticated()
                        : current.requiresAuthentication && !this.authService.isAuthenticated();
                    var callback = function (isSuspendedWithViolations) {
                        var redirections = [
                            { condition: requiresAuthentication, id: HCTRA.Model.SelectedOptions.LOGIN },
                            { condition: isSuspendedWithViolations, id: HCTRA.Model.SelectedOptions.SUSVIOL },
                            { condition: isMissingInformation, id: HCTRA.Model.SelectedOptions.MISSINFO },
                            { condition: isSuspendedAccount, id: HCTRA.Model.SelectedOptions.SUSACCT },
                            { condition: isNotFinishedWithSetup, id: HCTRA.Model.SelectedOptions.FINISHSETUP }
                        ];
                        for (var _i = 0, redirections_1 = redirections; _i < redirections_1.length; _i++) {
                            var check = redirections_1[_i];
                            if (check.condition) {
                                if (current.id === check.id) {
                                    break;
                                }
                                return _this.$q.reject({
                                    hasWorkItemRedirect: true,
                                    restrictedAbort: false,
                                    workItemRedirect: check.id
                                });
                            }
                        }
                        return _this.$q.resolve({
                            isExternal: !toWorkItem
                        });
                    };
                    if (this.authService.isAuthenticated()) {
                        return this.suspendedAccountService
                            .getSuspendedAccountTypeInformation()
                            .then(function (response) { return callback(response.violationFlag); });
                    }
                    else {
                        return callback(false);
                    }
                };
                StorefrontService.prototype.isWorkflowActive = function () {
                    if (!this.isEnabled() || this.workFlowIndex === null) {
                        return false;
                    }
                    return this.hasIncompleteWorkItems();
                };
                StorefrontService.prototype.startWorkItems = function () {
                    var _this = this;
                    if (!this.isEnabled()) {
                        return this.$q.reject(null);
                    }
                    //get next workitem..
                    return this.next()
                        .then(function (workItem) {
                        //if null, there are no more left, done
                        if (workItem === null) {
                            return null;
                        }
                        return _this.startNewSession()
                            .then(function () { return _this.getWorkItemInitState(workItem); });
                    });
                };
                StorefrontService.prototype.startNewSession = function (endExistingSession) {
                    var _this = this;
                    if (endExistingSession === void 0) { endExistingSession = false; }
                    //otherwise start a db session
                    var selectedOptions = this.getSelectedWorkitems().map(function (x) { return HCTRA.Model.SelectedOptions[x.id]; });
                    if (this.fullSiteMode) {
                        selectedOptions = [HCTRA.Model.SelectedOptions[HCTRA.Model.SelectedOptions.WEBST]];
                    }
                    if (endExistingSession) {
                        var endSessionRequest = {
                            logOffType: HCTRA.Model.StorefrontLogOffType.Forced.toString(),
                            storefrontSessionID: this.sessionId
                        };
                        this.genericRepo.dataFactory.EndStorefrontDBSession(endSessionRequest);
                    }
                    var startSessionRequest = {
                        location: HCTRA.Model.StoreLocations[this.storefrontUtilityService.storefrontLocation].toString(),
                        selectedOptions: (selectedOptions.length > 0 ? selectedOptions : [HCTRA.Model.SelectedOptions[HCTRA.Model.SelectedOptions.Unknown]]).join(',')
                    };
                    return this.genericRepo.dataFactory.StartStorefrontDBSession(startSessionRequest)
                        .then(function (response) {
                        _this.sessionId = response.dbResponse;
                        _this.saveToStorage();
                    });
                };
                StorefrontService.prototype.insertWorkItem = function (workItemId) {
                    // check if not already a workitem
                    var workItem = this.internalWorkItems.filter(function (w) { return w.id === workItemId && !w.isSelected && !w.isUnavailable; })[0];
                    if (workItem) {
                        workItem.isSelected = true;
                    }
                    return workItem;
                };
                StorefrontService.prototype.isQueued = function (workItemId) {
                    return this.internalWorkItems.some(function (w) { return w.id === workItemId && w.isSelected; });
                };
                StorefrontService.prototype.getWorkItemById = function (workItemId) {
                    return this.internalWorkItems.filter(function (x) { return x.id === workItemId; })[0];
                };
                StorefrontService.prototype.removeWorkItem = function (workItemId) {
                    var workItem = this.internalWorkItems.filter(function (w) { return w.id === workItemId && w.isSelected; })[0];
                    if (workItem) {
                        workItem.isSelected = false;
                    }
                    return workItem;
                };
                Object.defineProperty(StorefrontService.prototype, "stateChangingRestricted", {
                    //flag indicating that any state changes should be denied
                    get: function () {
                        return this.storefrontUtilityService.stateChangingRestricted;
                    },
                    enumerable: true,
                    configurable: true
                });
                StorefrontService.prototype.lockStateChanging = function (action) {
                    return this.storefrontUtilityService.lockStateChanging(action);
                };
                StorefrontService.prototype.reset = function (logOffType) {
                    var _this = this;
                    if (logOffType === void 0) { logOffType = HCTRA.Model.StorefrontLogOffType.Manual; }
                    var endSessionRequest = {
                        logOffType: HCTRA.Model.StorefrontLogOffType[logOffType].toString(),
                        storefrontSessionID: this.sessionId
                    };
                    //reset internals 
                    this.fullSiteMode = false;
                    this.sessionId = null;
                    this.workFlowIndex = null;
                    this.shadowItemIndex = null;
                    for (var _i = 0, _a = this.internalWorkItems; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.isSelected = false;
                        item.isUnavailable = false;
                        item.isCompleted = false;
                        item.isUnsaved = false;
                    }
                    this.saveToStorage();
                    this.addMissingInformationService.destroyMissingInformationFlags();
                    return this.lockStateChanging(function () {
                        return _this.eventHandlers.onResetting()
                            .then(function () { return _this.clearUserSession(endSessionRequest); })
                            .then(function () { return _this.eventHandlers.onResetComplete(logOffType === HCTRA.Model.StorefrontLogOffType.Forced); });
                    });
                };
                StorefrontService.prototype.clearUserSession = function (endSessionRequest) {
                    var _this = this;
                    return this.$q
                        .when(endSessionRequest.storefrontSessionID > 0 &&
                        this.genericRepo.dataFactory.EndStorefrontDBSession(endSessionRequest))
                        .catch(function () { })
                        .then(function () { return _this.authService.isAuthenticated() && _this.authService.logout(); })
                        .catch(function () { })
                        .then(function () { return _this.clearSession(); });
                };
                StorefrontService.prototype.hardReset = function () {
                    return this.reset(HCTRA.Model.StorefrontLogOffType.Forced);
                };
                StorefrontService.prototype.softReset = function () {
                    for (var _i = 0, _a = this.internalWorkItems; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.isSelected = false;
                        item.isUnavailable = false;
                        item.isCompleted = false;
                        item.isUnsaved = false;
                    }
                    this.workFlowIndex = null;
                    this.saveToStorage();
                    if (this.authService.isAuthenticated()) {
                        //force update to user profile
                        return this.authService.profile({});
                    }
                    return this.$q.resolve();
                };
                Object.defineProperty(StorefrontService.prototype, "onInitialized", {
                    get: function () {
                        return this.serviceInitialized;
                    },
                    enumerable: true,
                    configurable: true
                });
                StorefrontService.prototype.skip = function (workItemId, markCompleted, markUnsaved) {
                    var _this = this;
                    if (markCompleted === void 0) { markCompleted = false; }
                    if (markUnsaved === void 0) { markUnsaved = true; }
                    var currentItem = this.currentWorkItem();
                    //if skipping to a specific workitem...
                    if (angular.isNumber(workItemId)) {
                        //you can't skip to the current work item
                        if (currentItem && workItemId === currentItem.id) {
                            return this.$q.reject(currentItem);
                        }
                        //determine if you can go there
                        var destinationWorkItem = this.getWorkitemById(workItemId);
                        if (!destinationWorkItem || destinationWorkItem.isCompleted || !destinationWorkItem.isSelected) {
                            return this.$q.reject(currentItem);
                        }
                        //is it even real
                        var index = this.internalWorkItems.indexOf(destinationWorkItem);
                        if (index < 0) {
                            return this.$q.reject(currentItem);
                        }
                        //only can skipp if skippable or destination item is a shadow item
                        if (currentItem && !currentItem.isSkippable && !destinationWorkItem.isShadowItem) {
                            return this.$q.reject(currentItem);
                        }
                        //set to current and return init state
                        if (currentItem) {
                            currentItem.isUnsaved = markUnsaved;
                            currentItem.isCompleted = markCompleted;
                            if (!currentItem.isShadowItem && destinationWorkItem.isShadowItem) {
                                this.shadowItemIndex = this.workFlowIndex;
                            }
                            else if (currentItem.isShadowItem && !destinationWorkItem.isShadowItem) {
                                this.shadowItemIndex = null;
                            }
                        }
                        this.workFlowIndex = index;
                        this.saveToStorage();
                        var initState = this.getWorkItemInitState(destinationWorkItem);
                        if (initState) {
                            return this.$q.resolve(initState);
                        }
                        else {
                            return this.next(true).then(function (nextItem) { return _this.getWorkItemInitState(nextItem); });
                        }
                    }
                    else {
                        //only skippable workitems can skip
                        if (currentItem && !currentItem.isSkippable) {
                            return this.$q.reject(currentItem);
                        }
                        //..otherwise go to the next work item and return the initial state
                        return this.next(markCompleted, markUnsaved).then(function (nextItem) { return nextItem && _this.getWorkItemInitState(nextItem); });
                    }
                };
                StorefrontService.prototype.completeWorkItem = function () {
                    var _this = this;
                    var currentItem = this.currentWorkItem();
                    //resolve with null if no more workitem are left
                    if (!currentItem) {
                        return this.$q.resolve(null);
                    }
                    //otherwise go to the next one and return it's init state
                    return this.next(true).then(function (nextItem) { return nextItem && _this.getWorkItemInitState(nextItem); });
                };
                StorefrontService.prototype.saveSurveyResponse = function (experience, comments) {
                    var request = new HCTRA.Model.StorefrontSurveyRequest();
                    request.storefrontSessionID = this.sessionId;
                    request.experienceValue = experience;
                    request.comments = comments;
                    return this.genericRepo.dataFactory.SaveSurveyToStorefrontDB(request);
                };
                StorefrontService.prototype.prefetchContent = function (urls) {
                    var _this = this;
                    //perform a get on all urls and resolve when all are complete.
                    return this.$q.all(urls.map(function (url) { return _this.$http.get(url); }));
                };
                //determines based on state if the menu is visible
                StorefrontService.prototype.showMenu = function (state) {
                    //only show the menu when not home, survey or selection screen
                    switch (state.name) {
                        case this.stateNames.storefrontHome:
                        case this.stateNames.storefrontSelection:
                        case this.stateNames.storefrontSurvey:
                            return false;
                        default:
                            return true;
                    }
                };
                //determine if there are incompleted workitems remaining
                StorefrontService.prototype.hasIncompleteWorkItems = function () {
                    var remaining = this.internalWorkItems.filter(function (item) { return item.isSelected && !item.isCompleted; });
                    return remaining.length > 0;
                };
                StorefrontService.prototype.isCmsContent = function (state) {
                    var toController = state.controller;
                    return toController === "GenericNonSectionalCmsController" ||
                        toController === "GenericSectionalCmsController";
                };
                //determine if a given state is valid state for the given work item
                StorefrontService.prototype.isWorkitemState = function (item, state) {
                    for (var _i = 0, _a = item.states; _i < _a.length; _i++) {
                        var s = _a[_i];
                        if (s === state) {
                            return true;
                        }
                    }
                    return false;
                };
                StorefrontService.prototype.getSuspendedStates = function () {
                    return this.suspendedAccountWithoutViolationStateNames;
                };
                //find workitem by it's id
                StorefrontService.prototype.getWorkitemById = function (id) {
                    var query = this.internalWorkItems.filter(function (item) { return item.id === id; });
                    return query.length > 0 ? query[0] : null;
                };
                //gets all selected workitems
                StorefrontService.prototype.getSelectedWorkitems = function () {
                    return this.internalWorkItems.filter(function (x) { return x.isSelected && !x.isShadowItem; });
                };
                StorefrontService.prototype.clearSession = function () {
                    this.webStorage.removeEntry("StorefrontService");
                };
                //save service data to web storage
                StorefrontService.prototype.saveToStorage = function () {
                    var workItem = this.currentWorkItem(true);
                    var data = {
                        sessionId: this.sessionId,
                        currentItemName: workItem ? workItem.storefrontDisplayName : null,
                        currentItemId: workItem ? workItem.id : null,
                        selectedItemIds: this.getSelectedWorkitems().map(function (item) { return item.id; }),
                        fullSiteMode: this.isFullSiteMode,
                        completedItemIds: this.getSelectedWorkitems().filter(function (item) { return item.isCompleted; }).map(function (item) { return item.id; }),
                        shellUserInitialized: this.shellUserInitialized,
                        kioskToken: this.kioskToken
                    };
                    this.webStorage.setKeyValue("StorefrontService", data);
                };
                //restore service data from web storage
                StorefrontService.prototype.restoreFromStorage = function () {
                    var data = this.webStorage.getValue("StorefrontService");
                    if (data) {
                        this.sessionId = data.sessionId;
                        this.internalWorkItems
                            .filter(function (item) { return data.selectedItemIds.reduce(function (found, id) { return found || (item.id === id); }, false); })
                            .forEach(function (item) { return item.isSelected = true; });
                        this.internalWorkItems
                            .filter(function (item) { return data.completedItemIds.reduce(function (found, id) { return found || (item.id === id); }, false); })
                            .forEach(function (item) { return item.isCompleted = true; });
                        this.workFlowIndex =
                            angular.isNumber(data.currentItemId) && data.currentItemId >= 0
                                ? this.internalWorkItems.map(function (item) { return item.id; }).indexOf(data.currentItemId)
                                : null;
                        this.shadowItemIndex = null;
                        this.kioskToken = data.kioskToken;
                        this.isFullSiteMode = data.fullSiteMode;
                        this.shellUserInitialized = data.shellUserInitialized;
                    }
                };
                StorefrontService.prototype.abortWorkflow = function () {
                    var currentItem = this.currentWorkItem();
                    if (currentItem) {
                        this.internalWorkItems.filter(function (item) { return item.isSelected && item.id !== currentItem.id; }).forEach(function (item) { return item.isCompleted = true; });
                    }
                };
                //increments the workflow to the next required work item.
                //markAsCompleted lets the service know if the task it's leaving was completed or not
                StorefrontService.prototype.next = function (markAsCompleted, markUnsaved) {
                    var _this = this;
                    if (markAsCompleted === void 0) { markAsCompleted = true; }
                    if (markUnsaved === void 0) { markUnsaved = false; }
                    var previousItem;
                    if (!this.isWorkflowActive()) {
                        this.workFlowIndex = 0;
                        previousItem = null;
                    }
                    else {
                        previousItem = this.currentWorkItem();
                        previousItem.isCompleted = markAsCompleted;
                        previousItem.isUnsaved = markUnsaved;
                        this.workFlowIndex++;
                    }
                    //mark it complete or unsaved
                    var item = null;
                    //find the next selected workitem available
                    while (this.workFlowIndex < this.internalWorkItems.length) {
                        item = this.internalWorkItems[this.workFlowIndex];
                        if (item && item.isSelected && !item.isCompleted) {
                            break;
                        }
                        else {
                            this.workFlowIndex++;
                            item = null;
                        }
                    }
                    this.saveToStorage();
                    //if at the end of the flow but there's incomplete tasks..
                    if (!item && this.hasIncompleteWorkItems()) {
                        //oops! there should always be a registered handler
                        if (!this.eventHandlers || !this.eventHandlers.onIncompleteWorkItem) {
                            return this.$q.reject("incomplete workitem event not handled.");
                        }
                        //go to the top of the list, the first one incompleted
                        for (var _i = 0, _a = this.internalWorkItems; _i < _a.length; _i++) {
                            var workItem = _a[_i];
                            //only consider selected items that are not complete that actually have states to go through
                            if (workItem && workItem.isSelected && !workItem.isCompleted && workItem.states && workItem.states.length > 0) {
                                item = workItem;
                                break;
                            }
                        }
                        //let listener handle event
                        return this.eventHandlers.onIncompleteWorkItem(item);
                    }
                    else {
                        //you are done, signal it
                        if (!previousItem && !item) {
                            return this.$q.resolve(null);
                        }
                        if (previousItem && item) {
                            if (!previousItem.isShadowItem && item.isShadowItem) {
                                this.shadowItemIndex = this.workFlowIndex;
                            }
                            else if (previousItem.isShadowItem && !item.isShadowItem) {
                                this.shadowItemIndex = null;
                            }
                        }
                        return this.eventHandlers
                            //invoke with complete item and next one inline
                            .onCompletedWorkItem(previousItem, item || null)
                            .then(function () {
                            if (item && item.isAbortItem) {
                                _this.abortWorkflow();
                            }
                            if (item && (!item.states || item.states.length < 1 || item.isSelected === false)) {
                                //no states to go to, then mark it complete and go to next
                                return _this.next(true);
                            }
                            else {
                                return item || null;
                            }
                        });
                    }
                };
                StorefrontService.prototype.getFirstAvailableId = function () {
                    for (var _i = 0, _a = this.internalWorkItems; _i < _a.length; _i++) {
                        var workItem = _a[_i];
                        if (workItem && workItem.isSelected && !workItem.isCompleted && !workItem.isShadowItem) {
                            return workItem.id;
                        }
                    }
                    return null;
                };
                StorefrontService.prototype.setCurrentWorkItem = function (workItem) {
                    if (this.isEnabled() && this.isWorkflowActive() && workItem && workItem.isSelected && !workItem.isCompleted) {
                        var index = this.internalWorkItems.indexOf(workItem);
                        if (index >= 0) {
                            this.workFlowIndex = index;
                            this.saveToStorage();
                            return true;
                        }
                    }
                    return false;
                };
                StorefrontService.prototype.authenticateShellAccount = function () {
                    var _this = this;
                    //preflight check: is the machine a default config?
                    var machineName = this.storefrontUtilityService.machineName;
                    var defaultMachineName = this.storefrontUtilityService.defaultMachineName;
                    if (machineName === defaultMachineName) {
                        this.shellUserInitialized = true;
                        this.saveToStorage();
                        return this.$q.resolve();
                    }
                    else {
                        return this.genericRepo.dataFactory
                            .StorefrontInitialize()
                            .then(function (res) {
                            _this.kioskToken = res.token;
                            _this.shellUserInitialized = true;
                            _this.saveToStorage();
                        });
                    }
                };
                //get ids for workitems in cms
                StorefrontService.prototype.getCmsDbIds = function () {
                    return this.genericRepo.dataFactory
                        .getCmsPageById({
                        ItemId: this.routes.storefrontDBIdsId,
                        Fields: ""
                    })
                        .then(function (res) { return angular.fromJson(res.cmsResponse).Children; });
                };
                //get work item definitions in cms
                StorefrontService.prototype.getCmsWorkItems = function () {
                    return this.genericRepo.dataFactory
                        .getCmsPageById({
                        ItemId: this.routes.storefrontWorkItemSelectionParentId,
                        Fields: ""
                    })
                        .then(function (res) { return angular.fromJson(res.cmsResponse).Children; });
                };
                StorefrontService.prototype.getStorefrontLogoItem = function () {
                    var _this = this;
                    return this.getCmsMediaItem(this.routes.storefrontHCTRALogoId)
                        .then(function (response) {
                        _this.storefrontLogo = response;
                    });
                };
                StorefrontService.prototype.getStorefrontBackArrowImg = function () {
                    var _this = this;
                    return this.getCmsMediaItem(this.routes.storefrontBackArrowImgId)
                        .then(function (response) {
                        _this.backArrowImg = response;
                    });
                };
                StorefrontService.prototype.getStorefrontCloseModalButtonImg = function () {
                    var _this = this;
                    return this.getCmsMediaItem(this.routes.storefrontCloseModalImgId)
                        .then(function (response) {
                        _this.closeModalImg = response;
                    });
                };
                StorefrontService.prototype.getStorefrontMaintenanceImg = function () {
                    var _this = this;
                    return this.getCmsMediaItem(this.routes.storefrontMaintenanceImgId)
                        .then(function (response) {
                        _this.maintenanceImg = {
                            alt: response.Alt || response.alt,
                            image: response.image || response.Url || response.ItemMediaUrl
                        };
                    });
                };
                StorefrontService.prototype.getStorefrontTaskNotCompleteIcon = function () {
                    var _this = this;
                    return this.getCmsMediaItem(this.routes.storefrontTaskNotCompleteIconId)
                        .then(function (response) {
                        _this.taskNotCompleteIcon = response;
                    });
                };
                StorefrontService.prototype.getStorefrontTaskCompleteIcon = function () {
                    var _this = this;
                    return this.getCmsMediaItem(this.routes.storefrontTaskCompleteIconId)
                        .then(function (response) {
                        _this.taskCompleteIcon = response;
                    });
                };
                //builds the work item definitions
                StorefrontService.prototype.getCmsItemsAndBuildWorkItems = function () {
                    var _this = this;
                    var promises = [
                        this.getCmsDbIds(), this.getCmsWorkItems(),
                        this.getStorefrontLogoItem(), this.getStorefrontBackArrowImg(),
                        this.getStorefrontCloseModalButtonImg(), this.getStorefrontMaintenanceImg(),
                        this.getStorefrontTaskNotCompleteIcon(), this.getStorefrontTaskCompleteIcon()
                    ];
                    return this.$q.all(promises).then(function (results) {
                        var dbIds = results[0] || [];
                        var cmsWorkItems = results[1] || [];
                        //construct workitem definitions
                        cmsWorkItems.forEach(function (item) {
                            item.id = HCTRA.Model.SelectedOptions[item.dbId];
                            var definedStates = _this.workItemStateNames[item.id];
                            //setting acceptable states with some corner cases
                            switch (HCTRA.Model.SelectedOptions[item.dbId]) {
                                case HCTRA.Model.SelectedOptions.UBI:
                                    item.states = definedStates.filter(function (state) {
                                        var manageBillingInformationState = state.startsWith(_this.profileStates.UpdateBillingInformation);
                                        return _this.environmentConfig.billingInformation.UseUpdatedPage
                                            ? manageBillingInformationState
                                            : !manageBillingInformationState;
                                    });
                                    break;
                                case HCTRA.Model.SelectedOptions.MTOLL:
                                case HCTRA.Model.SelectedOptions.GINV:
                                    item.states = _this.environmentConfig.isMergeMATandVioOn ? _this.workItemStateNames[HCTRA.Model.SelectedOptions.EO] : definedStates;
                                    break;
                                default:
                                    item.states = definedStates;
                                    break;
                            }
                            item.unavailableWhenSelected =
                                _this.getListFromCmsMultilist(item.cmsUnavailableWhenSelected, HCTRA.Model.SelectedOptions, dbIds);
                            item.uiOrder = item.uiOrder;
                            item.isSkippable = item.isSkippable.toString() === "1";
                            item.requiresAuthentication = item.requiresAuthentication.toString() === "1";
                            item.unselectedIcon = _this.cmsUtilService.parseAllImageAttributes(item.cmsUnselectedIcon);
                            item.selectedIcon = _this.cmsUtilService.parseAllImageAttributes(item.cmsSelectedIcon);
                            item.completionModal = item.completionModal ? HCTRA.Model.StorefrontModalTemplatesEnum[item.completionModal] : null;
                            item.isShadowItem = false;
                        });
                        _this.addShadowItems(cmsWorkItems);
                        _this.internalWorkItems = cmsWorkItems.sort(function (w1, w2) { return w1.uiOrder - w2.uiOrder; });
                        _this.restoreFromStorage();
                    });
                };
                StorefrontService.prototype.addShadowItems = function (existingItems) {
                    existingItems.push(this.createShadowWorkItem("Suspended Account", HCTRA.Model.SelectedOptions.SUSACCT, this.getSuspendedStates(), true, HCTRA.Model.StorefrontModalTemplatesEnum.None, false));
                    existingItems.push(this.createShadowWorkItem("Suspended Account with Violations", HCTRA.Model.SelectedOptions.SUSVIOL, [], true, HCTRA.Model.StorefrontModalTemplatesEnum.VehicalViolationSuspendedAccountMessage, true));
                    existingItems.push(this.createShadowWorkItem("Add Missing Information", HCTRA.Model.SelectedOptions.MISSINFO, [this.loginStates.AddMissingInformation], true, HCTRA.Model.StorefrontModalTemplatesEnum.None, false));
                    existingItems.push(this.createShadowWorkItem("Login", HCTRA.Model.SelectedOptions.LOGIN, [this.loginStates.Login], false, HCTRA.Model.StorefrontModalTemplatesEnum.None, false));
                    existingItems.push(this.createShadowWorkItem("Not Finished With Account Setup", HCTRA.Model.SelectedOptions.FINISHSETUP, [], true, HCTRA.Model.StorefrontModalTemplatesEnum.FinishSetup, false));
                };
                StorefrontService.prototype.createShadowWorkItem = function (name, id, states, requiresAuthentication, completionModel, abortWhenComplete) {
                    return {
                        id: id,
                        states: states,
                        unavailableWhenSelected: [],
                        uiOrder: 0,
                        isSkippable: false,
                        requiresAuthentication: requiresAuthentication,
                        isShadowItem: true,
                        isSelected: false,
                        isUnavailable: false,
                        cmsUnavailableWhenSelected: "",
                        isCompleted: false,
                        isUnsaved: false,
                        storefrontDisplayName: name,
                        cmsStates: "",
                        dbId: "",
                        completionModal: completionModel,
                        isAbortItem: abortWhenComplete
                    };
                };
                //extract values from string
                StorefrontService.prototype.getListFromCmsMultilist = function (multiListString, listToSearch, enumToUse) {
                    //build lookup dictionary from array
                    // ReSharper disable once InconsistentNaming
                    var dict = enumToUse.reduce(function (acc, r) {
                        acc[r.ItemID.toLocaleUpperCase()] = r.name;
                        return acc;
                    }, {});
                    //extract guids..
                    return ((multiListString || "").match(this.guidRegex) || [])
                        //translate from lookup table
                        .map(function (val) { return listToSearch[dict[val.toLocaleUpperCase()]]; })
                        //filter out undefined values
                        .filter(function (obj) { return angular.isDefined(obj); });
                };
                return StorefrontService;
            }());
            Service.StorefrontService = StorefrontService;
        })(Service = Storefront.Service || (Storefront.Service = {}));
    })(Storefront = HCTRA.Storefront || (HCTRA.Storefront = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .factory("StorefrontService", HCTRA.Storefront.Service.StorefrontService.factory());
})();
var HCTRA;
(function (HCTRA) {
    var Storefront;
    (function (Storefront) {
        var Service;
        (function (Service) {
            var ReadonlyStorefrontWebStorage = /** @class */ (function () {
                function ReadonlyStorefrontWebStorage(innerData) {
                    this.innerData = innerData;
                }
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "kioskToken", {
                    get: function () { return this.innerData.kioskToken; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "sessionId", {
                    get: function () { return this.innerData.sessionId; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "selectedItemIds", {
                    get: function () { return this.innerData.selectedItemIds.slice(0); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "currentItemName", {
                    get: function () { return this.innerData.currentItemName; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "currentItemId", {
                    get: function () { return this.innerData.currentItemId; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "fullSiteMode", {
                    get: function () { return this.innerData.fullSiteMode; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "completedItemIds", {
                    get: function () { return this.innerData.completedItemIds.slice(0); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ReadonlyStorefrontWebStorage.prototype, "shellUserInitialized", {
                    get: function () { return this.innerData.shellUserInitialized; },
                    enumerable: true,
                    configurable: true
                });
                return ReadonlyStorefrontWebStorage;
            }());
            var StorefrontUtilityService = /** @class */ (function () {
                function StorefrontUtilityService(userAgent, $window, webStorage, storefrontUtilityInitializer, environmentConfig) {
                    this.userAgent = userAgent;
                    this.$window = $window;
                    this.webStorage = webStorage;
                    this.storefrontUtilityInitializer = storefrontUtilityInitializer;
                    this.environmentConfig = environmentConfig;
                    //regex to extract physical store location from user agent string
                    this.storeLocationRegex = /\(.*HCTRA\.Storefront\s([^;\)\s]+)(?:\s([^;\)\s]+))?.*\)/ig;
                    //flag indicating that any state changes should be denied
                    this.stateChangingRestricted = null;
                    storefrontUtilityInitializer(this, userAgent);
                }
                StorefrontUtilityService.factory = function () {
                    var service = function ($window, webStorage, init, environmentConfig) {
                        return new StorefrontUtilityService($window.navigator.userAgent, $window, webStorage, init, environmentConfig);
                    };
                    service.$inject = ["$window", "webStorage", "StorefrontUtilityInitializer", "environmentConfig"];
                    return service;
                };
                StorefrontUtilityService.configure = function (base, userAgent) {
                    if (base.webStorage.getValue("StorefrontUtilityService.TEST")) {
                        //angular.extend(base, base.webStorage.getValue("StorefrontUtilityService.TEST") || {});
                        console.error('StorefrontUtilityService.TEST is no longer supported.');
                    }
                    base.machineNameOverride = null;
                    var storeLocationMatch = base.storeLocationRegex.exec(userAgent);
                    if (storeLocationMatch && storeLocationMatch[1]) {
                        base.isRunningInKioskMode = true;
                        base.storeLocation = HCTRA.Model.StoreLocations[storeLocationMatch[1]];
                        base.machineNameOverride = storeLocationMatch[2] || null;
                    }
                };
                Object.defineProperty(StorefrontUtilityService.prototype, "isRunningAsKiosk", {
                    get: function () { return this.isRunningInKioskMode; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StorefrontUtilityService.prototype, "storefrontLocation", {
                    get: function () { return this.storeLocation; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StorefrontUtilityService.prototype, "accountLoggedInWorkItemIds", {
                    get: function () {
                        return [HCTRA.Model.SelectedOptions.UBI, HCTRA.Model.SelectedOptions.UCI, HCTRA.Model.SelectedOptions.UAC, HCTRA.Model.SelectedOptions.URAMT, HCTRA.Model.SelectedOptions.ARTAG, HCTRA.Model.SelectedOptions.MKPAY];
                    },
                    enumerable: true,
                    configurable: true
                });
                StorefrontUtilityService.prototype.lockStateChanging = function (action, all) {
                    var _this = this;
                    if (all === void 0) { all = false; }
                    var currentRestrictionState = this.stateChangingRestricted;
                    var setAll = currentRestrictionState ? currentRestrictionState.all : false;
                    this.stateChangingRestricted = { all: setAll || all };
                    return action().finally(function () { return _this.stateChangingRestricted = currentRestrictionState; });
                };
                Object.defineProperty(StorefrontUtilityService.prototype, "machineName", {
                    get: function () {
                        if (this.machineNameOverride && this.machineNameOverride.toLowerCase() === "-kapi") {
                            if ("KioApp" in this.$window && "DoUrlSubstitution" in this.$window["KioApp"]) {
                                return this.$window["KioApp"]["DoUrlSubstitution"]("$$KIO_COMPUTERNAME$$", 0);
                            }
                            else if ("external" in this.$window && "getKioProperty" in this.$window["external"]) {
                                var getKioProperty = this.$window["external"]["getKioProperty"];
                                var kioskName = getKioProperty("Kiosk") || "";
                                var unitName = getKioProperty("Unit") || "";
                                //handles situation if kiosk name was configured in the unit name
                                return (unitName.toUpperCase() === "HCTRA" ? null : unitName)
                                    || (kioskName.toUpperCase() === "HCTRA" ? null : kioskName)
                                    || this.machineNameOverride;
                            }
                            else {
                                return this.environmentConfig.storefrontConfigs.DefaultMachineName;
                            }
                        }
                        return this.machineNameOverride || this.environmentConfig.storefrontConfigs.DefaultMachineName;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StorefrontUtilityService.prototype, "defaultMachineName", {
                    get: function () {
                        return this.environmentConfig.storefrontConfigs.DefaultMachineName;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StorefrontUtilityService.prototype, "webStoreData", {
                    get: function () {
                        var storage = this.webStorage.getValue("StorefrontService");
                        return storage ? new ReadonlyStorefrontWebStorage(storage) : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StorefrontUtilityService.prototype, "delay", {
                    get: function () {
                        var shortDelay = this.environmentConfig.storefrontConfigs.StorefrontShortDelay;
                        return {
                            short: shortDelay,
                            medium: shortDelay * 4,
                            long: shortDelay * 10
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                return StorefrontUtilityService;
            }());
            Service.StorefrontUtilityService = StorefrontUtilityService;
        })(Service = Storefront.Service || (Storefront.Service = {}));
    })(Storefront = HCTRA.Storefront || (HCTRA.Storefront = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .factory("StorefrontUtilityService", HCTRA.Storefront.Service.StorefrontUtilityService.factory())
        .factory("StorefrontUtilityInitializer", function () { return HCTRA.Storefront.Service.StorefrontUtilityService.configure; });
})();
(function () {
    "use strict";
    // angular.module("HCTRAModule").service("stringUtils", HCTRA.Service.StringUtils);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        var TemplateCacheHelper = /** @class */ (function () {
            function TemplateCacheHelper($templateCache, $state) {
                var _this = this;
                this.$templateCache = $templateCache;
                this.$state = $state;
                this.clearList = [];
                this.constructUncachedList = function () {
                    var fromSitecoreRegex = /sitecore\/.*/;
                    var allStates = _this.$state.get();
                    var sitecoreStates = allStates.filter(function (s) { return fromSitecoreRegex.test(s.templateUrl); });
                    _this.clearList = sitecoreStates.map(function (s) { return s.templateUrl; }); // list of urls that should not be cached
                };
                this.removeUncachedFromCache = function () {
                    for (var _i = 0, _a = _this.clearList; _i < _a.length; _i++) {
                        var url = _a[_i];
                        _this.$templateCache.remove(url);
                    }
                };
            }
            TemplateCacheHelper.$inject = ['$templateCache', '$state'];
            return TemplateCacheHelper;
        }());
        Service.TemplateCacheHelper = TemplateCacheHelper;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("templateCacheHelper", HCTRA.Service.TemplateCacheHelper);
}());
/*
module HCTRA.Service {

    export interface IToggleButtonsService {

        disableButtonsGlobal(): void;
        enableButtonsGlobal(): void;
        disableUntilResolved(inProm: ng.IPromise<any>): ng.IPromise<any>;
    }

    export class ToggleButtonsService implements IToggleButtonsService {

        static $inject = ["hctraSpinnerService", "$document"]

        constructor(private hctraSpinnerService: HCTRA.Service.IHctraSpinnerService, private $document) { }

        private static locked: boolean = false;

        //this is not exposed through the interface, it is for testing only
        public resetLock = (): void => {
            ToggleButtonsService.locked = false;
        }

        public disableButtonsGlobal = (): void => {

            if (!ToggleButtonsService.locked) {
                this.disableButtons();
            }
        };

        public enableButtonsGlobal = (): void => {

            if (!ToggleButtonsService.locked) {
                this.enableButtons();
            }
        };

        public disableUntilResolved = (inProm: ng.IPromise<any>): ng.IPromise<any> => {

            ToggleButtonsService.locked = true;
            this.disableButtons();
            return inProm.finally(() => {
                ToggleButtonsService.locked = false;
                this.enableButtons();
            });
        };

        public disableButtons = (): void => {

            this.hctraSpinnerService.startSpinner();
            angular.element("button:not(#nav-expander):not(.exclude-global-disable)").prop("disabled", true);
            angular.forEach(this.$document[0].getElementsByClassName("disable-on-api-call"), toDisable => angular.element(toDisable).addClass("disabled"));
        };

        public enableButtons = (): void => {

            this.hctraSpinnerService.stopSpinner();
            angular.element("button:not(.exclude-global-disable)").prop("disabled", false);
            angular.element("disable-on-api-call").prop("disabled", false);
            angular.forEach(this.$document[0].getElementsByClassName("disable-on-api-call"), toDisable => angular.element(toDisable).removeClass("disabled"));

        };
    }
}

(function () {

    "use strict";

    angular.module("HCTRAModule").service("toggleButtonsService", HCTRA.Service.ToggleButtonsService);
}());
 */ 
// declare var LitlePayPage: any;
// module HCTRA.Service {
//     import VantivTriPosConfiguration = Model.VantivTriPosConfiguration;
//     import VantivTriPosCreateOmniTokenResponse = Model.VantivTriPosCreateOmniTokenResponse;
//     export interface IVantivPayment {
//         /** */
//         vantivPay(creditCardNumber: string): angular.IPromise<any>;
//         getTokenizedCreditCardData(config: VantivTriPosConfiguration, invokeManualEntry: boolean): angular.IPromise<Model.VantivTriPosCreateOmniTokenResponse>;
//     }
//     export class VantivPaymentService implements IVantivPayment {
//     //CreditCardType is convereted to enum in Angular
//         static $inject = ["$q",
//             "errorDisplayService",
//             "genericRepo",
//             "responseErrorService",
//             "environmentConfig",
//             "siteVerbiage",
//             "$http", "creditCardTypes", "StorefrontUtilityService"];
//         private static idCounter = 0;
//         private timeoutData: HCTRA.Model.VantivResponseLog;
//         constructor(private $q: ng.IQService,
//             private errorDisplayService: HCTRA.Service.IErrorDisplayService,
//             private genericRepo: HCTRA.Service.IGenericRepo,
//             private responseErrorService: HCTRA.Service.IResponseErrorService,
//             private envConfig: any,
//             private siteVerbiage: any,
//             private $http: angular.IHttpService,
//             private creditCardTypes,
//             private storefrontUtilityService: HCTRA.Storefront.Service.IStorefrontUtilityService) { }
//         private logVantivData = (logObj: HCTRA.Model.VantivRequestLog | HCTRA.Model.VantivResponseLog, isError: boolean) => {
//             if ((this.envConfig.vantivConfig.ErrorToggle && isError) || this.envConfig.vantivConfig.InfoToggle) {
//                 const logRequest = angular.copy(logObj);
//                 if (this.isVantivRequestLog(logRequest)) {
//                     this.genericRepo.dataFactory.LogVantivRequest(logRequest);
//                 } else {
//                     logRequest.isError = isError;
//                     this.genericRepo.dataFactory.LogVantivResponse(logRequest);
//                 }
//             }
//         };
//         private isVantivRequestLog = (log: any): log is HCTRA.Model.VantivRequestLog => {
//             return angular.isDefined((log as HCTRA.Model.VantivRequestLog).requestId);
//         };
//         public vantivPay = (creditCardNumber: string) : angular.IPromise<any> => {
//             const paypageId = this.envConfig.vantivConfig.PayPageID;
//             const reportGroup = this.envConfig.vantivConfig.ReportGroup;
//             const now = new Date();
//             const orderIdNbr = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds(), now.getMilliseconds());
//             const mTxnID = "T" + orderIdNbr.toString();
//             const litleRequest = {
//                 "paypageId": paypageId,
//                 "reportGroup": reportGroup,
//                 "orderId": orderIdNbr,
//                 "id": mTxnID,
//                 "url": this.envConfig.vantivConfig.PayPageUrl // "https://request-prelive.np-securepaypage-litle.com"//vantivRequest.url
//             };
//             // Right before sending to Vantiv, inject the input element and populate the value with credit card number as in memory
//             const ccElementId = this.generateElementId();
//             angular.element("body").append('<input id="' + ccElementId + '" type="hidden" value="' + creditCardNumber + '" />');
//             const injectedCreditCardElement = angular.element("body>input#" + ccElementId)[0];
//             const formFields = {
//                 "accountNum": injectedCreditCardElement,
//                 "cvv2": "",
//                 "paypageRegistrationId": "",
//                 "bin": ""
//             };
//             const deferred = this.$q.defer();
//             this.logVantivData(this.vantivRequestObjectForLogging(litleRequest), false);
//             new LitlePayPage().sendToLitle(litleRequest, formFields, deferred.resolve,
//                 deferred.reject, this.timeoutOnLitle, this.envConfig.vantivConfig.TimeoutMilliSeconds);
//             // TODO: inject hidden input vantivCreditCard field in current html with no value
//             // Right before sending to Vantiv, inject the input element and populate the value with credit card number as in memory
//             return deferred.promise.then((response: HCTRA.Model.VantivResponse) => {
//                 this.logVantivData(this.vantivResponseObjectForLogging(response), false);
//                 // Only return the useful properties
//                 const vantivDto = new HCTRA.Model.VantivDto(response.lastFour, response.paypageRegistrationId);
//                 return vantivDto;
//             }).catch((err: any) => {
//                 const errorMessage = this.onErrorAfterLitle(err);
//                 this.errorDisplayService.displayToasts(errorMessage);
//                 return this.$q.reject(errorMessage);
//             }).finally(() => {
//                 injectedCreditCardElement.remove();
//             });
//         };
//         public getTokenizedCreditCardData = (config: VantivTriPosConfiguration, invokeManualEntry: boolean): angular.IPromise<Model.VantivTriPosCreateOmniTokenResponse> => {
//             if (config.errors && config.errors.length > 0) {
//                 return this.$q.reject(config);
//             }
//             const url = config.url.replace(/\/$/, "") + "/token/omni";
//             //create header object scoped to this method
//             const header = {
//                 "appname": () => null,
//                 "version": () => null,                
//                 "tp-application-id": config.applicationId,
//                 "tp-application-name": config.applicationName,
//                 "tp-application-version": config.applicationVersion,
//                 "tp-authorization": config.authorization,
//                 "tp-express-acceptor-id": config.acceptorId,
//                 "tp-express-account-id": config.accountId,
//                 "tp-express-account-token": config.accountToken,
//                 "tp-request-id": config.requestId,
//                 "tp-return-logs": true
//             };
//             const data = {
//                 laneId: config.laneId,
//                 vaultId: config.vaultId,
//                 invokeManualEntry: invokeManualEntry
//             };
//             //destroy credentials
//             delete config.applicationId;
//             delete config.applicationName;
//             delete config.applicationVersion;
//             delete config.authorization;
//             delete config.acceptorId;
//             delete config.accountId;
//             delete config.accountToken;
//             delete config.url;
//             delete config.laneId;
//             delete config.vaultId;
//             return this.$http
//                     .post(url, data, {
//                         headers: header,
//                         withCredentials: false
//                     })
//                     .catch(e => {
//                         //in the rare case where an exception comes up, we still want to capture it
//                         const log = {
//                             isError: true,
//                             message: 'A error occured when contacting Vantivs API',
//                             machineName: this.storefrontUtilityService.machineName,
//                             rawData: JSON.stringify(e)
//                         };
//                         this.genericRepo
//                             .dataFactory
//                             .TriPosLog(log);
//                         return this.$q.reject(e);
//                     })
//                     .then(response => {
//                         const log = this.buildRequestObjForLogging(response);
//                         let responseData = response.data as Model.VantivTriPosCreateOmniTokenResponse;
//                         if (!responseData) {
//                             const xhrStatusError = (response.xhrStatus || '').toLowerCase() === 'error';
//                             log.isError = true;
//                             log.message = xhrStatusError 
//                                 ? 'Vantiv responded with no data with error status. This may be a possible CORS error.'
//                                 : 'Vantiv responded with no data and no error status.';
//                             responseData = { errors:[], _errors: [], cardLogo: '' } as any;
//                         }
//                         const wasCancelled = log.isError && 
//                                 responseData['_errors'].some(e => (e.exceptionMessage || '').indexOf("cancelled response") > -1);
//                         responseData.cancelledByUser = wasCancelled;
//                         if (wasCancelled) {
//                             log.isError = false;
//                         }
//                         if (responseData.cardLogo && !this.creditCardTypes[responseData.cardLogo.toLowerCase()]) {
//                             log.message = `Kiosk does not support '${responseData.cardLogo}' cards`;
//                             log.isError = true;
//                         }
//                         console.log(log);
//                         this.genericRepo
//                             .dataFactory
//                             .TriPosLog(log);
//                         return log.isError ? this.$q.reject(responseData) : this.$q.resolve(responseData);
//                     });
//         };
//         public buildRequestObjForLogging = (responseObject) => {
//             const { config, data, status } = responseObject;
//             const cleanHeaders = { ...config.headers, 'tp-express-account-token': '****' };
//             const cleanConfig = { data: config.data, headers: cleanHeaders, method: config.method, url: config.url  };
//             const cleanData = data ? { ...data, binValue: '****', expirationMonth: '**', expirationYear: '**', tokenId: '****', _processor: null } : {};
//             const cleanResponse = { config: cleanConfig, data: cleanData, status };
//             const message = (responseObject.data && responseObject.data.exceptionMessage) || (cleanData._errors || [])
//                 .map(x => x.exceptionMessage)
//                 .join(' ## ');
//             return {
//                 message,
//                 isError: (responseObject.data && responseObject.data._hasErrors) || (((responseObject.data && responseObject.data.errors) || []).length > 0),
//                 machineName: this.storefrontUtilityService.machineName,
//                 rawData: JSON.stringify(cleanResponse)
//             };
//         }
//         public vantivRequestObjectForLogging = (litleRequest): HCTRA.Model.VantivRequestLog => {
//             const ret = {
//                 orderId: litleRequest.orderId,
//                 requestId: litleRequest.id,
//                 paypageId: litleRequest.paypageId,
//                 reportGroup: litleRequest.reportGroup,
//                 url: litleRequest.url
//             } as HCTRA.Model.VantivRequestLog;
//             this.timeoutData = {
//                 orderId: litleRequest.orderId,
//                 reportGroup: litleRequest.reportGroup,
//                 violationsData: null
//             } as HCTRA.Model.VantivResponseLog;
//             return ret;
//         };
//         public vantivResponseObjectForLogging = (response): HCTRA.Model.VantivResponseLog => {
//             const ret = {
//                 orderId: response.orderId,
//                 message: response.message,
//                 response: response.response,
//                 paypageRegistrationId: response.paypageRegistrationId,
//                 litleTxnId: response.litleTxnId,
//                 responseTime: response.responseTime,
//                 targetServer: response.targetServer,
//                 type: response.type,
//                 id: response.id,
//                 reportGroup: response.reportGroup,
//                 violationsData: null
//             } as HCTRA.Model.VantivResponseLog;
//             return ret;
//         };
//         private timeoutOnLitle = () => {
//             const timeoutResponse = angular.copy(this.timeoutData);
//             timeoutResponse.customLogMessage = "Vantiv timeout error";
//             this.logVantivData(timeoutResponse, true);
//             this.responseErrorService.displayToast(this.siteVerbiage.genericErrorMsg, "error", false);
//         };
//         private onErrorAfterLitle = (response: any): string => {
//             var outMessage;
//             if (response.response === '871') {
//                 outMessage = "Invalid card number. Check and retry. (Not Mod10)";
//             }
//             else if (response.response === '872') {
//                 outMessage = "Invalid card number. Check and retry. (Too short)";
//             }
//             else if (response.response === '873') {
//                 outMessage = "Invalid card number. Check and retry. (Too long)";
//             }
//             else if (response.response === '874') {
//                 outMessage = "Invalid card number. Check and retry. (Not a number)";
//             }
//             else if (response.response === '875') {
//                 outMessage = this.siteVerbiage.genericErrorMsg;
//             }
//             else if (response.response === '876') {
//                 outMessage = "Invalid card number. Check and retry. (Failure from Server)";
//             }
//             else if (response.response === '881') {
//                 outMessage = "Invalid card validation code. Check and retry. (Not a number)";
//             }
//             else if (response.response === '882') {
//                 outMessage = "Invalid card validation code. Check and retry. (Too short)";
//             }
//             else if (response.response === '883') {
//                 outMessage = "Invalid card validation code. Check and retry. (Too long)";
//             }
//             else if (response.response === '889') {
//                 outMessage = this.siteVerbiage.genericErrorMsg;
//             }
//             // Log the Vantiv error
//             this.logVantivData({
//                 orderId: response.orderId,
//                 message: response.message,
//                 response: response.response,
//                 responseTime: response.responseTime,
//                 id: response.id,
//                 reportGroup: response.reportGroup,
//                 customLogMessage: outMessage,
//                 violationsData: null
//             } as HCTRA.Model.VantivResponseLog, true);
//             return outMessage;
//         };
//         private generateElementId = () => {
//             return "vantivRequiredCardElement" + VantivPaymentService.idCounter++;
//         };
//     }
// }
(function () {
    'use strict';
    // angular.module('HCTRAModule').service('vantivPaymentService', HCTRA.Service.VantivPaymentService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var ViolationsInvoicesService = /** @class */ (function () {
            function ViolationsInvoicesService($filter) {
                var _this = this;
                this.$filter = $filter;
                this.setupInvoices = function (object, invoicedSummaryObj) {
                    for (var z = 0; z < object.violationHeaders.length; z++) {
                        var b = object.violationHeaders[z];
                        var invoiceObject = {
                            violations: null
                        };
                        if ((b.amountDue - b.pastPayments) > 0.001) {
                            var agencyCode = b.agency.substr(0, 1);
                            if (agencyCode === 'H') {
                                object.violationHeaders[z].agencyCode = 'h';
                            }
                            else if (agencyCode === 'F') {
                                object.violationHeaders[z].agencyCode = 'f';
                            }
                            else {
                                object.violationHeaders[z].agencyCode = 'm';
                            }
                            object.hasUnpaidInvoices = true;
                            //b.amountDue - b.pastPayments is the root cause. Making changes here is not recommended as this is used by SAL as well. Ignore undiscountedTotal for CFDP and use values returned by API instead of calculating manually.
                            object.undiscountedTotal += (b.amountDue - b.pastPayments);
                            angular.element.extend(invoiceObject, b);
                            invoiceObject.violations = [];
                            for (var y = 0; (b.violations) && (y < b.violations.length); y++) {
                                invoiceObject.violations.push({
                                    amount: b.violations[y].amount,
                                    location: b.violations[y].location,
                                    date: b.violations[y].date
                                });
                            }
                            if (b.agencyCode === "f") {
                                object.viol.fortCount++;
                                object.viol.invoices.fData['i' + b.invoiceNumber] = invoiceObject;
                                invoicedSummaryObj.fData.push(invoiceObject);
                            }
                            else if (b.agencyCode === "h") {
                                object.viol.harrisCount++;
                                object.viol.invoices.hData['i' + b.invoiceNumber] = invoiceObject;
                                invoicedSummaryObj.hData.push(invoiceObject);
                            }
                            else if (b.agencyCode === "m") {
                                object.viol.montCount++;
                                object.viol.invoices.mData['i' + b.invoiceNumber] = invoiceObject;
                                invoicedSummaryObj.mData.push(invoiceObject);
                            }
                        }
                    }
                };
                this.paymentDetails = function ($scope, payDetails) {
                    if (payDetails.payType === "CREDIT") {
                        if (payDetails.state) {
                            //domestic address
                            $scope.billingData.cards = [{
                                    nameOnCard: payDetails.name,
                                    cardCode: payDetails.cardType,
                                    cardNbr: _this.$filter("creditCard")(payDetails.cardNumber, payDetails.cardType),
                                    cardExpires: (payDetails.expMonth + "/" + payDetails.expYear),
                                    address1: payDetails.address1,
                                    city: payDetails.city,
                                    state: payDetails.state,
                                    zip: payDetails.zip,
                                    plus4: payDetails.plus4,
                                    country: "USA"
                                }];
                            if (payDetails.address2) {
                                $scope.billingData.cards[0].address2 = payDetails.address2;
                            }
                        }
                        else {
                            //international address
                            $scope.billingData.cards = [{
                                    nameOnCard: payDetails.name,
                                    cardCode: payDetails.cardType,
                                    cardNbr: _this.$filter("creditCard")(payDetails.cardNumber, payDetails.cardType),
                                    cardExpires: (payDetails.expMonth + "/" + payDetails.expYear),
                                    address1: payDetails.intaddress1,
                                    address2: payDetails.intaddress2,
                                    address3: payDetails.intaddress3,
                                    address4: payDetails.intaddress4,
                                    displayCountry: payDetails.country,
                                    country: payDetails.country
                                }];
                        }
                    }
                    else if (payDetails.payType === "EFT") {
                        $scope.billingData.eft = {
                            accountType: payDetails.accountType,
                            routingNumber: payDetails.routing,
                            accountNumber: _this.$filter("bankAccount")(payDetails.accountNumber)
                        };
                    }
                };
            }
            ViolationsInvoicesService.$inject = [
                "$filter"
            ];
            return ViolationsInvoicesService;
        }());
        Service.ViolationsInvoicesService = ViolationsInvoicesService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("violationsInvoicesService", HCTRA.Service.ViolationsInvoicesService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var ViolationsCalcService = /** @class */ (function () {
            function ViolationsCalcService() {
            }
            ViolationsCalcService.prototype.calculateAllInvoicesSummary = function (violData, totalInvoicesDue, totalInvoicesPastPayments) {
                var container = new HCTRA.Model.TotalsDisplayContainer();
                var totalPayNow = 0;
                var totalOriginalAmountDue = 0;
                var thisPaymentPastPayments = 0;
                for (var authorities in violData) {
                    if (violData.hasOwnProperty(authorities)) {
                        for (var x = 0; x < violData[authorities].length; x++) {
                            var violDataEntry = violData[authorities][x];
                            totalPayNow += violDataEntry.payNow;
                            totalOriginalAmountDue += violDataEntry.invoiceDue;
                            thisPaymentPastPayments += violDataEntry.pastPayments;
                            if (violDataEntry.invoicePreviousPayment) {
                                thisPaymentPastPayments += violDataEntry.invoicePreviousPayment;
                            }
                        }
                    }
                }
                container.originalAmountOwedForAll.invoices = totalInvoicesDue;
                container.originalAmountOwedForAll.selectedInvoices = totalOriginalAmountDue;
                container.originalAmountOwedForAll.unselectedInvoices = container.originalAmountOwedForAll.invoices - container.originalAmountOwedForAll.selectedInvoices;
                container.amountPreviouslyPaidForAll.invoices = totalInvoicesPastPayments;
                container.amountPreviouslyPaidForAll.selectedInvoices = thisPaymentPastPayments;
                container.amountPreviouslyPaidForAll.unselectedInvoices = container.amountPreviouslyPaidForAll.invoices - container.amountPreviouslyPaidForAll.selectedInvoices;
                container.amountOwed.beforePaymentForAll.invoices = container.originalAmountOwedForAll.invoices - container.amountPreviouslyPaidForAll.invoices;
                container.amountOwed.beforePaymentForAll.selectedInvoices = container.originalAmountOwedForAll.selectedInvoices - container.amountPreviouslyPaidForAll.selectedInvoices;
                container.amountOwed.beforePaymentForAll.unselectedInvoices = container.amountOwed.beforePaymentForAll.invoices - container.amountOwed.beforePaymentForAll.selectedInvoices;
                container.amountBeingPaidNow = totalPayNow;
                container.amountOwed.afterPaymentForAll.invoices = container.amountOwed.beforePaymentForAll.invoices - container.amountBeingPaidNow;
                container.amountOwed.afterPaymentForAll.selectedInvoices = container.amountOwed.beforePaymentForAll.selectedInvoices - container.amountBeingPaidNow;
                container.amountOwed.afterPaymentForAll.unselectedInvoices = container.amountOwed.beforePaymentForAll.invoices - container.amountOwed.beforePaymentForAll.selectedInvoices;
                return container;
            };
            return ViolationsCalcService;
        }());
        Service.ViolationsCalcService = ViolationsCalcService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("violationsCalcService", HCTRA.Service.ViolationsCalcService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        "use strict";
        var ViolationsCmsService = /** @class */ (function () {
            function ViolationsCmsService($filter, webStorage, cmsTextInsertionService) {
                var _this = this;
                this.$filter = $filter;
                this.webStorage = webStorage;
                this.cmsTextInsertionService = cmsTextInsertionService;
                this.paymentPageSetup = function (response, summary) {
                    if (angular.isString(response.cmsResponse)) {
                        response.cmsResponse = angular.fromJson(response.cmsResponse);
                    }
                    if (angular.isString(response.cmsResponse.Children)) {
                        response.cmsResponse.Children = angular.fromJson(response.cmsResponse.Children);
                    }
                    //set the cms data now that values are set
                    var insertionValues = {
                        remaining_balance: _this.$filter("currency")(summary.amountOwed.afterPaymentForAll.invoices),
                        current_date: _this.$filter("dateWithTimeZone")(new Date(), "dateTimeFull"),
                        total_payment: _this.$filter("currency")(summary.amountBeingPaidNow, "$")
                    };
                    var importantInfo = {
                        title: _this.cmsTextInsertionService.insertValues(insertionValues, response.cmsResponse.Children[0].Title),
                        importantText: _this.cmsTextInsertionService.insertValues(insertionValues, response.cmsResponse.Children[0].LongDescription)
                    };
                    var violationsThankYou = {
                        confirmPay: _this.cmsTextInsertionService.insertValues(insertionValues, response.cmsResponse.Children[2].Title),
                        emailMessage: _this.cmsTextInsertionService.insertValues(insertionValues, response.cmsResponse.Children[2].ShortDescription)
                    };
                    var receiptPageSummary = {
                        summaryTitle: _this.cmsTextInsertionService.insertValues(insertionValues, response.cmsResponse.Children[1].Title),
                        remainingBalance: _this.cmsTextInsertionService.insertValues(insertionValues, response.cmsResponse.Children[1].ShortDescription)
                    };
                    var paymentPageSetupOut = new HCTRA.Model.PaymentPageSetupOut();
                    paymentPageSetupOut.insertionValues = insertionValues;
                    paymentPageSetupOut.importantInfo = importantInfo;
                    paymentPageSetupOut.violationsThankYou = violationsThankYou;
                    paymentPageSetupOut.receiptPageSummary = receiptPageSummary;
                    return paymentPageSetupOut;
                };
                this.receiptPageSetup = function (summary, emailAddress, insertionValues, cmsResponse) {
                    var thankYouData = {
                        tyTotalPayment: summary.amountBeingPaidNow,
                        tyConfirmationEmail: emailAddress,
                        tyRemainingBalance: (summary.amountOwed.afterPaymentForAll.invoices),
                        todayDate: new Date()
                    };
                    //Add the email to the available insertion data
                    insertionValues.confirmation_email = emailAddress;
                    var longDescription = _this.cmsTextInsertionService.checkOptional(insertionValues, cmsResponse.Children[2].LongDescription);
                    var cmsData = {};
                    cmsData.title = _this.cmsTextInsertionService.insertValues(insertionValues, cmsResponse.Children[0].Title);
                    cmsData.section = _this.cmsTextInsertionService.insertValues(insertionValues, cmsResponse.Children[0].LongDescription);
                    cmsData.thankYouText = _this.cmsTextInsertionService.insertValues(insertionValues, longDescription);
                    var receiptPageSetupOut = new HCTRA.Model.ReceiptPageSetupOut();
                    receiptPageSetupOut.thankYouData = thankYouData;
                    receiptPageSetupOut.cmsData = cmsData;
                    return receiptPageSetupOut;
                };
            }
            ViolationsCmsService.$inject = ["$filter", "webStorage", "cmsTextInsertionService"];
            return ViolationsCmsService;
        }());
        Service.ViolationsCmsService = ViolationsCmsService;
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    "use strict";
    angular.module("HCTRAModule").service("violationsCmsService", HCTRA.Service.ViolationsCmsService);
}());
var HCTRA;
(function (HCTRA) {
    var Service;
    (function (Service) {
        'use strict';
        // export interface IViolationsUtilService {
        //     getNumInvoicesWithCollectionFee: (invoices: HCTRA.Model.ViolationsData[]) => number;
        // }
        // export class ViolationsUtilService implements IViolationsUtilService {
        //     public getNumInvoicesWithCollectionFee = (invoices: HCTRA.Model.ViolationsData[]): number => {
        //         const numInvoicesWithCollectionFee = invoices.reduce<number>((u: number, v: HCTRA.Model.ViolationsData) => u + +(!!v.collectionFee), 0);
        //         return numInvoicesWithCollectionFee;
        //     }
        // }
    })(Service = HCTRA.Service || (HCTRA.Service = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    // angular.module('HCTRAModule').service('violationsUtilService', HCTRA.Service.ViolationsUtilService);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').factory('violationSortService', [
        function () {
            var violationSort = {};
            violationSort.sortViolationInvoices = function (inInvoices, onField) {
                var arr;
                for (var agencies in inInvoices) {
                    arr = inInvoices[agencies];
                    arr.sort(function (obj1, obj2) {
                        if (obj1[onField] < obj2[onField]) {
                            return -1;
                        }
                        else if (obj1[onField] === obj2[onField]) {
                            return 0;
                        }
                        else {
                            return 1;
                        }
                    });
                    inInvoices[agencies] = arr;
                }
            };
            return violationSort;
        }
    ]);
}());
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller('SetupOnlineAccessConfirmationController', ['$scope', 'loginRoutes', '$location', 'routes', 'webStorage',
        function ($scope, loginRoutes, $location, routes, webStorage) {
            $scope.goToLogin = function () {
                webStorage.removeEntry('setupConfirmation');
                $location.url(loginRoutes.Login);
            };
            var init = function () {
                webStorage.validateOnValue('setupConfirmation', routes.setupOnlineAccess);
            };
            init();
        }]);
}());
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller('SetupOnlineAccessIdentificationController', ['$scope', '$state', 'stateNames', 'genericRepo', 'responseErrorService', 'webStorage', 'validationService',
        function ($scope, $state, stateNames, genericRepo, responseErrorService, webStorage, validationService) {
            $scope.validations = {};
            var unwatch = $scope.$watch('setupOnlineAccessIdentificationForm', function () {
                if ($scope.setupOnlineAccessIdentificationForm) {
                    $scope.validations = validationService($scope.setupOnlineAccessIdentificationForm);
                    unwatch();
                }
            });
            //Fix for bug 8171: Need to cause first field focus
            $scope.vm = {};
            $scope.vm.remote = {};
            $scope.vm.remote.firstField = function () {
                //method in appController.js
                $scope.$parent.focusFirstField();
            };
            $scope.setupOnlineAccessIdentificationDetails = {};
            $scope.submitInfo = function (formIsValid) {
                if (formIsValid) {
                    storeUnusedFields();
                    genericRepo.dataFactory.submitSetupOnlineAccessAccount($scope.setupOnlineAccessIdentificationDetails).then(function (response) {
                        if (response.errors.length == 0) {
                            webStorage.setKeyValue('setupAcctId', response.acctId);
                            webStorage.setKeyValue('setupDbSessionId', response.dbSessionId);
                            webStorage.setKeyValue('setupLastLoginIp', response.lastLoginIp);
                            $state.go(stateNames.setupOnlineAccessLoginInfo);
                        }
                        else {
                            refillUnusedFields();
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                }
            };
            // Consider refactoring with the same set of code from ForgotPasswordAccountController
            var idValue1, idValue2;
            var storeUnusedFields = function () {
                if ($scope.setupOnlineAccessIdentificationDetails.accountInfo === 'account') {
                    idValue1 = $scope.setupOnlineAccessIdentificationDetails.tagNumber;
                    $scope.setupOnlineAccessIdentificationDetails.tagNumber = '';
                }
                else if ($scope.setupOnlineAccessIdentificationDetails.accountInfo === 'tag') {
                    idValue1 = $scope.setupOnlineAccessIdentificationDetails.accountNumber;
                    $scope.setupOnlineAccessIdentificationDetails.accountNumber = '';
                }
                if ($scope.setupOnlineAccessIdentificationDetails.personalInfo === 'driversLicense') {
                    idValue2 = $scope.setupOnlineAccessIdentificationDetails.taxIdNumber;
                    $scope.setupOnlineAccessIdentificationDetails.taxIdNumber = '';
                }
                else if ($scope.setupOnlineAccessIdentificationDetails.personalInfo === 'taxId') {
                    idValue2 = $scope.setupOnlineAccessIdentificationDetails.driversLicense;
                    $scope.setupOnlineAccessIdentificationDetails.driversLicense = '';
                }
            };
            var refillUnusedFields = function () {
                if (idValue1 != null) {
                    if ($scope.setupOnlineAccessIdentificationDetails.accountInfo === 'account') {
                        $scope.setupOnlineAccessIdentificationDetails.tagNumber = idValue1;
                    }
                    else if ($scope.setupOnlineAccessIdentificationDetails.accountInfo === 'tag') {
                        $scope.setupOnlineAccessIdentificationDetails.accountNumber = idValue1;
                    }
                }
                if (idValue2 != null) {
                    if ($scope.setupOnlineAccessIdentificationDetails.personalInfo === 'driversLicense') {
                        $scope.setupOnlineAccessIdentificationDetails.taxIdNumber = idValue2;
                    }
                    else if ($scope.setupOnlineAccessIdentificationDetails.personalInfo === 'taxId') {
                        $scope.setupOnlineAccessIdentificationDetails.driversLicense = idValue2;
                    }
                }
            };
        }]);
}());
(function () {
    'use strict';
    angular
        .module('HCTRAModule').controller('SetupOnlineAccessLoginInfoController', ['$scope', '$state', 'stateNames', 'routes', 'genericRepo', 'responseErrorService', 'validationService', 'webStorage',
        function ($scope, $state, stateNames, routes, genericRepo, responseErrorService, validationService, webStorage) {
            $scope.validations = {};
            var unwatch = $scope.$watch('setupOnlineAccessLoginInfoForm', function () {
                if ($scope.setupOnlineAccessLoginInfoForm) {
                    $scope.validations = validationService($scope.setupOnlineAccessLoginInfoForm);
                    unwatch();
                }
            });
            $scope.setupOnlineAccessLoginInfoDetails = {};
            $scope.submitInfo = function (formIsValid) {
                if (formIsValid) {
                    genericRepo.dataFactory.submitSetupOnlineAccessLoginInfo($scope.setupOnlineAccessLoginInfoDetails).then(function (response) {
                        if (response.errors.length == 0) {
                            webStorage.setKeyValue('setupConfirmation', 'true');
                            $state.go(stateNames.setupOnlineAccessConfirmation);
                        }
                        else {
                            responseErrorService.displayErrorsFromResponse(response);
                        }
                    });
                }
            };
            var init = function () {
                webStorage.validateOnValue('setupAcctId', routes.setupOnlineAccess);
                webStorage.validateOnValue('setupDbSessionId', routes.setupOnlineAccess);
                webStorage.validateOnValue('setupLastLoginIp', routes.setupOnlineAccess);
                $scope.setupOnlineAccessLoginInfoDetails.acctId = webStorage.getValue('setupAcctId');
                $scope.setupOnlineAccessLoginInfoDetails.dbSessionId = webStorage.getValue('setupDbSessionId');
                $scope.setupOnlineAccessLoginInfoDetails.lastLoginIp = webStorage.getValue('setupLastLoginIp');
                webStorage.removeEntry('setupAcctId');
                webStorage.removeEntry('setupDbSessionId');
                webStorage.removeEntry('setupLastLoginIp');
            };
            init();
        }]);
}());
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("SiteMapController", ['$scope', 'linkLookupService', 'AuthService', 'routes',
        function ($scope, linkLookupService, AuthService, routes) {
            $scope.vm = {
                sitemap: {
                    ezTagSection: {
                        title: "EZ Tag Account", array: []
                    },
                    aboutHctraSection: {
                        title: "About HCTRA", array: []
                    },
                    travelToolsSection: {
                        title: "Travel Tools", array: []
                    },
                    helpAndSupportSection: {
                        title: "Help & Support", array: []
                    },
                    tollInvoicesSection: {
                        title: "Violations & Missed Tolls", array: []
                    },
                    jobSection: {
                        title: "Job Openings", array: []
                    },
                    faqSection: {
                        title: "FAQ Articles", array: []
                    }
                }
            };
            var SITCORE_PATHS = {
                "/sitecore/content/HCTRA/EZTagAccount": $scope.vm.sitemap.ezTagSection.array,
                "/sitecore/content/HCTRA/TollInvoices": $scope.vm.sitemap.tollInvoicesSection.array,
                "/sitecore/content/HCTRA/AboutHCTRA": $scope.vm.sitemap.aboutHctraSection.array,
                "/sitecore/content/HCTRA/TravelTools": $scope.vm.sitemap.travelToolsSection.array,
                "/sitecore/content/HCTRA/HelpAndSupport": $scope.vm.sitemap.helpAndSupportSection.array
            };
            var SITECORE_TEMPLATE_TYPES = {
                Page: orderPageTemplates,
                News: false,
                Closure: false,
                FAQ: addFaqSection,
                JobOpening: addJobSection,
                MajorProject: addtoAboutHctra,
                Template: false
            };
            var unwatch = $scope.$watch(function () {
                return linkLookupService.cmsIdDictionary ? true : false;
            }, function (newValue) {
                if (newValue) {
                    createSitemap();
                    sortAndRemoveEmptySitemapSections();
                    unwatch();
                }
            });
            function sortAndRemoveEmptySitemapSections() {
                for (var key in $scope.vm.sitemap) {
                    // skip loop if the property is from prototype
                    // eslint-disable-next-line no-prototype-builtins
                    if (!$scope.vm.sitemap.hasOwnProperty(key)) {
                        continue;
                    }
                    if ($scope.vm.sitemap[key].array.length > 0) {
                        $scope.vm.sitemap[key].array.sort(function (firstObject, secondObject) {
                            var firstName = firstObject.title.toUpperCase();
                            var secondName = secondObject.title.toUpperCase();
                            return (firstName < secondName) ? -1 : (firstName > secondName) ? 1 : 0;
                        });
                    }
                    else {
                        delete $scope.vm.sitemap[key];
                    }
                }
            }
            function createSitemap() {
                var dict = linkLookupService.cmsIdDictionary;
                for (var key in dict) {
                    if (!dict[key]) {
                        continue;
                    }
                    // skip loop if the property is from prototype
                    // eslint-disable-next-line no-prototype-builtins
                    if (!dict.hasOwnProperty(key) || shouldSkipLink(dict[key])) {
                        continue;
                    }
                    if (dict[key].templateName && SITECORE_TEMPLATE_TYPES[dict[key].templateName]) {
                        SITECORE_TEMPLATE_TYPES[dict[key].templateName](dict[key]);
                    }
                }
            }
            function shouldSkipLink(link) {
                return (link.itemID === routes.cmsSitemap || (!link.includeInSearch && !AuthService.isAuthenticated())) ||
                    (link.friendlyURL.toString().includes("/IgnorePage"));
            }
            function orderPageTemplates(link) {
                var relativePathArray = link.itemPath.split("/");
                var relativePathArrayOrIdentifier = relativePathArray.length >= 5 ?
                    SITCORE_PATHS["/" + relativePathArray[1] + "/" + relativePathArray[2] + "/" + relativePathArray[3] + "/" + relativePathArray[4]]
                    : false;
                if (relativePathArrayOrIdentifier) {
                    addLink(relativePathArrayOrIdentifier, link);
                }
                else {
                    addLink($scope.vm.sitemap.ezTagSection.array, link);
                }
            }
            function addFaqSection(link) {
                addLink($scope.vm.sitemap.faqSection.array, link);
            }
            function addJobSection(link) {
                addLink($scope.vm.sitemap.jobSection.array, link);
            }
            function addtoAboutHctra(link) {
                addLink($scope.vm.sitemap.aboutHctraSection.array, link);
            }
            function addLink(array, link) {
                array.push({ title: link.title, url: link.friendlyURL });
            }
            $scope.isNotPrototypeProperty = function (key, object) {
                // eslint-disable-next-line no-prototype-builtins
                return object.hasOwnProperty(key);
            };
        }]);
}());
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines the all tasks complete modal
        var StorefrontAllTasksCompleteController = /** @class */ (function () {
            function StorefrontAllTasksCompleteController($scope, $uibModalInstance, modalOptions, storefrontService, storefrontModalService, actions) {
                this.$scope = $scope;
                this.$uibModalInstance = $uibModalInstance;
                this.modalOptions = modalOptions;
                this.storefrontService = storefrontService;
                this.storefrontModalService = storefrontModalService;
                this.actions = actions;
                $scope.header = modalOptions.headerText;
                $scope.body = modalOptions.bodyText;
                $scope.call = function (action) { return $uibModalInstance.close(action); };
                $scope.actionText = function (action) { return actions[action]; };
                $scope.actions = actions;
            }
            StorefrontAllTasksCompleteController.$inject = [
                "$scope", "$uibModalInstance", "modalOptions", "StorefrontService", "StorefrontModalService", "actions"
            ];
            return StorefrontAllTasksCompleteController;
        }());
        Controller.StorefrontAllTasksCompleteController = StorefrontAllTasksCompleteController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontAllTasksCompleteController", HCTRA.Controller.StorefrontAllTasksCompleteController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines a generic prompt
        var StorefrontCmsModalController = /** @class */ (function () {
            function StorefrontCmsModalController($scope, $uibModalInstance, controllerName, template) {
                this.$scope = $scope;
                this.$uibModalInstance = $uibModalInstance;
                this.controllerName = controllerName;
                this.template = template;
                $scope.cmsController = controllerName;
                $scope.cmsTemplate = template;
                $scope.exit = function () { return $uibModalInstance.close(); };
            }
            StorefrontCmsModalController.$inject = ["$scope", "$uibModalInstance", "controllerName", "template"];
            return StorefrontCmsModalController;
        }());
        Controller.StorefrontCmsModalController = StorefrontCmsModalController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule')
        .controller("StorefrontCmsModalController", HCTRA.Controller.StorefrontCmsModalController)
        .directive("storefrontDynamicController", ['$compile', '$parse', function ($compile, $parse) {
            return {
                restrict: 'A',
                terminal: true,
                priority: 100000,
                link: function (scope, elem) {
                    var name = $parse(elem.attr('storefront-dynamic-controller'))(scope);
                    elem.removeAttr('storefront-dynamic-controller');
                    elem.attr('ng-controller', name);
                    $compile(elem)(scope);
                }
            };
        }]);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines root storefront controller that wires up service calls, state redirects, and other events  
        var StorefrontController = /** @class */ (function () {
            function StorefrontController(storefrontService, $scope, $q, $state, stateNames, router, storefrontModalService, storefrontEventService, $window, routes, errorDisplayService, loginStates, storefrontCmsIds) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.$scope = $scope;
                this.$q = $q;
                this.$state = $state;
                this.stateNames = stateNames;
                this.router = router;
                this.storefrontModalService = storefrontModalService;
                this.storefrontEventService = storefrontEventService;
                this.$window = $window;
                this.routes = routes;
                this.errorDisplayService = errorDisplayService;
                this.loginStates = loginStates;
                this.storefrontCmsIds = storefrontCmsIds;
                //flag for tracking when the store front is ready for use
                this.readyToUse = false;
                this.getBackgroundImage = function (currentState) {
                    var canStateUseBackground = _this.canShowBackgroundImage(currentState);
                    if (canStateUseBackground) {
                        var id = _this.storefrontCmsIds.LandingPage;
                        if (id) {
                            return _this.storefrontService
                                .getCmsItemById(id)
                                .then(function (response) { return _this.backgroundImage = response.ImageItem; });
                        }
                    }
                    return _this.$q.resolve(null);
                };
                //builds list of urls to give to service to pre-cache
                this.prefetchAllContent = function () {
                    //get all storefront templates used in workitems
                    var urlsToPrefetch = [];
                    //build a lookup for all available routes' template paths
                    var routeMap = _this.buildRouteLookup(_this.router);
                    //for each workitem
                    _this.storefrontService.workItems
                        //get all states
                        .map(function (item) { return item.states; })
                        //smoosh them together
                        .reduce(function (a, b) { return a.concat(b); }, [])
                        //add a few extras
                        .concat([_this.stateNames.storefrontSelection, _this.stateNames.storefrontSurvey, _this.loginStates.Login, _this.loginStates.AddMissingInformation])
                        //then for all those states
                        .forEach(function (state) {
                        //lookup there template path and add to array
                        if (!angular.isArray(routeMap[state])) {
                            urlsToPrefetch.push(routeMap[state]);
                        }
                        else {
                            urlsToPrefetch.push.apply(urlsToPrefetch, routeMap[state]);
                        }
                    });
                    //add workitem image content
                    _this.storefrontService.workItems
                        .forEach(function (workItem) {
                        if (workItem.selectedIcon && workItem.unselectedIcon) {
                            urlsToPrefetch.push(workItem.selectedIcon.image);
                            urlsToPrefetch.push(workItem.unselectedIcon.image);
                        }
                    });
                    //send all defined urls to be prefetched!
                    return _this.storefrontService.prefetchContent(urlsToPrefetch.filter(function (url) { return angular.isDefined(url); }));
                };
                //determine if a ui-view directive should use the default '' view template or if a storefront view is available for display
                this.templateInUse = function () {
                    if (_this.storefrontService.fullSiteMode || !_this.$state.current.views || !_this.$state.current.views["storefront"]) {
                        return "";
                    }
                    else {
                        return "storefront";
                    }
                };
                //redirects to workitem's start state or if null, go to survey
                this.goToWorkItem = function (item) {
                    //don't go to workitem if in fullsite mode!
                    if (_this.storefrontService.fullSiteMode)
                        return _this.$q.resolve();
                    var initState = item ? _this.storefrontService.getWorkItemInitState(item) : _this.stateNames.storefrontSurvey;
                    if (initState) {
                        return _this.$state.go(initState);
                    }
                    return _this.$q.resolve();
                };
                this.canShowBackgroundImage = function (currentState) {
                    currentState = currentState || _this.$state.current;
                    return currentState &&
                        (currentState.name === '' ||
                            currentState.name === _this.stateNames.storefrontHome ||
                            currentState.name === _this.stateNames.storefrontSelection);
                };
                //set up scope variables
                this.initialUrl = this.$window.location.origin + this.routes.storefrontHome;
                $scope.hasStarted = function () { return _this.hasStarted(); };
                $scope.isWorkflowActive = function () { return _this.storefrontService.isWorkflowActive(); };
                $scope.showWorkflowFunctions = function () { return (_this.storefrontService.fullSiteMode || _this.hasStarted()) &&
                    _this.$state.current.name !== _this.stateNames.storefrontSurvey; };
                $scope.showTranslationSelect = function () {
                    return _this.hasStarted() && !_this.storefrontService.fullSiteMode;
                };
                $scope.finish = function () { return _this.finish(); };
                $scope.isFullSiteViewActive = function () { return _this.storefrontService.fullSiteMode; };
                $scope.showMenu = function () { return _this.storefrontService.showMenu(_this.$state.current); };
                $scope.showMainView = function () {
                    var currentItem = _this.storefrontService.currentWorkItem();
                    var hasStates = currentItem && currentItem.states && currentItem.states.length > 0;
                    return !_this.isExternalTaskModalOpen() && (!currentItem || hasStates);
                };
                $scope.templateToUse = function () { return _this.templateInUse(); };
                $scope.isCmsContentView = function () { return _this.storefrontService.isCmsContent(_this.$state.current) && !_this.storefrontService.fullSiteMode; };
                $scope.closeCmsContentView = function () { return _this.storefrontModalService.closeCmsContent(); };
                $scope.isReadyToUse = function () { return _this.readyToUse; };
                $scope.externalModalOpen = function () { return _this.storefrontModalService.isExternalTaskModalOpen(); };
                $scope.transitioningState = false;
                $scope.transitionSubView = false;
                $scope.machineName = this.storefrontService.machineName;
                $scope.host = this.$window.location.origin;
                $scope.resetTaps = 0;
                $scope.hardReset = function () {
                    $scope.resetTaps++;
                    if ($scope.resetTaps >= 10) {
                        $scope.resetTaps = 0;
                        _this.storefrontService.reset(HCTRA.Model.StorefrontLogOffType.Forced);
                    }
                };
                //initial modal settings
                storefrontModalService.setGlobalModalSettings();
                this.onInitialized =
                    //when store front servcie is ready..
                    storefrontService.onInitialized
                        //init shell user
                        .then(function () { return _this.initShellUser(); })
                        //prefetch content
                        .then(function () { return _this.prefetchAllContent(); })
                        .then(function () { return _this.getBackgroundImage(_this.$state.get(_this.stateNames.storefrontHome)); })
                        .then(function () {
                        _this.$scope.backgroundImage = _this.backgroundImage;
                        $scope.showBackgroundImage = _this.canShowBackgroundImage(_this.$state.current);
                    })
                        .then(function () {
                        //logo
                        _this.$scope.storefrontLogo = _this.storefrontService.getStorefrontLogo();
                        //wire up events
                        _this.storefrontEventService.startListening(_this);
                        //clean up...
                        _this.$scope.$on("$destroy", function () { return _this.storefrontEventService.stopListening(); });
                    })
                        //flag ready to use
                        .then(function () {
                        _this.readyToUse = storefrontService.isEnabled();
                    })
                        .catch(function (e) {
                        //in case something bad happened, so a failure to init message
                        _this.$window.console.log(e);
                        return _this.storefrontModalService
                            .failedToInitMessage().then(function () {
                            _this.onResetComplete(true);
                        });
                    })
                        //regardless, resolves with instance of this controller
                        .then(function () { return _this; });
            }
            /****************************Start IStorefrontEventHandlers*****************************************************************/
            StorefrontController.prototype.onIncompleteWorkItem = function (workItem) {
                return this.storefrontModalService.skippedTasksMessage(workItem).then(this.goToWorkItem);
            };
            StorefrontController.prototype.onCompletedWorkItem = function (completedWorkItem, nextWorkItem) {
                var _this = this;
                if (completedWorkItem) {
                    return this.storefrontModalService
                        .showCompletionMessage(completedWorkItem)
                        .then(function () {
                        if (nextWorkItem && nextWorkItem.isSelected) {
                            return _this.goToWorkItem(nextWorkItem).catch(function () { return _this.$q.resolve(); });
                        }
                        else if (nextWorkItem && !nextWorkItem.isSelected) {
                            return _this.$q.reject("no");
                        }
                        return _this.$q.resolve();
                    });
                }
                else {
                    //starting...
                    return this.$q.resolve();
                }
            };
            StorefrontController.prototype.onResetting = function () {
                this.storefrontModalService.setGlobalModalSettings();
                this.storefrontModalService.closeAll(true);
                this.storefrontEventService.resetState();
                return this.$state.go(this.stateNames.storefrontHome);
            };
            StorefrontController.prototype.onStartTransition = function (fromState, toState) {
                this.$scope.resetTaps = 0;
                if (!this.storefrontService.fullSiteMode) {
                    this.$scope.transitionSubView =
                        this.storefrontService.showMenu(toState) &&
                            this.storefrontService.showMenu(fromState);
                    this.$scope.transitioningState = true;
                }
                this.$scope.showBackgroundImage = this.canShowBackgroundImage(toState);
                if (this.$scope.showBackgroundImage) {
                    this.$scope.backgroundImage = this.backgroundImage;
                }
                return this.$q.resolve();
            };
            StorefrontController.prototype.onEndTransition = function () {
                this.$scope.transitioningState = false;
                if (!this.$scope.showBackgroundImage) {
                    this.$scope.backgroundImage = null;
                }
            };
            StorefrontController.prototype.onResetComplete = function (hard) {
                this.errorDisplayService.clearToasts();
                if (hard) {
                    this.$window.location.href = this.initialUrl;
                    return this.$q.resolve();
                }
                return this.$q.resolve();
            };
            /****************************End IStorefrontEventHandlers**********************************************************************/
            StorefrontController.prototype.initShellUser = function () {
                var _this = this;
                if (this.storefrontService.isShellAccountInitialized) {
                    return this.$q.resolve();
                }
                return this.storefrontService
                    .authenticateShellAccount()
                    .then(function () { return _this.$window.location.reload(); });
            };
            //builds a reverse lookup by statename from the routes
            StorefrontController.prototype.buildRouteLookup = function (routeConfigs) {
                return routeConfigs.reduce(function (acc, route) {
                    if (route.config && route.config.templateUrl) {
                        if (!angular.isFunction(route.config.templateUrl)) {
                            acc[route.name] = route.config.templateUrl;
                        }
                    }
                    else if (route.config && route.config.views) {
                        acc[route.name] = acc[route.name] || [];
                        for (var viewName in route.config.views) {
                            if (route.config.views.hasOwnProperty(viewName)) {
                                var view = route.config.views[viewName];
                                if (view && view.templateUrl && !angular.isFunction(view.templateUrl)) {
                                    acc[route.name].push(view.templateUrl);
                                }
                            }
                        }
                    }
                    return acc;
                }, {});
            };
            //true if user not at home screen has started
            StorefrontController.prototype.hasStarted = function () {
                return this.$state.current.name !== this.stateNames.storefrontHome;
            };
            //true if a modal was opened to show an external task
            StorefrontController.prototype.isExternalTaskModalOpen = function () {
                return this.storefrontModalService.isExternalTaskModalOpen();
            };
            //exits everything
            StorefrontController.prototype.finish = function () {
                this.storefrontModalService.exit();
            };
            StorefrontController.$inject = [
                "StorefrontService", "$scope", "$q",
                "$state", "stateNames", "router", "StorefrontModalService", "StorefrontEventService", "$window", "routes",
                "errorDisplayService", "loginStates", "storefrontCmsIds"
            ];
            return StorefrontController;
        }());
        Controller.StorefrontController = StorefrontController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontController", HCTRA.Controller.StorefrontController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines a generic prompt
        var StorefrontExternalTaskModalController = /** @class */ (function () {
            function StorefrontExternalTaskModalController($scope, $uibModalInstance) {
                this.$scope = $scope;
                this.$uibModalInstance = $uibModalInstance;
                $scope.exit = function () {
                    $scope.show = false;
                    $uibModalInstance.close();
                };
                $scope.show = true;
            }
            StorefrontExternalTaskModalController.$inject = ["$scope", "$uibModalInstance"];
            return StorefrontExternalTaskModalController;
        }());
        Controller.StorefrontExternalTaskModalController = StorefrontExternalTaskModalController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontExternalTaskModalController", HCTRA.Controller.StorefrontExternalTaskModalController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines a generic prompt
        var StorefrontGenericPromptController = /** @class */ (function () {
            function StorefrontGenericPromptController($scope, $uibModalInstance, modalOptions, storefrontService, storefrontModalService, actions, showModalClose, showGoBack, imageData) {
                if (showModalClose === void 0) { showModalClose = false; }
                this.$scope = $scope;
                this.$uibModalInstance = $uibModalInstance;
                this.modalOptions = modalOptions;
                this.storefrontService = storefrontService;
                this.storefrontModalService = storefrontModalService;
                this.actions = actions;
                this.showModalClose = showModalClose;
                this.showGoBack = showGoBack;
                this.imageData = imageData;
                $scope.header = modalOptions.headerText;
                $scope.body = modalOptions.bodyText;
                $scope.image = imageData;
                $scope.actions = actions;
                $scope.showModalClose = showModalClose;
                $scope.showGoBack = showGoBack;
                $scope.actionText = function (action) { return actions && actions[action]; };
                $scope.call = function (action) { return $uibModalInstance.close(action); };
                $scope.dismiss = function () { return $uibModalInstance.dismiss(); };
            }
            StorefrontGenericPromptController.$inject = ["$scope", "$uibModalInstance", "modalOptions", "StorefrontService", "StorefrontModalService", "actions", "showModalClose", "showGoBack", "imageData"];
            return StorefrontGenericPromptController;
        }());
        Controller.StorefrontGenericPromptController = StorefrontGenericPromptController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontGenericPromptController", HCTRA.Controller.StorefrontGenericPromptController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines controller for handling a prompt to continue seesion.
        var StorefrontInactivityController = /** @class */ (function () {
            function StorefrontInactivityController($scope, $uibModalInstance, environmentConfig, modalOptions, $interval, storefrontService, actions, cmsTextInsertionService) {
                var _this = this;
                this.$scope = $scope;
                this.$uibModalInstance = $uibModalInstance;
                this.environmentConfig = environmentConfig;
                this.modalOptions = modalOptions;
                this.$interval = $interval;
                this.storefrontService = storefrontService;
                this.actions = actions;
                this.cmsTextInsertionService = cmsTextInsertionService;
                //the initial amount of time before session resets
                $scope.timeLeftAfterWarningInMinutesStatic = (environmentConfig.storefrontConfigs.StorefrontInactivityReset - environmentConfig.storefrontConfigs.StorefrontInactivityWarning) / 60000 | 0;
                //the remaining time left until the session resets. this will update every second.
                $scope.timeLeftTillResetInSeconds = (environmentConfig.storefrontConfigs.StorefrontInactivityReset - environmentConfig.storefrontConfigs.StorefrontInactivityWarning) / 1000 | 0;
                //sets up interval to count down time left
                var intervalCancel = $interval(function () {
                    $scope.timeLeftTillResetInSeconds--;
                    if ($scope.timeLeftTillResetInSeconds <= 0) {
                        $interval.cancel(intervalCancel);
                        _this.storefrontService.reset(HCTRA.Model.StorefrontLogOffType.Auto);
                    }
                }, 1000);
                var insertionValues = {
                    timeLeftAfterWarningInMinutesStatic: $scope.timeLeftAfterWarningInMinutesStatic
                };
                $scope.call = function (action) { return $uibModalInstance.close(action); };
                $scope.actionText = function (action) { return actions[action]; };
                $scope.headerText = this.cmsTextInsertionService.insertValues(insertionValues, modalOptions.headerText);
                $scope.bodyText = modalOptions.bodyText;
                //clean up
                $scope.$on("$destroy", function () { return $interval.cancel(intervalCancel); });
            }
            StorefrontInactivityController.$inject = ["$scope", "$uibModalInstance", "environmentConfig", "modalOptions", "$interval", "StorefrontService", "actions", "cmsTextInsertionService"];
            return StorefrontInactivityController;
        }());
        Controller.StorefrontInactivityController = StorefrontInactivityController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontInactivityController", HCTRA.Controller.StorefrontInactivityController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines a replacement controller to use for all default modals within store front
        var StorefrontModalReplacementController = /** @class */ (function () {
            function StorefrontModalReplacementController($scope, $uibModalInstance, modalOptions) {
                this.$scope = $scope;
                this.$uibModalInstance = $uibModalInstance;
                this.modalOptions = modalOptions;
                $scope.header = modalOptions.headerText;
                $scope.closeButtonText = modalOptions.closeButtonText;
                $scope.actionButtonText = modalOptions.actionButtonText;
                $scope.body = modalOptions.bodyText;
                $scope.subText = modalOptions.subText;
                $scope.action = function () {
                    $uibModalInstance.close();
                };
                $scope.dismiss = function () {
                    $uibModalInstance.dismiss('cancel');
                };
            }
            StorefrontModalReplacementController.$inject = ["$scope", "$uibModalInstance", "modalOptions"];
            return StorefrontModalReplacementController;
        }());
        Controller.StorefrontModalReplacementController = StorefrontModalReplacementController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontModalReplacementController", HCTRA.Controller.StorefrontModalReplacementController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //define work item selection logic
        var StorefrontOptionSelectionController = /** @class */ (function () {
            function StorefrontOptionSelectionController(storefrontService, $scope, $state, homeStates, storefrontModalService, $q) {
                var _this = this;
                this.storefrontService = storefrontService;
                this.$scope = $scope;
                this.$state = $state;
                this.homeStates = homeStates;
                this.storefrontModalService = storefrontModalService;
                this.$q = $q;
                this.startWorkItems = function () {
                    if (!_this.isProceeding) {
                        _this.isProceeding = true;
                        _this.storefrontService.startWorkItems()
                            .then(function (initState) {
                            if (initState) {
                                _this.$state.go(initState);
                            }
                        })
                            .catch(function () {
                            _this.isProceeding = false;
                        });
                    }
                };
                this.keyPressed = function (event) {
                    if (!_this.$scope.noTasksSelected && event.keyCode === 13) {
                        event.preventDefault();
                        event.stopPropagation();
                        _this.startWorkItems();
                    }
                };
                this.toggleWorkItem = function (workItem) {
                    if (workItem.isUnavailable || !workItem.states || workItem.states.length === 0)
                        return;
                    workItem.isSelected = !workItem.isSelected;
                    _this.setUnavailbleSettings();
                    _this.setCanProceed();
                };
                this.setCanProceed = function () {
                    _this.$scope.noTasksSelected = _this.storefrontService.workItems.reduce(function (acc, item) { return !item.isSelected && acc; }, true);
                };
                this.foreachWorkItem = function (func) { return _this.storefrontService.workItems.forEach(func); };
                this.getSelectionIcon = function (item, isHovering) {
                    var imageData = {
                        alt: null,
                        url: null
                    };
                    if (item.isUnavailable) {
                        imageData.url = _this.defaultIcon.ItemMedialUrl;
                        imageData.alt = "unavailable";
                    }
                    else if (item.isSelected) {
                        imageData.url = _this.selectedIcon.ItemMedialUrl;
                        imageData.alt = "selected";
                    }
                    else if (isHovering) {
                        imageData.url = _this.hoverIcon.ItemMedialUrl;
                        imageData.alt = "hover";
                    }
                    else {
                        imageData.url = _this.defaultIcon.ItemMedialUrl;
                        imageData.alt = "none";
                    }
                    return imageData;
                };
                this.getContentFromState = function (name) {
                    return _this.storefrontService.getCmsItemById(_this.$state.current["cms"][name]);
                };
                //go home is store front not enabled
                if (!storefrontService.isEnabled()) {
                    $state.go(this.homeStates.Frame);
                    return;
                }
                this.isProceeding = false;
                //opens storefront in full site mode
                $scope.dontSeeWantIneed = function () {
                    _this.storefrontModalService.iDontSeeWhatINeedMessage(null);
                };
                $scope.getSelectionIcon = this.getSelectionIcon;
                this.setUnavailbleSettings();
                this.setCanProceed();
                var contentIds = ["selectedIconId", "hoverIconId", "defaultIconId", "taskSelectionPageId"]
                    .reduce(function (acc, key) { return (acc[key] = _this.getContentFromState(key), acc); }, {});
                this.$q.all(contentIds).then(function (content) {
                    _this.$scope.cmsContent = content.taskSelectionPageId;
                    _this.defaultIcon = content.defaultIconId;
                    _this.hoverIcon = content.hoverIconId;
                    _this.selectedIcon = content.selectedIconId;
                    _this.$scope.uiSortedWorkItems = _this.storefrontService.workItems.filter(function (item) { return !item.isShadowItem; });
                    _this.$scope.startWorkItems = _this.startWorkItems;
                    _this.$scope.toggleWorkItem = _this.toggleWorkItem;
                    _this.$scope.keyPressed = _this.keyPressed;
                });
            }
            StorefrontOptionSelectionController.prototype.setUnavailbleSettings = function () {
                var set = {};
                this.foreachWorkItem(function (item) {
                    if (item.isSelected && item.unavailableWhenSelected) {
                        for (var _i = 0, _a = item.unavailableWhenSelected; _i < _a.length; _i++) {
                            var id = _a[_i];
                            set[id] = true;
                        }
                    }
                });
                if (this.storefrontService.isAuthenticated()) {
                    set[HCTRA.Model.SelectedOptions.OACC] = true;
                }
                this.foreachWorkItem(function (item) {
                    item.isUnavailable = set[item.id];
                    if (set[item.id]) {
                        item.isSelected = false;
                    }
                });
            };
            StorefrontOptionSelectionController.$inject = ["StorefrontService", "$scope", "$state", "homeStates", "StorefrontModalService", "$q"];
            return StorefrontOptionSelectionController;
        }());
        Controller.StorefrontOptionSelectionController = StorefrontOptionSelectionController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontOptionSelectionController", HCTRA.Controller.StorefrontOptionSelectionController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines contoller for viewing a js rendered pdf file
        var StorefrontPdfViewerController = /** @class */ (function () {
            function StorefrontPdfViewerController($window, $scope, $timeout, $uibModalInstance, pdfHref) {
                var _this = this;
                this.$window = $window;
                this.$scope = $scope;
                this.$timeout = $timeout;
                this.$uibModalInstance = $uibModalInstance;
                this.pdfHref = pdfHref;
                this.styleHeader = "\n    @page {\n        size: A4;   \n        margin: 0cm;  \n\n        @bottom-left {\n            content: \"\";\n            font-size: 0;\n            margin: 0;\n        }    \n\n        @bottom-right {\n            content: \"\";\n            font-size: 0;\n            margin: 0;\n        }    \n\n        @top-left {\n            content: \"\";\n            font-size: 0;\n            margin: 0;\n        }    \n\n        @top-right {\n            content: \"\";\n            font-size: 0;\n            margin: 0;\n        }    \n    }\n\n    html, body, img {\n        padding: 0;\n    }\n\n    img {\n        display: block;\n        page-break-before:avoid;\n        page-break-after: avoid;\n        page-break-inside:avoid; \n        margin: 0 auto;\n    }\n";
                var maxAttempts = 15;
                var currentAttempt = 0;
                var pdfDataRaw = null;
                //placeholder loading message
                $scope.message = "Loading...";
                $scope.close = function () {
                    $uibModalInstance.close();
                };
                //print pdf in new window
                $scope.print = function () {
                    //only print if the raw pdf image data is loaded
                    if (!pdfDataRaw)
                        return;
                    var header = _this.styleHeader;
                    var newWin = _this.$window.open('', '');
                    newWin.document.open();
                    //insert raw image tags into new window to be printed
                    var page = "\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta http- equiv=\"X-UA-Compatible\" content= \"IE=Edge\" />\n        <style type=\"text/css\" media= \"print\" > " + header + " </style>\n    </head>\n    <body>" + pdfDataRaw + "</body>\n</html>";
                    newWin.document.write(page);
                    newWin.document.close();
                    //wait a bit before trying to print, to ensure raw image tags have loaded
                    var c = _this;
                    c.$timeout(500)
                        .then(function () { return newWin.print(); })
                        .then(function () { return c.$timeout(10000); })
                        .then(function () {
                        if (!newWin.closed) {
                            newWin.close();
                        }
                    });
                };
                //passthrough errors from pdf renderer
                $scope.error = function (e) {
                    if (angular.isDefined(e.status) && e.status >= 400 && currentAttempt < maxAttempts) {
                        //retry
                        currentAttempt++;
                        pdfDataRaw = null;
                        _this.$timeout(function () { return $scope.pdfRequest = { url: pdfHref }; }, 1000);
                    }
                    else if (angular.isDefined(e.status) && e.status >= 400) {
                        $scope.message = "Could not load PDF document at this time.";
                    }
                    else {
                        $uibModalInstance.close(e);
                    }
                };
                //translate the raw rendered pdf pages into image tags and store into a string
                $scope.loaded = function (pdfData) {
                    //width: 8.27 in;
                    //max - height: 11.69 in;
                    pdfDataRaw = pdfData.reduce(function (acc, d) {
                        if (!d.width || !d.height)
                            return acc + '';
                        var width, height;
                        var ratio = d.height / d.width;
                        if (ratio > Math.SQRT2) { // height is max
                            height = 1100;
                            width = 1100 / ratio;
                        }
                        else if (ratio < Math.SQRT2 && ratio > Math.SQRT1_2) {
                            if (d.width > d.height) {
                                height = 850;
                                width = 850 * ratio;
                            }
                            else {
                                width = 850;
                                height = 850 * ratio;
                            }
                        }
                        else { // width is max
                            width = 1100;
                            height = 1100 / ratio;
                        }
                        width = (width | 0) / 100;
                        height = (height | 0) / 100;
                        return acc + ("<img src=\"" + d.data + "\" style=\"width:" + width + "in;height:" + height + "in;\" />");
                    }, "");
                };
                //variable to pass pdf location to pdf viewer directive
                $scope.pdfRequest = { url: pdfHref };
            }
            StorefrontPdfViewerController.$inject = ["$window", "$scope", "$timeout", "$uibModalInstance", "pdfHref"];
            return StorefrontPdfViewerController;
        }());
        Controller.StorefrontPdfViewerController = StorefrontPdfViewerController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontPdfViewerController", HCTRA.Controller.StorefrontPdfViewerController);
})();
//Migrated
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines suppression controller with fail safe reboot if
        //app enters a invalid state.
        var StorefrontSuppressionController = /** @class */ (function () {
            function StorefrontSuppressionController($scope, storefrontService, $timeout) {
                this.$scope = $scope;
                this.storefrontService = storefrontService;
                this.$timeout = $timeout;
                //if this controller becomes active for more than 
                //15 seconds, something maybe wrong and force a hard
                //reset of application
                var performReset = true;
                var timeoutPromise = $timeout(15000);
                timeoutPromise.then(function () {
                    if (performReset) {
                        storefrontService.hardReset();
                    }
                });
                //however, if controller is being unloaded before the
                //timeout, don't perform hard reset
                $scope.$on('$destroy', function () {
                    $timeout.cancel(timeoutPromise);
                    performReset = false;
                });
            }
            StorefrontSuppressionController.$inject = ["$scope", "StorefrontService", "$timeout"];
            return StorefrontSuppressionController;
        }());
        Controller.StorefrontSuppressionController = StorefrontSuppressionController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontSuppressionController", HCTRA.Controller.StorefrontSuppressionController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines the survey controller
        var StorefrontSurveyController = /** @class */ (function () {
            function StorefrontSurveyController($scope, storefrontService, $state, stateNames, $q) {
                var _this = this;
                this.$scope = $scope;
                this.storefrontService = storefrontService;
                this.$state = $state;
                this.stateNames = stateNames;
                this.$q = $q;
                this.done = function () {
                    _this.storefrontService
                        .reset()
                        .finally(function () { return _this.$state.go(_this.stateNames.storefrontHome); });
                };
                this.submit = function () {
                    //"submit" survey
                    _this.$scope.isSubmitting = true;
                    _this.storefrontService.saveSurveyResponse(_this.$scope.survey.selection, _this.$scope.survey.comments)
                        .finally(function () {
                        _this.$scope.isSubmitting = false;
                        _this.$scope.isSubmitted = true;
                    });
                };
                this.getCmsContent = function (id) {
                    return _this.storefrontService.getCmsItemById(_this.$state.current["cms"][id]);
                };
                if (this.storefrontService.isEnabled() && this.storefrontService.fullSiteMode) {
                    this.storefrontService.fullSiteMode = false;
                }
                $scope.done = this.done;
                $scope.submit = this.submit;
                $scope.survey = {
                    comments: null,
                    selection: null
                };
                $scope.isSubmitted = false;
                $scope.isSubmitting = false;
                $scope.canSubmitt = function (modelValue) { return (modelValue !== null); };
                this.getCmsContent("surveyId").then(function (res) {
                    $scope.surveyContent = res;
                    $scope.maxCommentsChars = res.maxCommentCharacters;
                    $scope.options = [
                        {
                            name: res.goodRatingText,
                            color: "rating-good",
                            selectedImageUrl: res.goodRatingIconSelected.image,
                            unSelectedImageUrl: res.goodRatingIconUnselected.image,
                            value: 1
                        },
                        {
                            name: res.neutralRatingText,
                            color: "rating-neutral",
                            selectedImageUrl: res.neutralRatingIconSelected.image,
                            unSelectedImageUrl: res.neutralRatingIconUnselected.image,
                            value: 0
                        },
                        {
                            name: res.badRatingText,
                            color: "rating-bad",
                            selectedImageUrl: res.badRatingIconSelected.image,
                            unSelectedImageUrl: res.badRatingIconUnselected.image,
                            value: -1
                        }
                    ];
                    _this.getCmsContent("surveyThankYouModalId").then(function (thankYouRes) {
                        $scope.thankYouMessage = thankYouRes.Title;
                        $scope.buttons = thankYouRes.buttons;
                    });
                    $scope.maxCharsReached = function () {
                        var chars = ($scope.survey.comments) ? ($scope.survey.comments.length >= ($scope.maxCommentsChars - 1)) : false;
                        return chars;
                    };
                    $scope.charRemaining = function () {
                        var remaining = ($scope.survey.comments) ? ($scope.maxCommentsChars - $scope.survey.comments.length) : $scope.maxCommentsChars;
                        return remaining;
                    };
                });
            }
            StorefrontSurveyController.$inject = ["$scope", "StorefrontService", "$state", "stateNames", "$q"];
            return StorefrontSurveyController;
        }());
        Controller.StorefrontSurveyController = StorefrontSurveyController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontSurveyController", HCTRA.Controller.StorefrontSurveyController);
})();
var HCTRA;
(function (HCTRA) {
    var Controller;
    (function (Controller) {
        //defines the task complete modal
        var StorefrontTaskCompleteController = /** @class */ (function () {
            function StorefrontTaskCompleteController($scope, $uibModalInstance, modalOptions, storefrontService, storefrontModalService, actions, cmsTextInsertionService) {
                this.$scope = $scope;
                this.$uibModalInstance = $uibModalInstance;
                this.modalOptions = modalOptions;
                this.storefrontService = storefrontService;
                this.storefrontModalService = storefrontModalService;
                this.actions = actions;
                this.cmsTextInsertionService = cmsTextInsertionService;
                $scope.completeTaskCount = storefrontService.workItems.filter(function (x) { return x.isSelected && x.isCompleted && !x.isShadowItem; }).length;
                $scope.selectedTaskCount = storefrontService.workItems.filter(function (x) { return x.isSelected && !x.isShadowItem; }).length;
                var insertionValues = {
                    completeTaskCount: $scope.completeTaskCount,
                    selectedTaskCount: $scope.selectedTaskCount
                };
                $scope.body = this.cmsTextInsertionService.insertValues(insertionValues, modalOptions.bodyText);
                $scope.header = modalOptions.headerText;
                $scope.actionText = function (action) { return actions && actions[action]; };
                $scope.call = function (action) { return $uibModalInstance.close(action); };
                $scope.actions = actions;
                $scope.addWorkItem = function (workItemIdAsString) {
                    var workItemId = HCTRA.Model.SelectedOptions[workItemIdAsString];
                    var workItem = storefrontService.insertWorkItem(workItemId);
                    storefrontService
                        .skip(workItemId)
                        .then(function () { return $uibModalInstance.close(workItem); });
                };
            }
            StorefrontTaskCompleteController.$inject = [
                "$scope", "$uibModalInstance", "modalOptions", "StorefrontService", "StorefrontModalService", "actions", "cmsTextInsertionService"
            ];
            return StorefrontTaskCompleteController;
        }());
        Controller.StorefrontTaskCompleteController = StorefrontTaskCompleteController;
    })(Controller = HCTRA.Controller || (HCTRA.Controller = {}));
})(HCTRA || (HCTRA = {}));
(function () {
    'use strict';
    angular.module('HCTRAModule').controller("StorefrontTaskCompleteController", HCTRA.Controller.StorefrontTaskCompleteController);
})();
(function () {
    'use strict';
    describe('ManagePaymentParentController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, displayedMessage = {
            value: ""
        }, inState = {
            statePath: ""
        };
        var billingInfoUtilitiesService;
        beforeEach(angular.mock.module(function ($provide) {
            billingInfoUtilitiesService = jasmine.createSpyObj('billingInfoUtilitiesService', ['isInternationalAddress', 'hasMultipleCards', 'isPrimaryCCAvailable', 'hasNoBillingInfo']);
            billingInfoUtilitiesService.isInternationalAddress.and.returnValue(false);
            $provide.value('billingInfoUtilitiesService', billingInfoUtilitiesService);
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('billingInfoStateManagerService', hctraMocks.billingInfoStateManagerService());
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('countryConversionService', hctraMocks.countryConversionService());
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            $controller('ManagePaymentParentController', { $scope: scope });
        }));
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        it('should return data from API', function () {
            expect(scope.billingType).toBe('CREDIT');
        });
        it('should take you to previous page, not back button/function', function () {
        });
    });
}());
(function () {
    "use strict";
    //describe() begins a unit testing fixture
    describe("CreateAccountController", function () {
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, controller, inState = {
            value: ""
        }, newAccountObj = {
            paymentExists: true,
            localDataExists: true
        }, authObj = {
            isAuthenticated: false
        }, inHctraSession = {
            value: ""
        }, inSession = {
            acctActivity: null
        }, responseErrorServiceMock = {
            displayErrorsFromResponse: function () { },
            isErrorFree: function () { return true; }
        }, currentUserMock = {
            updateCurrentUser: function () { }
        }, genericRepoMock = {
            dataFactory: {
                setupAccountStep1: function () {
                    return {
                        then: function (cb) {
                            cb({ newAccountStep: { currentStep: 100 } });
                        }
                    };
                },
                getPersonalInfo: function () {
                    return {
                        then: function () {
                            return {
                                then: function () { },
                                finally: function () { }
                            };
                        }
                    };
                },
                getSecurityQuestions: function () {
                    return {
                        then: function () {
                            return {
                                then: function () { },
                                finally: function () { }
                            };
                        }
                    };
                },
                getCmsPageById: function () {
                    return {
                        then: function () {
                            return {
                                then: function () { },
                                finally: function () { }
                            };
                        }
                    };
                }
            }
        };
        var stringUtilsMock;
        //$provide is a module-level object, and thus must get its own 
        //injection through the angular.mock.module() function
        beforeEach(angular.mock.module(function ($provide) {
            //"$state", "newAccountService", "responseErrorService", "genericRepo", "AuthService", "stateNames"
            stringUtilsMock = {
                getParameterObject: function () { }
            },
                spyOn(stringUtilsMock, "getParameterObject").and.returnValue({
                    MinPassword: 'Must be at least 12 characters.',
                    MaxPassword: 'Must be no more than 50 characters.',
                    PasswordPlaceholder: 'min. 12 characters',
                    InvalidCharacter: 'Password contains invalid characters.'
                });
            $provide.value("stringUtilsService", stringUtilsMock);
            $provide.value("$state", hctraMocks.$state(inState));
            $provide.value("stateNames", hctraMocks.stateNames());
            $provide.value("genericRepo", genericRepoMock);
            $provide.value("newAccountService", hctraMocks.newAccountService(newAccountObj));
            $provide.value("AuthService", hctraMocks.AuthService(authObj));
            $provide.value("responseErrorService", responseErrorServiceMock);
            $provide.value("AUTH_EVENTS", hctraMocks.AUTH_EVENTS());
            $provide.value("hctraSessionLogin", hctraMocks.hctraSessionLogin(inHctraSession));
            $provide.value("SessionService", hctraMocks.Session(inSession));
            $provide.value("NamesToCurrentUserService", hctraMocks.NamesToCurrentUserService());
            $provide.value("CurrentUser", currentUserMock);
        }));
        //inject() injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile) {
            //create new, empty ng scope and controller objects
            scope = $rootScope.$new();
            var rootScope = $rootScope;
            controller = $controller("CreateAccountController", { $scope: scope, $rootScope: rootScope });
            $templateCache.put("/app/templates/newAccount/step1/setupAccountLoginPartial.html", $templateCache.get("app/templates/newAccount/step1/setupAccountLoginPartial.html"));
            // compile the template and add it to the scope
            var templateHtml = $templateCache.get("app/templates/newAccount/step1/createAccount.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        //begin an actual, trivial test
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("should accept valid company name", function () {
            scope.accountInfo.companyName = "testcompanyname";
            scope.$digest();
            expect(scope.form.personalAccountForm.companyName.$valid).toBeTruthy();
            scope.accountInfo.companyName = "thisIs100characters.thisIs100characters.thisIs100characters.thisIs100characters.thisIs100characters.";
            scope.$digest();
            expect(scope.form.personalAccountForm.companyName.$valid).toBeTruthy();
        });
        it("should reject an invalid company name", function () {
            scope.accountInfo.companyName = "testcompany*";
            scope.$digest();
            expect(scope.form.personalAccountForm.companyName.$valid).toBeFalsy();
            scope.accountInfo.companyName = "thisIs101characters.thisIs101characters.thisIs101characters.thisIs101characters.thisIs101characters.1";
            scope.$digest();
            expect(scope.form.personalAccountForm.companyName.$valid).toBeFalsy();
        });
        it("should accept valid username", function () {
            scope.accountInfo.username = "testusername";
            scope.$digest();
            expect(scope.form.personalAccountForm.username.$valid).toBeTruthy();
        });
        it("should reject an invalid username", function () {
            scope.accountInfo.username = "testu";
            scope.$digest();
            expect(scope.form.personalAccountForm.username.$valid).toBeFalsy();
            scope.accountInfo.username = "testusername!!!!";
            scope.$digest();
            expect(scope.form.personalAccountForm.username.$valid).toBeFalsy();
            scope.accountInfo.username = "test username";
            scope.$digest();
            expect(scope.form.personalAccountForm.username.$valid).toBeFalsy();
        });
        it("should accept valid password", function () {
            scope.accountInfo.password = "password~!@#$^&*()_+";
            scope.$digest();
            expect(scope.form.personalAccountForm.password.$valid).toBeTruthy();
        });
        it("should reject an invalid password", function () {
            scope.accountInfo.password = "passwor";
            scope.$digest();
            expect(scope.form.personalAccountForm.password.$valid).toBeFalsy();
            scope.accountInfo.password = "password!!!!password!!!!password!!!!password!!!!password!!!!password!!!!";
            scope.$digest();
            expect(scope.form.personalAccountForm.password.$valid).toBeFalsy();
            scope.accountInfo.password = "password123456%";
            scope.$digest();
            expect(scope.form.personalAccountForm.password.$valid).toBeFalsy();
        });
        it("should accept valid security question answer", function () {
            scope.accountInfo.securityQuestionAnswer = "My answer";
            scope.$digest();
            expect(scope.form.personalAccountForm.yourAnswer.$valid).toBeTruthy();
        });
        it("should reject an invalid security question answer", function () {
            scope.accountInfo.securityQuestionAnswer = "";
            scope.$digest();
            expect(scope.form.personalAccountForm.yourAnswer.$valid).toBeFalsy();
            scope.accountInfo.securityQuestionAnswer = "password!!!!";
            scope.$digest();
            expect(scope.form.personalAccountForm.yourAnswer.$valid).toBeFalsy();
        });
        it("should call getCmsPageById and assign cms variables", function () {
            var res = {
                errors: [],
                cmsResponse: angular.toJson({
                    LongDescription: 'This is the long description',
                    Parameters: angular.toJson({ MinPassword: 'Must be at least 12 characters.', MaxPassword: 'Must be no more than 50 characters.', PasswordPlaceholder: 'min. 12 characters', InvalidCharacter: 'Password contains invalid characters.' })
                })
            };
            scope.createAccVM = {};
            controller.populateCmsParams(res);
            expect(scope.createAccVM.existingEzTagNotice).toEqual("This is the long description");
            expect(scope.createAccVM.pwPlaceHolder).toEqual("min. 12 characters");
            expect(scope.createAccVM.minPassword).toEqual("Must be at least 12 characters.");
            expect(scope.createAccVM.maxPassword).toEqual("Must be no more than 50 characters.");
            expect(scope.createAccVM.invalidCharacter).toEqual("Password contains invalid characters.");
        });
        it("should call on responseErrorService if there are errors", function () {
            var res = {
                errors: ["one error"]
            };
            spyOn(responseErrorServiceMock, "isErrorFree").and.returnValue(false);
            controller.populateCmsParams(res);
            expect(responseErrorServiceMock.isErrorFree).toHaveBeenCalledTimes(1);
            //expect(angular.fromJson).toHaveBeenCalledTimes(0);
        });
        it("should call CurrentUser.updateCurrentUser() in onSubmit()", function () {
            //Assemble
            spyOn(currentUserMock, "updateCurrentUser");
            scope.isLoggedIn = false;
            spyOn(responseErrorServiceMock, "isErrorFree").and.returnValue(true);
            //Act
            controller.onSubmit(true);
            //Assert
            expect(currentUserMock.updateCurrentUser).toHaveBeenCalledTimes(1);
        });
    });
}());
(function () {
    "use strict";
    //describe() begins a unit testing fixture
    describe("CreateAccountDetailsController", function () {
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, inState = {
            value: ""
        }, newAccountObj = {
            paymentExists: true
        }, displayedMessage = {
            value: ""
        }, inSession = {
            acctActivity: null
        }, rootScope;
        var billingInfoUtilitiesService;
        //$provide is a module-level object, and thus must get its own 
        //injection through the angular.mock.module() function
        beforeEach(angular.mock.module(function ($provide) {
            //"genericRepo", "newAccountService", "stateNames", "$state"
            billingInfoUtilitiesService = jasmine.createSpyObj('billingInfoUtilitiesService', ['isInternationalAddress', 'hasNoBillingInfo']);
            billingInfoUtilitiesService.isInternationalAddress.and.returnValue(false);
            $provide.value('billingInfoUtilitiesService', billingInfoUtilitiesService);
            $provide.value("$state", hctraMocks.$state(inState));
            $provide.value("stateNames", hctraMocks.stateNames());
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("newAccountService", hctraMocks.newAccountService(newAccountObj));
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
            $provide.value("SessionService", hctraMocks.Session(inSession));
            $provide.value("NamesToCurrentUserService", hctraMocks.NamesToCurrentUserService());
            $provide.value("countryConversionService", hctraMocks.countryConversionService());
            $provide.value("CurrentUser", hctraMocks.CurrentUser());
        }));
        //inject() injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile) {
            //create new, empty ng scope and controller objects
            scope = $rootScope.$new();
            rootScope = $rootScope;
            //create the controller
            $controller("CreateAccountDetailsController", { $scope: scope, $rootScope: rootScope });
            $templateCache.put("/app/templates/newAccount/step2/phoneAddressInfoPartial.html", $templateCache.get("app/templates/newAccount/step2/phoneAddressInfoPartial.html"));
            $templateCache.put("/app/directives/contactEntry/primaryPhone.html", $templateCache.get("app/directives/contactEntry/primaryPhone.html"));
            $templateCache.put("/app/directives/contactEntry/phoneNumberAndExt.html", $templateCache.get("app/directives/contactEntry/phoneNumberAndExt.html"));
            $templateCache.put("/app/directives/violations/step2/addressEntryTemplate.html", $templateCache.get("app/directives/Violations/step2/addressEntryTemplate.html"));
            $templateCache.put("/app/directives/contactEntry/authorizedContactEntry.html", $templateCache.get("app/directives/contactEntry/authorizedContactEntry.html"));
            $templateCache.put("/app/directives/contactEntry/accountPreferences.html", $templateCache.get("app/directives/contactEntry/accountPreferences.html"));
            var templateHtml = $templateCache.get("app/templates/newAccount/step2/createAccountDetails.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        //begin an actual, trivial test
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("should default to TX as state for license and address", function () {
            expect(scope.accountDetails.driverLicState).toBe("TX");
            expect(scope.accountDetails.state).toBe("TX");
        });
        it("should have a defined form that is invalid", function () {
            expect(scope.form.personalInformationForm).toBeDefined();
            expect(scope.form.personalInformationForm.$valid).toBeFalsy();
        });
        it("should pass validation if valid number given to zip", function () {
            scope.accountDetails.zip = "12345";
            scope.$digest();
            expect(scope.form.personalInformationForm.zipCode.$valid).toBeTruthy();
        });
        it("should fail validation if invalid number given to zip", function () {
            scope.accountDetails.zip = "1234";
            scope.$digest();
            expect(scope.form.personalInformationForm.zipCode.$valid).toBeFalsy();
            scope.accountDetails.zip = "123456";
            scope.$digest();
            expect(scope.form.personalInformationForm.zipCode.$valid).toBeFalsy();
            scope.accountDetails.zip = "";
            scope.$digest();
            expect(scope.form.personalInformationForm.zipCode.$valid).toBeFalsy();
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('AddEZTAGController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, AddEZTAGController, inState = {
            value: ""
        }, newAccountObj = {
            paymentExists: true
            // Requirement 60300: Motorocycle flag change
            //inVehicleList: [{
            //    transactionId: 'data',
            //    licState: 'TX',
            //    licPlate: 123456
            //},
            //{
            //    transactionId: 'data2',
            //    licState: 'TX',
            //    licPlate: 1234
            //}]
        }, displayedMessage = {
            value: ""
        }, rootScope, stateNames, tagListConfigObj = {
            accountTags: [
                { transactionId: 98743294 },
                { transactionId: 19098453 }
            ],
            accountTagsExists: true
        };
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            //'localDataRepo'
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('tagList', hctraMocks.tagListConfigurable(tagListConfigObj));
            $provide.value('newAccountService', hctraMocks.newAccountService(newAccountObj));
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('localDataRepo', hctraMocks.localDataRepo());
            $provide.value('modalService', hctraMocks.modalService({}, {}));
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, _stateNames_) {
            //create new, empty ng scope and controller objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            rootScope = _$rootScope_;
            stateNames = _stateNames_;
            //create the controller
            AddEZTAGController = $controller('AddEZTAGController', { $scope: scope, $rootScope: rootScope });
        }));
        beforeEach(function () {
            tagListConfigObj.accountTags = [
                { transactionId: 98743294 },
                { transactionId: 19098453 }
            ];
            tagListConfigObj.accountTagsExists = true;
        });
        //begin an actual, trivial test
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        it('should return true from hasVehicles', function () {
            expect(scope.hasVehicles()).toBeTruthy();
        });
        // Requirement 60300: Motorocycle flag change
        //it('should return true from hasVehicles if session has data', function () {
        //    expect(scope.hasVehicles()).toBeTruthy();
        //});
        //describe('if there are no vehicles in the list', function () {
        //    beforeEach(function () {
        //        tagListConfigObj.accountTags = [];
        //        tagListConfigObj.accountTagsExists = false;
        //    });
        //    xit('should route to vehicleInformation', function () {
        //        //scope.hasVehicles = function () { return false; } // no vehicles
        //        expect(inState.value).toBe(stateNames.vehicleInformation);
        //    });
        //});
        //describe('if there is only one vehicle in the list and it is deleted', function () {
        //    beforeEach(function () {
        //        tagListConfigObj.accountTags = [
        //            { transactionId: 98743294 }
        //        ];
        //        tagListConfigObj.accountTagsExists = true;
        //    });
        //    xit('should route to vehicleInformation if no vehicles in list after delete', function () {
        //        //scope.hasVehicles = function () { return false; } // no vehicles
        //        scope.onDelete(0);
        //        expect(inState.value).toBe(stateNames.vehicleInformation);
        //    });
        //});
        it('should route to addAdditionalVehicle if at least one vehicle in list', function () {
            expect(inState.value).toBe(stateNames.addAdditionalVehicle);
        });
        it('should return correct class given a valid class id', function () {
            var x = 2;
            expect(scope.classIdToLabel(x)).toBe("2-Axles");
            x = 3;
            expect(scope.classIdToLabel(x)).toBe("3-Axles");
            x = 4;
            expect(scope.classIdToLabel(x)).toBe("4-Axles");
            x = 5;
            expect(scope.classIdToLabel(x)).toBe("5-Axles");
            x = 6;
            expect(scope.classIdToLabel(x)).toBe("6+-Axles");
        });
        it('should route to addAdditionalVehicle if at least one vehicle in list after delete', function () {
            scope.onDelete(0);
            expect(inState.value).toBe(stateNames.addAdditionalVehicle);
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('VehicleInformationController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, VehicleInformationController, inState = {
            value: ""
        }, displayedMessage = {
            value: ""
        }, newAccountObj = {
            paymentExists: true
        }, rootScope;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            //'genericRepo', 'newAccountService'
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('newAccountService', hctraMocks.newAccountService(newAccountObj));
            $provide.value('modalService', hctraMocks.modalService({}, {}));
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
            //create new, empty ng scope and controller objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            rootScope = _$rootScope_;
            scope.repoName = "addEZTag";
            scope.vehicleList = [];
            scope.$parent.vehicleList = scope.vehicleList;
            scope.form = {};
            //create the controller
            VehicleInformationController = $controller('VehicleInformationController', { $scope: scope, $rootScope: rootScope });
        }));
        //begin an actual, trivial test
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        it('should result in transactionId of 1234567 in newAccountService after onSubmit', function () {
            scope.onSubmit(true);
            expect(newAccountObj.transactionId).toBe(1234567);
        });
        it('should correctly set payment data in newAccountService', function () {
            scope.onSubmit(true);
            expect(newAccountObj.payment.tagSalesAmt).toBe(15);
            expect(newAccountObj.payment.depositAmt).toBe(40);
            expect(newAccountObj.payment.totalAmt).toBe(40);
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('AddBankAccountController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, AddBankAccountController, templateCache, compile, displayedMessage = {
            value: ""
        }, inState = {
            value: ""
        }, newAccountObj = {
            paymentExists: true
        }, inSession = {
            savedStep: ""
        }, rootScope;
        var mockEftAchDisclaimer = { ngOnInit: function () { } };
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            // '$state', 'removeDoubleCharService', 'genericRepo', 'responseErrorService', 'stateNames'
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('newAccountService', hctraMocks.newAccountService(newAccountObj));
            $provide.value('SessionService', hctraMocks.Session(inSession));
            $provide.value('eftAchDisclaimer', mockEftAchDisclaimer);
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, _$injector_, $templateCache, $compile) {
            //create new, empty ng scope and controller objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            templateCache = $templateCache;
            compile = $compile;
            rootScope = _$rootScope_;
            scope.bankDetails = {};
            scope.accountDetails = {};
            scope.paymentInfo = {};
            inState.value = '';
            //create the controller
            AddBankAccountController = $controller('AddBankAccountController', { $scope: scope, $rootScope: rootScope });
            //add the template to the cache
            $templateCache.put('bankAccount.html', '<form name="paymentEntry" novalidate> <div> <div class="form-group" ng-class="getErrorStatusClass(\'bankAccountType\')"> <label for="bankAccountType">Bank Account Type</label> <select name="bankAccountType" id="bankAccountType" class="form-control" ng-options="c.val as c.txt for c in bankDetails.types" ng-model="bankDetails.accountType" required> <option ng-show="bankDetails.accountType==\'\'" value="">Select Bank Account Type</option> </select> <div ng-messages="getErrorList(\'bankAccountType\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please select the account type</p> </div> </div> <div class="form-group" ng-class="getErrorStatusClass(\'routing\')"> <label for="routing">Routing Number</label> <input type="text" class="form-control" ng-model="bankDetails.routingNumber" required name="routing" ng-pattern="/^\\d{9}$/" /> <div ng-messages="getErrorList(\'routing\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter the routing number</p> <p ng-message="pattern" class="help-block">Not a valid routing number</p> </div> <!-- TODO Add the real URL for this link --> <p><a href="#">Routing Number</a> - first group of numbers of your check</p> </div> <div class="form-group" ng-class="getErrorStatusClass(\'account\')"> <label for="account">Account Number</label> <input type="text" class="form-control" ng-model="bankDetails.accountNumber" required name="account" ng-pattern="/^(\\d*|\\*{12}\\d{4})$/" ng-maxlength="17" /> <div ng-messages="getErrorList(\'account\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter the account number</p> <p ng-message="maxlength" class="help-block">Must be no more than 17 characters</p> <p ng-message="pattern" class="help-block">Not a valid account number</p> </div> <!-- TODO Add the real URL for this link --> <p><a href="#">Account Number</a> - second group of numbers of your check</p> </div> <div class="form-group" ng-class="getErrorStatusClass(\'account2\')"> <label for="account2">Confirm Account Number</label> <input type="text" class="form-control" ng-model="bankDetails.account2" required compare-to="bankDetails.accountNumber" name="account2" /> <div ng-messages="getErrorList(\'account2\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please confirm the account number</p> <p ng-message="compareTo" class="help-block">Account numbers do not match</p> </div> </div></div> <div> <h3>EZ TAG Agreement</h3> <!--TODO: 2 different out-of-scope links on this page--> <p>Before moving forward, please review the <a href="#">EZ Agreement</a>. Here\'s a short summary of the major points of the agreement:</p> <p>You must <strong>maintain updated credit card (account number/expiration date)</strong> or other payment information to maintain an active account.</p> <p>You must <strong>maintain updated license plate information</strong> to maintain an active account.</p> <p>You must <strong>maintain updated address and other contact information</strong>.</p> <p>You must notify HCTRA immediately if the EZ TAG is lost, stolen or damaged.</p> <p>It is your responsibility to <strong>maintain an EZ TAG Account balance</strong> sufficient to cover all toll transactions and other authorized transactions.<strong>If the County is unable to charge or debit your account and the EZ TAG balance falls below zero, continued use of your EZ TAG may result in violations.</strong> Then your account will be suspended until violation issues are resolved and updated account information is received by the County.</p> <!-- TODO Add the real link to e-mail support--> <p>If you have any questions, please <a href="#">e-mail support.</a></p></div> <div ng-class="getErrorStatusClass(\'accept\')"> <span class="checkbox"><input type="checkbox" ng-model="paymentInfo.accept" name="accept" required />I agree to the EZ Agreement</span> <div ng-messages="getErrorList(\'accept\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">You must accept the agreement</p> </div> </div> <!--<div class="pull-right"> <button ng-click="submitBK(paymentEntry.$valid)" class="btn btn-lg">Continue</button> </div>--> <div class="row wizard-btn-margins"> <div class="col-xs-6 col-sm-3 no-padding-left"> <a href="" ui-sref="{{previousDestName}}" class="pull-left">Previous</a> </div> <div class="col-xs-6 col-sm-3 no-padding-right"> <button type="submit" ng-click="submitBK(paymentEntry.$valid)" class="btn btn-default pull-right">Continue</button> </div> </div></form>');
            //compile the template and add it to the scope
            var templateHtml = templateCache.get('bankAccount.html');
            var formElem = angular.element(templateHtml);
            compile(formElem)(scope);
            scope.$digest();
        }));
        //begin an actual, trivial test
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        //Begin testing validations
        it('should invalidate form at first', function () {
            expect(scope.paymentEntry.$invalid).toBeTruthy();
        });
        //reverse of last test
        it('should not have a valid form at first', function () {
            expect(scope.paymentEntry.$valid).toBeFalsy();
        });
        it('should change state if submitted and form is valid', function () {
            scope.apiAction = "update";
            scope.submitBK(true);
            expect(inState.value).toBe('NewAccount.CreateAccountSummary');
        });
        it('should not change state if submitted and form is invalid', function () {
            scope.submitBK(false);
            expect(inState.value).toBe('');
        });
        it('should have a valid form if all inputs valid', function () {
            scope.bankDetails.routingNumber = "123456789";
            scope.bankDetails.accountNumber = "1234567";
            scope.bankDetails.account2 = "1234567";
            scope.bankDetails.accountType = "business";
            scope.paymentInfo.accept = true;
            scope.$digest();
            expect(scope.paymentEntry.$valid).toBeTruthy();
        });
        it('should have invalid form if an input is invalid', function () {
            scope.bankDetails.routingNumber = "1234567890";
            scope.bankDetails.accountNumber = "1234567";
            scope.bankDetails.account2 = "1234567";
            scope.bankDetails.accountType = "business";
            scope.paymentInfo.accept = true;
            scope.$digest();
            expect(scope.paymentEntry.$valid).toBeFalsy();
        });
        it('should have invalid input if routingNumber is not 9 digits', function () {
            scope.bankDetails.routingNumber = "1234567890";
            scope.$digest();
            expect(scope.paymentEntry.routing.$valid).toBeFalsy();
            scope.bankDetails.routingNumber = "12345678";
            scope.$digest();
            expect(scope.paymentEntry.routing.$valid).toBeFalsy();
        });
        it('should have maximum accountNumber of 17 digits', function () {
            scope.bankDetails.accountNumber = "1";
            scope.$digest();
            expect(scope.paymentEntry.account.$valid).toBeTruthy();
            scope.bankDetails.accountNumber = "1234567890123456";
            scope.$digest();
            expect(scope.paymentEntry.account.$valid).toBeTruthy();
            scope.bankDetails.accountNumber = "12345678901234567";
            scope.$digest();
            expect(scope.paymentEntry.account.$valid).toBeTruthy();
            scope.bankDetails.accountNumber = "123456789012345678";
            scope.$digest();
            expect(scope.paymentEntry.account.$valid).toBeFalsy();
        });
        it('should accept accountNumber with 12 asterisks followed by 4 digits', function () {
            scope.bankDetails.accountNumber = "************1234";
            scope.$digest();
            expect(scope.paymentEntry.account.$valid).toBeTruthy();
            scope.bankDetails.accountNumber = "***********1234";
            scope.$digest();
            expect(scope.paymentEntry.account.$valid).toBeFalsy();
            scope.bankDetails.accountNumber = "************134";
            scope.$digest();
            expect(scope.paymentEntry.account.$valid).toBeFalsy();
        });
    });
}());
(function () {
    'use strict';
    describe('AddCreditCardController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, AddCreditCardController, displayedMessage = {
            value: ""
        }, inState = {
            value: ""
        }, newAccountObj = {
            paymentExists: true
        }, inSession = {};
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('removeDoubleCharService', hctraMocks.removeDoubleCharService());
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('newAccountService', hctraMocks.newAccountService(newAccountObj));
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('SessionService', hctraMocks.Session(inSession));
            $provide.value('validationService', hctraMocks.validationService());
            $provide.value('countryConversionService', hctraMocks.countryConversionService());
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile) {
            //create new, empty ng scope and controller objects
            scope = $rootScope.$new();
            scope.accountDetails = {};
            scope.paymentInfo = {};
            scope.mailingAddress = {};
            scope.creditCard = {
                cardNbr: null,
                cardCode: null,
                cardTypeDisplay: null,
                nameOnCard: null,
                expMonth: null,
                selectedYear: null,
                cardExpires: null,
                accountBillingMethodId: null,
                paypageRegistrationId: null,
                omniToken: null,
                isNewCard: null
            };
            inState.value = '';
            //create the controller
            AddCreditCardController = $controller('AddCreditCardController', { $scope: scope, $rootScope: $rootScope });
            //add the template to the cache
            $templateCache.put('creditCard.html', ' <form name="paymentEntry" novalidate> <div> <div class="form-group" ng-class="getErrorStatusClass(\'nameOnCard\')"> <label for="cardName">Name on Credit Card</label> <input type="text" ng-change="removeDoubles(creditCard, \'nameOnCard\')" class="form-control" ng-model="creditCard.nameOnCard" required name="nameOnCard" ng-pattern="/^[0-9a-zA-Z\-\,\.\\\'\s]*$/" /> <div ng-messages="getErrorList(\'nameOnCard\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter the name on the card</p> <p ng-message="pattern" class="help-block">Not a valid card name</p> </div> </div> <div class="form-group" ng-class="getErrorStatusClass(\'creditCardType\')"> <label for="cardType">Credit Card Type</label> <select ng-model="creditCard.cardCode" class="form-control" name="creditCardType" ng-options="c.cardCode as c.cardName for c in creditCard.types" required> <option ng-show="creditCard.cardCode==\'\'" value="">Select Credit Card Type</option> </select> <div ng-messages="getErrorList(\'creditCardType\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter the type of your credit card</p> </div> </div> <div class="form-group" ng-class="getErrorStatusClass(\'cardNumber\')"> <label for="cardNumber">Credit Card Number</label> <input type="text" name="cardNumber" class="form-control" ng-model="creditCard.cardNbr" ng-minlength="13" ng-maxlength="19" required luhn allow-masked/> <div ng-messages="getErrorList(\'cardNumber\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter your credit card number</p> <p ng-message="minlength" class="help-block">Must be at least 13 characters</p> <p ng-message="maxlength" class="help-block">Must be no more than 19 characters</p> <p ng-message="luhn" class="help-block">This is not a valid credit card number</p> </div> </div> <div class="row"> <p style="margin-left:1.2em"><strong>Card Expiration Date</strong></p> <div> <div class="col-xs-7" ng-class="getErrorStatusClass(\'expMonth\')"> <label for="expMonth" class="sr-only">Please enter credit card expiration month</label> <select name="expMonth" class="form-control" ng-model="creditCard.expMonth" id="expMonth" required ng-options="month.value as month.label for month in months"> <option value="" disabled selected></option> </select> <div ng-messages="getErrorList(\'expMonth\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter the expiration month on the card</p> </div> </div> <div class="col-xs-5" ng-class="getErrorStatusClass(\'expYear\')"> <label for="expYear" class="sr-only">Please enter the expiration year on your credit card.</label> <select name="expYear" id="driverState" class="form-control" required ng-options="year for year in yearList track by year" ng-model="creditCard.selectedYear" ng-change="onYearChange()"> <option value="" disabled selected></option> </select> <div ng-messages="getErrorList(\'expYear\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter the expiration year on the card</p> </div> </div> </div> </div> <h3 style="margin-top: 2.5em">Credit Card Billing Address</h3> <span class="checkbox"><input type="checkbox" ng-model="paymentInfo.sameAddress" name="billingAddressSame" checked="checked" />Same as mailing address</span> <div ng-if="(paymentInfo.sameAddress)" class="group-paragraphs tab-23"> <p>{{mailingAddress.firstName + " " + mailingAddress.lastName}}</p> <p>{{mailingAddress.address1}}</p> <p>{{mailingAddress.city + ", " + mailingAddress.state + " " + mailingAddress.zip + (mailingAddress.plus4 ? "-" : "") + mailingAddress.plus4}}</p> <!--<p></p>--> </div> <div ng-if="(!paymentInfo.sameAddress)"><div class="form-group" ng-class="getErrorStatusClass(\'addressLine1\')"> <label for="addressLine1">Address Line 1</label> <input id="addressLine1" name="addressLine1" ng-model="accountDetails.address1" class="form-control" type="text" required ng-maxlength="127" ng-pattern="/^[0-9a-zA-Z\\#\\.\\:\\\'\\/\\-\\,\s]*$/" /> <div ng-messages="getErrorList(\'addressLine1\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter a value</p> <p ng-message="maxlength" class="help-block">Must be 127 characters or less</p> <p ng-message="pattern" class="help-block">Not a valid Address</p> </div></div><div class="form-group" ng-class="getErrorStatusClass(\'addressLine2\')"> <label for="addressLine2">Address Line 2</label> <input id="addressLine2" name="addressLine2" ng-model="accountDetails.address2" class="form-control" type="text" ng-maxlength="127" ng-pattern="/^[0-9a-zA-Z\\#\\.\\:\\\'\\/\\-\\,\s]*$/" /> <div ng-messages="getErrorList(\'addressLine2\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="maxlength" class="help-block">Must be 127 characters or less</p> <p ng-message="pattern" class="help-block">Not a valid Address</p> </div></div><div class="form-group" ng-class="getErrorStatusClass(\'city\')"> <label for="city">City</label> <input id="city" name="city" ng-model="accountDetails.city" class="form-control" type="text" required /> <div ng-messages="getErrorList(\'city\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">Please enter a value</p> </div> <p>Military Address please enter \'APO\' or \'FFO\'</p></div><div class="form-group row no-margin"> <label for="addressState">State</label> <div id="addressState"> <div class="col-xs-4 no-padding-left"> <select name="state" ng-model=\'accountDetails.state\' ng-options="state.stateCode as state.stateCode for state in stateList" class="form-control"></select> </div> </div></div><div class="form-group row no-margin"> <label for="zipCode">Zip Code</label> <div id="zipCode"> <div class="col-xs-7 no-padding-left" ng-class="getErrorStatusClass(\'zipCode\')"> <input type="text" name="zipCode" ng-model="accountDetails.zip" class="form-control" required ng-pattern="/^\d{5}$/" /> </div> <div class="col-xs-1 no-padding vcenter text-center"> - </div> <div class="col-xs-4 no-padding-right"> <label for="plus4" class="sr-only">Zip Code Plus Four Extension</label> <input type="text" id="plus4" name="plus4" ng-model="accountDetails.plus4" class="form-control" ng-pattern="/^\d{4}$/" ng-class="getErrorStatusClass(\'plus4\')" /> </div> </div> <div ng-messages="getErrorList(\'zipCode\')" ng-if="hasSubmitted()" role="alert" ng-class="getErrorStatusClass(\'zipCode\')"> <p ng-message="required" class="help-block">Please enter a value</p> <p ng-message="pattern" class="help-block">Not a valid zip code</p> </div> <div ng-messages="getErrorList(\'plus4\')" ng-if="hasSubmitted()" role="alert" ng-class="getErrorStatusClass(\'plus4\')"> <p ng-message="pattern" class="help-block">Zip extension must be four digits</p> </div></div></div> <div> <h3>EZ TAG Agreement</h3> <!--TODO: 2 different out-of-scope links on this page--> <p>Before moving forward, please review the <a href="#">EZ Agreement</a>. Here\'s a short summary of the major points of the agreement:</p> <p>You must <strong>maintain updated credit card (account number/expiration date)</strong> or other payment information to maintain an active account.</p> <p>You must <strong>maintain updated license plate information</strong> to maintain an active account.</p> <p>You must <strong>maintain updated address and other contact information</strong>.</p> <p>You must notify HCTRA immediately if the EZ TAG is lost, stolen or damaged.</p> <p>It is your responsibility to <strong>maintain an EZ TAG Account balance</strong> sufficient to cover all toll transactions and other authorized transactions.<strong>If the County is unable to charge or debit your account and the EZ TAG balance falls below zero, continued use of your EZ TAG may result in violations.</strong> Then your account will be suspended until violation issues are resolved and updated account information is received by the County.</p> <!-- TODO Add the real link to e-mail support--> <p>If you have any questions, please <a href="#">e-mail support.</a></p></div> <div ng-class="getErrorStatusClass(\'accept\')"> <span class="checkbox"><input type="checkbox" ng-model="paymentInfo.accept" name="accept" required />I agree to the EZ Agreement</span> <div ng-messages="getErrorList(\'accept\')" ng-if="hasSubmitted()" role="alert"> <p ng-message="required" class="help-block">You must accept the agreement</p> </div> </div> <!--<div class="pull-right"> <button ng-click="submitCC(paymentEntry.$valid)" class="btn btn-lg">Continue</button> </div>--> <div class="row wizard-btn-margins"> <div class="col-xs-6 col-sm-3 no-padding-left"> <a href="" ui-sref="{{previousDestName}}" class="pull-left">Previous</a> </div> <div class="col-xs-6 col-sm-3 no-padding-right"> <button type="submit" ng-click="submitCC(paymentEntry.$valid)" class="btn btn-default pull-right">Continue</button> </div> </div> </form>');
            //compile the template and add it to the scope
            var templateHtml = $templateCache.get('creditCard.html');
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        //begin an actual, trivial test
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        //Begin testing validations
        it('should invalidate form at first', function () {
            expect(scope.paymentEntry.$invalid).toBeTruthy();
        });
        //reverse of last test
        it('should not have a valid form at first', function () {
            expect(scope.paymentEntry.$valid).toBeFalsy();
        });
        it('should be valid for proper credit card number', function () {
            scope.creditCard.cardNbr = "4111111111111111";
            scope.$digest();
            expect(scope.paymentEntry.cardNumber.$valid).toBeTruthy();
            scope.creditCard.cardNbr = "4556666488020742";
            scope.$digest();
            expect(scope.paymentEntry.cardNumber.$valid).toBeTruthy();
        });
        describe('Same Address not checked', function () {
            beforeEach(function () {
                scope.paymentInfo.sameAddress = false;
            });
            it('should show address partial if "Same as mailing address" is not checked', function () {
                scope.$digest();
                expect('addressLine1' in scope.paymentEntry).toBeTruthy();
            });
        });
        describe('Same Address checked', function () {
            beforeEach(function () {
                scope.paymentInfo.sameAddress = true;
            });
            it('should not show address partial if "Same as mailing address" is checked', function () {
                scope.$digest();
                expect('addressLine1' in scope.paymentEntry).toBeFalsy();
            });
        });
        //it('should change state if submitted and form is valid', () => {
        //    scope.submitBK(true);
        //    expect(inState.value).toBe('NewAccount.CreateAccountSummary');
        //});
        //it('should not change state if submitted and form is invalid', () => {
        //    scope.submitBK(false);
        //    expect(inState.value).toBe('');
        //});
        //it('should have a valid form if all inputs valid', () => {
        //    scope.bankDetails.routingNumber = "123456789";
        //    scope.bankDetails.accountNumber = "1234567";
        //    scope.bankDetails.account2 = "1234567";
        //    scope.bankDetails.accountType = "business";
        //    scope.paymentInfo.accept = true;
        //    scope.$digest();
        //    expect(scope.paymentEntry.$valid).toBeTruthy();
        //});
        //it('should have invalid form if an input is invalid', () => {
        //    scope.bankDetails.routingNumber = "1234567890";
        //    scope.bankDetails.accountNumber = "1234567";
        //    scope.bankDetails.account2 = "1234567";
        //    scope.bankDetails.accountType = "business";
        //    scope.paymentInfo.accept = true;
        //    scope.$digest();
        //    expect(scope.paymentEntry.$valid).toBeFalsy();
        //});
        //it('should have invalid input if routingNumber is not 9 digits', () => {
        //    scope.bankDetails.routingNumber = "1234567890";
        //    scope.$digest();
        //    expect(scope.paymentEntry.routing.$valid).toBeFalsy();
        //    scope.bankDetails.routingNumber = "12345678";
        //    scope.$digest();
        //    expect(scope.paymentEntry.routing.$valid).toBeFalsy();
        //});
        //it('should have maximum accountNumber of 17 digits', () => {
        //    scope.bankDetails.accountNumber = "1";
        //    scope.$digest();
        //    expect(scope.paymentEntry.account.$valid).toBeTruthy();
        //    scope.bankDetails.accountNumber = "1234567890123456";
        //    scope.$digest();
        //    expect(scope.paymentEntry.account.$valid).toBeTruthy();
        //    scope.bankDetails.accountNumber = "12345678901234567";
        //    scope.$digest();
        //    expect(scope.paymentEntry.account.$valid).toBeTruthy();
        //    scope.bankDetails.accountNumber = "123456789012345678";
        //    scope.$digest();
        //    expect(scope.paymentEntry.account.$valid).toBeFalsy();
        //});
        //it('should accept accountNumber with 12 asterisks followed by 4 digits', () => {
        //    scope.bankDetails.accountNumber = "************1234";
        //    scope.$digest();
        //    expect(scope.paymentEntry.account.$valid).toBeTruthy();
        //    scope.bankDetails.accountNumber = "***********1234";
        //    scope.$digest();
        //    expect(scope.paymentEntry.account.$valid).toBeFalsy();
        //    scope.bankDetails.accountNumber = "************134";
        //    scope.$digest();
        //    expect(scope.paymentEntry.account.$valid).toBeFalsy();
        //});
    });
}());
(function () {
    'use strict';
    describe('AddPaymentController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.module("HCTRATemplates"));
        var transactionId;
        var scope;
        var controller;
        var routes;
        var stateNames;
        var genericRepo;
        var scrollTo;
        var setUrl;
        var inState;
        var displayedMessage;
        var newAccountObj;
        var utilitiesObj;
        var linkLookupServiceObject;
        var linkLookupServiceMock;
        var stringUtilsMock;
        var responseErrorServiceMock;
        beforeEach(angular.mock.module(function ($provide) {
            routes = hctraMocks.routes();
            stateNames = hctraMocks.stateNames();
            genericRepo = {
                dataFactory: jasmine.createSpyObj("dataFactory", ["getBillingInfo", "getPersonalInfo", "getCmsPageById"])
            };
            scrollTo = {
                value: ""
            },
                setUrl = {
                    value: ""
                },
                inState = {
                    value: ""
                },
                displayedMessage = {
                    value: ""
                },
                newAccountObj = {
                    paymentExists: true
                },
                utilitiesObj = {
                    isInternational: false
                },
                linkLookupServiceObject = {
                    article: "",
                    url: "someUrl",
                    id: "testID"
                },
                linkLookupServiceMock = function (p) {
                    return {
                        cmsIdDictionary: p,
                        articleLookup: function (article) {
                            p.article = article;
                            return p.url;
                        },
                        articleLookupById: function (id) {
                            p.id = id;
                            return p.url;
                        }
                    };
                },
                stringUtilsMock = {
                    getParameterObject: function () { }
                },
                responseErrorServiceMock = hctraMocks.responseErrorService(displayedMessage);
            genericRepo.dataFactory.getBillingInfo.and.callFake(function () { return ({
                then: function () { }
            }); });
            genericRepo.dataFactory.getPersonalInfo.and.callFake(function () { return ({
                then: function () { }
            }); });
            genericRepo.dataFactory.getCmsPageById.and.callFake(function () { return ({
                then: function () { }
            }); });
            spyOn(stringUtilsMock, "getParameterObject").and.returnValue({
                AdditionalFeeHeader: "cms1",
                OneTimeActiviationFeeMessage: "cms2",
                OpeningCostsHeader: "cms3",
                OpeningCostsMessage: "cms4",
                LearnMoreButton: "cms5",
                EZTagAgreementURL: "cms6"
            });
            var tt = hctraMocks.newAccountService(newAccountObj);
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('$anchorScroll', hctraMocks.$anchorScroll(scrollTo));
            $provide.value("stateNames", stateNames);
            $provide.value('genericRepo', genericRepo);
            $provide.value('newAccountService', tt);
            transactionId = tt.getTransactionId();
            $provide.value('$window', hctraMocks.$window(setUrl));
            $provide.value("routes", routes);
            $provide.value('linkLookupService', linkLookupServiceMock(linkLookupServiceObject));
            $provide.value('billingInfoUtilitiesService', hctraMocks.billingInfoUtilitiesService(utilitiesObj));
            $provide.value("responseErrorService", responseErrorServiceMock);
            $provide.value("stringUtilsService", stringUtilsMock);
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile) {
            scope = $rootScope.$new();
            controller = $controller('AddPaymentController', { $scope: scope });
            var templateHtml = $templateCache.get("app/templates/newAccount/step4/addPaymentDetails.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        describe("constructor", function () {
            it("should scroll to new-account-title", function () {
                expect(scrollTo.value).toEqual("new-account-title");
            });
            it("should initialize Scope", function () {
                expect(scope.$parent.stepNum).toEqual(4);
                expect(scope.accountDetails).toEqual({});
                expect(scope.creditCard).toEqual({
                    transactionId: transactionId
                });
                expect(scope.bankDetails).toEqual({
                    transactionId: transactionId
                });
                expect(scope.mailingAddress).toEqual({});
                expect(scope.billingInfoExists).toEqual(false);
                expect(scope.apiAction).toEqual("add");
                expect(scope.previousDestName).toEqual(stateNames.addAdditionalVehicle);
                expect(scope.paymentInfo).toEqual({
                    sameAddress: true
                });
                expect(scope.international).toEqual(false);
                expect(scope.changeMethod).toBe(controller.changeMethod);
            });
        });
        describe("goToTagFAQ", function () {
            it("should go to state stateNames.helpAndSupport", function () {
                scope.goToTagFAQ();
                expect(inState.value).toEqual(stateNames.helpAndSupport);
            });
        });
        describe("goToEzTagInformationPage", function () {
            it("should open window using linkLookupService", function () {
                scope.goToEzTagInformationPage();
                expect(linkLookupServiceObject.id).toEqual(routes.ezTagAccountTypes);
                expect(setUrl.value).toEqual(linkLookupServiceObject.url);
            });
        });
        describe("onPrevious", function () {
            it("should go to previousDestination", function () {
                scope.previousDestName = "previousDestination";
                scope.onPrevious();
                expect(inState.value).toEqual("previousDestination");
            });
        });
        describe("goToContactUs", function () {
            it("should open window routes.contactUs", function () {
                scope.goToContactUs();
                expect(setUrl.value).toEqual(routes.contactUs);
            });
        });
        describe("changeMethod", function () {
            it("should go to state stateNames.creditCardEntry when scope.choice is \"ct\"", function () {
                scope.choice = "ct";
                scope.changeMethod();
                expect(inState.value).toEqual(stateNames.creditCardEntry);
            });
            it("should go to state stateNames.enterBankAccount when scope.choice is \"bk\"", function () {
                scope.choice = "bk";
                scope.changeMethod();
                expect(inState.value).toEqual(stateNames.enterBankAccount);
            });
            ["aa", "vb", "dd"].forEach(function (choice) {
                return it("should should not change state when scope.choice is not \"bk\" or \"ct\"", function () {
                    scope.choice = choice;
                    inState.value = "";
                    scope.changeMethod();
                    expect(inState.value).toEqual("");
                });
            });
        });
        describe("populatePersonalInfo", function () {
            var response;
            var expectedMailingAddress;
            beforeEach(function () {
                response = {
                    errors: [],
                    firstName: "fname",
                    lastName: "lname",
                    address1: "address_1",
                    address2: "address_1",
                    address3: "address_1",
                    address4: "address_1",
                    country: "des",
                    city: "city",
                    state: "some_state",
                    zip: "some_zip",
                    plus4: "plus_4",
                    international: false
                };
                expectedMailingAddress = {
                    firstName: "fname",
                    lastName: "lname",
                    address1: "address_1",
                    address2: "address_1",
                    address3: "address_1",
                    address4: "address_1",
                    country: "des",
                    city: "city",
                    state: "some_state",
                    zip: "some_zip",
                    plus4: "plus_4",
                    international: false
                };
                //expectedMailingAddress.international = false;
            });
            it("should not populate personal information when response errors", function () {
                response.errors.push({ key: "aKey", message: "aMessage" });
                controller.populatePersonalInfo(response);
                expect(scope.mailingAddress).toEqual({});
            });
            it("should populate personal information when response has no errors", function () {
                controller.populatePersonalInfo(response);
                expect(scope.mailingAddress).toEqual(expectedMailingAddress);
            });
            it("should set mailingAddress.plus4 to blank when response.plus4 is null", function () {
                response.plus4 = null;
                expectedMailingAddress.plus4 = "";
                controller.populatePersonalInfo(response);
                expect(scope.mailingAddress).toEqual(expectedMailingAddress);
            });
            it("should set mailingAddress.international to true when utilitiesObj.isInternational returns true", function () {
                utilitiesObj.isInternational = true;
                expectedMailingAddress.international = true;
                controller.populatePersonalInfo(response);
                expect(scope.mailingAddress).toEqual(expectedMailingAddress);
            });
        });
        describe("populateBillingInfo", function () {
            var validCCResponse = { errors: [], billingInfoExists: true, billingType: HCTRA.Constant.PaymentType.CREDIT, cards: "cards" };
            var validEFTResponse = { errors: [], billingInfoExists: true, billingType: HCTRA.Constant.PaymentType.EFT, eft: "eft" };
            beforeEach(function () {
                scope.billingInfoExists = null;
                spyOn(controller, "populateCreditCardInfo").and.callFake(function () { });
                spyOn(controller, "populateBankDetails").and.callFake(function () { });
                spyOn(controller, "changeMethod").and.callFake(function () { });
            });
            it("should set scope.billingInfoExists to true when response.billingInfoExists is true", function () {
                controller.populateBillingInfo({ billingInfoExists: true });
                expect(scope.billingInfoExists).toBe(true);
                expect(controller.changeMethod).toHaveBeenCalledTimes(1);
            });
            it("should set scope.billingInfoExists to false and not call changeMethod when response.billingInfoExists is false", function () {
                controller.populateBillingInfo({ billingInfoExists: false });
                expect(scope.billingInfoExists).toBe(false);
                expect(controller.changeMethod).not.toHaveBeenCalled();
            });
            it("should not touch scope.billingInfoExists or call changeMethod when errors", function () {
                controller.populateBillingInfo({ billingInfoExists: "do not read", errors: [{ key: "aKey", message: "aMessage" }] });
                expect(scope.billingInfoExists).toBe(null);
                expect(controller.changeMethod).not.toHaveBeenCalled();
            });
            [
                [{ errors: [], billingInfoExists: true, billingType: HCTRA.Constant.PaymentType.CASH }, 1],
                [{ errors: [], billingInfoExists: true, billingType: HCTRA.Constant.PaymentType.INVOICE }, 1],
                [{ errors: [], billingInfoExists: true, billingType: HCTRA.Constant.PaymentType.NON_REVENUE }, 1],
                [{ errors: [], billingInfoExists: false, billingType: HCTRA.Constant.PaymentType.CREDIT }, 0],
                [{ errors: [], billingInfoExists: false, billingType: HCTRA.Constant.PaymentType.EFT }, 0],
                [{ errors: [{ key: "aKey", message: "aMessage" }], billingInfoExists: true, billingType: HCTRA.Constant.PaymentType.CREDIT }, 0],
                [{ errors: [{ key: "aKey", message: "aMessage" }], billingInfoExists: true, billingType: HCTRA.Constant.PaymentType.EFT }, 0]
            ].forEach(function (_a) {
                var response = _a[0], changeMethodCallCount = _a[1];
                return it("should not call either populateCreditCardInfo or populateBankDetails when response " + angular.toJson(response) + " and call changeMethod " + changeMethodCallCount + " times", function () {
                    controller.populateBillingInfo(response);
                    expect(controller.populateBankDetails).not.toHaveBeenCalled();
                    expect(controller.populateCreditCardInfo).not.toHaveBeenCalled();
                    expect(controller.changeMethod).toHaveBeenCalledTimes(changeMethodCallCount);
                });
            });
            it("should call populateCreditCardInfo and changeMethod when response " + angular.toJson(validCCResponse), function () {
                controller.populateBillingInfo(validCCResponse);
                expect(controller.populateCreditCardInfo).toHaveBeenCalledTimes(1);
                expect(controller.populateCreditCardInfo).toHaveBeenCalledWith(validCCResponse.cards);
                expect(controller.changeMethod).toHaveBeenCalledTimes(1);
            });
            it("should call populateBankDetails and changeMethod when response " + angular.toJson(validEFTResponse), function () {
                controller.populateBillingInfo(validEFTResponse);
                expect(controller.populateBankDetails).toHaveBeenCalledTimes(1);
                expect(controller.populateBankDetails).toHaveBeenCalledWith(validEFTResponse.eft);
                expect(controller.changeMethod).toHaveBeenCalledTimes(1);
            });
        });
        describe("populateCardInfo", function () {
            var expirationDate = new Date(Date.now());
            var card = {
                address1: "address_1",
                address2: "address_1",
                address3: "address_1",
                address4: "address_1",
                country: "des",
                city: "city",
                state: "some_state",
                zip: "some_zip",
                plus4: "plus_4",
                nameOnCard: "name",
                cardCode: "A",
                cardNbr: "1234",
                accountBillingMethodId: "accountBillingMethodId",
                cardExpiresDate: expirationDate
            };
            var expectedAccountDetails = {
                address1: "address_1",
                address2: "address_1",
                address3: "address_1",
                address4: "address_1",
                country: "des",
                city: "city",
                state: "some_state",
                zip: "some_zip",
                plus4: "plus_4"
            };
            var expectedCreditCard = {
                nameOnCard: "name",
                cardCode: "A",
                cardNbr: "1234",
                accountBillingMethodId: "accountBillingMethodId",
                expMonth: (expirationDate.getMonth() + 1),
                selectedYear: expirationDate.getFullYear().toString(),
                transactionId: 91827364
            };
            it("should not populate accountDetails or creditCard when zero cards", function () {
                controller.populateCreditCardInfo([]);
                expect(scope.apiAction).toEqual("update");
                expect(scope.paymentInfo.sameAddress).toEqual(false);
                expect(scope.choice).toEqual("ct");
                expect(scope.international).toEqual(utilitiesObj.isInternational);
                expect(scope.creditCard).toEqual({
                    transactionId: transactionId
                });
                expect(scope.accountDetails).toEqual({});
            });
            it("should populate credit card information when one card is passed ", function () {
                controller.populateCreditCardInfo([card]);
                expect(scope.apiAction).toEqual("update");
                expect(scope.paymentInfo.sameAddress).toEqual(false);
                expect(scope.choice).toEqual("ct");
                expect(scope.international).toEqual(utilitiesObj.isInternational);
                expect(scope.creditCard).toEqual(expectedCreditCard);
                expect(scope.accountDetails).toEqual(expectedAccountDetails);
            });
            it("should populate credit card information when two cards are passed ", function () {
                var card2 = angular.copy(card);
                card2.nameOnCard = "second_card";
                controller.populateCreditCardInfo([card, card2]);
                expect(scope.apiAction).toEqual("update");
                expect(scope.paymentInfo.sameAddress).toEqual(false);
                expect(scope.choice).toEqual("ct");
                expect(scope.international).toEqual(utilitiesObj.isInternational);
                expect(scope.creditCard).toEqual(expectedCreditCard);
                expect(scope.accountDetails).toEqual(expectedAccountDetails);
            });
        });
        describe("populateBankDetails", function () {
            var eft = {
                accountTypeDisplay: "AccountType",
                routingNumber: "123123123",
                accountNumber: "123132",
                accountBillingMethodId: "accountBillingMethodId"
            };
            var expectedBankDetails = {
                accountTypeDisplay: "AccountType",
                routingNumber: "123123123",
                accountBillingMethodId: "accountBillingMethodId",
                accountNumber: "123132",
                account2: "123132",
                transactionId: 91827364
            };
            it("should populate bankDetails and set apiAction to update when eft info is passed", function () {
                controller.populateBankDetails(eft);
                expect(scope.apiAction).toEqual("update");
                expect(scope.choice).toEqual("bk");
                expect(scope.bankDetails).toEqual(expectedBankDetails);
            });
        });
        describe("populateCmsParams", function () {
            var res = {
                errors: [],
                cmsResponse: "this is a response"
            };
            it("should populate scope parameters with cms values", function () {
                spyOn(angular, "fromJson").and.returnValue({
                    Parameters: "This the parameters",
                    Children: [{ Parameters: "This is another parameter" }]
                });
                controller.populateCmsParams(res);
                expect(scope.additionalFeeHeader).toEqual("cms1");
                expect(scope.oneTimeActivationFeeMessage).toEqual("cms2");
                expect(scope.openingCostsHeader).toEqual("cms3");
                expect(scope.openingCostsMessage).toEqual("cms4");
                expect(scope.learnMoreButton).toEqual("cms5");
            });
            it("should call on responseErrorService if there are errors", function () {
                res.errors = ["one error"];
                spyOn(responseErrorServiceMock, "isErrorFree").and.returnValue(false);
                spyOn(angular, "fromJson");
                controller.populateCmsParams(res);
                expect(responseErrorServiceMock.isErrorFree).toHaveBeenCalledTimes(1);
                expect(angular.fromJson).toHaveBeenCalledTimes(0);
            });
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('CreateAccountSummaryController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, CreateAccountSummaryController, scrollTo = {
            value: ""
        }, displayedMessage = {
            value: ""
        }, inState = {
            value: ""
        };
        var billingInfoUtilitiesService;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            //'$scope', '$anchorScroll', '$state', 'genericRepo', 'responseErrorService', 'stateNames', 'CurrentUser'
            billingInfoUtilitiesService = jasmine.createSpyObj('billingInfoUtilitiesService', ['isInternationalAddress']);
            billingInfoUtilitiesService.isInternationalAddress.and.returnValue(false);
            $provide.value('billingInfoUtilitiesService', billingInfoUtilitiesService);
            $provide.value('$anchorScroll', hctraMocks.$anchorScroll(scrollTo));
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('CurrentUser', hctraMocks.CurrentUser());
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
            //create new, empty ng scope and controller objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            //create the controller
            CreateAccountSummaryController = $controller('CreateAccountSummaryController', { $scope: scope });
        }));
        //begin an actual, trivial test
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        it('should start with a false fromEditScreen', function () {
            expect(scope.fromEditScreen).toBeFalsy();
        });
        it('should have true fromEditScreen after goTo("State.Name")', function () {
            scope.goTo("State.Name");
            expect(scope.fromEditScreen).toBeTruthy();
        });
        it('should transistion to State.Name after goTo("State.Name")', function () {
            scope.goTo("State.Name");
            expect(inState.value).toBe("State.Name");
        });
        it('should transition to Choose Payment Method after onPrevious()', function () {
            scope.onPrevious();
            expect(inState.value).toBe('NewAccount.PaymentMaster.ChooseMethod');
        });
        it('should have true billingInfo after init', function () {
            expect(scope.billingInfo.billingInfoExists).toBeTruthy();
        });
        it('should have defined personalInfo', function () {
            expect(scope.personalInfo.personalInfoExists).toBeTruthy();
        });
        // Requirement 60300: Motorocycle flag change
        // Re-added
        it('should have defined vehicleList', function () {
            expect(scope.vehicleList.vehicleListExists).toBeTruthy();
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('CheckoutController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, $state, dataFactory, newAccountService, CheckoutController, $q, displayedMessage = {
            value: ""
        }, inSession = {};
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            //'$state', 'genericRepo', 'responseErrorService', 'stateNames', 'newAccountService'
            $state = jasmine.createSpyObj('$state', ['go']);
            dataFactory = jasmine.createSpyObj('dataFactory', ['makePayment', 'checkoutPayment']);
            newAccountService = jasmine.createSpyObj('NewAccountService', ['getVehicleList', 'getTransactionId', 'setTransactionId', 'setPayment', 'setDeliveryMethod', 'clearVehicleList', 'getDeliveryMethod']);
            newAccountService.getVehicleList.and.returnValue(["vehicle"]);
            newAccountService.getTransactionId.and.returnValue(["123456"]);
            newAccountService.getDeliveryMethod.and.returnValue(["mail"]);
            $provide.factory('$q', ['replacementQService', function (replacementQService) {
                    return replacementQService;
                }]);
            $provide.value('$state', $state);
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('genericRepo', { dataFactory: dataFactory });
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('newAccountService', newAccountService);
            $provide.value('SessionService', hctraMocks.Session(inSession));
            $provide.value('CurrentUser', hctraMocks.CurrentUser());
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function ($injector) {
            //create new, empty ng scope and controller objects
            var rootScope = $injector.get('$rootScope');
            var controller = $injector.get('$controller');
            scope = rootScope.$new();
            $controller = controller;
            rootScope.currentUser = {};
            rootScope.currentUser.acctActivity = "";
            scope.setCurrentUser = function () { };
            $q = $injector.get("replacementQService");
            //create the controller
            dataFactory.checkoutPayment.and.returnValue($q.resolve({
                transactionId: '12345',
                ezTagTransaction: {
                    tagSalesAmt: 30,
                    depositAmt: 80,
                    totalAmt: 80,
                    tagCostExists: true,
                    transactionId: '12345'
                },
                errors: []
            }));
            CheckoutController = $controller('CheckoutController', { $scope: scope });
        }));
        //begin an actual, trivial test
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        /*** Bug 13724 fix is temporarily doing away with the "payment exists" path because call to calculateActivationFee is not being made ***/
        //describe('Payment exists', function () {
        //    beforeEach(function () { newAccountObj.paymentExists = true; });
        //    it('should have defined payment after values retrieved from newAccountService', function () {
        //        expect(scope.payment.paymentExists).toBeTruthy();
        //    });
        //    it('should have payment with totalAmt of 40 after values retrieved from newAccountService', function () {
        //        expect(scope.payment.totalAmt).toBe(40);
        //    });
        //    it('should set totalAmt to 40', function () {
        //        scope.onCheckout();
        //        expect(newAccountObj.payment.totalAmt).toBe(40);
        //    });
        //});
        describe('Payment does not exist', function () {
            beforeEach(function () {
                $state.go.and.returnValue($q.resolve({ errors: [] }));
            });
            //it('should have defined payment after promise resolved', function () {
            //    expect(scope.payment.paymentExists).toBeTruthy();
            //});
            it('should have payment with totalAmt of 80 after promise resolved', function () {
                return scope.init().then(function () {
                    expect(scope.payment.totalAmt).toBe(80);
                });
            });
            it('should set totalAmt to 80', function () {
                dataFactory.makePayment.and.returnValue($q.resolve({
                    transactionId: '12345',
                    ezTagTransaction: {
                        tagSalesAmt: 30,
                        depositAmt: 80,
                        totalAmt: 80,
                        tagCostExists: true,
                        transactionId: '12345'
                    },
                    errors: []
                }));
                return scope.onCheckout().then(function () {
                    expect(newAccountService.setPayment).toHaveBeenCalled();
                    expect(newAccountService.setPayment.calls.argsFor(0)[0].totalAmt).toBe(80);
                }).catch(function (e) {
                    fail(e);
                });
            });
        });
        describe('Payment button disabled', function () {
            it('enables button only when payment is made successfully AND state change is complete', function () {
                expect(scope.paymentIsPending).toBeFalsy();
                dataFactory.makePayment.and.callFake(function () {
                    expect(scope.paymentIsPending).toBeTruthy();
                    return $q.resolve({ errors: [] });
                });
                $state.go.and.callFake(function () {
                    expect(scope.paymentIsPending).toBeTruthy();
                    return $q.resolve({ errors: [] });
                });
                return scope
                    .onCheckout()
                    .catch(function (e) {
                    fail(e);
                })
                    .finally(function () {
                    expect(scope.paymentIsPending).toBeFalsy();
                });
            });
        });
        describe('Payment button disabled', function () {
            it('enables button only when payment is made successfully AND state change is complete', function () {
                expect(scope.paymentIsPending).toBeFalsy();
                dataFactory.makePayment.and.callFake(function () {
                    expect(scope.paymentIsPending).toBeTruthy();
                    return $q.resolve({ errors: [] });
                });
                $state.go.and.callFake(function () {
                    expect(scope.paymentIsPending).toBeTruthy();
                    return $q.resolve({ errors: [] });
                });
                return scope
                    .onCheckout()
                    .catch(function (e) {
                    fail(e);
                })
                    .finally(function () {
                    expect(scope.paymentIsPending).toBeFalsy();
                });
            });
            it('should not allow a payment while another is already processing', function () {
                expect(scope.paymentIsPending).toBeFalsy();
                dataFactory.makePayment.and.returnValue($q.resolve({ errors: [] }));
                $state.go.and.callFake(function () {
                    //try to checkout again
                    return scope
                        .onCheckout()
                        .then(function (obj) {
                        expect(scope.paymentIsPending).toBeTruthy();
                        expect(obj).toBeDefined();
                        expect(obj.status).toBe("processing");
                    })
                        .catch(function (e) { fail(e); })
                        .then({ errors: [] });
                });
                return scope
                    .onCheckout()
                    .catch(function (e) {
                    fail(e);
                });
            });
        });
        it('should set deliveryMethod to "mail"', function () {
            dataFactory.makePayment.and.returnValue($q.resolve({
                transactionId: '12345',
                deliveryMethod: "mail",
                ezTagTransaction: {
                    tagSalesAmt: 30,
                    depositAmt: 80,
                    totalAmt: 80,
                    tagCostExists: true,
                    transactionId: '12345'
                },
                errors: []
            }));
            $state.go.and.returnValue($q.resolve({ errors: [] }));
            return scope.onCheckout().finally(function () {
                expect(newAccountService.setDeliveryMethod).toHaveBeenCalledWith('mail');
            });
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('CreateAccountReceiptController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, CreateAccountReceiptController, genericRepo, responseErrorService, $q, cmsReturn, accountReciept, inState = {
            value: ""
        }, stringUtilsMock = {
            getParameterObject: function () {
                return {
                    ThankYouMessage: "cms1",
                    OrderReceivedMessage: "cms2",
                    ByMailMessage: "cms3",
                    ByPickupMessage: "cms4",
                    EmailConfirmMessage: "cms5"
                };
            }
        };
        var billingInfoUtilitiesService;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            //'$state', 'genericRepo', 'responseErrorService', 'stateNames', 'newAccountService'
            billingInfoUtilitiesService = jasmine.createSpyObj('billingInfoUtilitiesService', ['isInternationalAddress']);
            billingInfoUtilitiesService.isInternationalAddress.and.returnValue(false);
            genericRepo = {
                dataFactory: jasmine.createSpyObj('dataFactory', ['getCmsPageById', 'getCreateAccountReceipt'])
            };
            responseErrorService = jasmine.createSpyObj('responseErrorService', ['isErrorFree', 'displayAlertsFromResponse']);
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('genericRepo', genericRepo);
            $provide.value('responseErrorService', responseErrorService);
            $provide.value('newAccountService', hctraMocks.newAccountService());
            $provide.value('stringUtilsService', stringUtilsMock);
            $provide.value('billingInfoUtilitiesService', billingInfoUtilitiesService);
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function ($injector, _$rootScope_, _$controller_) {
            $q = $injector.get("replacementQService");
            //create new, empty ng scope and controller objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            responseErrorService.isErrorFree.and.returnValue(true);
            cmsReturn = $q.resolve({
                errors: [], cmsResponse: angular.toJson({
                    Parameter: {
                        thankYouMessage: "cms1",
                        orderReceivedMessage: "cms2",
                        byMailMessage: "cms3",
                        byPickupMessage: "cms4",
                        emailConfirmMessage: "cms5"
                    }
                })
            });
            accountReciept = $q.resolve({
                errors: [],
                billingInfo: {
                    cards: [{}],
                    billingInfoExists: true
                },
                personalInfo: {
                    personalInfoExists: true
                },
                orderShippingTime: '5-10 business days',
                contactNames: {},
                accountPreferences: {},
                accountTags: {
                    accountTagsExists: true
                }
            });
            genericRepo.dataFactory
                .getCmsPageById.and.returnValue(cmsReturn);
            genericRepo.dataFactory
                .getCreateAccountReceipt.and.returnValue(accountReciept);
            //create the controller
            CreateAccountReceiptController = $controller('CreateAccountReceiptController', { $scope: scope });
        }));
        function wrap_it(name, func) {
            it(name, function () {
                return $q.all([cmsReturn, accountReciept]).then(func);
            });
        }
        //begin an actual, trivial test
        wrap_it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        wrap_it('should have defined billingInfo after promise resolved', function () {
            expect(scope.billingInfo.billingInfoExists).toBeTruthy();
        });
        wrap_it('should have defined personalInfo after promise resolved', function () {
            expect(scope.personalInfo.personalInfoExists).toBeTruthy();
        });
        wrap_it('should have defined vehicleList after promise resolved', function () {
            expect(scope.vehicleList.accountTagsExists).toBeTruthy();
        });
        wrap_it('should have orderShippingTime with value "5-10 business days" after promise resolved', function () {
            expect(scope.orderShippingTime).toBe('5-10 business days');
        });
        wrap_it('should have deliveryMethod with value "mail"', function () {
            expect(scope.deliveryMethod).toBe('mail');
        });
        wrap_it('should have transactionId with value 91827364', function () {
            expect(scope.transactionId).toBe(91827364);
        });
        wrap_it('should have defined payment after init', function () {
            expect(scope.payment).toBeTruthy();
        });
        wrap_it('should assign cms params after init', function () {
            expect(scope.thankYouMessage).toEqual("cms1");
            expect(scope.orderReceivedMessage).toEqual("cms2");
            expect(scope.byMailMessage).toEqual("cms3");
            expect(scope.byPickupMessage).toEqual("cms4");
            expect(scope.emailConfirmMessage).toEqual("cms5");
        });
    });
}());
// (function (): void {
// 	"use strict";
// 	describe("ActivateEzTagController", () => {
// 		beforeEach(angular.mock.module("HCTRATemplates"));
// 		beforeEach(angular.mock.module("HCTRAModule"));
// 		let scope;
// 		let	linkLookupService;
// 		let	setUrl: { value: string };
// 		let	displayedMessage: { value: string };
// 		let	testStorage: {};
// 		let	storageForService: {
// 				transactionId: string;
// 				step: number;
// 				listOfVehicles: Array<any>;
// 			};
// 		let	linkLookupServiceInputRoute: string;
// 		let environmentConfig: {
// 			twoFactorAuth: {
// 				enableTagActivation: boolean
// 			}
// 		};
// 		let authService: { isAuthenticated: () => boolean};
// 		let session: { acctId: number };
// 		beforeEach(angular.mock.module(() => {
// 			setUrl = {
// 				value: ""
// 			};
// 			displayedMessage = {
// 				value: ""
// 			};
// 			testStorage = {};
// 			storageForService = {
// 				transactionId: "",
// 				step: 0,
// 				listOfVehicles: []
// 			};
// 			linkLookupServiceInputRoute = null;
// 		}));
// 		beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
// 			authService = jasmine.createSpyObj('authService', ['isAuthenticated']);
// 			session = { acctId: 0 };
// 			environmentConfig = {
// 				twoFactorAuth: {
// 					enableTagActivation: false
// 				}
// 			};
// 			$provide.value("$location", hctraMocks.$location(setUrl)); // might need to change url
// 			$provide.value("routes", hctraMocks.routes());
// 			$provide.value("genericRepo", hctraMocks.genericRepo());
// 			$provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
// 			$provide.value("validationService", hctraMocks.validationService);
// 			$provide.value("modalService", hctraMocks.modalService);
// 			$provide.value("webStorage", hctraMocks.fakeWebStorage(testStorage));
// 			$provide.value("activateEzTagWizardDirectorService", hctraMocks.activateEzTagWizardDirectorService(storageForService));
// 			$provide.value("linkLookupService", hctraMocks.linkLookupService());
// 			$provide.value("$window", { open: (): void => { return; } });
// 			$provide.constant("environmentConfig", environmentConfig);
// 			$provide.value("AuthService", authService);
// 			$provide.value("Session", session);
// 		}));
// 		beforeEach(angular.mock.inject(($rootScope: angular.IRootScopeService,
// 			$controller: angular.IControllerService,
// 			$templateCache: angular.ITemplateCacheService,
// 			$compile: angular.ICompileService,
// 			_linkLookupService_) => {
// 			// create new, empty ng scope and controller objects
// 			scope = $rootScope.$new();
// 			const rootScope: angular.IRootScopeService = $rootScope;
// 			// set a base scope object
// 			scope.activateEzTag = {};
// 			scope.activateTagStep1Form = {};
// 			linkLookupService = _linkLookupService_;
// 			spyOn(linkLookupService, "articleLookupById").and.callFake((param: any) => { linkLookupServiceInputRoute = param; });
// 			// create the controller
// 			$controller("ActivateEzTagController", { $scope: scope, $rootScope: rootScope });
// 			$templateCache.put("/app/templates/activateEzTag/activateEzTagHeaderPartial.html",
// 				$templateCache.get("app/templates/activateEzTag/activateEzTagHeaderPartial.html"));
// 			const templateHtml: string = $templateCache.get("app/templates/activateEzTag/activateEzTag.html") as string;
// 			const formElem: angular.IAugmentedJQuery = angular.element(templateHtml);
// 			$compile(formElem)(scope);
// 			scope.$digest();
// 		}));
// 		describe('non removeDL', () => {
// 			[true, false].forEach((isAuthenticated)=>{
// 				beforeEach(()=> {
// 					environmentConfig = {
// 						twoFactorAuth: {
// 							enableTagActivation: false
// 						}
// 					};
// 					scope.removeDL = false;
// 					scope.isAuthenticated = isAuthenticated;
// 					session.acctId = isAuthenticated ? 1234 : 0;
// 					scope.$digest();
// 				});
// 				it("form should be invalid first", () => {
// 					expect(scope.activateTagStep1Form.$invalid).toBeTruthy();
// 				});
// 				it("entering transactionId, selecting DL and filling in DL should make form valid", () => {
// 					scope.activateEzTag.transactionId = "123456";
// 					scope.activateEzTag.acctInfoSelect = "driversLicense";
// 					scope.activateEzTag.driversLicense = "12345678";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.$invalid).toBeFalsy();
// 				});
// 				it("entering transactionId, selecting taxId and filling taxId should make form valid", () => {
// 					scope.activateEzTag.transactionId = "123456";
// 					scope.activateEzTag.acctInfoSelect = "taxId";
// 					scope.activateEzTag.taxIdNumber = "123456789";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.$invalid).toBeFalsy();
// 				});
// 				it("entering just transactionId should not make form valid", () => {
// 					scope.transactionId = "123456";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.$invalid).toBeTruthy();
// 				});
// 				it("entering just DL should not make form valid", () => {
// 					scope.activateEzTag.acctInfoSelect = "driversLicense";
// 					scope.activateEzTag.driversLicense = "123456";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.$invalid).toBeTruthy();
// 				});
// 				it("entering just taxID should not make form valid", () => {
// 					scope.activateEzTag.acctInfoSelect = "taxId";
// 					scope.activateEzTag.taxIdNumber = "123456789";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.$invalid).toBeTruthy();
// 				});
// 				it("validate that invalid taxID is caught", () => {
// 					scope.activateEzTag.acctInfoSelect = "taxId";
// 					scope.activateEzTag.taxIdNumber = "12345678";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.taxIdNumber.$invalid).toBeTruthy();
// 					scope.activateEzTag.taxIdNumber = "123456789123456789";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.taxIdNumber.$invalid).toBeTruthy();
// 					scope.activateEzTag.taxIdNumber = "";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.taxIdNumber.$invalid).toBeTruthy();
// 					scope.activateEzTag.taxIdNumber = "!@123345";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.taxIdNumber.$invalid).toBeTruthy();
// 				});
// 				it("validate that invalid DL is caught", () => {
// 					scope.activateEzTag.acctInfoSelect = "driversLicense";
// 					scope.activateEzTag.driversLicense = "123456789123456789123456789";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.driversLicense.$invalid).toBeTruthy();
// 					scope.activateEzTag.driversLicense = "";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.driversLicense.$invalid).toBeTruthy();
// 				});
// 				it("validate that invalid TransactionId is caught", () => {
// 					scope.activateEzTag.transactionId = "";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.transactionId.$invalid).toBeTruthy();
// 					scope.activateEzTag.transactionId = "A";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.transactionId.$invalid).toBeTruthy();
// 				});
// 				it("validate that dropdown selections work correctly for driversLicense", () => {
// 					scope.activateEzTag.acctInfoSelect = "waterm";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.taxIdNumber).toBeUndefined();
// 					expect(scope.activateTagStep1Form.driversLicense).toBeUndefined();
// 					scope.activateEzTag.acctInfoSelect = "driversLicense";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.taxIdNumber).toBeUndefined();
// 					expect(scope.activateTagStep1Form.driversLicense).toBeDefined();
// 				});
// 				it("validate that dropdown selections work correctly for taxId", () => {
// 					scope.activateEzTag.acctInfoSelect = "waterm";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.taxIdNumber).toBeUndefined();
// 					expect(scope.activateTagStep1Form.driversLicense).toBeUndefined();
// 					scope.activateEzTag.acctInfoSelect = "taxId";
// 					scope.$digest();
// 					expect(scope.activateTagStep1Form.driversLicense).toBeUndefined();
// 					expect(scope.activateTagStep1Form.taxIdNumber).toBeDefined();
// 				});
// 				it("validate isItalic works corretly", () => {
// 					scope.activateEzTag.acctInfoSelect = "waterm";
// 					const shouldBeSetItalic: string = scope.isItalic("acctInfoSelect");
// 					scope.$digest();
// 					expect(shouldBeSetItalic).toBe("setItalic");
// 					scope.activateEzTag.acctInfoSelect = "taxId";
// 					const shouldBeBlank: string = scope.isItalic("acctInfoSelect");
// 					scope.$digest();
// 					expect(shouldBeBlank).toBe("");
// 				});
// 				it("validate blankOutUnusedFields works corretly", () => {
// 					scope.activateEzTag.acctInfoSelect = "driversLicense";
// 					scope.activateEzTag.transactionId = "123456789";
// 					scope.activateEzTag.taxIdNumber = "123456789";
// 					scope.activateEzTag.driversLicense = "123456789";
// 					scope.activateEzTag.selectedState = "TX";
// 					let cleansedInformation: any = scope.blankOutUnusedFields();
// 					expect(cleansedInformation.transactionId).toBe("123456789");
// 					expect(cleansedInformation.taxIdNumber).toBeUndefined();
// 					expect(cleansedInformation.driversLicense).toBe("123456789");
// 					expect(cleansedInformation.state).toBe("TX");
// 					expect(cleansedInformation.emailAddress).toBeUndefined();
// 					expect(cleansedInformation.phoneNumber).toBeUndefined();
// 					expect(cleansedInformation.accountId).toBe(null);
// 					scope.activateEzTag.acctInfoSelect = "taxId";
// 					scope.activateEzTag.transactionId = "123456789";
// 					scope.activateEzTag.taxIdNumber = "12-3456-789";
// 					scope.activateEzTag.driversLicense = "123456789";
// 					scope.activateEzTag.selectedState = "TX";
// 					cleansedInformation = scope.blankOutUnusedFields();
// 					expect(cleansedInformation.transactionId).toBe("123456789");
// 					expect(cleansedInformation.taxIdNumber).toBe("123456789");
// 					expect(cleansedInformation.driversLicense).toBeUndefined();
// 					expect(cleansedInformation.state).toBeUndefined();
// 					expect(cleansedInformation.emailAddress).toBeUndefined();
// 					expect(cleansedInformation.phoneNumber).toBeUndefined();
// 					expect(cleansedInformation.accountId).toBe(null);
// 				});
// 				it("validate onCancel works corretly", () => {
// 					scope.onCancel();
// 					expect(setUrl.value).toBe("/Home");
// 				});
// 				it("validate createActivateEzTagStep1MarkerAndAdvance works corretly", () => {
// 					scope.activateEzTag.transactionId = "123456789";
// 					const accountTags = [{
// 						acctTagSeq: 22,
// 						acctTagSeqSpecified: true,
// 						acctTagStatus: "A",
// 						fullTagId: "HCTR09000001",
// 						licPlate: "TST123",
// 						licState: "TX",
// 						motorcycle: false,
// 						nickname: "Motor 114",
// 						tagId: "09000001",
// 						tagStatusDesc: "Active",
// 						temporaryLicPlate: false,
// 						vehicleClassCode: "2",
// 						vehicleClassDesc: "Two Axle Vehicle",
// 						vehicleColor: "BLACK",
// 						vehicleMake: "COACHMAN",
// 						vehicleModel: "ABC",
// 						vehicleYear: "2001"
// 					}];
// 					scope.createActivateEzTagStep1MarkerAndAdvance(accountTags);
// 					expect(setUrl.value).toBe("/ConfirmTagActivation");
// 					expect(storageForService.transactionId).toBe("123456789");
// 					expect(storageForService.step).toBe(2);
// 					expect(angular.equals(storageForService.listOfVehicles, accountTags)).toBeTruthy();
// 				});
// 				it("validate that Faq article route is correct", () => {
// 					scope.searchFaqMountEzTag();
// 					expect(linkLookupServiceInputRoute)
// 						.toBe("B40CBAB4-DD52-46E2-A5FB-DE7F4CDB8C55");
// 				});
// 			});
// 		});
// 		describe('removeDL - not authenticated', () => {
// 			beforeEach(()=> {
// 				environmentConfig = {
// 					twoFactorAuth: {
// 						enableTagActivation: true
// 					}
// 				};
// 				scope.isAuthenticated = false;
// 				scope.removeDL = true;
// 				session.acctId = 0;
// 				scope.$digest();
// 			});
// 			it("form should be invalid first", () => {
// 				expect(scope.activateTagStep1Form.$invalid).toBeTruthy();
// 			});
// 			it("entering transactionId, selecting email and filling in email should make form valid", () => {
// 				scope.activateEzTag.transactionId = "123456";
// 				scope.activateEzTag.verificationSelect = "emailAddress";
// 				scope.activateEzTag.emailAddress = "test@test.org";
// 				scope.$digest();
// 				expect(scope.activateTagStep1Form.$invalid).toBeFalsy();
// 			});
// 			it("entering transactionId, selecting phone and filling phone should make form valid", () => {
// 				scope.activateEzTag.transactionId = "123456";
// 				scope.activateEzTag.verificationSelect = "phoneNumber";
// 				scope.activateEzTag.phoneNumber = "8675309";
// 				scope.$digest();
// 				expect(scope.activateTagStep1Form.$invalid).toBeFalsy();
// 			});
// 			it("entering just transactionId should not make form valid", () => {
// 				scope.transactionId = "123456";
// 				scope.$digest();
// 				expect(scope.activateTagStep1Form.$invalid).toBeTruthy();
// 			});
// 			it("validate that invalid TransactionId is caught", () => {
// 				scope.activateEzTag.transactionId = "";
// 				scope.$digest();
// 				expect(scope.activateTagStep1Form.transactionId.$invalid).toBeTruthy();
// 				scope.activateEzTag.transactionId = "A";
// 				scope.$digest();
// 				expect(scope.activateTagStep1Form.transactionId.$invalid).toBeTruthy();
// 			});
// 			it("validate isItalic works corretly", () => {
// 				scope.activateEzTag.acctInfoSelect = "waterm";
// 				const shouldBeSetItalic: string = scope.isItalic("acctInfoSelect");
// 				scope.$digest();
// 				expect(shouldBeSetItalic).toBe("setItalic");
// 				scope.activateEzTag.acctInfoSelect = "taxId";
// 				const shouldBeBlank: string = scope.isItalic("acctInfoSelect");
// 				scope.$digest();
// 				expect(shouldBeBlank).toBe("");
// 			});
// 			it("validate blankOutUnusedFields works corretly - email", () => {
// 				scope.activateEzTag.transactionId = "123456789";
// 				scope.activateEzTag.verificationSelect = 'emailAddress';
// 				scope.activateEzTag.emailAddress = 'test@test.org';
// 				const cleansedInformation: any = scope.blankOutUnusedFields();
// 				expect(cleansedInformation.transactionId).toBe("123456789");
// 				expect(cleansedInformation.taxIdNumber).toBeUndefined();
// 				expect(cleansedInformation.driversLicense).toBeUndefined();
// 				expect(cleansedInformation.state).toBeUndefined();
// 				expect(cleansedInformation.emailAddress).toBe('test@test.org');
// 				expect(cleansedInformation.phoneNumber).toBeUndefined();
// 				expect(cleansedInformation.accountId).toBe(null);				
// 			});
// 			it("validate blankOutUnusedFields works corretly - phone", () => {
// 				scope.activateEzTag.transactionId = "123456789";
// 				scope.activateEzTag.verificationSelect = 'phoneNumber';
// 				scope.activateEzTag.phoneNumber = '8675309';
// 				const cleansedInformation: any = scope.blankOutUnusedFields();
// 				expect(cleansedInformation.transactionId).toBe("123456789");
// 				expect(cleansedInformation.taxIdNumber).toBeUndefined();
// 				expect(cleansedInformation.driversLicense).toBeUndefined();
// 				expect(cleansedInformation.state).toBeUndefined();
// 				expect(cleansedInformation.emailAddress).toBeUndefined();
// 				expect(cleansedInformation.phoneNumber).toBe('8675309');
// 				expect(cleansedInformation.accountId).toBe(null);
// 			});
// 			it("validate onCancel works corretly", () => {
// 				scope.onCancel();
// 				expect(setUrl.value).toBe("/Home");
// 			});
// 			it("validate createActivateEzTagStep1MarkerAndAdvance works corretly", () => {
// 				scope.activateEzTag.transactionId = "123456789";
// 				const accountTags = [{
// 					acctTagSeq: 22,
// 					acctTagSeqSpecified: true,
// 					acctTagStatus: "A",
// 					fullTagId: "HCTR09000001",
// 					licPlate: "TST123",
// 					licState: "TX",
// 					motorcycle: false,
// 					nickname: "Motor 114",
// 					tagId: "09000001",
// 					tagStatusDesc: "Active",
// 					temporaryLicPlate: false,
// 					vehicleClassCode: "2",
// 					vehicleClassDesc: "Two Axle Vehicle",
// 					vehicleColor: "BLACK",
// 					vehicleMake: "COACHMAN",
// 					vehicleModel: "ABC",
// 					vehicleYear: "2001"
// 				}];
// 				scope.createActivateEzTagStep1MarkerAndAdvance(accountTags);
// 				expect(setUrl.value).toBe("/ConfirmTagActivation");
// 				expect(storageForService.transactionId).toBe("123456789");
// 				expect(storageForService.step).toBe(2);
// 				expect(angular.equals(storageForService.listOfVehicles, accountTags)).toBeTruthy();
// 			});
// 			it("validate that Faq article route is correct", () => {
// 				scope.searchFaqMountEzTag();
// 				expect(linkLookupServiceInputRoute)
// 					.toBe("B40CBAB4-DD52-46E2-A5FB-DE7F4CDB8C55");
// 			});
// 		});
// 		describe('removeDL - authenticated', () => {
// 			beforeEach(()=> {
// 				environmentConfig = {
// 					twoFactorAuth: {
// 						enableTagActivation: true
// 					}
// 				};
// 				scope.isAuthenticated = true;
// 				scope.removeDL = true;
// 				session.acctId = 1234;
// 				scope.$digest();
// 			});
// 			it("form should be invalid first", () => {
// 				expect(scope.activateTagStep1Form.$invalid).toBeTruthy();
// 			});
// 			it("entering transactionId should make form valid", () => {
// 				scope.activateEzTag.transactionId = "123456";
// 				scope.$digest();			
// 				expect(scope.activateTagStep1Form.$invalid).toBeFalsy();
// 			});
// 			it("validate that invalid TransactionId is caught", () => {
// 				scope.activateEzTag.transactionId = "";
// 				scope.$digest();
// 				expect(scope.activateTagStep1Form.transactionId.$invalid).toBeTruthy();
// 				scope.activateEzTag.transactionId = "A";
// 				scope.$digest();
// 				expect(scope.activateTagStep1Form.transactionId.$invalid).toBeTruthy();
// 			});
// 			it("validate isItalic works corretly", () => {
// 				scope.activateEzTag.acctInfoSelect = "waterm";
// 				const shouldBeSetItalic: string = scope.isItalic("acctInfoSelect");
// 				scope.$digest();
// 				expect(shouldBeSetItalic).toBe("setItalic");
// 				scope.activateEzTag.acctInfoSelect = "taxId";
// 				const shouldBeBlank: string = scope.isItalic("acctInfoSelect");
// 				scope.$digest();
// 				expect(shouldBeBlank).toBe("");
// 			});
// 			it("validate blankOutUnusedFields works corretly", () => {
// 				scope.activateEzTag.transactionId = "123456789";
// 				const cleansedInformation: any = scope.blankOutUnusedFields();
// 				expect(cleansedInformation.transactionId).toBe("123456789");
// 				expect(cleansedInformation.taxIdNumber).toBeUndefined();
// 				expect(cleansedInformation.driversLicense).toBeUndefined();
// 				expect(cleansedInformation.state).toBeUndefined();
// 				expect(cleansedInformation.emailAddress).toBeUndefined();
// 				expect(cleansedInformation.phoneNumber).toBeUndefined();
// 				expect(cleansedInformation.accountId).toBe(1234);
// 			});
// 			it("validate onCancel works corretly", () => {
// 				scope.onCancel();
// 				expect(setUrl.value).toBe("/Home");
// 			});
// 			it("validate createActivateEzTagStep1MarkerAndAdvance works corretly", () => {
// 				scope.activateEzTag.transactionId = "123456789";
// 				const accountTags = [{
// 					acctTagSeq: 22,
// 					acctTagSeqSpecified: true,
// 					acctTagStatus: "A",
// 					fullTagId: "HCTR09000001",
// 					licPlate: "TST123",
// 					licState: "TX",
// 					motorcycle: false,
// 					nickname: "Motor 114",
// 					tagId: "09000001",
// 					tagStatusDesc: "Active",
// 					temporaryLicPlate: false,
// 					vehicleClassCode: "2",
// 					vehicleClassDesc: "Two Axle Vehicle",
// 					vehicleColor: "BLACK",
// 					vehicleMake: "COACHMAN",
// 					vehicleModel: "ABC",
// 					vehicleYear: "2001"
// 				}];
// 				scope.createActivateEzTagStep1MarkerAndAdvance(accountTags);
// 				expect(setUrl.value).toBe("/ConfirmTagActivation");
// 				expect(storageForService.transactionId).toBe("123456789");
// 				expect(storageForService.step).toBe(2);
// 				expect(angular.equals(storageForService.listOfVehicles, accountTags)).toBeTruthy();
// 			});
// 			it("validate that Faq article route is correct", () => {
// 				scope.searchFaqMountEzTag();
// 				expect(linkLookupServiceInputRoute)
// 					.toBe("B40CBAB4-DD52-46E2-A5FB-DE7F4CDB8C55");
// 			});
// 		});
// 	});
// }());
(function () {
    "use strict";
    describe("activateEzTagWizardDirectorService", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var service, 
        //             setUrl = {
        //                 value: ""
        //             },
        mockLocation, testStorage;
        beforeEach(angular.mock.module(function ($provide) {
            testStorage = {
                activateEzTagWizardInformation: {
                    transactionId: "",
                    step: 0,
                    listOfVehicles: []
                }
            };
            mockLocation = jasmine.createSpyObj("$location", ["absUrl", "url", "protocol", "host", "port", "path", "search", "hash", "replace", "state"]);
            $provide.value("webStorage", hctraMocks.fakeWebStorage(testStorage));
            $provide.value("$location", mockLocation);
            $provide.value("routes", hctraMocks.routes());
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("activateEzTagWizardDirectorService");
        }));
        it("save step test", function () {
            service.saveStep([1, 2, 3, 4], "123456789", "/ActivateEzTag");
            expect(testStorage.activateEzTagWizardInformation.step).toEqual(2);
            expect(testStorage.activateEzTagWizardInformation.transactionId).toEqual("123456789");
            expect(angular.equals(testStorage.activateEzTagWizardInformation.listOfVehicles, [1, 2, 3, 4])).toBeTruthy();
        });
        it("destroy information test", function () {
            testStorage.activateEzTagWizardInformation.step = 2;
            testStorage.activateEzTagWizardInformation.transactionId = "123456789";
            testStorage.activateEzTagWizardInformation.listOfVehicles = [1, 2, 3, 4];
            service.destroyActivateEzTagInformation();
            expect(testStorage.activateEzTagWizardInformation).not.toBeDefined();
        });
        it("redirection test: no information stored -- Going to Step 1", function () {
            mockLocation.url.calls.reset();
            testStorage.activateEzTagWizardInformation = "";
            var redirectOccured = service.redirectToCorrectScreen("/ActivateEzTag");
            expect(redirectOccured).toBeFalsy();
            //expect(setUrl.value).toBe("");
            expect(mockLocation.url).not.toHaveBeenCalled();
        });
        it("redirection test: no information stored -- Going to Step 2", function () {
            delete testStorage.activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/ConfirmTagActivation");
            expect(redirectOccured).toBeTruthy();
            //expect(setUrl.value).toBe("/ActivateEzTag");
            expect(mockLocation.url).toHaveBeenCalledWith("/ActivateEzTag");
        });
        it("redirection test: no information stored -- Going to Step 3", function () {
            delete testStorage.activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/TagActivationGratitude");
            expect(redirectOccured).toBeTruthy();
            //expect(setUrl.value).toBe("/ActivateEzTag");
            expect(mockLocation.url).toHaveBeenCalledWith("/ActivateEzTag");
        });
        it("redirection test: Info saved is Step 1 but going to Step 2", function () {
            //setUrl.value = "/ConfirmTagActivation";
            var activateEzTagWizardInformation = {
                transactionId: "",
                step: 1,
                listOfVehicles: []
            };
            testStorage.activateEzTagWizardInformation = activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/ConfirmTagActivation");
            expect(redirectOccured).toBeTruthy();
            //expect(setUrl.value).toBe("/ActivateEzTag");
            expect(mockLocation.url).toHaveBeenCalledWith("/ActivateEzTag");
        });
        it("redirection test: Info saved is Step 2 and going to Step 2", function () {
            //setUrl.value = "/ConfirmTagActivation";
            mockLocation.url.calls.reset();
            var activateEzTagWizardInformation = {
                transactionId: "",
                step: 2,
                listOfVehicles: []
            };
            testStorage.activateEzTagWizardInformation = activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/ConfirmTagActivation");
            expect(redirectOccured).toBeFalsy();
            //expect(setUrl.value).toBe("/ConfirmTagActivation");
            expect(mockLocation.url).not.toHaveBeenCalled();
        });
        it("redirection test: Info saved is Step 3 but going to Step 2", function () {
            //setUrl.value = "/ConfirmTagActivation";
            var activateEzTagWizardInformation = {
                transactionId: "",
                step: 3,
                listOfVehicles: []
            };
            testStorage.activateEzTagWizardInformation = activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/ConfirmTagActivation");
            expect(redirectOccured).toBeTruthy();
            //expect(setUrl.value).toBe("/TagActivationGratitude");
            expect(mockLocation.url).toHaveBeenCalledWith("/TagActivationGratitude");
        });
        it("redirection test: Info saved is Step 1 but going to Step 3", function () {
            //setUrl.value = "/TagActivationGratitude";
            var activateEzTagWizardInformation = {
                transactionId: "",
                step: 1,
                listOfVehicles: []
            };
            testStorage.activateEzTagWizardInformation = activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/TagActivationGratitude");
            expect(redirectOccured).toBeTruthy();
            //expect(setUrl.value).toBe("/ActivateEzTag");
            expect(mockLocation.url).toHaveBeenCalledWith("/ActivateEzTag");
        });
        it("redirection test: Info saved is Step 2 but going to Step 3", function () {
            //setUrl.value = "/TagActivationGratitude";
            var activateEzTagWizardInformation = {
                transactionId: "",
                step: 2,
                listOfVehicles: []
            };
            testStorage.activateEzTagWizardInformation = activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/TagActivationGratitude");
            expect(redirectOccured).toBeTruthy();
            //expect(setUrl.value).toBe("/ConfirmTagActivation");
            expect(mockLocation.url).toHaveBeenCalledWith("/ConfirmTagActivation");
        });
        it("redirection test: Info saved is Step 3 but going to Step 3", function () {
            mockLocation.url.calls.reset();
            //setUrl.value = "/TagActivationGratitude";
            var activateEzTagWizardInformation = {
                transactionId: "",
                step: 3,
                listOfVehicles: []
            };
            testStorage.activateEzTagWizardInformation = activateEzTagWizardInformation;
            var redirectOccured = service.redirectToCorrectScreen("/TagActivationGratitude");
            expect(redirectOccured).toBeFalsy();
            //expect(setUrl.value).toBe("/TagActivationGratitude");
            expect(mockLocation.url).not.toHaveBeenCalled();
        });
    });
}());
(function () {
    "use strict";
    describe("ConfirmTagActivationController", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, setUrl, displayedMessage, testStorage;
        beforeEach(angular.mock.module(function () {
            setUrl = {
                value: ""
            };
            displayedMessage = {
                value: ""
            };
            testStorage = {
                activateEzTagWizardInformation: {
                    transactionId: "123456789",
                    step: 2,
                    listOfVehicles: "[{\"tagId\": \"01588990\", \"fullTagId\": \"HCTR01588990\", \"acctTagSeq\": 10, " +
                        "\"acctTagSeqSpecified\": true, \"licPlate\": \"3YX480\", \"licState\": \"TX\", \"motorcycle\": true, " +
                        "\"nickname\": \"Stevens Motorcycle\", \"temporaryLicPlate\": false, \"vehicleClassCode\": null, " +
                        "\"vehicleClassDesc\": null, \"vehicleColor\": \"BLACK\", \"vehicleMake\": \"YAMAHA\", \"vehicleModel\": " +
                        "\"V-STAR 950\", \"vehicleYear\": \"2009\", \"acctTagStatus\": \"V\", \"tagStatusDesc\": null}]"
                },
                transactionId: "",
                step: 2,
                listOfVehicles: []
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$location", hctraMocks.$location(setUrl)); // might need to change url
            $provide.value("routes", hctraMocks.routes());
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
            $provide.value("validationService", hctraMocks.validationService);
            $provide.value("webStorage", hctraMocks.fakeWebStorage(testStorage));
            $provide.value("activateEzTagWizardDirectorService", hctraMocks.activateEzTagWizardDirectorService(testStorage));
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile) {
            // create new, empty ng scope and controller objects
            scope = $rootScope.$new();
            var rootScope = $rootScope;
            // set a base scope object
            scope.activateEzTag = {};
            scope.activateTagStep2Form = {};
            // create the controller
            $controller("ConfirmTagActivationController", { $scope: scope, $rootScope: rootScope });
            $templateCache.put("/app/templates/activateEzTag/activateEzTagHeaderPartial.html", $templateCache.get("app/templates/activateEzTag/activateEzTagHeaderPartial.html"));
            $templateCache.put("/app/directives/checkboxTemplate.html", $templateCache.get("app/directives/checkboxTemplate.html"));
            var templateHtml = $templateCache.get("app/templates/activateEzTag/confirmTagActivation.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        it("form should be invalid first", function () {
            expect(scope.activateTagStep2Form.$invalid).toBeTruthy();
        });
        it("checking confirm box should validate form", function () {
            scope.activateEzTag.userHasConfirmed = true;
            scope.$digest();
            expect(scope.activateTagStep2Form.$invalid).toBeFalsy();
        });
        it("validate onCancel works corretly", function () {
            scope.onCancel();
            expect(setUrl.value).toBe("/ActivateEzTag");
            expect(testStorage.activateEzTagWizardInformation).toEqual({
                transactionId: null,
                step: null,
                listOfVehicles: null
            });
            var activateEzTagWizardInformation = {
                transactionId: "123456789",
                step: 2,
                listOfVehicles: "[{\"tagId\": \"01588990\", \"fullTagId\": \"HCTR01588990\", \"acctTagSeq\": 10, " +
                    "\"acctTagSeqSpecified\": true, \"licPlate\": \"3YX480\", \"licState\": \"TX\", \"motorcycle\": true, " +
                    "\"nickname\": \"Stevens Motorcycle\", \"temporaryLicPlate\": false, \"vehicleClassCode\": null, " +
                    "\"vehicleClassDesc\": null, \"vehicleColor\": \"BLACK\", \"vehicleMake\": \"YAMAHA\", \"vehicleModel\": " +
                    "\"V-STAR 950\", \"vehicleYear\": \"2009\", \"acctTagStatus\": \"V\", \"tagStatusDesc\": null}]"
            };
            testStorage.activateEzTagWizardInformation = activateEzTagWizardInformation;
        });
        it("validate createActivateEzTagStep2MarkerAndAdvance works corretly", function () {
            scope.activateEzTag.transactionId = "123456789";
            scope.activateEzTag.vehicleList = [{
                    acctTagSeq: 22,
                    acctTagSeqSpecified: true,
                    acctTagStatus: "A",
                    fullTagId: "HCTR09000001",
                    licPlate: "TST123",
                    licState: "TX",
                    motorcycle: false,
                    nickname: "Motor 114",
                    tagId: "09000001",
                    tagStatusDesc: "Active",
                    temporaryLicPlate: false,
                    vehicleClassCode: "2",
                    vehicleClassDesc: "Two Axle Vehicle",
                    vehicleColor: "BLACK",
                    vehicleMake: "COACHMAN",
                    vehicleModel: "ABC",
                    vehicleYear: "2001"
                }];
            scope.createActivateEzTagStep2MarkerAndAdvance();
            expect(setUrl.value).toBe("/TagActivationGratitude");
            expect(testStorage.transactionId).toBe("123456789");
            expect(angular.equals(testStorage.listOfVehicles, scope.activateEzTag.vehicleList)).toBeTruthy();
            expect(testStorage.step).toBe(3);
        });
    });
}());
(function () {
    "use strict";
    describe("TagActivationGratitudeController", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope;
        var setUrl;
        var testStorage;
        var authObj;
        beforeEach(angular.mock.module(function () {
            setUrl = {
                value: ""
            };
            testStorage = {
                activateEzTagWizardInformation: {
                    transactionId: "123456789",
                    step: 2,
                    listOfVehicles: "[{\"tagId\": \"01588990\", \"fullTagId\": \"HCTR01588990\", \"acctTagSeq\": 10, " +
                        "\"acctTagSeqSpecified\": true, \"licPlate\": \"3YX480\", \"licState\": \"TX\", \"motorcycle\": true, " +
                        "\"nickname\": \"Stevens Motorcycle\", \"temporaryLicPlate\": false, \"vehicleClassCode\": null, " +
                        "\"vehicleClassDesc\": null, \"vehicleColor\": \"BLACK\", \"vehicleMake\": \"YAMAHA\", \"vehicleModel\": " +
                        "\"V-STAR 950\", \"vehicleYear\": \"2009\", \"acctTagStatus\": \"V\", \"tagStatusDesc\": null}]"
                },
                transactionId: "",
                step: 2,
                listOfVehicles: []
            };
            authObj = {
                isAuthenticated: false
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$location", hctraMocks.$location(setUrl)); // might need to change url
            $provide.value("homeRoutes", { Frame: 'fake home' });
            $provide.value("webStorage", hctraMocks.fakeWebStorage(testStorage));
            $provide.value("activateEzTagWizardDirectorService", hctraMocks.activateEzTagWizardDirectorService(testStorage));
            $provide.value("AuthService", hctraMocks.AuthService(authObj));
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile) {
            // create new, empty ng scope and controller objects
            scope = $rootScope.$new();
            var rootScope = $rootScope;
            // set a base scope object
            scope.activateEzTag = {};
            // create the controller
            $controller("TagActivationGratitudeController", { $scope: scope, $rootScope: rootScope });
            $templateCache.put("/app/templates/activateEzTag/activateEzTagHeaderPartial.html", $templateCache.get("app/templates/activateEzTag/activateEzTagHeaderPartial.html"));
            var templateHtml = $templateCache.get("app/templates/activateEzTag/tagActivationGratitude.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        it("test exitWizard when logged in", function () {
            authObj.isAuthenticated = true;
            scope.exitWizard();
            expect(testStorage.activateEzTagWizardInformation).toEqual({
                transactionId: null,
                step: null,
                listOfVehicles: null
            });
            expect(setUrl.value).toBe("/ManageVehicles");
        });
        it("test exitWizard when not logged in", function () {
            authObj.isAuthenticated = false;
            scope.exitWizard();
            expect(testStorage.activateEzTagWizardInformation).toEqual({
                transactionId: null,
                step: null,
                listOfVehicles: null
            });
            expect(setUrl.value).toBe("/Home");
        });
    });
}());
(function () {
    'use strict';
    describe('ArticleController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var controller, ArticleController, state, scope, routes, stateNames, genericRepo, dateService, cmsUtilService, displayedMessage = {}, inState = {}, setUrl = {}, scrollTo = {}, inTimer = {}, rssObj = {};
        beforeEach(angular.mock.module(function () {
            displayedMessage = {};
            inState = {};
            setUrl = {};
            scrollTo = {};
            inTimer = {};
            rssObj = {};
        }));
        function fakeGenericRepoCall() {
            return {
                then: function (cb) {
                    cb({
                        responses: [
                            { cmsResponse: '{"ItemID":"dcb2d622-f2ab-474a-b9b7-782cca2c2bbf","HasChildren":"False","Title":"News"}', errors: [] },
                            { cmsResponse: '{"Query": {"Results":[{"itemID":"dc6f0ad8-19f7-4b7d-bb1d-002aa3539c03","hasChildren":false,"title":"MoonKnight","longDescription":"<span style=\\"color: #ff0000;\\">Lorem ipsum dolor</span> sit amet, <span style=\\"background-color: #92d050;\\">consectetur adipiscing </span>elit. <em>Mauris congue </em>vulputate <strong>erat hendrerit </strong>t<span style=\\"text-decoration: underline;\\">incidunt</span>.","category":"Category2","image":"","shortDescription":"<p><span style=\\"color: #545454;\\">Perchance he for whom this bells tolls may be so ill as that he knows not it tolls for him. And per</span></p>","__Updated":"20160810T214934Z","startDate":null,"endDate":null,"queryID":null,"itemPath":"/sitecore/content/HCTRA/TravelTools/NewsArchivePage/ResultsSection/Data/MoonKnight","displayName":"MoonKnight","subtitle":"hubahuba","friendlyURL":"","isPermanent":null}]}}', errors: [] }
                        ],
                        cmsResponse: null,
                        errors: [],
                        alerts: []
                    });
                }
            };
        }
        beforeEach(angular.mock.module(function ($provide) {
            genericRepo = {
                dataFactory: {
                    getCmsPages: function () { }
                }
            };
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('$location', hctraMocks.$location(setUrl));
            $provide.value('$anchorScroll', hctraMocks.$anchorScroll(scrollTo));
            $provide.value('$timeout', hctraMocks.$timeout(inTimer));
            $provide.value('dateService', hctraMocks.dateService());
            $provide.value('cmsUtilService', hctraMocks.cmsUtilService());
            $provide.value('rssService', hctraMocks.rssService(rssObj));
            $provide.value('operatingSystemSnifferService', hctraMocks.operatingSystemSnifferService());
            $provide.value('genericRepo', genericRepo);
        }));
        beforeEach(angular.mock.inject(function (_dateService_, _cmsUtilService_, _genericRepo_) {
            dateService = _dateService_;
            cmsUtilService = _cmsUtilService_;
            genericRepo = _genericRepo_;
            spyOn(dateService, 'isExpiredFilterForCms').and.callFake(hctraMocks.dateService().isExpiredFilterForCms);
            spyOn(cmsUtilService, 'processArticleArray').and.callFake(hctraMocks.cmsUtilService().processArticleArray);
            spyOn(cmsUtilService, 'formatDisplayDates');
            spyOn(genericRepo.dataFactory, 'getCmsPages').and.callFake(fakeGenericRepoCall);
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, _$state_, _routes_, _stateNames_) {
            scope = _$rootScope_.$new();
            controller = _$controller_;
            state = _$state_;
            routes = _routes_;
            stateNames = _stateNames_;
            ArticleController = controller('ArticleController', {
                $scope: scope
            });
        }));
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should initialize the article array in init', function () {
            expect(scope.articleArray).toBeDefined();
            expect(typeof scope.articleArray).toBe(typeof []);
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should set the top title of the page based on mock repo response', function () {
            expect(scope.topTitle).toBe("News");
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should set and process the article array based on mock repo response', function () {
            expect(scope.articleArray.length).toBe(1);
            expect(typeof scope.articleArray[0]).toBe(typeof {});
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
            expect(cmsUtilService.processArticleArray).toHaveBeenCalledWith([jasmine.objectContaining({
                    endDate: null,
                    startDate: null
                })]);
        });
        it('add extra margin when articles are zero in mobile', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([], false);
            expect(showingExtraMargin).toBeTruthy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('add extra margin when articles is undefined in mobile', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin(undefined, false);
            expect(showingExtraMargin).toBeTruthy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('add extra margin when articles is null in mobile', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin(null, false);
            expect(showingExtraMargin).toBeTruthy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('add extra margin when articles is one and includes transtarmap in mobile', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([{ title: 'Transtar Map' }], false);
            expect(showingExtraMargin).toBeTruthy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('do not add extra margin when articles is 1 and does not include transtarmap in mobile', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([{ title: 'hitman' }], false);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('do not add extra margin when articles is greater than 1 in mobile', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([1, 2], false);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should not add extra margin when articles are zero in desktop', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([], true);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should not add extra margin when articles is undefined in desktop', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin(undefined, true);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should not add extra margin when articles is null in desktop', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin(null, true);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should not add extra margin when articles is one and includes transtarmap in desktop', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([{ title: 'Transtar Map' }], true);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should not do not add extra margin when articles is 1 and does not include transtarmap in desktop', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([{ title: 'hitman' }], true);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        it('should not do not add extra margin when articles is greater than 1 in desktop', function () {
            var showingExtraMargin = scope.shouldShowExtraMargin([1, 2], true);
            expect(showingExtraMargin).toBeFalsy();
            expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
        });
        describe('Closures scenario', function () {
            it('should set the archive name in init', function () {
                state.current.cms.archiveName = 'Closures';
                ArticleController = controller('ArticleController', {
                    $scope: scope
                });
                expect(scope.archiveName).toBe('Closures');
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(2);
            });
            it('should set the archive type in init', function () {
                state.current.name = stateNames.closures;
                ArticleController = controller('ArticleController', {
                    $scope: scope
                });
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(2);
                expect(scope.isClosures).toBeTruthy();
            });
            it('should be able to navigate to the RSS feed for closures', function () {
                state.current.name = stateNames.closures;
                ArticleController = controller('ArticleController', {
                    $scope: scope
                });
                scope.goToRssFeed();
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(2);
                expect(rssObj.value).toBe(routes.rssMajorClosuresKey);
            });
            it('should be able to go to config archive', function () {
                state.current.cms.archive = stateNames.closuresArchive;
                scope.toArchive();
                expect(inState.value).toBe(stateNames.closuresArchive);
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
            });
        });
        describe('News scenario', function () {
            it('should set the archive name in init', function () {
                state.current.cms.archiveName = 'News';
                ArticleController = controller('ArticleController', {
                    $scope: scope
                });
                expect(scope.archiveName).toBe('News');
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(2);
            });
            it('should set the archive type in init', function () {
                state.current.name = stateNames.newsFeed;
                ArticleController = controller('ArticleController', {
                    $scope: scope
                });
                expect(scope.isClosures).toBeFalsy();
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(2);
            });
            it('should be able to navigate to the RSS feed for closures', function () {
                state.current.name = stateNames.newsFeed;
                ArticleController = controller('ArticleController', {
                    $scope: scope
                });
                scope.goToRssFeed();
                expect(rssObj.value).toBe(routes.rssLatestNewsKey);
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(2);
            });
            it('should be able to go to config archive', function () {
                state.current.cms.archive = stateNames.newsArchive;
                scope.toArchive();
                expect(inState.value).toBe(stateNames.newsArchive);
                expect(genericRepo.dataFactory.getCmsPages.calls.count()).toEqual(1);
            });
        });
    });
}());
(function () {
    'use strict';
    describe('cmsTextInsertionService', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var service, valuesObject, stringToinsert;
        beforeEach(angular.mock.module(function () {
            valuesObject = {};
            stringToinsert = "";
        }));
        beforeEach(angular.mock.inject(function (_cmsTextInsertionService_) {
            service = _cmsTextInsertionService_;
        }));
        it('should not replace the value', function () {
            valuesObject.test = 'This is a test';
            stringToinsert = 'test';
            var sut = service.insertValues(valuesObject, stringToinsert);
            expect(sut).toBeDefined();
            expect(sut).toEqual('test');
        });
        it('should replace [[key]] with value', function () {
            valuesObject.test = 'test';
            stringToinsert = ' testtesttest [[test]] testtesttest ';
            var sut = service.insertValues(valuesObject, stringToinsert);
            expect(sut).toBeDefined();
            expect(sut).toEqual(' testtesttest test testtesttest ');
        });
        it('should replace sentence within curly braces to empty', function () {
            valuesObject.test = null;
            stringToinsert = '{{{ asdf [[test]] asdf }}}';
            var sut = service.checkOptional(valuesObject, stringToinsert);
            expect(sut).toBeDefined();
            expect(sut).toEqual('');
        });
        it('should remove curly braces but keep sentence', function () {
            valuesObject.test = 'test';
            stringToinsert = '{{{ asdf [[test]] asdf }}}';
            var sut = service.checkOptional(valuesObject, stringToinsert);
            expect(sut).toBeDefined();
            expect(sut).toEqual(' asdf test asdf ');
        });
        describe("dynamic content", function () {
            it('should replace [[]] with {{}}', function () {
                var input = "There are some who call me... [[name]]";
                var output = service.dynamicContent(input);
                expect(output).toBe("There are some who call me... {{name}}");
            });
            it('should normalize prop key', function () {
                var input = "There are some who call me... [[name]]";
                var output = service.dynamicContent(input, { pathNorm: ["$ctrl"] });
                expect(output).toBe("There are some who call me... {{$ctrl.name}}");
            });
            it('should replace [[]] with {{}} with object path', function () {
                var input = "There are some who call me... [[name]]";
                var output = service.dynamicContent(input, { pathNorm: ["$ctrl", "viewModel"] });
                expect(output).toBe("There are some who call me... {{$ctrl.viewModel.name}}");
            });
            it('should allow angular filters', function () {
                var input = "There are some who call me... [[name | uppercase]]";
                var output = service.dynamicContent(input, { pathNorm: ["$ctrl"] });
                expect(output).toBe("There are some who call me... {{$ctrl.name | uppercase}}");
            });
        });
    });
}());
/*
(function () {
    'use strict';

    //describe() begins a unit testing fixture
    describe('metadataManagerService', function () {

        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));

        var service,
            findParentWasCalled,
            toggleForhasAnyOfKeysInList,

            setUrl = { testUrl: "/test" },
            wildCardUrlCheckerService = {
                findParentUrlInWildCardDict: function () {
                    findParentWasCalled = true;
                }
            },
            objectUtilService = {
                hasAnyOfKeysInList: function () {
                    return toggleForhasAnyOfKeysInList;
                }
            };

        //$provide is a module-level object, and thus must get its own
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('javaObjectUtilService', hctraMocks.javaObjectUtilService());
            $provide.value('$location', hctraMocks.$location(setUrl));
            $provide.value('cmsUtilService', hctraMocks.cmsUtilService());
            //$provide.value('$q', hctraMocks.$q());
            $provide.value('urlManagerService', hctraMocks.urlManagerService());
            $provide.value('wildCardUrlCheckerService', wildCardUrlCheckerService);
            $provide.value('objectUtilService', objectUtilService);
        }));

        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('metadataManagerService');
            service.metadataDictionary["/AccountSummary"] = {
                searchTitle: "AccountSummary"
            };
            service.metadataDictionary["/Home"] = {
                searchTitle: "Home",
                searchDescription: "Home Des",
                searchThumbnail: "<Thumb>",
                includeInSearch: true
            };
            findParentWasCalled = false;
            toggleForhasAnyOfKeysInList = false;
        }));

        describe('returnMetadataOrIndicatePageShouldBeIgnored', function () {

            it('test value not in dictionary', function () {
                var metadataValue = service.returnMetadataOrIndicatePageShouldBeIgnored("/OuchDaniel");
                expect(metadataValue.doNotIndex).toBe(true);
                expect(metadataValue.searchTitle).toBeUndefined();
                expect(metadataValue.searchDescription).toBeUndefined();
                expect(metadataValue.searchThumbnail).toBeUndefined();
                expect(findParentWasCalled).toBeTruthy();
            });

            it('test value in dictionary but not searchable', function () {
                var metadataValue = service.returnMetadataOrIndicatePageShouldBeIgnored("/AccountSummary");
                expect(metadataValue.doNotIndex).toBe(true);
                expect(metadataValue.searchTitle).toBe("AccountSummary");
                expect(metadataValue.searchDescription).toBeUndefined();
                expect(metadataValue.searchThumbnail).toBeUndefined();
                expect(findParentWasCalled).toBeFalsy();
            });

            it('test value that is in dictionary and searchable', function () {
                var metadataValue = service.returnMetadataOrIndicatePageShouldBeIgnored("/Home");
                expect(metadataValue.doNotIndex).toBeFalsy();
                expect(metadataValue.searchTitle).toBe("Home");
                expect(metadataValue.searchDescription).toBe("Home Des");
                expect(metadataValue.searchThumbnail).toBe("<Thumb>");
                expect(findParentWasCalled).toBeFalsy();

            });

        });

        describe('modifyRelativeUrlForUrlParamsInSitecore tests', function () {

            it('test when key is not found', function () {

                var relativeUrl = service.modifyRelativeUrlForUrlParamsInSitecore("/Home");
                expect(relativeUrl).toEqual("/Home");
            });

            it('test when key is found', function () {
                toggleForhasAnyOfKeysInList = true;
                var relativeUrl = service.modifyRelativeUrlForUrlParamsInSitecore("/Home");
                expect(relativeUrl).toEqual("/test");
            });
        });

        describe('lookupMetadataForWilcardRelativeUrl tests', function () {

            it('metaData found', function () {

                var metaData = service.lookupMetadataForWilcardRelativeUrl("/Home");
                expect(metaData).toEqual("/Home");
            });

            it('metaData Not found', function () {
                service.lookupMetadataForWilcardRelativeUrl(null);
                expect(findParentWasCalled).toBeTruthy();
            });
        });

        it('test that urlParametersToConsider has all neccessary urls', function () {
            expect(service.urlParametersToConsider).toEqual(['tollRoad']);
        });

    });

}());
*/ 
(function () {
    "use strict";
    describe("SearchArticleController", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, mockLocation, $controller, genericRepo, cmsUtilService, 
        //
        //            inLocation: {
        //                value: string,
        //                categoryPath: boolean,
        //                articlePath: boolean,
        //                deleteSuccess: boolean,
        //                hash: (inValue: any) => void
        //            },
        //            returnLocation: { [key: string]: any },
        //            returnLocationCounter: number,
        displayedMessage, inState, scrollTo, inTimer, DesktopSwitcher, genericRepoData, spyOnScope, goValues;
        beforeEach(angular.mock.module(function () {
            displayedMessage = {
                value: ""
            };
            inState = {
                value: "",
                current: {
                    name: "whatisthis",
                    parentState: false,
                    cms: {
                        categoriesPath: "",
                        titleType: "oisjgoisjaedg"
                    }
                },
                href: function (inObject, inObject2) { return { inObject: inObject, inObject2: inObject2 }; },
                go: function (inObject, inObject2) {
                    goValues = { inObject: inObject, inObject2: inObject2 };
                    return { inObject: inObject, inObject2: inObject2 };
                },
                is: function (inObject) { return inObject; }
            };
            scrollTo = {
                value: ""
            };
            inTimer = {
                func: null,
                value: -1
            };
            DesktopSwitcher = {
                isDesktop: true
            };
            //            inLocation = {
            //                value: "",
            //                categoryPath: true,
            //                articlePath: true,
            //                deleteSuccess: false,
            //                hash: (inValue: any): void => { returnLocation["Test" + returnLocationCounter++] = inValue; }
            //            };
            //            returnLocation = {};
            //            returnLocationCounter = 1;
            mockLocation = hctraMocks.$location();
            genericRepoData = { loadArchivePageData: {} };
            spyOnScope = {
                setDesktopParameters: function () { return; },
                setMobileParameters: function () { return; },
                scrollToSearchResults: function () { return; },
                createNavigationUrls: function () { return; },
                getStateThatTriggersSearch: function () { return; }
            };
            goValues = {
                inObject: {},
                inObject2: {}
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$location", mockLocation); // might need to change url
            $provide.value("genericRepo", hctraMocks.genericRepo(genericRepoData));
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
            $provide.value("$state", hctraMocks.fake$state(inState));
            $provide.value("$anchorScroll", hctraMocks.$anchorScroll(scrollTo));
            $provide.value("$timeout", hctraMocks.$timeout(inTimer));
            $provide.value("responsiveService", hctraMocks.responsiveService());
            $provide.value("operatingSystemSnifferService", hctraMocks.operatingSystemSnifferService(DesktopSwitcher));
            $provide.value("cmsUtilService", hctraMocks.cmsUtilService());
        }));
        beforeEach(angular.mock.inject(function ($rootScope, _$controller_, _genericRepo_, _cmsUtilService_) {
            // create new, empty ng scope, controller, service objects
            scope = $rootScope.$new();
            $controller = _$controller_;
            scope.searchForm = {
                $setSubmitted: function () {
                    return;
                }
            };
            // create the controller
            $controller("SearchArticleController", { $scope: scope });
            genericRepo = _genericRepo_.dataFactory;
            spyOnScope.setDesktopParameters = angular.copy(scope.setDesktopParameters);
            spyOnScope.setMobileParameters = angular.copy(scope.setMobileParameters);
            spyOnScope.scrollToSearchResults = angular.copy(scope.scrollToSearchResults);
            spyOnScope.createNavigationUrls = angular.copy(scope.createNavigationUrls);
            spyOnScope.getStateThatTriggersSearch = angular.copy(scope.getStateThatTriggersSearch);
            spyOn(genericRepo, "executeCmsPaging").and.callFake(hctraMocks.genericRepo().dataFactory.executeCmsPaging);
            cmsUtilService = _cmsUtilService_;
            spyOn(cmsUtilService, "convertStartEndDates").and.callFake(hctraMocks.cmsUtilService().convertStartEndDates);
            spyOn(cmsUtilService, "addDisplayDates").and.callFake(hctraMocks.cmsUtilService().addDisplayDates);
        }));
        it("test initializeScrollingGlobals for Desktop", function () {
            scope.pagingObject = {
                currentPage: 1,
                numberOfPages: 4,
                pageSize: 5
            };
            scope.initializeScrollingGlobals();
            expect(scope.endOfDataReached).toBeFalsy();
            expect(scope.virtualScrollisPaused).toBeFalsy();
            expect(scope.articleArray).toEqual([]);
            expect(scope.totalItems).toEqual(0);
            expect(scope.pagingObject.currentPage).toEqual(1);
            expect(scope.pagingObject.numberOfPages).toEqual(4);
            expect(scope.pagingObject.pageSize).toEqual(5);
        });
        it("test initializeScrollingGlobals for Mobile", function () {
            DesktopSwitcher.isDesktop = false;
            $controller("SearchArticleController", { $scope: scope });
            scope.pagingObject = {
                currentPage: 1,
                numberOfPages: 4,
                pageSize: 5
            };
            scope.initializeScrollingGlobals();
            expect(scope.endOfDataReached).toBeFalsy();
            expect(scope.virtualScrollisPaused).toBeFalsy();
            expect(scope.articleArray).toEqual([]);
            expect(scope.totalItems).toEqual(0);
            expect(scope.pagingObject.currentPage).toEqual(0);
            expect(scope.pagingObject.numberOfPages).toEqual(0);
            expect(scope.pagingObject.pageSize).toEqual("");
        });
        it("test init for a non-faq state", function () {
            inState.current.cms.categoriesPath = "whatup!";
            scope.pagingObject.currentPage = 1;
            scope.pagingObject.numberOfPages = 1;
            scope.pagingObject.pageSize = "";
            scope.categoryHolder = { category: { itemName: "test" } };
            genericRepoData.loadArchivePageData = {
                responses: [{ cmsResponse: angular.toJson({ Title: "Title1" }) }, { cmsResponse: angular.toJson({ Title: "Title2" }) }],
                hyperLinkedArticles: { articles: [1, 2, 3], numberOfPages: 4 },
                categories: [{ itemName: "test" }, "C2"],
                categoryIndex: 0,
                topSearchResults: null,
                dataNotFound: false,
                numberOfArticles: 5,
                errors: [],
                alerts: [],
                articleNotFoundText: "thisistrashynoidonotbelievethat"
            };
            scope.init();
            expect(scope.topTitle).toEqual("Title1");
            expect(scope.articleNotFoundText).toEqual("thisistrashynoidonotbelievethat");
            expect(scope.categories).toEqual(genericRepoData.loadArchivePageData.categories);
            expect(scope.commonFaqArray).toBeUndefined();
        });
        it("test init for a faq state", function () {
            inState.current.cms.categoriesPath = "whatup!";
            scope.pagingObject.currentPage = 1;
            scope.pagingObject.numberOfPages = 1;
            scope.pagingObject.pageSize = "";
            scope.categoryHolder = { category: { itemName: "test" } };
            genericRepoData.loadArchivePageData = {
                responses: [{ cmsResponse: angular.toJson({ Title: "Title1" }) }, { cmsResponse: angular.toJson({ Title: "Title2" }) }],
                hyperLinkedArticles: { articles: [1, 2, 3], numberOfPages: 4 },
                categories: [{ itemName: "test" }, "C2"],
                categoryIndex: 0,
                dataNotFound: false,
                numberOfArticles: 5,
                errors: [],
                alerts: [],
                articleNotFoundText: "thisistrashynoidonotbelievethat",
                topSearchResults: angular.toJson({ Query: { Results: [1, 2], TotalCount: 2 } })
            };
            scope.init();
            expect(scope.topTitle).toEqual("Title1");
            expect(scope.articleNotFoundText).toEqual("thisistrashynoidonotbelievethat");
            expect(scope.categories).toEqual(genericRepoData.loadArchivePageData.categories);
            expect(scope.commonFaqArray).toEqual([1, 2]);
            expect(scope.topSearchResultsCount).toEqual(2);
        });
        // TODO: make testcase for 5
        it("test buildSearchObect when a pagesize has not been set", function () {
            scope.categoryHolder.category.queryID = "546514";
            scope.archiveTypeChecker.isClosures = false;
            scope.pagingObject.currentPage = 1;
            scope.pagingObject.pageSize = "";
            var returnedObject = scope.buildSearchObject();
            expect(returnedObject.pagingSuffix).toBe("");
            expect(returnedObject.pageSize).toBe(50);
            expect(returnedObject.currentPage).toBe(1);
            expect(returnedObject.itemId).toBe("546514");
            expect(returnedObject.isClosures).toBe(false);
        });
        it("test buildSearchObect when a pagesize has been set", function () {
            scope.categoryHolder.category.queryID = "546514";
            scope.categoryHolder.category.itemPath = "jm23jm/arg/af";
            scope.archiveTypeChecker.isClosures = false;
            scope.pagingObject.currentPage = 1;
            scope.pagingObject.pageSize = 50;
            var returnedObject = scope.buildSearchObject();
            expect(returnedObject.pagingSuffix).toBe("");
            expect(returnedObject.pageSize).toBe(50);
            expect(returnedObject.currentPage).toBe(1);
            expect(returnedObject.itemId).toBe("546514");
            expect(returnedObject.isClosures).toBe(false);
        });
        it("test userClickedSearch", function () {
            scope.totalItems = 0;
            scope.userClickedSearch();
            expect(scope.totalItems).toBe(500);
        });
        it("test performSearch when mobile and endofdata has been reached", function () {
            scope.initializeScrollingGlobals();
            scope.isDesktop = false;
            scope.endOfDataReached = true;
            scope.virtualScrollisPaused = false;
            scope.pagingObject.currentPage = 5;
            scope.performSearch();
            expect(genericRepo.executeCmsPaging.calls.count()).toEqual(0);
            expect(scope.virtualScrollisPaused).toEqual(false);
            expect(scope.pagingObject.currentPage).toBe(5);
        });
        it("test performSearch when mobile and virtualscrollispaused is true", function () {
            scope.initializeScrollingGlobals();
            scope.isDesktop = false;
            scope.endOfDataReached = false;
            scope.virtualScrollisPaused = true;
            scope.pagingObject.currentPage = 5;
            scope.performSearch();
            expect(genericRepo.executeCmsPaging.calls.count()).toEqual(0);
            expect(scope.virtualScrollisPaused).toEqual(true);
            expect(scope.pagingObject.currentPage).toBe(5);
        });
        it("test performSearch when desktop", function () {
            scope.isDesktop = true;
            scope.performSearch();
            expect(genericRepo.executeCmsPaging.calls.count()).toEqual(1);
            expect(scope.virtualScrollisPaused).toEqual(false);
        });
        it("test performSearch when mobile and search ready", function () {
            scope.initializeScrollingGlobals();
            scope.isDesktop = false;
            scope.endOfDataReached = false;
            scope.virtualScrollisPaused = false;
            scope.pagingObject.currentPage = 5;
            scope.performSearch();
            expect(genericRepo.executeCmsPaging.calls.count()).toEqual(1);
            expect(scope.virtualScrollisPaused).toEqual(false);
            expect(scope.pagingObject.currentPage).toBe(0);
        });
        it("test SaveSearchParameters for mobile", function () {
            spyOn(scope, "setDesktopParameters").and.callFake(spyOnScope.setDesktopParameters);
            spyOn(scope, "setMobileParameters").and.callFake(spyOnScope.setMobileParameters);
            scope.isDesktop = false;
            scope.pagingObject.numberOfPages = 7;
            scope.totalItems = 5;
            scope.saveSearchParameters({ numberOfPages: 100, numberOfArticles: 50 });
            expect(scope.setDesktopParameters.calls.count()).toEqual(0);
            expect(scope.setMobileParameters.calls.count()).toEqual(1);
            expect(scope.pagingObject.numberOfPages).toEqual(100);
            expect(scope.totalItems).toBe(50);
        });
        it("test SaveSearchParameters for desktop", function () {
            spyOn(scope, "setDesktopParameters").and.callFake(spyOnScope.setDesktopParameters);
            spyOn(scope, "setMobileParameters").and.callFake(spyOnScope.setMobileParameters);
            scope.isDesktop = true;
            scope.pagingObject.numberOfPages = 7;
            scope.totalItems = 5;
            scope.saveSearchParameters({ numberOfPages: 100, numberOfArticles: 50 });
            expect(scope.setDesktopParameters.calls.count()).toEqual(1);
            expect(scope.setMobileParameters.calls.count()).toEqual(0);
            expect(scope.pagingObject.numberOfPages).toEqual(100);
            expect(scope.totalItems).toBe(50);
        });
        it("test setting of mobile parameters after a successful search", function () {
            scope.pagingObject.currentPage = 0;
            scope.pagingObject.numberOfPages = 1;
            var response = {
                articles: [1, 2, 3]
            };
            scope.articleArray = [];
            scope.setMobileParameters(response);
            expect(scope.endOfDataReached).toBeTruthy();
            expect(scope.articleArray).toEqual([1, 2, 3]);
            scope.pagingObject.currentPage = 0;
            scope.pagingObject.numberOfPages = 2;
            response = {
                articles: [1, 2, 3]
            };
            scope.articleArray = [];
            scope.setMobileParameters(response);
            expect(scope.endOfDataReached).toBeFalsy();
            expect(scope.articleArray).toEqual([1, 2, 3]);
            scope.pagingObject.currentPage = 0;
            scope.pagingObject.numberOfPages = 2;
            response = {
                articles: []
            };
            scope.articleArray = [1, 2, 3];
            scope.setMobileParameters(response);
            expect(scope.endOfDataReached).toBeFalsy();
            expect(scope.articleArray).toEqual([1, 2, 3]);
        });
        it("test setDesktopParameters", function () {
            spyOn(scope, "scrollToSearchResults").and.callFake(spyOnScope.scrollToSearchResults);
            spyOn(scope, "createNavigationUrls").and.callFake(spyOnScope.createNavigationUrls);
            scope.setDesktopParameters({ articles: [1, 2, 3] });
            expect(scope.createNavigationUrls.calls.count()).toEqual(1);
            expect(scope.scrollToSearchResults.calls.count()).toEqual(0); // on init page load
            expect(scope.articleArray).toEqual([1, 2, 3]);
        });
        it("test loading of archive page child", function () {
            inState.current.parentState = "test";
            scope.loadArchivePage();
            expect(goValues.inObject).toEqual(".Child");
            expect(goValues.inObject2).toEqual({
                category: "All",
                page: 0,
                size: ""
            });
        });
        it("test addDisplayDateToArticles with empty article array", function () {
            var articleArr = [];
            scope.addDisplayDateToArticles(articleArr);
            expect(cmsUtilService.convertStartEndDates.calls.count()).toEqual(0);
            expect(cmsUtilService.addDisplayDates.calls.count()).toEqual(0);
        });
        it("test addDisplayDateToArticles with array with items", function () {
            var articleArr = [1, 2, 3];
            inState.current.name = "ClosuresArchive.Child";
            scope.addDisplayDateToArticles(articleArr);
            expect(cmsUtilService.convertStartEndDates.calls.count()).toEqual(1);
            expect(cmsUtilService.addDisplayDates.calls.count()).toEqual(3);
            expect(cmsUtilService.addDisplayDates).toHaveBeenCalledWith(1, true);
        });
        it("test addDisplayDateToArticles with array with items - no closures", function () {
            var articleArr = [1, 2, 3];
            inState.current.name = "News";
            scope.addDisplayDateToArticles(articleArr);
            expect(cmsUtilService.convertStartEndDates.calls.count()).toEqual(1);
            expect(cmsUtilService.addDisplayDates.calls.count()).toEqual(3);
            expect(cmsUtilService.addDisplayDates).toHaveBeenCalledWith(1, false);
        });
        it("test setArchiveType", function () {
            inState.current.name = hctraMocks.stateNames().closuresArchiveChild;
            scope.setArchiveType();
            expect(scope.archiveTypeChecker.isClosures).toBeTruthy();
            expect(scope.archiveTypeChecker.isFaqs).toBeFalsy();
            expect(scope.archiveTypeChecker.isNews).toBeFalsy();
            inState.current.name = hctraMocks.stateNames().faqChild;
            scope.setArchiveType();
            expect(scope.archiveTypeChecker.isClosures).toBeFalsy();
            expect(scope.archiveTypeChecker.isFaqs).toBeTruthy();
            expect(scope.archiveTypeChecker.isNews).toBeFalsy();
            inState.current.name = hctraMocks.stateNames().newsArchiveChild;
            scope.setArchiveType();
            expect(scope.archiveTypeChecker.isClosures).toBeFalsy();
            expect(scope.archiveTypeChecker.isFaqs).toBeFalsy();
            expect(scope.archiveTypeChecker.isNews).toBeTruthy();
        });
        //todo: make testcase for 5
        it("test createInitialRequestObject", function () {
            inState.current.cms.pageTitleId = "asmdglkmsd";
            inState.current.cms.pageTitleFields = "a,whase,rh";
            inState.current.cms.categoriesFolderId = "2w4ygwsg";
            inState.current.cms.categoriesFields = "awrh,35uhwr";
            inState.current.cms.topSearch = "24tyqeg/24y2qef/";
            inState.current.cms.topFields = "2a4,gsdg,2q3t";
            scope.categoryHolder.category.itemId = "hi/you/see";
            scope.pagingObject.pageSize = "";
            scope.pagingObject.currentPage = 10;
            scope.archiveTypeChecker.isClosures = true;
            scope.archiveTypeChecker.isNews = false;
            var createdObject = scope.createInitialRequestObject();
            expect(createdObject.requests[0].itemId).toEqual("asmdglkmsd");
            expect(createdObject.requests[0].fields).toEqual("a,whase,rh");
            expect(createdObject.requests[1].itemId).toEqual("2w4ygwsg");
            expect(createdObject.requests[1].fields).toEqual("awrh,35uhwr");
            expect(createdObject.topId).toEqual("24tyqeg/24y2qef/");
            expect(createdObject.topFields).toEqual("2a4,gsdg,2q3t");
            expect(createdObject.searchSpecificCategory).toBeTruthy();
            expect(createdObject.categoryId).toEqual("hi/you/see");
            expect(createdObject.categoryPagingInformation.pagingSuffix).toEqual("");
            expect(createdObject.categoryPagingInformation.pageSize).toEqual(50);
            expect(createdObject.categoryPagingInformation.currentPage).toEqual(10);
            expect(createdObject.categoryPagingInformation.itemId).toBeFalsy();
            expect(createdObject.categoryPagingInformation.isClosures).toBeTruthy();
            expect(createdObject.categoryPagingInformation.isNews).toBeFalsy();
            scope.pagingObject.pageSize = 50;
            createdObject = scope.createInitialRequestObject();
            expect(createdObject.requests[0].itemId).toEqual("asmdglkmsd");
            expect(createdObject.requests[0].fields).toEqual("a,whase,rh");
            expect(createdObject.requests[1].itemId).toEqual("2w4ygwsg");
            expect(createdObject.requests[1].fields).toEqual("awrh,35uhwr");
            expect(createdObject.topId).toEqual("24tyqeg/24y2qef/");
            expect(createdObject.topFields).toEqual("2a4,gsdg,2q3t");
            expect(createdObject.searchSpecificCategory).toBeTruthy();
            expect(createdObject.categoryId).toEqual("hi/you/see");
            expect(createdObject.categoryPagingInformation.pagingSuffix).toEqual("");
            expect(createdObject.categoryPagingInformation.pageSize).toEqual(50);
            expect(createdObject.categoryPagingInformation.currentPage).toEqual(10);
            expect(createdObject.categoryPagingInformation.itemId).toBeFalsy();
            expect(createdObject.categoryPagingInformation.isClosures).toBeTruthy();
            expect(createdObject.categoryPagingInformation.isNews).toBeFalsy();
        });
        it("test scrollToSearchResults", function () {
            //            returnLocationCounter = 1;
            //            returnLocation = {};
            spyOn(mockLocation, "hash");
            scope.scrollToSearchResults();
            //
            //            let test1Key: string = "Test1";
            //            let test2Key: string = "Test2";
            expect(mockLocation.hash).toHaveBeenCalledTimes(2);
            expect(mockLocation.hash.calls.argsFor(0)[0]).toBe("search-results");
            expect(mockLocation.hash.calls.argsFor(1)[0]).toBe("");
            //
            //            expect(returnLocation[test1Key]).toEqual("search-results");
            //            expect(returnLocation[test2Key]).toEqual("");
        });
        it("test createNavigationUrls when in middle", function () {
            inState.current.name = "test";
            scope.categoryHolder.category.itemName = "hello";
            scope.pagingObject.numberOfPages = 190;
            scope.pagingObject.currentPage = 100;
            scope.pagingObject.pageSize = 5;
            scope.createNavigationUrls();
            expect(scope.navigationUrls.nextPage).toEqual({
                inObject: "test",
                inObject2: {
                    category: "hello",
                    page: 101,
                    size: 5
                }
            });
            expect(scope.navigationUrls.previousPage).toEqual({
                inObject: "test",
                inObject2: {
                    category: "hello",
                    page: 99,
                    size: 5
                }
            });
        });
        it("test createNavigationUrls when on end", function () {
            inState.current.name = "test";
            scope.categoryHolder.category.itemName = "hello";
            scope.pagingObject.numberOfPages = 101;
            scope.pagingObject.currentPage = 100;
            scope.pagingObject.pageSize = 5;
            scope.createNavigationUrls();
            expect(scope.navigationUrls.nextPage).toEqual({
                inObject: "test",
                inObject2: {
                    category: "hello",
                    page: 100,
                    size: 5
                }
            });
            expect(scope.navigationUrls.previousPage).toEqual({
                inObject: "test",
                inObject2: {
                    category: "hello",
                    page: 99,
                    size: 5
                }
            });
        });
        it("test createNavigationUrls when at start", function () {
            inState.current.name = "test";
            scope.categoryHolder.category.itemName = "hello";
            scope.pagingObject.numberOfPages = 101;
            scope.pagingObject.currentPage = 0;
            scope.pagingObject.pageSize = 5;
            scope.createNavigationUrls();
            expect(scope.navigationUrls.nextPage).toEqual({
                inObject: "test",
                inObject2: {
                    category: "hello",
                    page: 1,
                    size: 5
                }
            });
            expect(scope.navigationUrls.previousPage).toEqual({
                inObject: "test",
                inObject2: {
                    category: "hello",
                    page: 0,
                    size: 5
                }
            });
        });
        it("test triggerSearchAndClearInChildState", function () {
            spyOn(scope, "getStateThatTriggersSearch").and.callFake(spyOnScope.getStateThatTriggersSearch);
            inState.current.name = "test";
            scope.categoryHolder.category.itemName = "hello";
            scope.triggerSearchAndClearInChildState();
            expect(goValues.inObject).toEqual("test");
            expect(goValues.inObject2).toEqual({
                category: "hello",
                page: 0,
                size: ""
            });
            expect(scope.getStateThatTriggersSearch.calls.count()).toEqual(1);
        });
        it("test triggerPureSearchInChildState", function () {
            spyOn(scope, "getStateThatTriggersSearch").and.callFake(spyOnScope.getStateThatTriggersSearch);
            inState.current.name = "test";
            scope.categoryHolder.category.itemName = "hello";
            scope.pagingObject.currentPage = 100;
            scope.pagingObject.pageSize = 50;
            scope.triggerPureSearchInChildState();
            expect(goValues.inObject).toEqual("test");
            expect(goValues.inObject2).toEqual({
                category: "hello",
                page: 100,
                size: 50
            });
            expect(scope.getStateThatTriggersSearch.calls.count()).toEqual(1);
        });
        it("test getStateThatTriggersSearch returns .Child when in parent state", function () {
            inState.current.parentState = "FrequentlyAskedQuestions";
            inState.current.name = "FrequentlyAskedQuestions";
            var stateToTransistionTo = scope.getStateThatTriggersSearch();
            expect(stateToTransistionTo).toEqual(".Child");
        });
        it("test getStateThatTriggersSearch returns current state when it does not equal parent", function () {
            inState.current.parentState = "FrequentlyAskedQuestions";
            inState.current.name = "FrequentlyAskedQuestions.Child";
            var stateToTransistionTo = scope.getStateThatTriggersSearch();
            expect(stateToTransistionTo).toEqual("FrequentlyAskedQuestions.Child");
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('SearchArticleChildController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, SearchArticleChildController, scope, stateParams = {}, inState = {}, goValues = {};
        beforeEach(angular.mock.module(function () {
            inState = {
                go: function (inObject, inObject2) {
                    goValues = { inObject: inObject, inObject2: inObject2 };
                    return { inObject: inObject, inObject2: inObject2 };
                }
            };
            goValues = {};
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('$state', inState);
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('$stateParams', stateParams);
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
            //create new, empty ng scope, controller, service objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
        }));
        var stateParamArrayCounter = 0;
        var stateParamArray = [
            // all null
            {
                input: {
                    page: null,
                    size: null,
                    category: null
                },
                expected: {
                    page: 0,
                    size: "",
                    category: undefined
                }
            },
            // all null except category valid
            {
                input: {
                    page: null,
                    size: null,
                    category: "All"
                },
                expected: {
                    page: 0,
                    size: "",
                    category: "All"
                }
            },
            // all null and category is undefined
            {
                input: {
                    page: null,
                    size: null,
                    category: undefined
                },
                expected: {
                    page: 0,
                    size: "",
                    category: undefined
                }
            },
            // all null and category is empty string
            {
                input: {
                    page: null,
                    size: null,
                    category: ""
                },
                expected: {
                    page: 0,
                    size: "",
                    category: undefined
                }
            },
            // category valid, page non-number, size null
            {
                input: {
                    page: "hello",
                    size: null,
                    category: "All"
                },
                expected: {
                    page: 0,
                    size: "",
                    category: "All"
                }
            },
            // category valid, page null, size non-number
            {
                input: {
                    page: null,
                    size: "whatup",
                    category: "All"
                },
                expected: {
                    page: 0,
                    size: "",
                    category: "All"
                }
            },
            // category valid, page undefined, size non-number
            {
                input: {
                    page: undefined,
                    size: "whatup",
                    category: "All"
                },
                expected: {
                    page: 0,
                    size: "",
                    category: "All"
                }
            },
            // category valid, page non-number, size undefined
            {
                input: {
                    page: "uh-huh",
                    size: undefined,
                    category: "All"
                },
                expected: {
                    page: 0,
                    size: "",
                    category: "All"
                }
            },
            // category valid, page number, size undefined
            {
                input: {
                    page: 500,
                    size: undefined,
                    category: "All"
                },
                expected: {
                    page: 500,
                    size: "",
                    category: "All"
                }
            },
            // category valid, page undefined, size number
            {
                input: {
                    page: undefined,
                    size: 500,
                    category: "All"
                },
                expected: {
                    page: 0,
                    size: 500,
                    category: "All"
                }
            },
            // category valid, page undefined, size number
            {
                input: {
                    page: 400,
                    size: 500,
                    category: "All"
                },
                expected: {
                    page: 400,
                    size: 500,
                    category: "All"
                }
            }
        ];
        it('test stateParams combinations', function () {
            for (; stateParamArrayCounter < stateParamArray.length; stateParamArrayCounter++) {
                scope.$parent = {
                    pagingObject: {},
                    categoryHolder: { category: {} },
                    mobilePagingorInitialSize: "",
                    init: function () { return; }
                };
                goValues = {};
                stateParams.page = stateParamArray[stateParamArrayCounter].input.page;
                stateParams.size = stateParamArray[stateParamArrayCounter].input.size;
                stateParams.category = stateParamArray[stateParamArrayCounter].input.category;
                var expected = stateParamArray[stateParamArrayCounter].expected;
                SearchArticleChildController = $controller('SearchArticleChildController', { $scope: scope });
                expect(scope.$parent.pagingObject.currentPage).toEqual(expected.page);
                expect(scope.$parent.pagingObject.pageSize).toEqual(expected.size);
                expect(scope.$parent.categoryHolder.category.itemName).toEqual(expected.category);
                if (expected.category) {
                    expect(goValues.inObject).toBeUndefined();
                }
                else {
                    expect(goValues.inObject).toEqual("Home");
                }
            }
        });
        it('test that userClickedSearch is called when loaded and no redirect needed', function () {
            var clickHit = false;
            var initHit = false;
            scope.$parent = {
                pagingObject: {},
                categoryHolder: { category: {} },
                mobilePagingorInitialSize: "",
                init: function () { initHit = true; },
                parentIsLoaded: true,
                userClickedSearch: function () { clickHit = true; }
            };
            goValues = {};
            stateParams.page = 20;
            stateParams.size = 50;
            stateParams.category = "All";
            SearchArticleChildController = $controller('SearchArticleChildController', { $scope: scope });
            expect(clickHit).toBeTruthy();
            expect(initHit).toBeFalsy();
        });
        it('test that init is called when not loaded and no redirect needed', function () {
            var clickHit = false;
            var initHit = false;
            scope.$parent = {
                pagingObject: {},
                categoryHolder: { category: {} },
                mobilePagingorInitialSize: "",
                init: function () { initHit = true; },
                parentIsLoaded: false,
                userClickedSearch: function () { clickHit = true; }
            };
            goValues = {};
            stateParams.page = 20;
            stateParams.size = 50;
            stateParams.category = "All";
            SearchArticleChildController = $controller('SearchArticleChildController', { $scope: scope });
            expect(clickHit).toBeFalsy();
            expect(initHit).toBeTruthy();
        });
        it('test that none is called when redirect happens', function () {
            var clickHit = false;
            var initHit = false;
            scope.$parent = {
                pagingObject: {},
                categoryHolder: { category: {} },
                mobilePagingorInitialSize: "",
                init: function () { initHit = true; },
                parentIsLoaded: false,
                userClickedSearch: function () { clickHit = true; }
            };
            goValues = {};
            stateParams.page = 20;
            stateParams.size = 50;
            stateParams.category = null;
            SearchArticleChildController = $controller('SearchArticleChildController', { $scope: scope });
            expect(clickHit).toBeFalsy();
            expect(initHit).toBeFalsy();
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('SingleArticleController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, SingleArticleController, scope, homeStates, displayedMessage = {
            value: ""
        }, inState = {
            id: "test",
            path: "test",
            url: "test"
        }, stateChecker = function (inState) {
            return {
                current: {
                    cms: inState
                },
                go: function (url) {
                    inState.url = url;
                }
            };
        }, stateNames = {}, rootScope, 
        //correctFilter,
        $filter = function (filterText) {
            if (filterText === "date") {
                //correctFilter = true;
                return filterfunc;
            }
        }, cmsUtilServiceInputs = {}, cmsUtilService = {
            addDisplayDates: function (article, isArchive) {
                cmsUtilServiceInputs = {
                    article: article,
                    isArchive: isArchive
                };
                return { displayDate: "this is AWESOME!" };
            },
            convertStartEndDates: function (inputArray) {
                return inputArray;
            }
        };
        function filterfunc(date, dateFormat) {
            return "" + date + dateFormat;
        }
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            //correctFilter = false;
            homeStates = { Frame: 'Home' };
            cmsUtilServiceInputs = {};
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('$state', stateChecker(inState));
            $provide.value('stateNames', hctraMocks.stateNames());
            $provide.value('$filter', $filter);
            $provide.value('cmsUtilService', cmsUtilService);
            $provide.value('homeStates', homeStates);
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
            //create new, empty ng scope, controller, service objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            rootScope = _$rootScope_;
            stateNames = hctraMocks.stateNames();
            //create the controller
            SingleArticleController = $controller('SingleArticleController', {
                $scope: scope, $rootScope: rootScope
            });
        }));
        it('test initializing Controller with no correct url', function () {
            scope.init();
            expect(inState.url).toBe(homeStates.Frame);
        });
        it('test initializing Controller with FAQ url', function () {
            inState.id = "hitme";
            inState.path = "FAQ";
            scope.init();
            expect(scope.returnState).toBe(stateNames.faq);
            expect(scope.redirectText).toBe("View all Frequently Asked Questions");
        });
        it('test initializing Controller with Closure url', function () {
            inState.id = "hitme";
            inState.path = "Closures";
            scope.init();
            expect(scope.returnState).toBe(stateNames.closuresArchive);
            expect(scope.redirectText).toBe("View Closures Archive");
        });
        it('test initializing Controller with News url', function () {
            inState.id = "hitme";
            inState.path = "News";
            scope.init();
            expect(scope.returnState).toBe(stateNames.newsArchive);
            expect(scope.redirectText).toBe("View News Archive");
        });
        it('test initial Request with id and long', function () {
            scope.initialRequestById('{12345}');
            expect(scope.cmsData.description).toBe("test");
        });
        it('test closures date string construction', function () {
            scope.redirectText = "View Closures Archive";
            var theDate = new Date();
            var date = scope.formatDate({ StartDate: theDate });
            expect(cmsUtilServiceInputs).toEqual({ article: { StartDate: theDate }, isArchive: true });
            expect(date).toEqual("this is AWESOME!");
        });
        it('test news date string construction', function () {
            scope.redirectText = "View News Archive";
            var theDate = new Date();
            var date = scope.formatDate({ NewsDisplayDate: theDate });
            expect(date).toEqual("Published on: " + theDate + "longDate");
        });
        it('test FAQ date string construction', function () {
            scope.redirectText = "View all Frequently Asked Questions";
            var theDate = new Date();
            var date = scope.formatDate({ __Updated: theDate });
            expect(date).toEqual("Published on: " + theDate + "longDate");
        });
    });
}());
/*(function () {
    'use strict';

    describe('RatesController', function () {

        var $controller,
            scope,
            RatesController,
            
            inState = {
                value: "",
                statePath: 'ratesController'
            },
            setUrl = {
                value: "",
                fromRates: true
            };

        beforeEach(angular.mock.module('HCTRAModule'));

        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('$location', hctraMocks.$location(setUrl));
            $provide.value('$state', hctraMocks.$state(inState));
            $provide.value('routes', hctraMocks.routes());
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('ratesService', hctraMocks.ratesService());
            $provide.value('stringCheckService', hctraMocks.stringCheckService());
        }));

        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
            scope = _$rootScope_.$new();
            $controller = _$controller_;

            RatesController = $controller('RatesController', { $scope: scope });
        }));



        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });

        it('should have directions parsed from Sitecore or else set HideSelect', function () {
            for (var i = 0; i < scope.tollRoads.length; i++) {
                var tollRoad = scope.tollRoads[i];
                expect(tollRoad.Directions).toBeDefined();
                expect(tollRoad.LongDescription).toBeDefined();
                expect(tollRoad.Title).toBeDefined();

                if (tollRoad.Directions.length === 0) {
                    expect(tollRoad.HideSelect).toBeTruthy();
                } else {
                    expect(tollRoad.HideSelect).toBeUndefined();
                }
            }
        });

        it('should have toll sections parsed from Sitecore if directions exist', function () {
            for (var i = 0; i < scope.tollRoads.length; i++) {
                var tollRoad = scope.tollRoads[i];
                if (tollRoad.Directions.length === 0) {
                    expect(tollRoad.Directions.TollSections).toBeUndefined();
                } else {
                    expect(tollRoad.Directions[0].Direction).toBeDefined();
                    expect(tollRoad.Directions[0].TollSections).toBeDefined();
                    expect(tollRoad.Directions[0].TollSections[0].Rates).toBeDefined();

                    for (var j = 0; j < tollRoad.Directions[0].TollSections.length; j++) {
                        for (var k = 0; k < tollRoad.Directions[0].TollSections[0].Rates.length; k++) {
                            var tollSection = tollRoad.Directions[0].TollSections[j];
                            var rates = tollRoad.Directions[0].TollSections[j].Rates;
                            expect(rates[k]).toBeDefined();
                            expect(tollSection['Bold']).toBeDefined();
                            expect(tollSection['DisplayName']).toBeDefined();
                            expect(tollSection['LocationType']).toBeDefined();
                            expect(tollSection['Position']).toBeDefined();
                            expect(tollSection['TollingLocations']).toBeDefined();
                        }
                    }
                }
            }
        });

        it('should set first selected options', function () {
            expect(scope.selectedTollRoad.Title).toBe("Sam Houston Tollway");
            expect(scope.selectedDirection.Direction).toBe("Clockwise");
        });

        it('should use axleClassSelected to show/hide axle classifications', function () {
            scope.selectedClass = {
                Label: '2 Axles (Cash)',
                Value: '2 Axles (Cash)'
            };
            expect(scope.axleClassSelected('All Axles')).toBeFalsy();
            expect(scope.axleClassSelected('2 Axles (Cash)')).toBeTruthy();

            scope.selectedClass = {
                Label: 'All Axles',
                Value: 'All Axles'
            };
            expect(scope.axleClassSelected('All Axles')).toBeTruthy();
            expect(scope.axleClassSelected('2 Axles (Cash)')).toBeTruthy();
        });

    });

}());
*/ 
(function () {
    'use strict';
    describe('ratesService', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var ratesService, tollLocationsArray, 
        // tollLocationsObj,
        directionsArray, directionsObj, tollRoadsArray, 
        // tollRatesArray,
        tollRoadObj, stringUtilsService;
        beforeEach(angular.mock.module(function () {
            tollLocationsArray = [];
            directionsArray = [];
            tollRoadsArray = [];
            // tollLocationsObj = {
            //     Position: '12.34'
            // };
            directionsObj = {
                DisplayName: 'DisplayName'
            };
            tollRoadObj = {
                Title: 'Title',
                LongDescription: 'LongDescription'
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            stringUtilsService = jasmine.createSpyObj('stringUtilsService', ['getParameterArray']);
            $provide.value('stringCheckService', hctraMocks.stringCheckService());
            $provide.value('stringUtilsService', stringUtilsService);
        }));
        beforeEach(angular.mock.inject(function (_ratesService_) {
            ratesService = _ratesService_;
        }));
        function setupMapTollRoads(tollLocationsArray) {
            directionsObj.Children = tollLocationsArray;
            directionsArray.push(directionsObj);
            tollRoadObj.Children = directionsArray;
            tollRoadsArray.push(tollRoadObj);
        }
        it('should contain title, long description, and hide select', function () {
            tollRoadObj.Children = null;
            tollRoadsArray.push(tollRoadObj);
            var test = ratesService.mapTollRoads(tollRoadsArray);
            expect(test[0].Title).toEqual('Title');
            expect(test[0].LongDescription).toEqual('LongDescription');
            expect(test[0].Directions).toBeDefined();
            expect(test[0].HideSelect).toBeTruthy();
        });
        it('should have no rate data', function () {
            tollLocationsArray = null;
            setupMapTollRoads(tollLocationsArray);
            var test = ratesService.mapTollRoads(tollRoadsArray);
            expect(test[0].Directions[0].Direction).toEqual('DisplayName');
            expect(test[0].Directions[0].TollSections[0].TollingLocations).toEqual('No rate data');
        });
        // it('should be bold, contain position, and not have rate', function () {
        //     tollLocationsObj.Bold = 'yes';
        //     tollRatesArray = "2 Axles (Cash)=";
        //     tollLocationsObj.Rates = tollRatesArray;
        //     tollLocationsArray.push(tollLocationsObj);
        //     setupMapTollRoads(tollLocationsArray);
        //     var test = ratesService.mapTollRoads(tollRoadsArray);
        //     expect(test[0].Directions[0].TollSections[0].Position).toEqual(12.34);
        //     expect(test[0].Directions[0].TollSections[0].Bold).toBeTruthy();
        //     expect(test[0].Directions[0].TollSections[0].Rates[0].Value).toEqual('Cash Not Accepted');
        // });
        // it('should not be bold, and have rate', function () {
        //     tollLocationsObj.Bold = 'no';
        //     tollRatesArray = "2 Axles (Cash)=1.52";
        //     tollLocationsObj.Rates = tollRatesArray;
        //     tollLocationsArray.push(tollLocationsObj);
        //     setupMapTollRoads(tollLocationsArray);
        //     var test = ratesService.mapTollRoads(tollRoadsArray);
        //     expect(test[0].Directions[0].TollSections[0].Bold).toBeFalsy();
        //     expect(test[0].Directions[0].TollSections[0].Rates[0].Value).toEqual('$1.52');
        // });
    });
}());
// (function () {
//     'use strict';
//     //describe() begins a unit testing fixture
//     describe('AppController', function () {
//         //module() is registered on window and is a shortcut to angular.mock.module()
//         //use it to mock the main app module
//         //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
//         // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
//         // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
//         beforeEach(angular.mock.module('HCTRAModule'));
//         var $controller,
//             genericRepo = hctraMocks.genericRepo(),
// 			scope,
// 			AppController,
// 			setUrl = {
// 			    value: "",
// 			    testPath: "thisIsTheLife"
// 			},
// 			displayedMessage = {
// 			    value: ""
// 			},
//             rootScope,
//             wildCardToggler,
// 			wildCardUrlCheckerService = {
// 			    wildCardUrlisMatch: function () { return wildCardToggler; }
// 			},
//             metadataManagerService = {},
//             focusExclusionService = {
//                 dictByUrl: {}
//             };
//         //$provide is a module-level object, and thus must get its own 
//         //injection through the module() function
//         beforeEach(angular.mock.module(function ($provide) {
//             $provide.value('$location', hctraMocks.$location(setUrl));
//             $provide.value('AuthService', hctraMocks.AuthService());
//             $provide.value('routes', hctraMocks.routes());
//             $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
//             $provide.value('AUTH_EVENTS', hctraMocks.AUTH_EVENTS());
//             $provide.value('Session', hctraMocks.Session());
//             $provide.value('genericRepo', genericRepo);
//             $provide.value('operatingSystemSnifferService', hctraMocks.operatingSystemSnifferService());
//             $provide.value('USER_ROLES', hctraMocks.USER_ROLES());
//             $provide.value('modalService', hctraMocks.modalService()); 
//             $provide.value('wildCardUrlCheckerService ', wildCardUrlCheckerService); 
//             $provide.value('metadataManagerService ', metadataManagerService);
//             $provide.value('$window ', hctraMocks.$window());
//             $provide.value('responsiveService', hctraMocks.responsiveService(true));
//             $provide.value('bowserService', hctraMocks.bowserService());
//             $provide.value('MegaMenuCache', hctraMocks.megaMenuCache());
//             $provide.value('stateStackMemoryService', hctraMocks.stateStackMemoryService());
//             $provide.constant('environmentConfig', hctraMocks.environmentConfig());
//             $provide.value('focusExclusionService', focusExclusionService);
//             $provide.value('maintenanceService', hctraMocks.maintenanceService());
//             $provide.value('StorefrontService', hctraMocks.StorefrontService());
//         }));
//         //inject() is a window-registered global for angular.mock.inject
//         //it injects the root scope and controller-grabbing services into your test
//         //the injector unwraps the underscores
//         beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, _wildCardUrlCheckerService_) {
//             //create new, empty ng scope and controller objects
//             scope = _$rootScope_.$new();
//             $controller = _$controller_;
//             rootScope = _$rootScope_;
//             spyOn(genericRepo.dataFactory, "getCmsPageById").and.returnValue({
//                 then: function (cb) {
//                     cb({ cmsResponse: '{"ItemID":"d7bc3008-dcf8-45d6-9a0d-e9454e4ed479","ItemName":"HomePage","ItemPath":"/sitecore/content/HCTRA/Home/HomePage","ParentID":"648cbe61-3bfd-455b-8b73-9c0acb3712a3","TemplateID":"dafb3eaf-dabf-4275-a114-875cfab3de36","TemplateName":"Page","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Home Page","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/32x32/text_rich_colored.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/text_rich_colored.png","ItemUrl":"~/link.aspx?_id=D7BC3008DCF845D69A0DE9454E4ED479&amp;_z=z","NumberOfItemsToShow":"0","SearchDescription":"The Harris County Toll Road Authority (HCTRA) operates toll roads within the Greater Houston Metropolitan region through the use of EZ TAG. ","File":"","Title":"Home","Image":"","ShortDescription":"412","PermanentURL":"/Home","FriendlyURL":"","SearchThumbnail":"<image mediaid=\\"{E1A56831-4AE0-40D4-BAE9-CA274DC99372}\\" alt=\\"TestingImage\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","IncludeInSearch":"1","Top6":"1","SearchTitle":"Harris County Toll Road Authority ","Purpose":"Home Page","Children":[{"ItemID":"e87b241d-22e2-447b-8810-36a530cf2eb0","ItemName":"SlideshowSection","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection","ParentID":"d7bc3008-dcf8-45d6-9a0d-e9454e4ed479","TemplateID":"c7ee86ff-40e2-4518-bc3a-74cbbf74cf60","TemplateName":"SlideshowSection","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Slideshow Section","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/32x32/window_gear.png","ItemMedialUrl":"/~/icon/Applications/48x48/window_gear.png.aspx","ItemUrl":"~/link.aspx?_id=E87B241D22E2447B881036A530CF2EB0&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","Title":"Slideshow","Image":"","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","IntervalInSeconds":"5","Purpose":"Slideshow Section1","Children":[{"ItemID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","ItemName":"Desktop","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop","ParentID":"e87b241d-22e2-447b-8810-36a530cf2eb0","TemplateID":"a87a00b1-e6db-45ab-8b54-636fec3b5523","TemplateName":"Folder","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Desktop","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/16x16/folder.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/folder.png","ItemUrl":"~/link.aspx?_id=A8BE255761074A9D9B7E79D63CB3B32F&amp;_z=z","Children":[{"ItemID":"6f95f978-f2f7-4759-8f01-a7e1453c3ad7","ItemName":"Slide4","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/Slide4","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedOut2","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=6F95F978F2F747598F01A7E1453C3AD7&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"","Title":"Slide 4","Image":"<image mediaid=\\"{44512BE3-3775-421E-8273-6A3CE762C5BA}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/NewAccount/PersonalAccount"},{"ItemID":"4128cc4a-beaf-42a6-88d1-bef65a618d08","ItemName":"LoggedIn1","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/LoggedIn1","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedOut1","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=4128CC4ABEAF42A688D1BEF65A618D08&amp;_z=z","LongDescription":"","File":"","ShowLoggedin":"","Title":"Loggedout1","Image":"<image mediaid=\\"{8EE995A4-0267-46B3-8CB4-E7ABDE9662F5}\\" alt=\\"Missed a toll\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"","SlideURL":"/MissedAToll"},{"ItemID":"1a9595c0-23ed-4ad6-9654-8d6bef54ef82","ItemName":"LoggedIn1","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/LoggedIn1","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn1","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=1A9595C023ED4AD696548D6BEF54EF82&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"Got new plates?","Image":"<image mediaid=\\"{3E40C8EB-AA1E-4427-A7AD-450562AFB794}\\" alt=\\"Kids new toy\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/ManageVehicles"},{"ItemID":"93ff9145-6384-4cfb-ac05-64b2a62dd17f","ItemName":"LoggedIn2","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/LoggedIn2","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn2","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=93FF914563844CFBAC0564B2A62DD17F&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"Got a new credit card?","Image":"<image mediaid=\\"{63254708-8801-4BD0-9C91-9FEBD4DF3F40}\\" alt=\\"Missed a toll\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/AccountInformation"},{"ItemID":"1439a983-fe51-4908-a1d2-f3604afc9531","ItemName":"LoggedIn3","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/LoggedIn3","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn3","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=1439A983FE514908A1D2F3604AFC9531&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"Purchased a New Car?","Image":"<image mediaid=\\"{6A83BDFB-8D61-4357-BEBC-B9B0217F8F70}\\" alt=\\"Ship Channel Bridge\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/ManageVehicles"},{"ItemID":"a13e9866-0c98-4c4c-bedb-ad73f0c448aa","ItemName":"LoggedIn4","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/LoggedIn4","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn4","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=A13E98660C984C4CBEDBAD73F0C448AA&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"Missed a Toll?","Image":"<image mediaid=\\"{5C1CE806-6020-4B55-B724-451BCDA5DD6F}\\" alt=\\"Ship Channel Bridge\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/MissedAToll"},{"ItemID":"86e52e5c-6d70-4d16-b0cb-e82776ead534","ItemName":"LoggedOut3","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/LoggedOut3","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedOut3","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=86E52E5C6D704D16B0CBE82776EAD534&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"","Title":"LoggedOut3","Image":"<image mediaid=\\"{5CC58C42-768E-40ED-9E92-9BCE78741820}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"https://www.bancpass.com/"},{"ItemID":"34939345-3021-4313-9a14-05f6eb165ec9","ItemName":"LoggedOut4","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Desktop/LoggedOut4","ParentID":"a8be2557-6107-4a9d-9b7e-79d63cb3b32f","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedOut4","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=34939345302143139A1405F6EB165EC9&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"<file mediaid=\\"{B5277B5F-24B3-45B4-9244-5501FD7BE9AA}\\" src=\\"-/media/B5277B5F24B345B492445501FD7BE9AA.ashx\\" />","ShowLoggedin":"","Title":"LoggedOut4","Image":"<image mediaid=\\"{8826BEA7-A645-4F20-A82F-E8A2DCDBF394}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":""}]},{"ItemID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","ItemName":"Mobile","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile","ParentID":"e87b241d-22e2-447b-8810-36a530cf2eb0","TemplateID":"a87a00b1-e6db-45ab-8b54-636fec3b5523","TemplateName":"Folder","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Mobile","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/16x16/folder.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/folder.png","ItemUrl":"~/link.aspx?_id=6A24E78E02DD465D8208F4E42A5544C2&amp;_z=z","Children":[{"ItemID":"b2e6cbb3-0d66-4b9b-bc0c-564576186615","ItemName":"LoggedIn3","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/LoggedIn3","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn3","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=B2E6CBB30D664B9BBC0C564576186615&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"LoggedIn3","Image":"<image mediaid=\\"{63254708-8801-4BD0-9C91-9FEBD4DF3F40}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/AccountInformation"},{"ItemID":"66993864-34f1-4899-b313-f17d9c87227d","ItemName":"LoggedIn4","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/LoggedIn4","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn4","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=6699386434F14899B313F17D9C87227D&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"LoggedIn4","Image":"<image mediaid=\\"{6A83BDFB-8D61-4357-BEBC-B9B0217F8F70}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/ManageVehicles"},{"ItemID":"9eb7cadd-42ea-437d-b91a-8384cd157230","ItemName":"LoggedIn5","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/LoggedIn5","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn5","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=9EB7CADD42EA437DB91A8384CD157230&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"LoggedIn5","Image":"<image mediaid=\\"{8EE995A4-0267-46B3-8CB4-E7ABDE9662F5}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/MissedAToll"},{"ItemID":"070faccc-6efa-40dc-beed-9b561da5fdb1","ItemName":"LoggedOut1","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/LoggedOut1","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedOut1","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=070FACCC6EFA40DCBEED9B561DA5FDB1&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"","Title":"Slide 3m","Image":"<image mediaid=\\"{849784E0-CC34-4CF3-B39B-ED3B750E4132}\\" alt=\\"ez tag online today\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/NewAccount/PersonalAccount"},{"ItemID":"696bc295-5c0f-4996-ad0b-a39144754a34","ItemName":"LoggedOut2","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/LoggedOut2","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedOut2","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=696BC2955C0F4996AD0BA39144754A34&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"","Title":"Slide 1m","Image":"<image mediaid=\\"{E1A56831-4AE0-40D4-BAE9-CA274DC99372}\\" alt=\\"open an ez taz account\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"https://www.bancpass.com/"},{"ItemID":"96959bbc-d90e-45f4-a11b-2397eee41e2d","ItemName":"LoggedOut3","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/LoggedOut3","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedOut3","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=96959BBCD90E45F4A11B2397EEE41E2D&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"","Title":"LoggedOut3","Image":"<image mediaid=\\"{8EE995A4-0267-46B3-8CB4-E7ABDE9662F5}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/MissedAToll"},{"ItemID":"b014ff8d-dab5-442a-9b60-948d7b0f3e2f","ItemName":"Slide1m","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/Slide1m","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn1","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=B014FF8DDAB5442A9B60948D7B0F3E2F&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","ShowLoggedin":"1","Title":"Slide 1m","Image":"<image mediaid=\\"{E1CDC02E-15E4-417D-B408-02CF711D53CB}\\" alt=\\"Add Vehicle\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":"/ManageVehicles"},{"ItemID":"273e1ca3-74ef-4eb5-ac67-c916a8677b60","ItemName":"Slide2m","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SlideshowSection/Mobile/Slide2m","ParentID":"6a24e78e-02dd-465d-8208-f4e42a5544c2","TemplateID":"fd9bb9e6-96c8-47b1-ba52-07cb1e0c1efc","TemplateName":"Slide","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"LoggedIn2","HasChildren":"False","ItemIcon":"/temp/IconCache/Imaging/32x32/layer_blend_h.png","ItemMedialUrl":"/~/icon/Imaging/48x48/layer_blend_h.png.aspx","ItemUrl":"~/link.aspx?_id=273E1CA374EF4EB5AC67C916A8677B60&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"<file mediaid=\\"{B5277B5F-24B3-45B4-9244-5501FD7BE9AA}\\" src=\\"-/media/B5277B5F24B345B492445501FD7BE9AA.ashx\\" />","ShowLoggedin":"1","Title":"Slide 2m","Image":"<image mediaid=\\"{67716F6A-3A6B-42D6-A162-65FD342B088F}\\" alt=\\"learn more\\" height=\\"\\" width=\\"\\" hspace=\\"\\" vspace=\\"\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SlideURL":""}]}]},{"ItemID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","ItemName":"ModulesSection","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection","ParentID":"d7bc3008-dcf8-45d6-9a0d-e9454e4ed479","TemplateID":"2fa89c27-0690-46a7-bf44-be716ddeb106","TemplateName":"Section","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Modules Section","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/32x32/window_gear.png","ItemMedialUrl":"/~/icon/Applications/48x48/window_gear.png.aspx","ItemUrl":"~/link.aspx?_id=77AE01537E1E4153A71AA9BB5448A3B6&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","Title":"Modules","Image":"","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","Purpose":"Modules Section","Children":[{"ItemID":"8d073f60-15af-4eec-bbb1-4a2dc145cc15","ItemName":"EZTagAccountContent","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection/EZTagAccountContent","ParentID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","TemplateID":"86b81397-b806-4f6c-97b3-40548a52bb18","TemplateName":"ModuleLink","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"EZTag Account Content","HasChildren":"False","ItemIcon":"/temp/IconCache/Software/32x32/graph_edge_directed.png","ItemMedialUrl":"/~/icon/Software/48x48/graph_edge_directed.png.aspx","ItemUrl":"~/link.aspx?_id=8D073F6015AF4EECBBB14A2DC145CC15&amp;_z=z","Image":"<image mediaid=\\"{20772B13-C9BB-49BC-9480-694D795949D4}\\" />","Title":"EZ TAG Account","Position":"1","TitleURL":"/AccountSummary","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","UserLoggedIn":"1","LinkTitle":"Summary"},{"ItemID":"dd8ac1c9-32c2-40c7-b31e-152f13d9f512","ItemName":"OpenEZTagAccountContent","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection/OpenEZTagAccountContent","ParentID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","TemplateID":"86b81397-b806-4f6c-97b3-40548a52bb18","TemplateName":"ModuleLink","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Open EZTag Account Content","HasChildren":"False","ItemIcon":"/temp/IconCache/Software/32x32/graph_edge_directed.png","ItemMedialUrl":"/~/icon/Software/48x48/graph_edge_directed.png.aspx","ItemUrl":"~/link.aspx?_id=DD8AC1C932C240C7B31E152F13D9F512&amp;_z=z","Image":"<image mediaid=\\"{A9B28028-01A0-4905-904B-1A213EB96A6B}\\" />","Title":"Sign up for an EZ TAG account","Position":"1","TitleURL":"/NewAccount","ShortDescription":"<p>Open an account. Order your EZ TAG.</p>\\n<p>Use the EZ TAG lanes today!</p>","UserLoggedIn":"","LinkTitle":"Sign up"},{"ItemID":"6fe03edd-bea8-4ef7-b723-0e5302b91ef4","ItemName":"Account Activity Content","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection/Account Activity Content","ParentID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","TemplateID":"86b81397-b806-4f6c-97b3-40548a52bb18","TemplateName":"ModuleLink","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Account Activity Content","HasChildren":"False","ItemIcon":"/temp/IconCache/Software/32x32/graph_edge_directed.png","ItemMedialUrl":"/~/icon/Software/48x48/graph_edge_directed.png.aspx","ItemUrl":"~/link.aspx?_id=6FE03EDDBEA84EF7B7230E5302B91EF4&amp;_z=z","Image":"<image mediaid=\\"{A851E36C-DC4B-4565-8230-B3690C2132D6}\\" />","Title":"View your account activity","Position":"2","TitleURL":"/AccountActivity","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","UserLoggedIn":"1","LinkTitle":"View activity"},{"ItemID":"6627ad3b-917a-4f8d-b5fc-cf68f4a5d910","ItemName":"Login to Your Account","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection/Login to Your Account","ParentID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","TemplateID":"86b81397-b806-4f6c-97b3-40548a52bb18","TemplateName":"ModuleLink","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Login to Your Account","HasChildren":"False","ItemIcon":"/temp/IconCache/Software/32x32/graph_edge_directed.png","ItemMedialUrl":"/~/icon/Software/48x48/graph_edge_directed.png.aspx","ItemUrl":"~/link.aspx?_id=6627AD3B917A4F8DB5FCCF68F4A5D910&amp;_z=z","Image":"<image mediaid=\\"{F25F5225-5592-4DD8-A999-756EC0FF43AC}\\" />","Title":"Login to your EZ TAG account","Position":"2","TitleURL":"/Login","ShortDescription":"<p>Check your account activity.</p>\\n<p>Manage your vehicles.</p>","UserLoggedIn":"","LinkTitle":"Login"},{"ItemID":"b13847cd-bc76-4997-a065-48ded65ff146","ItemName":"Pay a Missed Toll","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection/Pay a Missed Toll","ParentID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","TemplateID":"86b81397-b806-4f6c-97b3-40548a52bb18","TemplateName":"ModuleLink","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Pay a Missed Toll","HasChildren":"False","ItemIcon":"/temp/IconCache/Software/32x32/graph_edge_directed.png","ItemMedialUrl":"/~/icon/Software/48x48/graph_edge_directed.png.aspx","ItemUrl":"~/link.aspx?_id=B13847CDBC764997A06548DED65FF146&amp;_z=z","Image":"<image mediaid=\\"{BA1B071F-3C05-48BB-96A8-29F1DC9DD213}\\" />","Title":"Pay for missed tolls","Position":"3","TitleURL":"/MissedAToll","ShortDescription":"<p>Pay for any missed tolls you may have.</p>\\n<p>Avoid getting a toll violation invoice.</p>","UserLoggedIn":"","LinkTitle":"Coming soon"},{"ItemID":"8939357e-3983-433d-8387-226c375926ec","ItemName":"PayTollViolationsContent","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection/PayTollViolationsContent","ParentID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","TemplateID":"86b81397-b806-4f6c-97b3-40548a52bb18","TemplateName":"ModuleLink","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Pay Toll Violations Content","HasChildren":"False","ItemIcon":"/temp/IconCache/Software/32x32/graph_edge_directed.png","ItemMedialUrl":"/~/icon/Software/48x48/graph_edge_directed.png.aspx","ItemUrl":"~/link.aspx?_id=8939357E3983433D8387226C375926EC&amp;_z=z","Image":"<image mediaid=\\"{FC0FD68F-9F0F-444D-B697-3C3524705752}\\" />","Title":"Pay a toll violation invoice","Position":"4","TitleURL":"/Violations","ShortDescription":"<p>Have you received a toll violation invoice?</p>\\n<p>You can pay for that here.</p>","UserLoggedIn":"","LinkTitle":"Pay now"},{"ItemID":"af5da048-1ee9-465e-bb80-a8782e2ab6ed","ItemName":"TravelToolsContent","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/ModulesSection/TravelToolsContent","ParentID":"77ae0153-7e1e-4153-a71a-a9bb5448a3b6","TemplateID":"86b81397-b806-4f6c-97b3-40548a52bb18","TemplateName":"ModuleLink","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Travel Tools Content","HasChildren":"False","ItemIcon":"/temp/IconCache/Software/32x32/graph_edge_directed.png","ItemMedialUrl":"/~/icon/Software/48x48/graph_edge_directed.png.aspx","ItemUrl":"~/link.aspx?_id=AF5DA0481EE9465EBB80A8782E2AB6ED&amp;_z=z","Image":"<image mediaid=\\"{BDCBA473-37B8-4275-A530-E91E91F38D73}\\" />","Title":"Travel Tools","Position":"5","TitleURL":"/TollRoadInformation","ShortDescription":"<p>Find information on toll roads, closure, and rates.</p>\\n<p>Access news, maps, and roadside assistance info.</p>","UserLoggedIn":"","LinkTitle":"Learn more"}]},{"ItemID":"4e740cef-9f8f-4df6-b8fa-e7ae133cb7a8","ItemName":"MajorClosuresSection","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection","ParentID":"d7bc3008-dcf8-45d6-9a0d-e9454e4ed479","TemplateID":"2fa89c27-0690-46a7-bf44-be716ddeb106","TemplateName":"Section","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Major Closures Section","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/32x32/window_gear.png","ItemMedialUrl":"/~/icon/Applications/48x48/window_gear.png.aspx","ItemUrl":"~/link.aspx?_id=4E740CEF9F8F4DF6B8FAE7AE133CB7A8&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","Title":"Major Closures","Image":"<image mediaid=\\"{8048EA20-22E3-4067-9A7C-853C7BE22185}\\" />","ShortDescription":"<a href=\\"https://traffic.houstontranstar.org/layers/\\" target=\\"_blank\\">Transtar Map</a>","Purpose":"Major Closures Section","Children":[{"ItemID":"1c046a9d-f1f0-4c5b-93e8-f94311bbd96e","ItemName":"TopClosuresSearch","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/TopClosuresSearch","ParentID":"4e740cef-9f8f-4df6-b8fa-e7ae133cb7a8","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Top Closures Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=1C046A9DF1F04C5B93E8F94311BBD96E&amp;_z=z","Database":"","Query":{"TotalCount":2,"TotalPage":1,"Links":[],"Results":[{"ItemID":"ed8a5d80-8e18-41b9-9361-387848ac2f25","ItemName":"Is Permanent Closure","ItemPath":"/sitecore/content/HCTRA/TravelTools/ClosuresArchivePage/ResultsSection/Data/Is Permanent Closure","ParentID":"f61771f6-b9a0-4e8f-8675-a3dda6b37060","TemplateID":"e5b5bb79-af8c-4c56-9689-4a96138b71a1","TemplateName":"Closure","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Is Permanent Closure","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/stop.png","ItemMedialUrl":"/~/icon/Applications/48x48/stop.png.aspx","ItemUrl":"~/link.aspx?_id=ED8A5D808E1841B99361387848AC2F25&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","Title":"Is Permanent Closure","__Updated":"20160811T201712Z","__Is Bucket":"","__Subitems Sorting":"","__Help link":"","__Archive date":"","__Enforce version presence":"","__Reminder text":"","ShortDescription":"<p>ASDKJKFJAHFAHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH</p>\\n<p>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIEEEEEEEEEEEEEEEEEEEEEEOOOOOOOOOOOOOOOOOOOOOOOOOOO</p>","__Semantics":"{4E543538-0847-44FC-A5B4-91867FF10F5F}","__Workflow":"","LongDescription":"","__Created by":"sitecore\\\\Admin","__Bucket Parent Reference":"","__Short description":"","__Validator Bar Validation Rules":"","SearchDescription":"","EndDate":"","__Publishing groups":"{8E080626-DDC3-4EF4-A1D1-F0BE4A200254}","__Hidden":"","File":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Read Only":"","__Unpublish":"","__Long description":"","MapURL":"","__Suppressed Validation Rules":"","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","Category":"Military Occupation","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\Admin","Subtitle":"Hello subtitle","__Source Item":"","StartDate":"20160809T153100Z","__Content Test":"","__Publish":"","Image":"","__Lock":"","__Standard values":"","__Editor":"","__Revision":"babeeff3-1e05-4c45-9712-17b8e8e9ba70","__Skin":"","__Reminder date":"","__Validate Button Validation Rules":"","__Created":"20160809T153047Z","__Source":"","__Preview":"","__Icon":"","FriendlyURL":"","__Owner":"sitecore\\\\admin","SearchThumbnail":"","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","ShowInHomePage":"1","__Security":"","IsPermanent":"1","IncludeInSearch":"1","__Reminder recipients":"","__Final Renderings":"","Top6":"","__Workflow Validation Rules":"","SearchTitle":"","__Context Menu":"","__Bucketable":"","__Default View":"","__Boost":"","__Thumbnail":"","__Persistent Bucket Filter":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""},{"ItemID":"849a7946-cabb-49a8-be9f-97dfef673bcf","ItemName":"No Subtitle Closed","ItemPath":"/sitecore/content/HCTRA/TravelTools/ClosuresArchivePage/ResultsSection/Data/No Subtitle Closed","ParentID":"f61771f6-b9a0-4e8f-8675-a3dda6b37060","TemplateID":"e5b5bb79-af8c-4c56-9689-4a96138b71a1","TemplateName":"Closure","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"No Subtitle Closed","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/stop.png","ItemMedialUrl":"/~/icon/Applications/48x48/stop.png.aspx","ItemUrl":"~/link.aspx?_id=849A7946CABB49A8BE9F97DFEF673BCF&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","Title":"Has no Subtitle","__Updated":"20160811T201715Z","__Is Bucket":"","__Subitems Sorting":"","__Help link":"","__Archive date":"","__Enforce version presence":"","__Reminder text":"","ShortDescription":"<p>All the data here</p>\\n<p>La di da</p>","__Semantics":"{4E543538-0847-44FC-A5B4-91867FF10F5F}","__Workflow":"","LongDescription":"","__Created by":"sitecore\\\\Admin","__Bucket Parent Reference":"","__Short description":"","__Validator Bar Validation Rules":"","SearchDescription":"","EndDate":"20160831T230000Z","__Publishing groups":"{8E080626-DDC3-4EF4-A1D1-F0BE4A200254}","__Hidden":"","File":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Read Only":"","__Unpublish":"","__Long description":"","MapURL":"","__Suppressed Validation Rules":"","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","Category":"Category1","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\Admin","Subtitle":"","__Source Item":"","StartDate":"20160808T223400Z","__Content Test":"","__Publish":"","Image":"","__Lock":"","__Standard values":"","__Editor":"","__Revision":"edd13f64-779a-4e56-95fa-ad4e7199c88b","__Skin":"","__Reminder date":"","__Validate Button Validation Rules":"","__Created":"20160808T215511Z","__Source":"","__Preview":"","__Icon":"","FriendlyURL":"","__Owner":"sitecore\\\\admin","SearchThumbnail":"","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","ShowInHomePage":"1","__Security":"","IsPermanent":"1","IncludeInSearch":"1","__Reminder recipients":"","__Final Renderings":"","Top6":"","__Workflow Validation Rules":"","SearchTitle":"","__Context Menu":"","__Bucketable":"","__Default View":"","__Boost":"","__Thumbnail":"","__Persistent Bucket Filter":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"813965f6-89aa-4a9c-908b-72c9d35a0171","ItemName":"ClosuresFeed","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/ClosuresFeed","ParentID":"4e740cef-9f8f-4df6-b8fa-e7ae133cb7a8","TemplateID":"b960cbe4-381f-4a2b-9f44-a43c7a991a0b","TemplateName":"RSS Feed","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Closures Feed","HasChildren":"False","ItemIcon":"/sitecore/shell/themes/standard/Custom/16x16/rss.png","ItemMedialUrl":"/sitecore/shell/themes/standard/Custom/48x48/rss.png","ItemUrl":"~/link.aspx?_id=813965F689AA4A9C908B72C9D35A0171&amp;_z=z","Description":"HCTRA Closures Feed","Cache Duration":"","Title":"HCTRA Closures Feed","Image":"","Link":"","Type":"","Cacheable":"","Managing editor":"","Copyright":"HCTRA Closures Feed  2015","Source":"/sitecore/content/HCTRA/TravelTools/ClosuresArchivePage/ResultsSection/Data"},{"ItemID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","ItemName":"Marketing","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing","ParentID":"4e740cef-9f8f-4df6-b8fa-e7ae133cb7a8","TemplateID":"a87a00b1-e6db-45ab-8b54-636fec3b5523","TemplateName":"Folder","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Marketing","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/16x16/folder.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/folder.png","ItemUrl":"~/link.aspx?_id=6E2C79A3B4754DD59B6A9F5978D50422&amp;_z=z","Children":[{"ItemID":"6d5846ca-3da9-4ae2-aec5-ecba5e02e335","ItemName":"Careers","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Careers","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Careers","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=6D5846CA3DA94AE2AEC5ECBA5E02E335&amp;_z=z","ShowInHomePage":"1","Image":"<image mediaid=\\"{2EB62CFA-5C06-4F8D-8099-8D8909FBE267}\\" />","ImageURL":"/Employment","UserLoggedIn":"","IsDefault":"","isLargeImage":""},{"ItemID":"d068eacc-1c68-443e-b516-764c3f5b84a3","ItemName":"HCTRA Map","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/HCTRA Map","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"HCTRA Map","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=D068EACC1C68443EB516764C3F5B84A3&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{39877E77-BECF-49FC-AB9C-7DAF2EBBFB35}\\" />","ImageURL":"/TollRoadMap","UserLoggedIn":"","IsDefault":"1","isLargeImage":""},{"ItemID":"0382f24c-17dd-4b43-b700-59a5d8dd39f8","ItemName":"Regional Toll Roads","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Regional Toll Roads","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Regional Toll Roads","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=0382F24C17DD4B43B70059A5D8DD39F8&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{5AC713F6-B54E-4BB8-A298-79610B1CE9E1}\\" />","ImageURL":"/TollRoadInformation","UserLoggedIn":"","IsDefault":"","isLargeImage":""},{"ItemID":"24cf9d18-03d0-4fc8-ada3-f384df289669","ItemName":"Roadside Assistance","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Roadside Assistance","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Roadside Assistance","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=24CF9D1803D04FC8ADA3F384DF289669&amp;_z=z","ShowInHomePage":"1","Image":"<image mediaid=\\"{C2A11E3D-620C-4AF8-BACD-0C04A378F8E9}\\" />","ImageURL":"/RoadsideAssistance","UserLoggedIn":"","IsDefault":"","isLargeImage":"1"},{"ItemID":"0d5365c1-66d3-47b3-9672-c58505003f73","ItemName":"Store Locations","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Store Locations","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Store Locations","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=0D5365C166D347B39672C58505003F73&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{85009F47-2BA5-4FFE-8F81-66D885B2E817}\\" />","ImageURL":"/HelpAndSupport#ez-tag-store-locations","UserLoggedIn":"","IsDefault":"1","isLargeImage":""},{"ItemID":"497f3426-6af4-440b-a55a-217d52b5bee8","ItemName":"Toll Receipt","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Toll Receipt","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Toll Receipt","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=497F34266AF4440BA55A217D52B5BEE8&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{FAEA3BCF-679A-4451-9890-D3CE187B6129}\\" />","ImageURL":"/AccountActivityReceipts","UserLoggedIn":"1","IsDefault":"1","isLargeImage":""}]},{"ItemID":"afb454c8-fb19-418c-a925-815de50b43b4","ItemName":"Marketing Queries","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing Queries","ParentID":"4e740cef-9f8f-4df6-b8fa-e7ae133cb7a8","TemplateID":"a87a00b1-e6db-45ab-8b54-636fec3b5523","TemplateName":"Folder","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Marketing Queries","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/16x16/folder.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/folder.png","ItemUrl":"~/link.aspx?_id=AFB454C8FB19418CA925815DE50B43B4&amp;_z=z","Children":[{"ItemID":"91f3d5e6-cf68-4531-af89-7319187b9794","ItemName":"DefaultImage","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing Queries/DefaultImage","ParentID":"afb454c8-fb19-418c-a925-815de50b43b4","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Default Image Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=91F3D5E6CF684531AF897319187B9794&amp;_z=z","Database":"","Query":{"TotalCount":3,"TotalPage":1,"Links":[],"Results":[{"ItemID":"d068eacc-1c68-443e-b516-764c3f5b84a3","ItemName":"HCTRA Map","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/HCTRA Map","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"HCTRA Map","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=D068EACC1C68443EB516764C3F5B84A3&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T145949Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{39877E77-BECF-49FC-AB9C-7DAF2EBBFB35}\\" />","ImageURL":"/TollRoadMap","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"4165c304-929c-4f49-8d08-7e81a305af47","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""},{"ItemID":"0d5365c1-66d3-47b3-9672-c58505003f73","ItemName":"Store Locations","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Store Locations","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Store Locations","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=0D5365C166D347B39672C58505003F73&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160809T203844Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{85009F47-2BA5-4FFE-8F81-66D885B2E817}\\" />","ImageURL":"/HelpAndSupport#ez-tag-store-locations","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\Admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"a9773041-1e0e-42ba-80aa-57a414e0ae97","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""},{"ItemID":"497f3426-6af4-440b-a55a-217d52b5bee8","ItemName":"Toll Receipt","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Toll Receipt","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Toll Receipt","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=497F34266AF4440BA55A217D52B5BEE8&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160810T160412Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{FAEA3BCF-679A-4451-9890-D3CE187B6129}\\" />","ImageURL":"/AccountActivityReceipts","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"1","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"dd43b5fd-8f50-40e5-89a6-83169a8d50e0","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"0c387203-ade9-4c1b-acf6-bdfe2d27cbda","ItemName":"DefaultImageLarge","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing Queries/DefaultImageLarge","ParentID":"afb454c8-fb19-418c-a925-815de50b43b4","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Default Image Large Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=0C387203ADE94C1BACF6BDFE2D27CBDA&amp;_z=z","Database":"","Query":{"TotalCount":0,"TotalPage":0,"Links":[],"Results":[]}},{"ItemID":"b361b25d-eb72-4331-a8b8-4caed9de5f6c","ItemName":"DefaultImageSmall","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing Queries/DefaultImageSmall","ParentID":"afb454c8-fb19-418c-a925-815de50b43b4","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Default Image Small Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=B361B25DEB724331A8B84CAED9DE5F6C&amp;_z=z","Database":"","Query":{"TotalCount":3,"TotalPage":1,"Links":[],"Results":[{"ItemID":"d068eacc-1c68-443e-b516-764c3f5b84a3","ItemName":"HCTRA Map","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/HCTRA Map","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"HCTRA Map","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=D068EACC1C68443EB516764C3F5B84A3&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T145949Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{39877E77-BECF-49FC-AB9C-7DAF2EBBFB35}\\" />","ImageURL":"/TollRoadMap","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"4165c304-929c-4f49-8d08-7e81a305af47","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""},{"ItemID":"0d5365c1-66d3-47b3-9672-c58505003f73","ItemName":"Store Locations","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Store Locations","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Store Locations","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=0D5365C166D347B39672C58505003F73&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160809T203844Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{85009F47-2BA5-4FFE-8F81-66D885B2E817}\\" />","ImageURL":"/HelpAndSupport#ez-tag-store-locations","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\Admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"a9773041-1e0e-42ba-80aa-57a414e0ae97","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""},{"ItemID":"497f3426-6af4-440b-a55a-217d52b5bee8","ItemName":"Toll Receipt","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Toll Receipt","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Toll Receipt","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=497F34266AF4440BA55A217D52B5BEE8&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160810T160412Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{FAEA3BCF-679A-4451-9890-D3CE187B6129}\\" />","ImageURL":"/AccountActivityReceipts","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"1","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"dd43b5fd-8f50-40e5-89a6-83169a8d50e0","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"19aa516f-02e4-4724-b8db-4abc4310d511","ItemName":"ShowInHomeImageLarge","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing Queries/ShowInHomeImageLarge","ParentID":"afb454c8-fb19-418c-a925-815de50b43b4","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Show In Home Image Large Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=19AA516F02E44724B8DB4ABC4310D511&amp;_z=z","Database":"","Query":{"TotalCount":1,"TotalPage":1,"Links":[],"Results":[{"ItemID":"24cf9d18-03d0-4fc8-ada3-f384df289669","ItemName":"Roadside Assistance","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Roadside Assistance","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Roadside Assistance","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=24CF9D1803D04FC8ADA3F384DF289669&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T162110Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"1","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{C2A11E3D-620C-4AF8-BACD-0C04A378F8E9}\\" />","ImageURL":"/RoadsideAssistance","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"1d4ca944-1dd7-4782-8892-e68f839d2711","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"1","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"c93339d7-6695-4dc3-9bd4-81bfa9eb1e31","ItemName":"ShowInHomeImageSmall","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing Queries/ShowInHomeImageSmall","ParentID":"afb454c8-fb19-418c-a925-815de50b43b4","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Show In Home Image Small Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=C93339D766954DC39BD481BFA9EB1E31&amp;_z=z","Database":"","Query":{"TotalCount":1,"TotalPage":1,"Links":[],"Results":[{"ItemID":"6d5846ca-3da9-4ae2-aec5-ecba5e02e335","ItemName":"Careers","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/MajorClosuresSection/Marketing/Careers","ParentID":"6e2c79a3-b475-4dd5-9b6a-9f5978d50422","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Careers","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=6D5846CA3DA94AE2AEC5ECBA5E02E335&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T162420Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"1","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{2EB62CFA-5C06-4F8D-8099-8D8909FBE267}\\" />","ImageURL":"/Employment","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"9410c3d7-d637-45a3-abb2-e2c4b65b394c","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}}]}]},{"ItemID":"aef08e47-973d-423c-8d15-7b24774d21d8","ItemName":"NewsSection","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection","ParentID":"d7bc3008-dcf8-45d6-9a0d-e9454e4ed479","TemplateID":"2fa89c27-0690-46a7-bf44-be716ddeb106","TemplateName":"Section","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"News Section","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/32x32/window_gear.png","ItemMedialUrl":"/~/icon/Applications/48x48/window_gear.png.aspx","ItemUrl":"~/link.aspx?_id=AEF08E47973D423C8D157B24774D21D8&amp;_z=z","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","File":"","Title":"News","Image":"<image mediaid=\\"{62C0152A-7EAC-4662-A674-F723E2B1484F}\\" />","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","Purpose":"News Section","Children":[{"ItemID":"5870d93f-efb1-40b9-a4a0-299310bb214c","ItemName":"TopNewsSearch","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/TopNewsSearch","ParentID":"aef08e47-973d-423c-8d15-7b24774d21d8","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Top News Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=5870D93FEFB140B9A4A0299310BB214C&amp;_z=z","Database":"","Query":{"TotalCount":2,"TotalPage":1,"Links":[],"Results":[{"ItemID":"9c658628-525a-4635-8935-9b073dad0ed7","ItemName":"Baseball","ItemPath":"/sitecore/content/HCTRA/TravelTools/NewsArchivePage/ResultsSection/Data/Baseball","ParentID":"ab5d4a81-5158-4306-8424-decaafab4e8d","TemplateID":"59e99db4-8dcb-4be8-a384-01127cdec002","TemplateName":"News","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Baseball","HasChildren":"False","ItemIcon":"/temp/IconCache/NetworkV2/32x32/newspaper.png","ItemMedialUrl":"/~/icon/NetworkV2/48x48/newspaper.png.aspx","ItemUrl":"~/link.aspx?_id=9C658628525A463589359B073DAD0ED7&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T201653Z","__Is Bucket":"","__Subitems Sorting":"","__Persistent Bucket Filter":"","__Archive date":"","EndDate":"","__Reminder text":"","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","__Semantics":"{4E543538-0847-44FC-A5B4-91867FF10F5F}","__Workflow":"","LongDescription":"    <p>We hope you&rsquo;ll find our new website makes it easier to manage your EZ TAG account online. </p>\\n    <p>We&rsquo;ve been listening to your feedback and have incorporated changes you have asked for.&nbsp;We\'re not done making changes yet. We will continue to make improvements and add functionality to help you pay your tolls and manage your account more efficiently. </p>\\n    <p>Smartphone users now have access to&nbsp;a more streamlined account-management experience. If you\'re accessing the site on your mobile device,&nbsp; a link&nbsp;at the bottom of the page&nbsp;will take you to the full&nbsp;desktop version to view all capabilities the website now offers.</p>\\n    <p>So log in, check out your account, make any changes needed, and <a href=\\"/HelpAndSupport#email-us\\" id=\\"let us know what you think\\" target=\\"_self\\">let us know what you think</a>. We hope you&rsquo;ll like it as much we do!</p>\\n    <p>&nbsp;</p>\\n    <div class=\\"row\\">\\n        <div class=\\"col-xs-12 col-sm-3\\">\\n            <div class=\\"row\\">\\n                <div class=\\"col-xs-12\\">\\n                    <img alt=\\"\\" style=\\"width: 150px; height: 150px;margin:0 auto;display:block;\\" src=\\"-/media/A1957D8A5087417097F160C8D71B36F1.ashx\\">\\n                </div>\\n                <div class=\\"col-xs-12\\">\\n                    <p style=\\"text-align:center;\\"><strong>Account Management</strong><br><br>Easy and fast sign-up and<br>management</p>\\n                </div>\\n            </div>\\n        </div>\\n        <div class=\\"col-xs-12 col-sm-3\\">\\n            <div class=\\"row\\">\\n                <div class=\\"col-xs-12\\">\\n                    <img alt=\\"\\" style=\\"width: 150px; height: 150px;margin:0 auto;display:block;\\" src=\\"-/media/DAD8599760B74E92AA08173C821F52BC.ashx\\">\\n                </div>\\n                <div class=\\"col-xs-12\\">\\n                    <p style=\\"text-align:center;\\"><strong>Fully Responsive Design</strong><br><br>Looks great on all mobile<br>devices and browsers</p>\\n                </div>\\n            </div>\\n        </div>\\n        <div class=\\"col-xs-12 col-sm-3\\">\\n            <div class=\\"row\\">\\n                <div class=\\"col-xs-12\\">\\n                    <img alt=\\"\\" style=\\"width: 150px; height: 150px;margin:0 auto;display:block;\\" src=\\"-/media/6308EBA5EA6A4DF38036219C4F84F9D1.ashx\\">\\n                </div>\\n                <div class=\\"col-xs-12\\">\\n                    <p style=\\"text-align:center;\\"><strong>Travel Tools</strong><br><br>Useful information for your<br>daily commute</p>\\n                </div>\\n            </div>\\n        </div>\\n    </div>","__Created by":"sitecore\\\\admin","__Bucket Parent Reference":"","__Short description":"","__Validator Bar Validation Rules":"","SearchDescription":"Baseball is fun","__Publishing groups":"{8E080626-DDC3-4EF4-A1D1-F0BE4A200254}","IncludeInSearch":"1","__Hidden":"","File":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Read Only":"","__Unpublish":"","__Long description":"","Title":"No Subtitle, Yes Short Descrip","__Suppressed Validation Rules":"","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"100","__Renderers":"","__Thumbnail":"","__Display name":"","__Default workflow":"","__Valid to":"","Category":"Category 1","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\Admin","__Source Item":"","__Content Test":"","__Publish":"","Image":"","__Lock":"<r />","__Standard values":"","__Editor":"","__Enforce version presence":"","__Revision":"1e9a0e19-ae1d-4c86-92af-e38ea21176a4","__Skin":"","ShowInHomePage":"1","__Reminder date":"","__Validate Button Validation Rules":"","__Created":"20160608T220132Z","__Source":"","__Help link":"","__Preview":"","__Icon":"","FriendlyURL":"/TestBaseballyay","__Owner":"sitecore\\\\admin","__Editors":"","SearchThumbnail":"","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Security":"","Subtitle":"","__Reminder recipients":"","__Final Renderings":"","Top6":"","__Workflow Validation Rules":"","SearchTitle":"News - BaseballSUX","__Context Menu":"","__Bucketable":"","__Default View":"","__Boost":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""},{"ItemID":"d59c643f-3545-4d93-97dd-c474fbd1127a","ItemName":"JoseNews","ItemPath":"/sitecore/content/HCTRA/TravelTools/NewsArchivePage/ResultsSection/Data/JoseNews","ParentID":"ab5d4a81-5158-4306-8424-decaafab4e8d","TemplateID":"59e99db4-8dcb-4be8-a384-01127cdec002","TemplateName":"News","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Jose News","HasChildren":"False","ItemIcon":"/temp/IconCache/NetworkV2/32x32/newspaper.png","ItemMedialUrl":"/~/icon/NetworkV2/48x48/newspaper.png.aspx","ItemUrl":"~/link.aspx?_id=D59C643F35454D9397DDC474FBD1127A&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T201658Z","__Is Bucket":"","__Subitems Sorting":"","__Persistent Bucket Filter":"","__Archive date":"","EndDate":"","__Reminder text":"","ShortDescription":"","__Semantics":"{4E543538-0847-44FC-A5B4-91867FF10F5F}","__Workflow":"","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","__Created by":"sitecore\\\\jsalinas","__Bucket Parent Reference":"","__Short description":"","__Validator Bar Validation Rules":"","SearchDescription":"","__Publishing groups":"{8E080626-DDC3-4EF4-A1D1-F0BE4A200254}","IncludeInSearch":"1","__Hidden":"","File":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Read Only":"","__Unpublish":"","__Long description":"","Title":"Yes Subtitle, No Short Descrip","__Suppressed Validation Rules":"","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Thumbnail":"","__Display name":"Jose News","__Default workflow":"","__Valid to":"","Category":"Category 1","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\Admin","__Source Item":"","__Content Test":"","__Publish":"20160712T145200Z","Image":"","__Lock":"","__Standard values":"","__Editor":"","__Enforce version presence":"","__Revision":"50e49be0-4b88-4e5b-972f-7ebfaa76dcd9","__Skin":"","ShowInHomePage":"1","__Reminder date":"","__Validate Button Validation Rules":"","__Created":"20160712T144543Z","__Source":"","__Help link":"","__Preview":"","__Icon":"","FriendlyURL":"","__Owner":"sitecore\\\\admin","__Editors":"","SearchThumbnail":"","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Security":"","Subtitle":"mr subtitle lalala","__Reminder recipients":"","__Final Renderings":"","Top6":"","__Workflow Validation Rules":"","SearchTitle":"","__Context Menu":"","__Bucketable":"","__Default View":"","__Boost":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"1f63634c-3a1d-44d1-921d-65cfbdec0383","ItemName":"NewsFeed","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/NewsFeed","ParentID":"aef08e47-973d-423c-8d15-7b24774d21d8","TemplateID":"b960cbe4-381f-4a2b-9f44-a43c7a991a0b","TemplateName":"RSS Feed","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"News Feed","HasChildren":"False","ItemIcon":"/sitecore/shell/themes/standard/Custom/16x16/rss.png","ItemMedialUrl":"/sitecore/shell/themes/standard/Custom/48x48/rss.png","ItemUrl":"~/link.aspx?_id=1F63634C3A1D44D1921D65CFBDEC0383&amp;_z=z","Description":"HCTRA News Feed","Cache Duration":"","Title":"HCTRA News Feed","Image":"","Link":"","Type":"","Cacheable":"","Managing editor":"","Copyright":"HCTRA News Feed  2015","Source":"/sitecore/content/HCTRA/TravelTools/NewsArchivePage/ResultsSection/Data"},{"ItemID":"47158ea9-730e-4fc4-b93a-e862dff4e724","ItemName":"Marketing","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing","ParentID":"aef08e47-973d-423c-8d15-7b24774d21d8","TemplateID":"a87a00b1-e6db-45ab-8b54-636fec3b5523","TemplateName":"Folder","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Marketing","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/16x16/folder.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/folder.png","ItemUrl":"~/link.aspx?_id=47158EA9730E4FC4B93AE862DFF4E724&amp;_z=z","Children":[{"ItemID":"6502f96c-a1e7-4977-a12a-092cc5d3528c","ItemName":"Careers","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Careers","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Careers","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=6502F96CA1E74977A12A092CC5D3528C&amp;_z=z","ShowInHomePage":"1","Image":"<image mediaid=\\"{2EB62CFA-5C06-4F8D-8099-8D8909FBE267}\\" />","ImageURL":"/Employment","UserLoggedIn":"","IsDefault":"1","isLargeImage":"1"},{"ItemID":"eb9d2831-239a-48f5-915c-9c60bd0e14a4","ItemName":"HCTRA Map","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/HCTRA Map","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"HCTRA Map","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=EB9D2831239A48F5915C9C60BD0E14A4&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{39877E77-BECF-49FC-AB9C-7DAF2EBBFB35}\\" />","ImageURL":"/TollRoadMap","UserLoggedIn":"1","IsDefault":"","isLargeImage":""},{"ItemID":"3f1df1bf-75e6-4cf0-9bfb-a10af523b59a","ItemName":"Regional Toll Roads","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Regional Toll Roads","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Regional Toll Roads","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=3F1DF1BF75E64CF09BFBA10AF523B59A&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{5AC713F6-B54E-4BB8-A298-79610B1CE9E1}\\" />","ImageURL":"/TollRoadInformation","UserLoggedIn":"","IsDefault":"1","isLargeImage":""},{"ItemID":"041718c2-41b3-449f-8fea-b010f243b843","ItemName":"Roadside Assistance","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Roadside Assistance","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Roadside Assistance","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=041718C241B3449F8FEAB010F243B843&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{C2A11E3D-620C-4AF8-BACD-0C04A378F8E9}\\" />","ImageURL":"/RoadsideAssistance","UserLoggedIn":"","IsDefault":"","isLargeImage":"1"},{"ItemID":"7da10120-8493-4b29-ad7d-6babc38f0879","ItemName":"Store Locations","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Store Locations","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Store Locations","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=7DA1012084934B29AD7D6BABC38F0879&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{85009F47-2BA5-4FFE-8F81-66D885B2E817}\\" />","ImageURL":"/HelpAndSupport#ez-tag-store-locations","UserLoggedIn":"","IsDefault":"","isLargeImage":""},{"ItemID":"172257c8-c8a3-4836-96c6-af878d2a744a","ItemName":"Toll Receipt","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Toll Receipt","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Toll Receipt","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=172257C8C8A3483696C6AF878D2A744A&amp;_z=z","ShowInHomePage":"","Image":"<image mediaid=\\"{FAEA3BCF-679A-4451-9890-D3CE187B6129}\\" />","ImageURL":"/AccountActivityReceipts","UserLoggedIn":"1","IsDefault":"","isLargeImage":""}]},{"ItemID":"607411aa-96ca-46f7-b842-781e47bbe948","ItemName":"Marketing Queries","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing Queries","ParentID":"aef08e47-973d-423c-8d15-7b24774d21d8","TemplateID":"a87a00b1-e6db-45ab-8b54-636fec3b5523","TemplateName":"Folder","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Marketing Queries","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/16x16/folder.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/folder.png","ItemUrl":"~/link.aspx?_id=607411AA96CA46F7B842781E47BBE948&amp;_z=z","Children":[{"ItemID":"ce6eb2c9-e098-4720-91b3-368ae8179a24","ItemName":"DefaultImage","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing Queries/DefaultImage","ParentID":"607411aa-96ca-46f7-b842-781e47bbe948","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Default Image Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=CE6EB2C9E098472091B3368AE8179A24&amp;_z=z","Database":"","Query":{"TotalCount":2,"TotalPage":1,"Links":[],"Results":[{"ItemID":"6502f96c-a1e7-4977-a12a-092cc5d3528c","ItemName":"Careers","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Careers","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Careers","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=6502F96CA1E74977A12A092CC5D3528C&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T142357Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"1","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{2EB62CFA-5C06-4F8D-8099-8D8909FBE267}\\" />","ImageURL":"/Employment","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"144ee029-3c18-4421-8594-434b699f073f","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"1","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""},{"ItemID":"3f1df1bf-75e6-4cf0-9bfb-a10af523b59a","ItemName":"Regional Toll Roads","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Regional Toll Roads","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Regional Toll Roads","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=3F1DF1BF75E64CF09BFBA10AF523B59A&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T142318Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{5AC713F6-B54E-4BB8-A298-79610B1CE9E1}\\" />","ImageURL":"/TollRoadInformation","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"61a29c85-5980-4c53-ae30-35a1e1641d9a","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"470ab3af-c9d7-4e42-9236-f795f7bd2051","ItemName":"DefaultImageLarge","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing Queries/DefaultImageLarge","ParentID":"607411aa-96ca-46f7-b842-781e47bbe948","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Default Image Large Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=470AB3AFC9D74E429236F795F7BD2051&amp;_z=z","Database":"","Query":{"TotalCount":1,"TotalPage":1,"Links":[],"Results":[{"ItemID":"6502f96c-a1e7-4977-a12a-092cc5d3528c","ItemName":"Careers","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Careers","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Careers","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=6502F96CA1E74977A12A092CC5D3528C&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T142357Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"1","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{2EB62CFA-5C06-4F8D-8099-8D8909FBE267}\\" />","ImageURL":"/Employment","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"144ee029-3c18-4421-8594-434b699f073f","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"1","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"301d6cfc-80a8-411e-8b81-cb7e0cac1c23","ItemName":"DefaultImageSmall","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing Queries/DefaultImageSmall","ParentID":"607411aa-96ca-46f7-b842-781e47bbe948","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Default Image Small Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=301D6CFC80A8411E8B81CB7E0CAC1C23&amp;_z=z","Database":"","Query":{"TotalCount":1,"TotalPage":1,"Links":[],"Results":[{"ItemID":"3f1df1bf-75e6-4cf0-9bfb-a10af523b59a","ItemName":"Regional Toll Roads","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Regional Toll Roads","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Regional Toll Roads","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=3F1DF1BF75E64CF09BFBA10AF523B59A&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T142318Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{5AC713F6-B54E-4BB8-A298-79610B1CE9E1}\\" />","ImageURL":"/TollRoadInformation","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"61a29c85-5980-4c53-ae30-35a1e1641d9a","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"0b5db013-cdc9-4548-a0ce-488a80ca15aa","ItemName":"ShowInHomeImageLarge","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing Queries/ShowInHomeImageLarge","ParentID":"607411aa-96ca-46f7-b842-781e47bbe948","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Show In Home Image Large Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=0B5DB013CDC94548A0CE488A80CA15AA&amp;_z=z","Database":"","Query":{"TotalCount":1,"TotalPage":1,"Links":[],"Results":[{"ItemID":"6502f96c-a1e7-4977-a12a-092cc5d3528c","ItemName":"Careers","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing/Careers","ParentID":"47158ea9-730e-4fc4-b93a-e862dff4e724","TemplateID":"d0693e5b-8a76-4e27-8c14-068662e78ad3","TemplateName":"MarketingImage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Careers","HasChildren":"False","ItemIcon":"/temp/IconCache/Apps/32x32/dna.png","ItemMedialUrl":"/temp/IconCache/Apps/48x48/dna.png","ItemUrl":"~/link.aspx?_id=6502F96CA1E74977A12A092CC5D3528C&amp;_z=z","__Boosting Rules":"","__Archive Version date":"","__Updated":"20160811T142357Z","__Created":"20160809T202410Z","__Persistent Bucket Filter":"","__Archive date":"","__Enforce version presence":"","__Created by":"sitecore\\\\Admin","__Reminder text":"","__Publishing groups":"","__Semantics":"","__Read Only":"","__Default View":"","__Bucket Parent Reference":"","__Short description":"","ShowInHomePage":"1","__Thumbnail":"","__Suppressed Validation Rules":"","__Hidden":"","__Masters":"","__Enabled Views":"","__Enable item fallback":"","__Long description":"","__Unpublish":"","Image":"<image mediaid=\\"{2EB62CFA-5C06-4F8D-8099-8D8909FBE267}\\" />","ImageURL":"/Employment","__Default Bucket Query":"","__Controller":"","__Style":"","__Renderings":"","__Sortorder":"","__Renderers":"","__Editors":"","__Display name":"","__Default workflow":"","__Valid to":"","__Quick Actions":"","__Should Not Organize In Bucket":"","__Tracking":"","__Updated by":"sitecore\\\\admin","__Source Item":"","UserLoggedIn":"","__Content Test":"","__Publish":"","IsDefault":"1","__Lock":"","__Subitems Sorting":"","__Standard values":"","__Editor":"","__Revision":"144ee029-3c18-4421-8594-434b699f073f","__Skin":"","__Workflow":"","__Validate Button Validation Rules":"","__Source":"","__Help link":"","__Preview":"","__Icon":"","__Reminder date":"","__Owner":"sitecore\\\\Admin","__Quick Action Bar Validation Rules":"","__Hide version":"","__Never publish":"","__Insert Rules":"","__Valid from":"","__Controller Action":"","__Workflow state":"","__Validator Bar Validation Rules":"","__Security":"","__Reminder recipients":"","__Final Renderings":"","__Workflow Validation Rules":"","__Context Menu":"","__Bucketable":"","__Is Bucket":"","__Boost":"","isLargeImage":"1","__Presets":"","__Page Level Test Set Definition":"","__Originator":"","__Ribbon":"","__Facets":""}]}},{"ItemID":"a22c16ba-8432-4257-bc49-1b1d153bd35f","ItemName":"ShowInHomeImageSmall","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/NewsSection/Marketing Queries/ShowInHomeImageSmall","ParentID":"607411aa-96ca-46f7-b842-781e47bbe948","TemplateID":"79e0e28f-5591-410e-a086-754edc7cef88","TemplateName":"Query Definition","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Show In Home Image Small Search","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/gears_view.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/gears_view.png","ItemUrl":"~/link.aspx?_id=A22C16BA84324257BC491B1D153BD35F&amp;_z=z","Database":"","Query":{"TotalCount":0,"TotalPage":0,"Links":[],"Results":[]}}]}]},{"ItemID":"9bd5e5db-03cf-4b79-8cd3-75c87e675262","ItemName":"EZTagSection","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/EZTagSection","ParentID":"d7bc3008-dcf8-45d6-9a0d-e9454e4ed479","TemplateID":"2fa89c27-0690-46a7-bf44-be716ddeb106","TemplateName":"Section","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"EZ Tag Section","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/32x32/window_gear.png","ItemMedialUrl":"/~/icon/Applications/48x48/window_gear.png.aspx","ItemUrl":"~/link.aspx?_id=9BD5E5DB03CF4B798CD375C87E675262&amp;_z=z","LongDescription":"","File":"","Title":"EZ Tag","Image":"","ShortDescription":"<p><span style=\\"background-color: #d8d8d8;\\"></span><a href=\\"https://www.bancpass.com/\\" target=\\"_blank\\"><span style=\\"text-decoration: underline;\\">BancPass</span></a></p>\\n<p><a href=\\"/NonSectional?path=/sitecore/content/HCTRA/HelpAndSupport/Regional%20Toll%20Roads\\" target=\\"_parent\\">Regional Toll Roads</a></p>\\n<p>&nbsp;</p>","Purpose":"EZ Tag Section","Children":[{"ItemID":"be42d5ce-ae97-490c-a7e7-d0c7da9c7449","ItemName":"test","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/EZTagSection/test","ParentID":"9bd5e5db-03cf-4b79-8cd3-75c87e675262","TemplateID":"a87a00b1-e6db-45ab-8b54-636fec3b5523","TemplateName":"Folder","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"test","HasChildren":"True","ItemIcon":"/temp/IconCache/Applications/16x16/folder.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/folder.png","ItemUrl":"~/link.aspx?_id=BE42D5CEAE97490CA7E7D0C7DA9C7449&amp;_z=z","Children":[{"ItemID":"07252dc8-c6a3-4ce9-9c90-212319dcb14b","ItemName":"PageAA","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/EZTagSection/test/PageAA","ParentID":"be42d5ce-ae97-490c-a7e7-d0c7da9c7449","TemplateID":"105715bb-396c-4275-be73-f21d85df4219","TemplateName":"SimplePage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"PageAA","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/16x16/document_notebook.png","ItemMedialUrl":"/~/icon/Applications/48x48/document_notebook.png.aspx","ItemUrl":"~/link.aspx?_id=07252DC8C6A34CE99C90212319DCB14B&amp;_z=z","Title":"page123","SearchDescription":"","LongDescription":"","FriendlyURL":"","SearchThumbnail":"","IncludeInSearch":"1","Top6":"","SearchTitle":""},{"ItemID":"d462fb51-a31a-40e8-97fd-3b61d433c248","ItemName":"Page1","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/EZTagSection/test/Page1","ParentID":"be42d5ce-ae97-490c-a7e7-d0c7da9c7449","TemplateID":"105715bb-396c-4275-be73-f21d85df4219","TemplateName":"SimplePage","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Page1","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/16x16/document_notebook.png","ItemMedialUrl":"/~/icon/Applications/48x48/document_notebook.png.aspx","ItemUrl":"~/link.aspx?_id=D462FB51A31A40E897FD3B61D433C248&amp;_z=z","Title":"Page1234","SearchDescription":"","LongDescription":"","FriendlyURL":"","SearchThumbnail":"","IncludeInSearch":"1","Top6":"","SearchTitle":""},{"ItemID":"be4abc6c-1f9a-4306-b162-6b85ba371679","ItemName":"PageA","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/EZTagSection/test/PageA","ParentID":"be42d5ce-ae97-490c-a7e7-d0c7da9c7449","TemplateID":"dafb3eaf-dabf-4275-a114-875cfab3de36","TemplateName":"Page","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"PageA","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/text_rich_colored.png","ItemMedialUrl":"/temp/IconCache/Applications/48x48/text_rich_colored.png","ItemUrl":"~/link.aspx?_id=BE4ABC6C1F9A4306B1626B85BA371679&amp;_z=z","NumberOfItemsToShow":"0","LongDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","SearchDescription":"","File":"","Title":"PageA","Image":"","ShortDescription":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue vulputate erat hendrerit tincidunt.","PermanentURL":"","FriendlyURL":"","SearchThumbnail":"","IncludeInSearch":"1","Top6":"","SearchTitle":"","Purpose":"PageA"}]}]},{"ItemID":"e93991fe-99df-4ee1-8342-5f24043f2195","ItemName":"SpecialInterestSection","ItemPath":"/sitecore/content/HCTRA/Home/HomePage/SpecialInterestSection","ParentID":"d7bc3008-dcf8-45d6-9a0d-e9454e4ed479","TemplateID":"2fa89c27-0690-46a7-bf44-be716ddeb106","TemplateName":"Section","CloneSource":null,"ItemLanguage":"en","ItemVersion":"1","DisplayName":"Special Interest Section","HasChildren":"False","ItemIcon":"/temp/IconCache/Applications/32x32/window_gear.png","ItemMedialUrl":"/~/icon/Applications/48x48/window_gear.png.aspx","ItemUrl":"~/link.aspx?_id=E93991FE99DF4EE183425F24043F2195&amp;_z=z","LongDescription":"","File":"","Title":"Special Interest","Image":"","ShortDescription":"<p><a href=\\"/SamHoustonNortheast\\" target=\\"_parent\\">Sam Houston Northeast</a></p>\\n<p><a href=\\"/HardyTollway\\" target=\\"_parent\\">Hardy Toll Road</a></p>\\n<p><a href=\\"/KatyManagedLanes\\" target=\\"_parent\\">Katy Managed Lanes</a></p>\\n<p><a href=\\"/ShipChannelBridge\\" target=\\"_parent\\">Ship Channel Bridge</a></p>\\n<p><a href=\\"/Tomball\\" target=\\"_parent\\">Tomball Tollway</a></p>","Purpose":"Special Interest Section"}]}', errors: [], alerts: [] });
//                 }
//             });
//             //create the controller
//             AppController = $controller('AppController', { $scope: scope, $rootScope: rootScope });
//             scope.remoteObj.focusFirstField = function () { };
//             wildCardToggler = false;
//            //create a spy to ensure that $broadcast is called on successful login
//             spyOn(rootScope, '$broadcast');
//             spyOn(scope.remoteObj, 'focusFirstField');
//             spyOn(_wildCardUrlCheckerService_, 'wildCardUrlisMatch').and.callFake(wildCardUrlCheckerService.wildCardUrlisMatch);
//             scope.$digest();
//         }));
//         describe('focusFirstField tests', function () {
//             it('test that focusFirstField is calling remote object', function () {
//                 scope.focusFirstField();
//                 expect(scope.remoteObj.focusFirstField.calls.count()).toEqual(1);
//             });
//             it('test that focusFirstField is calling remote object', function () {
//                 wildCardToggler = true;
//                 scope.focusFirstField();
//                 expect(scope.remoteObj.focusFirstField.calls.count()).toEqual(0);
//             });
//         });
//     });
// }());
(function () {
    'use strict';
    describe('AuthResolver', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        function unwatch() { }
        var service, USER_ROLES, addMissingInformationService, rootScope, $state, authObj = {
            isAuthenticated: true,
            isAuthorized: true
        };
        var storefrontUtilityService;
        var authenticateRedirectService;
        beforeEach(function () {
            storefrontUtilityService = {
                isRunningAsKiosk: false,
                webStoreData: null
            };
        });
        describe("returns promise", function () {
            beforeEach(angular.mock.module(function ($provide) {
                authenticateRedirectService = jasmine.createSpyObj('authRedirectService', ['saveToState']);
                rootScope = jasmine.createSpyObj('rootScope', ['$watch', '$apply', '$digest', '$on']);
                rootScope.$watch.and.callFake(function (prop, action) {
                    action && action(rootScope[prop]);
                    return unwatch;
                });
                USER_ROLES = hctraMocks.USER_ROLES();
                addMissingInformationService = hctraMocks.addMissingInformationService();
                $state = hctraMocks.$state({});
                $provide.value('$location', hctraMocks.$location(''));
                $provide.value('AuthService', hctraMocks.AuthService(authObj));
                $provide.value('USER_ROLES', USER_ROLES);
                $provide.value('$state', $state);
                $provide.value('stateNames', hctraMocks.stateNames());
                $provide.value('addMissingInformationService', addMissingInformationService);
                $provide.value('authenticateRedirectService', authenticateRedirectService);
                $provide.value('StorefrontUtilityService', storefrontUtilityService);
                $provide.value('$rootScope', rootScope);
                $provide.factory('$q', ['replacementQService', function (replacementQService) { return replacementQService; }]);
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('AuthResolver');
            }));
            it('should resolve as successful', function () {
                var authRoles = [USER_ROLES.anonymous];
                addMissingInformationService.setMissingInformation(false, false, false);
                addMissingInformationService.setProfileCallHasOccured(true);
                //var result;
                return service.resolve(authRoles).then(function (data) {
                    //result = data;
                    expect(data).toBe('success');
                });
                //rootScope.$apply();
            });
            // it('should resolve as successful when role is active', async function () {
            // 	var authRoles = [USER_ROLES.active];
            // 	addMissingInformationService.setMissingInformation(false, false, false);
            // 	//var result;
            // 	rootScope.currentUser = {};
            // 	rootScope.currentUser.acctActivity = "A";
            // 	const data = await service.resolve(authRoles);//.then(function (data) {
            // 	    //result = data;
            // 	    expect(data).toBe('success');
            // 	//});
            // 	// rootScope.currentUser = {};
            // 	// rootScope.currentUser.acctActivity = "A";
            // 	//rootScope.$apply();
            // 	//rootScope.$digest();				
            // });
            it('should resolve as successful when role anonymous', function () {
                var authRoles = [USER_ROLES.anonymous];
                authObj.isAuthenticated = false;
                addMissingInformationService.setMissingInformation(false, false, false);
                //var result;
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                return service.resolve(authRoles).then(function (data) {
                    //result = data;
                    expect(data).toBe('success');
                });
                // rootScope.currentUser = {};
                // rootScope.currentUser.acctActivity = "A";
                //rootScope.$apply();
                //rootScope.$digest();				
            });
            // it('should resolve as successful when missing info', async function () {
            // 	var authRoles = [USER_ROLES.anonymous];
            // 	addMissingInformationService.setMissingInformation(true, false, false);
            // 	//var result;
            // 	rootScope.currentUser = {};
            // 	rootScope.currentUser.acctActivity = "A";
            // 	const data = await service.resolve(authRoles);//.then(function (data) {
            // 	    //result = data;
            // 	    expect(data).toBe('success');
            // 	//});
            // 	// rootScope.currentUser = {};
            // 	// rootScope.currentUser.acctActivity = "A";
            // 	//rootScope.$apply();
            // 	//rootScope.$digest();
            // });
            it('should reject as notAuthenticated when not notAuthenticated', function () {
                authObj.isAuthenticated = false;
                authObj.isAuthorized = false;
                var authRoles = [USER_ROLES.active];
                addMissingInformationService.setMissingInformation(true, false, false);
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                //var result;
                return service.resolve(authRoles).then(function () {
                }).catch(function (data) {
                    //result = data;
                    expect(data).toBe('notAuthenticated');
                });
                // rootScope.$apply();
                // rootScope.$digest();
            });
            it('should reject as missingRequiredInformation when not missingRequiredInformation', function () {
                authObj.isAuthenticated = true,
                    authObj.isAuthorized = false;
                var authRoles = [USER_ROLES.active];
                addMissingInformationService.setMissingInformation(true, false, false);
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                //var result;
                return service.resolve(authRoles).then(function () {
                }).catch(function (data) {
                    //result = data;
                    expect(data).toBe('missingRequiredInformation');
                });
                // rootScope.$apply();
                // rootScope.$digest();
            });
            it('should reject as notAuthorized when not notAuthorized', function () {
                authObj.isAuthenticated = true,
                    authObj.isAuthorized = false;
                var authRoles = [USER_ROLES.active];
                addMissingInformationService.setMissingInformation(false, false, false);
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                //var result;
                return service.resolve(authRoles).then(function () {
                }).catch(function (data) {
                    //result = data;
                    expect(data).toBe('notAuthorized');
                });
                // rootScope.$apply();
                // rootScope.$digest();
            });
        });
        describe("redirects to different $state", function () {
            beforeEach(angular.mock.module(function ($provide) {
                authenticateRedirectService = jasmine.createSpyObj('authRedirectService', ['saveToState']);
                rootScope = jasmine.createSpyObj('rootScope', ['$watch', '$apply', '$digest', '$on']);
                rootScope.$watch.and.callFake(function (prop, action) {
                    action && action(rootScope[prop]);
                    return unwatch;
                });
                USER_ROLES = hctraMocks.USER_ROLES();
                addMissingInformationService = hctraMocks.addMissingInformationService();
                $state = hctraMocks.$state({});
                $provide.value('AuthService', hctraMocks.AuthService(authObj));
                $provide.value('USER_ROLES', USER_ROLES);
                $provide.value('$state', $state);
                $provide.value('stateNames', hctraMocks.stateNames());
                $provide.value('addMissingInformationService', addMissingInformationService);
                $provide.value('authenticateRedirectService', authenticateRedirectService);
                $provide.value('StorefrontUtilityService', storefrontUtilityService);
                $provide.value('$rootScope', rootScope);
                $provide.factory('$q', ['replacementQService', function (replacementQService) { return replacementQService; }]);
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('AuthResolver');
                spyOn($state, "go");
            }));
            it('should check spy is called with Login when not authenticated', function () {
                authObj.isAuthenticated = false;
                authObj.isAuthorized = false;
                var authRoles = [USER_ROLES.active];
                addMissingInformationService.setMissingInformation(true, false, false);
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                return service.resolve(authRoles).then(function () {
                }).catch(function () {
                    expect($state.go).toHaveBeenCalledWith('Login');
                });
                // rootScope.$apply();
                // rootScope.$digest();
            });
            it('should check spy is called with missingRequiredInformation when not missingRequiredInformation', function () {
                authObj.isAuthenticated = true,
                    authObj.isAuthorized = false;
                var authRoles = [USER_ROLES.active];
                addMissingInformationService.setMissingInformation(true, false, false);
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                return service.resolve(authRoles).then(function () {
                }).catch(function () {
                    expect($state.go).toHaveBeenCalledWith('AddMissingInformation');
                });
                // rootScope.$apply();
                // rootScope.$digest();
            });
            it('should check spy is not called when not notAuthorized', function () {
                authObj.isAuthenticated = true,
                    authObj.isAuthorized = false;
                var authRoles = [USER_ROLES.active];
                addMissingInformationService.setMissingInformation(false, false, false);
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                return service.resolve(authRoles).then(function () {
                }).catch(function () {
                    expect($state.go).not.toHaveBeenCalledWith('Login');
                    expect($state.go).not.toHaveBeenCalledWith('AddMissingInformation');
                });
                // rootScope.$apply();
                // rootScope.$digest();
            });
        });
        describe('storefront override', function () {
            beforeEach(angular.mock.module(function ($provide) {
                rootScope = jasmine.createSpyObj('rootScope', ['$watch', '$apply', '$digest', '$on']);
                rootScope.$watch.and.callFake(function (prop, action) {
                    action && action(rootScope[prop]);
                    return unwatch;
                });
                authenticateRedirectService = jasmine.createSpyObj('authRedirectService', ['saveToState']);
                USER_ROLES = hctraMocks.USER_ROLES();
                addMissingInformationService = hctraMocks.addMissingInformationService();
                $state = hctraMocks.$state({});
                $provide.value('AuthService', hctraMocks.AuthService(authObj));
                $provide.value('USER_ROLES', USER_ROLES);
                $provide.value('$state', $state);
                $provide.value('stateNames', hctraMocks.stateNames());
                $provide.value('addMissingInformationService', addMissingInformationService);
                $provide.value('authenticateRedirectService', authenticateRedirectService);
                $provide.value('StorefrontUtilityService', storefrontUtilityService);
                $provide.value('$rootScope', rootScope);
                $provide.factory('$q', ['replacementQService', function (replacementQService) { return replacementQService; }]);
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('AuthResolver');
                spyOn($state, "go");
            }));
            it('transitions in kiosk non-fullsite mode missing data', function () {
                storefrontUtilityService.isRunningAsKiosk = true;
                storefrontUtilityService.webStoreData = { fullSiteMode: false };
                var authRoles = [USER_ROLES.anonymous];
                addMissingInformationService.setMissingInformation(true, false, false);
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                return service.resolve(authRoles).then(function (data) {
                    expect(data).toBe('success');
                });
                // rootScope.currentUser = {};
                // rootScope.currentUser.acctActivity = "A";
                // rootScope.$apply();
                // rootScope.$digest();
            });
            it('does not transition in kiosk fullsite node', function () {
                storefrontUtilityService.isRunningAsKiosk = true;
                storefrontUtilityService.webStoreData = { fullSiteMode: true };
                var authRoles = [USER_ROLES.anonymous];
                addMissingInformationService.setMissingInformation(true, false, false);
                //.then(function (data) {
                //expect(data).not.toBe('success');
                //});
                rootScope.currentUser = {};
                rootScope.currentUser.acctActivity = "A";
                // rootScope.$apply();
                // rootScope.$digest();
                return service.resolve(authRoles).catch(function (data) {
                    expect(data).not.toBe('success');
                });
            });
        });
    });
}());
(function () {
    'use strict';
    describe('dateService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service, bowserService, date1, date2, dateObj;
        beforeEach(angular.mock.module(function () {
            date1 = new Date(1992, 10, 9, 5, 5, 5, 100);
            date2 = new Date(1992, 10, 9, 5, 5, 5, 100);
            dateObj = {
                endDate: new Date(1992, 10, 9, 5, 5, 5, 100)
            };
        }));
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('bowserService', hctraMocks.bowserService());
            $provide.factory('momentService', ['momentjs', function (momentjs) { return ({ moment: function (d) { return momentjs(d || dateObj.endDate); } }); }]);
        }));
        beforeEach(angular.mock.inject(function ($injector, _bowserService_) {
            service = $injector.get('dateService');
            bowserService = _bowserService_;
        }));
        it('should return a new date that is 5 days ago', function () {
            date1.setMonth(6);
            date1.setDate(10);
            expect(service.getDaysAgo(5, date1).getDate()).toEqual(5);
        });
        it('should return a new date that is in a previous month', function () {
            date1.setMonth(6);
            date1.setDate(2);
            expect(service.getDaysAgo(5, date1).getDate()).toEqual(27);
        });
        it('should return true if the date1 is before date2', function () {
            date1.setMonth(6);
            date1.setDate(10);
            date2.setMonth(6);
            date2.setDate(20);
            expect(service.isBefore(date1, date2)).toBeTruthy();
        });
        it('should return true if the date1 is after date2', function () {
            date1.setMonth(6);
            date1.setDate(20);
            date2.setMonth(6);
            date2.setDate(10);
            expect(service.isAfter(date1, date2)).toBeTruthy();
        });
        it('should return true if the string is in date format', function () {
            expect(service.isDate('07/18/2016')).toBeTruthy();
            expect(service.isDate('07/18/16')).toBeTruthy();
            // Chutzpah PhantomJS doesn't support proper date conversion as of 2.1.1 but these tests work fine when run in Chrome
            if (!bowserService.phantom) {
                expect(service.isDate('07-18-2016')).toBeTruthy();
                expect(service.isDate('07-18-16')).toBeTruthy();
            }
            expect(service.isDate('July 18, 2016')).toBeTruthy();
            expect(service.isDate('Test')).toBeFalsy();
        });
        it('should keep articles that are permanent', function () {
            var article = {
                isPermanent: '1',
                endDate: new Date(1990, 7, 10, 2, 45, 0)
            };
            expect(service.isExpiredFilterForCms(article)).toBeTruthy();
        });
        it('should filter down to millisecond granularity', function () {
            var currentDate = angular.copy(dateObj.endDate);
            var articleValid = {
                isPermanent: '',
                endDate: new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), 900)
            };
            var articleExpired = {
                isPermanent: '',
                endDate: new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), 0)
            };
            expect(service.isExpiredFilterForCms(articleValid)).toBeTruthy();
            expect(service.isExpiredFilterForCms(articleExpired)).toBeFalsy();
        });
        it('should filter down to second granularity', function () {
            var currentDate = angular.copy(dateObj.endDate);
            var articleValid = {
                isPermanent: '',
                endDate: new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), 59, 0)
            };
            var articleExpired = {
                isPermanent: '',
                endDate: new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), 0, 0)
            };
            expect(service.isExpiredFilterForCms(articleValid)).toBeTruthy();
            expect(service.isExpiredFilterForCms(articleExpired)).toBeFalsy();
        });
        it('should filter down to minute granularity', function () {
            var currentDate = angular.copy(dateObj.endDate);
            var articleValid = {
                isPermanent: '',
                endDate: new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), 59, 59, 0)
            };
            var articleExpired = {
                isPermanent: '',
                endDate: new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), 0, 0, 0)
            };
            expect(service.isExpiredFilterForCms(articleValid)).toBeTruthy();
            expect(service.isExpiredFilterForCms(articleExpired)).toBeFalsy();
        });
        it('should keep articles that have no end date', function () {
            var article = {
                isPermanent: '',
                endDate: null
            };
            expect(service.isExpiredFilterForCms(article)).toBeTruthy();
            article = {
                isPermanent: '',
                endDate: ''
            };
            expect(service.isExpiredFilterForCms(article)).toBeTruthy();
        });
        it('should filter out end dates that are before today (single date obj)', function () {
            var yesterdayDate = angular.copy(dateObj.endDate);
            yesterdayDate.setDate(yesterdayDate.getDate() - 1);
            var article = {
                isPermanent: '',
                endDate: yesterdayDate
            };
            expect(service.isExpiredFilterForCms(article)).toBeFalsy();
        });
        it('should filter out end dates that are before today (date obj array)', function () {
            var yesterdayDate = angular.copy(dateObj.endDate);
            yesterdayDate.setDate(yesterdayDate.getDate() - 1);
            var tomorrowDate = angular.copy(dateObj.endDate);
            tomorrowDate.setDate(tomorrowDate.getDate() + 1);
            var articleArr = [
                {
                    isPermanent: '',
                    endDate: yesterdayDate
                },
                {
                    isPermanent: '',
                    endDate: tomorrowDate
                }
            ];
            expect(articleArr.filter(service.isExpiredFilterForCms)).toEqual([{
                    isPermanent: '',
                    endDate: tomorrowDate
                }]);
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('focusExclusionService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var dictByUrl = {};
        var routes;
        var dictByWildCard = {};
        var service = {};
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('routes', hctraMocks.routes());
        }));
        beforeEach(angular.mock.inject(function ($injector, _routes_) {
            service = $injector.get('focusExclusionService');
            routes = _routes_;
            dictByUrl[routes.faq] = true;
            dictByUrl[routes.closuresArchive] = true;
            dictByUrl[routes.newsArchive] = true;
            dictByWildCard[routes.faq] = { expectedSegments: 4, path: routes.faq };
            dictByWildCard[routes.closuresArchive] = { expectedSegments: 4, path: routes.closuresArchive };
            dictByWildCard[routes.newsArchive] = { expectedSegments: 4, path: routes.newsArchive };
        }));
        it('test that dictByUrl has all needed properties', function () {
            expect(service.dictByUrl).toEqual(dictByUrl);
        });
        it('test that dictByWildCard has all needed properties', function () {
            expect(service.dictByWildCard).toEqual(dictByWildCard);
        });
    });
}());
//migrated
/*
(() => {
    'use strict';

    describe('httpFactory', () => {
        
        let service;
        const $http = {
            defaults: {
                headers: {
                    common: {}
                }
            }
        };
        const siteVerbiage = {};
        const $state = {};
        const responseErrorService = {};
        const stateNames = {};
        let serverConstants;
        const toggleButtonsService = {};
        const operatingSystemSnifferService = {

            getOS: (() => { }) as (() => any),
            isDesktopOs: () => { return false; }
        };
        const storefrontUtilityService = {
            isRunningAsKiosk: false
        };

        beforeEach(angular.mock.module('HCTRAModule'));


        beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {

            serverConstants = {
                appNameHeaderKey: "Mock App Header Key",
                appNameWebsiteStorefrontHeaderValue: "Mock App Name Website Storefront",
                appNameWebsiteDesktopHeaderValue: "Mock App Name Website Desktop",
                appNameWebsiteMobileHeaderValue: "Mock App Name Website Mobile",
                versionHeaderKey: "Mock Version Header Key",
                currentlyDownloadedWebUiVersion: "0.1.2.3.4.5"

            };

            $provide.value("$http", $http);
            $provide.value("siteVerbiage", siteVerbiage);
            $provide.value("$state", $state);
            $provide.value("responseErrorService", responseErrorService);
            $provide.value("stateNames", stateNames)
            $provide.value("serverConstants", serverConstants);
            $provide.value("toggleButtonsService", toggleButtonsService);
            $provide.value("operatingSystemSnifferService", operatingSystemSnifferService);
            $provide.value("StorefrontUtilityService", storefrontUtilityService);
        }));

        beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
            service = $injector.get('httpFactory');
        }));

        describe("canary", () => {

            it("should pass", () => {
                expect(true).toBe(true);
            });
        });

        describe("constructor\init", () => {

            it("should set appNameHeaderKey and versionHeaderKey for $http.defaults.headers.common", () => {

                expect($http.defaults.headers.common["Mock App Header Key"]).toContain("Mock App Name Website");
                expect($http.defaults.headers.common["Mock Version Header Key"]).toBe("0.1.2");
            });

            it("should call operatingSystemSnifferService.getOS then operatingSystemSnifferService.isDesktopOs()", () => {

                const calls = [];

                spyOn(operatingSystemSnifferService, "getOS").and.callFake(() => calls.push("getOS"));
                spyOn(operatingSystemSnifferService, "isDesktopOs").and.callFake(() => calls.push("isDesktopOs") as any);

                service.init();

                expect(calls).toEqual(["getOS", "isDesktopOs"]);

                expect(operatingSystemSnifferService.getOS).toHaveBeenCalledTimes(1);
                expect(operatingSystemSnifferService.isDesktopOs).toHaveBeenCalledTimes(1);
            });

            [
                { isRunningAsKiosk: false, isDesktop: false, appNameHeaderKey: "Mock App Name Website Mobile" },
                { isRunningAsKiosk: false, isDesktop: true, appNameHeaderKey: "Mock App Name Website Desktop" },
                { isRunningAsKiosk: true, isDesktop: false, appNameHeaderKey: "Mock App Name Website Storefront" },
                { isRunningAsKiosk: true, isDesktop: true, appNameHeaderKey: "Mock App Name Website Storefront" }
            ].forEach(({ isRunningAsKiosk, isDesktop, appNameHeaderKey }) => {
                
                it(`should set appNameHeaderKey to ${appNameHeaderKey} when isRunningKiosk: ${isRunningAsKiosk} and isDesktop(): ${isDesktop}`, () => {

                    storefrontUtilityService.isRunningAsKiosk = isRunningAsKiosk;
                    spyOn(operatingSystemSnifferService, "isDesktopOs").and.returnValue(isDesktop);

                    service.init();

                    expect($http.defaults.headers.common["Mock App Header Key"]).toBe(appNameHeaderKey);
                });

            });

            [
                ["0.1.2.3.4.5", "0.1.2"],
                ["x.t.a.b.t.u", "x.t.a"],
                ["@.$.,.%.^.)", "@.$.,"]
            ].forEach(([currentlyDownloadedWebUiVersion, expected]) => {

                it(`should set versionHeaderKey to ${expected} when currentlyDownloadedWebUiVersion is ${currentlyDownloadedWebUiVersion}}`, () => {

                    serverConstants.currentlyDownloadedWebUiVersion = currentlyDownloadedWebUiVersion;

                    service.init();

                    expect($http.defaults.headers.common["Mock Version Header Key"]).toBe(expected);
                });

            });

        });
    });
})();
*/ 
(function () {
    'use strict';
    describe('javaObjectUtilService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('javaObjectUtilService');
        }));
        it('test empty object checker', function () {
            var testObject = {};
            expect(service.isEmpty(testObject)).toBeTruthy();
            testObject = null;
            expect(service.isEmpty(testObject)).toBeTruthy();
            testObject = undefined;
            expect(service.isEmpty(testObject)).toBeTruthy();
            testObject = "";
            expect(service.isEmpty(testObject)).toBeTruthy();
            testObject = { test: "test" };
            expect(service.isEmpty(testObject)).toBeFalsy();
        });
    });
}());
//migrated
(function () {
    'use strict';
    describe('HCTRA.Math', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        it('should return undefined if either operand is non-integer', function () {
            expect(HCTRA.HctraMath.mod(1, "5")).not.toBeDefined();
            expect(HCTRA.HctraMath.mod("2", 6)).not.toBeDefined();
            expect(HCTRA.HctraMath.mod("3", "5")).not.toBeDefined();
            expect(HCTRA.HctraMath.mod(1, NaN)).not.toBeDefined();
            expect(HCTRA.HctraMath.mod(NaN, 5)).not.toBeDefined();
            expect(HCTRA.HctraMath.mod(1.1, 5)).not.toBeDefined();
            expect(HCTRA.HctraMath.mod(1, 5.5)).not.toBeDefined();
        });
        it('should return mod properly for non-negative left operand and positive right operand', function () {
            expect(HCTRA.HctraMath.mod(0, 5)).toBe(0);
            expect(HCTRA.HctraMath.mod(1, 5)).toBe(1);
            expect(HCTRA.HctraMath.mod(6, 5)).toBe(1);
            expect(HCTRA.HctraMath.mod(11, 5)).toBe(1);
            expect(HCTRA.HctraMath.mod(2, 5)).toBe(2);
            expect(HCTRA.HctraMath.mod(7, 5)).toBe(2);
            expect(HCTRA.HctraMath.mod(12, 5)).toBe(2);
        });
        it('should return mod properly if left operand is negative', function () {
            expect(HCTRA.HctraMath.mod(-1, 5)).toBe(4);
            expect(HCTRA.HctraMath.mod(-6, 5)).toBe(4);
            expect(HCTRA.HctraMath.mod(-11, 5)).toBe(4);
            expect(HCTRA.HctraMath.mod(-2, 5)).toBe(3);
            expect(HCTRA.HctraMath.mod(-7, 5)).toBe(3);
            expect(HCTRA.HctraMath.mod(-12, 5)).toBe(3);
        });
        it('should return mod properly if right operand is negative', function () {
            // TODO: Unsure if this is the correct behavior
            expect(HCTRA.HctraMath.mod(1, -5)).toBe(-4);
            expect(HCTRA.HctraMath.mod(6, -5)).toBe(-4);
            expect(HCTRA.HctraMath.mod(11, -5)).toBe(-4);
            expect(HCTRA.HctraMath.mod(2, -5)).toBe(-3);
            expect(HCTRA.HctraMath.mod(7, -5)).toBe(-3);
            expect(HCTRA.HctraMath.mod(12, -5)).toBe(-3);
        });
        it('should return mod properly if both are negative', function () {
            // TODO: Unsure if this is the correct behavior
            expect(HCTRA.HctraMath.mod(-1, -5)).toBe(-1);
            expect(HCTRA.HctraMath.mod(-6, -5)).toBe(-1);
            expect(HCTRA.HctraMath.mod(-11, -5)).toBe(-1);
            expect(HCTRA.HctraMath.mod(-2, -5)).toBe(-2);
            expect(HCTRA.HctraMath.mod(-7, -5)).toBe(-2);
            expect(HCTRA.HctraMath.mod(-12, -5)).toBe(-2);
        });
    });
}());
(function () {
    'use strict';
    describe('removeDoubleCharService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //    $provide.value('DEPENDENCY', hctraMocks.DEPENDENCY);
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('removeDoubleCharService');
        }));
        it('should remove a double "@"', function () {
            expect(service.removeDoubleChar('test@@test@@')).toEqual('test@test@');
        });
        it('should remove any length of whitespace with a single whitespace', function () {
            expect(service.removeDoubleChar('test      test     ')).toEqual('test test ');
        });
        it('should remove any length of periods with a single period', function () {
            expect(service.removeDoubleChar('test.....test.....')).toEqual('test.test.');
        });
        it('should remove any length of dashes with a single dash', function () {
            expect(service.removeDoubleChar('test------test-----')).toEqual('test-test-');
        });
        it('should remove any length of underscores with a single underscore', function () {
            expect(service.removeDoubleChar('test_____test______')).toEqual('test_test_');
        });
        it('should remove any length of whitespace with a single whitespace', function () {
            expect(service.removeDoubleChar('test      test     ')).toEqual('test test ');
        });
        it('should remove any of the following characters: <, >, single and double quote', function () {
            expect(service.removeDoubleChar('t<es>t"test<')).toEqual('testtest');
        });
    });
}());
(function () {
    'use strict';
    describe('stringCheckService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('stringCheckService');
        }));
        it('should return true if the number is a float', function () {
            expect(service.isFloat('3.14')).toBeTruthy();
        });
        it('should return false if the number is not a float', function () {
            expect(service.isFloat('test')).toBeFalsy();
        });
    });
}());
(function () {
    'use strict';
    describe('toggleFullWebsiteService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service, setUrl = {}, inDoc = {}, inStorage = {};
        beforeEach(angular.mock.module(function () {
        }));
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('$window', hctraMocks.$window(setUrl));
            $provide.value('$document', hctraMocks.$document(inDoc));
            $provide.value('webStorage', hctraMocks.webStorage(inStorage));
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('toggleFullWebsiteService');
        }));
        it('should set FOOTER_FORCE_DESKTOP_VIEW to true', function () {
            service.onMobileClick();
            expect(inStorage['FOOTER_FORCE_DESKTOP_VIEW']).toBeDefined();
            expect(inStorage['FOOTER_FORCE_DESKTOP_VIEW']).toBeTruthy();
        });
        it('should set FOOTER_FORCE_DESKTOP_VIEW to false', function () {
            service.onDesktopClick();
            expect(inStorage['FOOTER_FORCE_DESKTOP_VIEW']).toBeDefined();
            expect(inStorage['FOOTER_FORCE_DESKTOP_VIEW']).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    describe("validationService", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var service, formObj;
        beforeEach(angular.mock.module(function () {
            formObj = {};
        }));
        beforeEach(angular.mock.inject(function (_validationService_) {
            service = _validationService_;
        }));
        it("should return true if an error is triggered on the form", function () {
            formObj.test = { $valid: false };
            formObj.$submitted = true;
            expect(service(formObj).isErrorTriggered("test")).toBeTruthy();
        });
        it("should return false if there isnt an error on the form", function () {
            formObj.test = { $valid: true };
            formObj.$submitted = true;
            expect(service(formObj).isErrorTriggered("test")).toBeFalsy();
        });
        it("should return \"has-error\" if form has an error", function () {
            formObj.test = { $valid: false };
            formObj.$submitted = true;
            expect(service(formObj).getErrorStatusClass("test")).toEqual("has-error");
        });
        it("should return empty string if form has an error", function () {
            formObj.test = { $valid: true };
            formObj.$submitted = true;
            expect(service(formObj).getErrorStatusClass("test")).toEqual("");
        });
        it("should return \"has-error\" if the form is invalid", function () {
            formObj.test = { $valid: false };
            expect(service(formObj).getErrorStatusClassForDateRange("test")).toEqual("has-error");
        });
        it("should return empty string if the form is valid", function () {
            formObj.test = { $valid: true };
            expect(service(formObj).getErrorStatusClassForDateRange("test")).toEqual("");
        });
        it("should be defined if form input is defined", function () {
            formObj.test = { $valid: true };
            expect(service(formObj).getErrorStatusClassFastWithNullCheck("test")).toBeDefined();
        });
        it("should return empty string if form input is null", function () {
            expect(service(formObj).getErrorStatusClassFastWithNullCheck("test")).toEqual("");
        });
        it("should be defined if form input is defined", function () {
            formObj.test = { $error: true };
            expect(service(formObj).getErrorListWithNullCheck("test")).toBeDefined();
        });
        it("should return empty array if form input is null", function () {
            expect(service(formObj).getErrorListWithNullCheck("test")).toEqual([]);
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('wildCardUrlCheckerService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var routes;
        var service = {};
        var wildCardDict = {};
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('routes', hctraMocks.routes());
        }));
        beforeEach(angular.mock.inject(function ($injector, _routes_) {
            service = $injector.get('wildCardUrlCheckerService');
            routes = _routes_;
            wildCardDict[routes.faq] = { expectedSegments: 4, path: routes.faq };
            wildCardDict[routes.closuresArchive] = { expectedSegments: 4, path: routes.closuresArchive };
            wildCardDict[routes.newsArchive] = { expectedSegments: 4, path: routes.newsArchive };
        }));
        it('test findParentUrlInWildCardDict for matching route but too many segments', function () {
            expect(service.findParentUrlInWildCardDict("/FAQ/All/0/501/"))
                .toEqual(null);
        });
        it('test wildCardUrlisMatch for matching route but too many segments', function () {
            expect(service.wildCardUrlisMatch("/FAQ/All/0/501/", wildCardDict))
                .toBeFalsy();
        });
        it('test findParentUrlInWildCardDict for faq wilcard route - 4 segments', function () {
            expect(service.findParentUrlInWildCardDict("/FAQ/All/0/"))
                .toEqual("/FAQ");
        });
        it('test wildCardUrlisMatch for faq wilcard route - 4 segments', function () {
            expect(service.wildCardUrlisMatch("/FAQ/All/0/", wildCardDict))
                .toBeTruthy();
        });
        it('test findParentUrlInWildCardDict for faq wilcard route - 3 segments', function () {
            expect(service.findParentUrlInWildCardDict("/FAQ/All/0"))
                .toEqual("/FAQ");
        });
        it('test wildCardUrlisMatch for faq wilcard route - 3 segments', function () {
            expect(service.wildCardUrlisMatch("/FAQ/All/0", wildCardDict))
                .toBeTruthy();
        });
        it('test findParentUrlInWildCardDict for faq wilcard route - 2 segments', function () {
            expect(service.findParentUrlInWildCardDict("/FAQ/All"))
                .toEqual("/FAQ");
        });
        it('test wildCardUrlisMatch for faq wilcard route - 2 segments', function () {
            expect(service.wildCardUrlisMatch("/FAQ/All", wildCardDict))
                .toBeTruthy();
        });
        it('test findParentUrlInWildCardDict for faq wilcard route - 1 segments', function () {
            expect(service.findParentUrlInWildCardDict("/FAQ"))
                .toEqual("/FAQ");
        });
        it('test wildCardUrlisMatch for faq wilcard route - 1 segments', function () {
            expect(service.wildCardUrlisMatch("/FAQ", wildCardDict))
                .toBeTruthy();
        });
        it('test findParentUrlInWildCardDict only /', function () {
            expect(service.findParentUrlInWildCardDict("/"))
                .toEqual(null);
        });
        it('test wildCardUrlisMatch only /', function () {
            expect(service.wildCardUrlisMatch("/", wildCardDict))
                .toBeFalsy();
        });
        //it('test findParentUrlInWildCardDict for closure wilcard route', function () {
        //    expect(service.findParentUrlInWildCardDict("/ClosuresArchive/All/0/"))
        //        .toEqual("/ClosuresArchive");
        //});
        //it('test wildCardUrlisMatch for closure wilcard route', function () {
        //    expect(service.wildCardUrlisMatch("/ClosuresArchive/All/0/", wildCardDict))
        //        .toBeTruthy();
        //});
        it('test findParentUrlInWildCardDict for News wilcard route', function () {
            expect(service.findParentUrlInWildCardDict("/NewsArchive/All/0/"))
                .toEqual("/NewsArchive");
        });
        it('test wildCardUrlisMatch for News wilcard route', function () {
            expect(service.wildCardUrlisMatch("/NewsArchive/All/0/", wildCardDict))
                .toBeTruthy();
        });
        it('test findParentUrlInWildCardDict for non-wilcard route', function () {
            expect(service.findParentUrlInWildCardDict("/Home/All/0/"))
                .toBeNull();
        });
        it('test wildCardUrlisMatch for non-wilcard route', function () {
            expect(service.wildCardUrlisMatch("/Home/All/0/", wildCardDict))
                .toBeFalsy();
        });
        it('test findParentUrlInWildCardDict for null route', function () {
            expect(service.findParentUrlInWildCardDict(null))
                .toBeNull();
        });
        it('test wildCardUrlisMatch for null route', function () {
            expect(service.wildCardUrlisMatch(null, wildCardDict))
                .toBeFalsy();
        });
        it('test findParentUrlInWildCardDict for null route', function () {
            expect(service.findParentUrlInWildCardDict(undefined))
                .toBeNull();
        });
        it('test wildCardUrlisMatch for null route', function () {
            expect(service.wildCardUrlisMatch(undefined, wildCardDict))
                .toBeFalsy();
        });
        it('test findParentUrlInWildCardDict for null route', function () {
            expect(service.findParentUrlInWildCardDict("hello"))
                .toBeNull();
        });
        it('test wildCardUrlisMatch for null route', function () {
            expect(service.wildCardUrlisMatch("hello", wildCardDict))
                .toBeFalsy();
        });
    });
}());
(function () {
    'use strict';
    describe('wizardStepperService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('wizardStepperService');
        }));
        it('should return stepOn if on the current step', function () {
            expect(service().checkStep(0)).toEqual('stepOn');
        });
        it('should return step if not on the current step', function () {
            expect(service().checkStep(-1)).toEqual('step');
        });
    });
}());
(function () {
    'use strict';
    describe('assignNullDataDefaults', function () {
        var service;
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('assignNullDataDefaults');
        }));
        describe("canary", function () {
            it("should pass", function () {
                expect(true).toBe(true);
            });
        });
        describe("service", function () {
            [1, "a", true].forEach(function (response) {
                it("should return response unchanged when response not object", function () {
                    var expectedResponse = angular.copy(response);
                    expect(service(response)).toEqual(expectedResponse);
                });
            });
            [{ data: 1 }, { data: "a" }, { data: true, other: {} }].forEach(function (response) {
                it("should return response unchanged when response.data truthy and not an object", function () {
                    var expectedResponse = angular.copy(response);
                    expect(service(response)).toEqual(expectedResponse);
                });
            });
            [
                [
                    { other: 1 },
                    { data: { errors: [], alerts: [] }, other: 1 }
                ],
                [
                    { data: null, stuff: {} },
                    { data: { errors: [], alerts: [] }, stuff: {} }
                ],
                [
                    { data: 0, cool: true },
                    { data: { errors: [], alerts: [] }, cool: true }
                ],
                [
                    { data: false, status: "great" },
                    { data: { errors: [], alerts: [] }, status: "great" }
                ]
            ].forEach(function (_a) {
                var response = _a[0], expectedResponse = _a[1];
                it("should return response with empty data.errors and data.alerts when response.data falsy", function () {
                    expect(service(response)).toEqual(expectedResponse);
                });
            });
            [
                [
                    { other: 1 },
                    { data: { errors: [], alerts: [] }, other: 1 }
                ],
                [
                    { data: null, stuff: {} },
                    { data: { errors: [], alerts: [] }, stuff: {} }
                ],
                [
                    { data: 0, cool: true },
                    { data: { errors: [], alerts: [] }, cool: true }
                ],
                [
                    { data: false, status: "great" },
                    { data: { errors: [], alerts: [] }, status: "great" }
                ],
                [
                    { data: "", temperature: "cold" },
                    { data: { errors: [], alerts: [] }, temperature: "cold" }
                ]
            ].forEach(function (_a) {
                var response = _a[0], expectedResponse = _a[1];
                it("should return response with empty data.errors and data.alerts when response.data falsy", function () {
                    expect(service(response)).toEqual(expectedResponse);
                });
            });
            [
                [
                    { data: { alerts: [1] }, other: 1 },
                    { data: { errors: [], alerts: [1] }, other: 1 }
                ],
                [
                    { data: { errors: 0, alerts: [] }, stuff: {} },
                    { data: { errors: [], alerts: [] }, stuff: {} }
                ],
                [
                    { data: { errors: "", alerts: ["asd", "dds"] }, cool: true },
                    { data: { errors: [], alerts: ["asd", "dds"] }, cool: true }
                ],
                [
                    { data: { errors: false, alerts: [{}, {}, {}] }, status: "great" },
                    { data: { errors: [], alerts: [{}, {}, {}] }, status: "great" }
                ],
                [
                    { data: { errors: null, alerts: [{}, {}, {}] }, temperature: "cold" },
                    { data: { errors: [], alerts: [{}, {}, {}] }, temperature: "cold" }
                ]
            ].forEach(function (_a) {
                var response = _a[0], expectedResponse = _a[1];
                it("should return response with empty data.errors response.data.errors falsy", function () {
                    expect(service(response)).toEqual(expectedResponse);
                });
            });
            [
                [
                    { data: { errors: [1] }, other: 1 },
                    { data: { alerts: [], errors: [1] }, other: 1 }
                ],
                [
                    { data: { alerts: 0, errors: [] }, stuff: {} },
                    { data: { alerts: [], errors: [] }, stuff: {} }
                ],
                [
                    { data: { alerts: "", errors: ["asd", "dds"] }, cool: true },
                    { data: { alerts: [], errors: ["asd", "dds"] }, cool: true }
                ],
                [
                    { data: { alerts: false, errors: [{}, {}, {}] }, status: "great" },
                    { data: { alerts: [], errors: [{}, {}, {}] }, status: "great" }
                ],
                [
                    { data: { alerts: null, errors: [{}, {}, {}] }, temperature: "cold" },
                    { data: { alerts: [], errors: [{}, {}, {}] }, temperature: "cold" }
                ]
            ].forEach(function (_a) {
                var response = _a[0], expectedResponse = _a[1];
                it("should return response with empty data.alerts response.data.alerts falsy", function () {
                    expect(service(response)).toEqual(expectedResponse);
                });
            });
        });
    });
})();
describe("GlobalVariableInterceptor tests", function () {
    var service;
    var CurrentUser;
    var $rootScope;
    var webStorage;
    var webStorageConst;
    var serverConstants;
    var response;
    beforeEach(angular.mock.module('HCTRAModule'));
    beforeEach(angular.mock.inject(function ($injector) {
        CurrentUser = jasmine.createSpyObj("CurrentUser", ["updateCurrentUser", "getCurrentUser"]);
        $rootScope = $injector.get("$rootScope");
        webStorage = jasmine.createSpyObj("webStorage", ["setKeyValue", "removeEntry"]);
        webStorageConst = $injector.get("webStorageConst");
        serverConstants = $injector.get("serverConstants");
        service = new HCTRA.Service.GlobalVariableInterceptor(CurrentUser, $rootScope, webStorage, webStorageConst, serverConstants);
    }));
    describe("response", function () {
        beforeEach(function () {
            webStorage.removeEntry.and.callThrough();
            webStorage.setKeyValue.and.callThrough();
        });
        it("response data should trigger and provoke all update", function () {
            response = {
                data: {
                    currentBalanceObj: {
                        currentBalance: 20
                    },
                    currentPaymentPlanBalanceObj: {
                        currentBalance: 20
                    }
                },
                headers: function () {
                    return "WEBUIVersion";
                }
            };
            CurrentUser.updateCurrentUser.and.callThrough();
            CurrentUser.getCurrentUser.and.returnValue({
                currentBalanceObj: {
                    currentBalance: 20
                }
            });
            service.response(response);
            expect(service.$rootScope.currentBalance).toEqual(20);
            expect(CurrentUser.getCurrentUser).toHaveBeenCalledTimes(2);
            expect(CurrentUser.getCurrentUser).toHaveBeenCalledTimes(2);
        });
        it("response data should trigger and update currentBalanceObj ", function () {
            response = {
                data: {
                    currentBalanceObj: {
                        currentBalance: 20
                    }
                },
                headers: function () {
                    return "WEBUIVersion";
                }
            };
            CurrentUser.getCurrentUser.and.returnValue({
                currentBalanceObj: {
                    currentBalance: 21
                }
            });
            CurrentUser.updateCurrentUser.and.callThrough();
            service.response(response);
            expect(service.$rootScope.currentBalance).toEqual(20);
            expect(CurrentUser.updateCurrentUser).toHaveBeenCalledTimes(1);
            expect(CurrentUser.getCurrentUser).toHaveBeenCalledTimes(1);
        });
        it("response data should return even if currentUser not available ", function () {
            response = {
                data: {
                    currentBalanceObj: {
                        currentBalance: 20
                    }
                },
                headers: function () {
                    return "WEBUIVersion";
                }
            };
            CurrentUser.getCurrentUser.and.returnValue(null);
            CurrentUser.updateCurrentUser.and.callThrough();
            var result = service.response(response);
            expect(result).toEqual(response);
        });
        it("response data NOT should trigger since currentBalanceObj.currentBalance is null ", function () {
            response = {
                data: {
                    currentBalanceObj: {
                        currentBalance: null
                    }
                },
                headers: function () {
                    return "WEBUIVersion";
                }
            };
            CurrentUser.getCurrentUser.and.returnValue({
                currentBalanceObj: {
                    currentBalance: 20
                }
            });
            CurrentUser.updateCurrentUser.and.callThrough();
            service.response(response);
            expect(CurrentUser.updateCurrentUser).toHaveBeenCalledTimes(0);
            expect(CurrentUser.getCurrentUser).toHaveBeenCalledTimes(0);
        });
        it("response data should trigger and update currentPaymentPlanBalanceObj ", function () {
            response = {
                data: {
                    currentPaymentPlanBalanceObj: {
                        currentBalance: 20
                    }
                },
                headers: function () {
                    return "WEBUIVersion";
                }
            };
            CurrentUser.getCurrentUser.and.returnValue({
                currentBalanceObj: {
                    currentBalance: 20
                }
            });
            CurrentUser.updateCurrentUser.and.callThrough();
            service.response(response);
            expect(service.$rootScope.currentBalance).toBeUndefined();
            expect(webStorage.removeEntry).toHaveBeenCalledTimes(0);
            expect(webStorage.setKeyValue).toHaveBeenCalledTimes(1);
            expect(CurrentUser.updateCurrentUser).toHaveBeenCalledTimes(1);
            expect(CurrentUser.getCurrentUser).toHaveBeenCalledTimes(1);
        });
        it("response data should NOT trigger since currentPaymentPlanBalanceObj.currentBalance is NULL  ", function () {
            response = {
                data: {
                    currentPaymentPlanBalanceObj: {
                        currentBalance: null
                    }
                },
                headers: function () {
                    return "WEBUIVersion";
                }
            };
            CurrentUser.getCurrentUser.and.returnValue({
                currentBalanceObj: {
                    currentBalance: 20
                }
            });
            CurrentUser.updateCurrentUser.and.callThrough();
            service.response(response);
            expect(service.$rootScope.currentBalance).toBeUndefined();
            expect(webStorage.removeEntry).toHaveBeenCalledTimes(1);
            expect(webStorage.setKeyValue).toHaveBeenCalledTimes(0);
            expect(CurrentUser.updateCurrentUser).toHaveBeenCalledTimes(1);
            expect(CurrentUser.getCurrentUser).toHaveBeenCalledTimes(1);
        });
        it("nothing should be call if data have no return values ", function () {
            response = {
                headers: function () {
                    return "WEBUIVersion";
                }
            };
            CurrentUser.getCurrentUser.and.returnValue({
                currentBalanceObj: {
                    currentBalance: 20
                }
            });
            CurrentUser.updateCurrentUser.and.callThrough();
            service.response(response);
            expect(service.$rootScope.currentBalance).toBeUndefined();
            expect(webStorage.removeEntry).toHaveBeenCalledTimes(0);
            expect(webStorage.setKeyValue).toHaveBeenCalledTimes(0);
            expect(CurrentUser.updateCurrentUser).toHaveBeenCalledTimes(0);
            expect(CurrentUser.getCurrentUser).toHaveBeenCalledTimes(0);
        });
    });
});
(function () {
    'use strict';
    describe('HttpResponseErrorLogInterceptor', function () {
        var service;
        var scope;
        var applicationLoggingService;
        var siteVerbiage;
        var errorInterceptorService;
        var $window;
        var authService;
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.module(function ($provide) {
            applicationLoggingService = jasmine.createSpyObj("applicationLoggingService", ["interceptorError", "error"]);
            siteVerbiage = {
                genericErrorMsg: "fake generic error"
            };
            errorInterceptorService = jasmine.createSpyObj("errorInterceptorService", ["shouldMessageTriggerLogging"]);
            authService = jasmine.createSpyObj("AuthService", ["logoutOnFourOneSeven"]);
            $provide.value('AuthService', authService);
            $window = { location: jasmine.createSpyObj("location", ["reload"]) };
            $provide.value('applicationLoggingService', applicationLoggingService);
            $provide.value('siteVerbiage', siteVerbiage);
            $provide.value('errorInterceptorService', errorInterceptorService);
            $provide.value('$window', $window);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('HttpResponseErrorLogInterceptor');
            var rootscope = $injector.get('$rootScope');
            scope = rootscope.$new();
        }));
        describe("canary", function () {
            it("should pass", function () {
                expect(true).toBe(true);
            });
        });
        describe("responseError function", function () {
            it("should call the response fucntion", function () {
                spyOn(service, "response").and.returnValue("response was called");
                var result = service.responseError("fake input");
                expect(result).toBe("response was called");
                expect(service.response).toHaveBeenCalledWith("fake input");
                expect(service.response).toHaveBeenCalledTimes(1);
            });
        });
        describe("response", function () {
            [
                null,
                true,
                1,
                "html page",
                {},
                { errors: [] }
            ].forEach(function (data) {
                it("should return response unchanged when status code 200 and no errors ", function () {
                    var response = {
                        status: 200,
                        data: data
                    };
                    var expectedResponse = angular.copy(response);
                    expect(service.response(response)).toEqual(expectedResponse);
                    expect(applicationLoggingService.error).toHaveBeenCalledTimes(0);
                    expect(applicationLoggingService.interceptorError).toHaveBeenCalledTimes(0);
                    expect(errorInterceptorService.shouldMessageTriggerLogging).toHaveBeenCalledTimes(0);
                    expect($window.location.reload).toHaveBeenCalledTimes(0);
                });
            });
            [
                null,
                0,
                100,
                204,
                206,
                200,
                300,
                503,
                600,
                700
            ].forEach(function (statusCode) {
                it("should return response unchanged when status code " + statusCode + " and no loggable errors ", function () {
                    errorInterceptorService.shouldMessageTriggerLogging.and.returnValue(false);
                    var response = {
                        status: statusCode,
                        data: { errors: [{ message: "" }, { message: "" }] }
                    };
                    var expectedResponse = angular.copy(response);
                    expect(service.response(response)).toEqual(expectedResponse);
                    expect(applicationLoggingService.error).toHaveBeenCalledTimes(0);
                    expect(applicationLoggingService.interceptorError).toHaveBeenCalledTimes(0);
                    expect(errorInterceptorService.shouldMessageTriggerLogging).toHaveBeenCalledTimes(2);
                    expect($window.location.reload).toHaveBeenCalledTimes(0);
                });
            });
            [
                null,
                0,
                100,
                204,
                206,
                200,
                300,
                400,
                500,
                503,
                600,
                700
            ].forEach(function (statusCode) {
                it("should return response unchanged when status code " + statusCode + " and call applicationLoggingService.interceptorError when loggable errors", function () {
                    errorInterceptorService.shouldMessageTriggerLogging.and.returnValue(true);
                    var response = {
                        status: statusCode,
                        data: { errors: [{ message: "" }, { message: "" }] },
                        config: {
                            method: "duck",
                            url: "quack"
                        }
                    };
                    var expectedResponse = angular.copy(response);
                    expect(service.response(response)).toEqual(expectedResponse);
                    expect(applicationLoggingService.error).toHaveBeenCalledTimes(0);
                    expect(applicationLoggingService.interceptorError).toHaveBeenCalledTimes(1);
                    expect(applicationLoggingService.interceptorError).toHaveBeenCalledWith(angular.toJson({
                        method: "duck",
                        url: "quack",
                        message: { errors: [{ message: "" }, { message: "" }] },
                        status: statusCode
                    }));
                    expect(errorInterceptorService.shouldMessageTriggerLogging).toHaveBeenCalledTimes(2);
                    expect($window.location.reload).toHaveBeenCalledTimes(0);
                });
            });
            it("should call reload when statuscode 503", function () {
                errorInterceptorService.shouldMessageTriggerLogging.and.returnValue(true);
                var response = {
                    status: 503,
                    data: { errors: [] },
                    config: {
                        method: "duck",
                        url: "quack"
                    }
                };
                service.response(response);
                expect($window.location.reload).toHaveBeenCalledTimes(1);
                expect($window.location.reload).toHaveBeenCalledWith(true);
            });
            [
                null,
                0,
                204,
                206,
                400,
                500
            ].forEach(function (statusCode) {
                it("should return response with generic error when status code " + statusCode + " and no errors in response", function () {
                    errorInterceptorService.shouldMessageTriggerLogging.and.returnValue(true);
                    var response = {
                        status: statusCode,
                        data: {},
                        config: {
                            method: "cat",
                            url: "meow"
                        }
                    };
                    var expectedResponse = {
                        status: statusCode,
                        data: { errors: [{ method: 'cat', url: 'meow', message: 'We are unable to process your request at this time.', status: statusCode }], alerts: [] },
                        config: {
                            method: "cat",
                            url: "meow"
                        }
                    };
                    var result = service.response(response);
                    expect(result).toEqual(expectedResponse);
                    expect(applicationLoggingService.interceptorError).toHaveBeenCalledTimes(0);
                    expect(applicationLoggingService.error).toHaveBeenCalledTimes(1);
                    expect(applicationLoggingService.error).toHaveBeenCalledWith(angular.toJson({
                        method: "cat",
                        url: "meow",
                        message: {},
                        status: statusCode
                    }));
                    expect(errorInterceptorService.shouldMessageTriggerLogging).toHaveBeenCalledTimes(0);
                    expect($window.location.reload).toHaveBeenCalledTimes(0);
                });
            });
            [
                null,
                0,
                204,
                206,
                400,
                500
            ].forEach(function (statusCode) {
                it("should return response with generic error when status code " + statusCode + " and response.data is not an object", function () {
                    errorInterceptorService.shouldMessageTriggerLogging.and.returnValue(true);
                    var response = {
                        status: statusCode,
                        data: "<html><head><title>Request Rejected</title></head><body>The requested URL was rejected. Please consult with your administrator.<br><br>Your support ID is: 12736568780651982685</body></html>",
                        config: {
                            method: "cat",
                            url: "meow"
                        }
                    };
                    var expectedResponse = {
                        status: statusCode,
                        data: {
                            originalResponse: "<html><head><title>Request Rejected</title></head><body>The requested URL was rejected. Please consult with your administrator.<br><br>Your support ID is: 12736568780651982685</body></html>",
                            errors: [{ method: 'cat', url: 'meow', message: 'We are unable to process your request at this time.', status: statusCode }], alerts: []
                        },
                        config: {
                            method: "cat",
                            url: "meow"
                        }
                    };
                    var result = service.response(response);
                    expect(result).toEqual(expectedResponse);
                    expect(applicationLoggingService.interceptorError).toHaveBeenCalledTimes(0);
                    expect(applicationLoggingService.error).toHaveBeenCalledTimes(1);
                    expect(applicationLoggingService.error).toHaveBeenCalledWith(angular.toJson({
                        method: "cat",
                        url: "meow",
                        message: "<html><head><title>Request Rejected</title></head><body>The requested URL was rejected. Please consult with your administrator.<br><br>Your support ID is: 12736568780651982685</body></html>",
                        status: statusCode
                    }));
                    expect(errorInterceptorService.shouldMessageTriggerLogging).toHaveBeenCalledTimes(0);
                    expect($window.location.reload).toHaveBeenCalledTimes(0);
                });
            });
        });
    });
})();
(function () {
    "use strict";
    describe("CircularList", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        it("should navigate head properly", function () {
            var circularList = new HCTRA.Datastructure.CircularList(["first", "second", "third"]);
            expect(circularList.moveHeadRight()).toBe("second");
            expect(circularList.moveHeadRight()).toBe("third");
            expect(circularList.moveHeadRight()).toBe("first");
            expect(circularList.moveHeadLeft()).toBe("third");
        });
        it("should peek properly", function () {
            var circularList = new HCTRA.Datastructure.CircularList(["first", "second", "third"]);
            expect(circularList.peekCurrent()).toBe("first");
            expect(circularList.peekLeft()).toBe("third");
            expect(circularList.peekRight()).toBe("second");
        });
        it("should not reference the same array", function () {
            var inArr = ["first", "second", "third"];
            var circularList = new HCTRA.Datastructure.CircularList(inArr);
            inArr.push("fourth");
            expect(circularList.peekLeft()).toBe("third");
        });
        it("should reference the same objects in the array", function () {
            var inArr = [{ prop: 3 }, { prop: 4 }, { prop: 5 }];
            var circularList = new HCTRA.Datastructure.CircularList(inArr);
            inArr[0].prop = 10;
            expect(circularList.peekCurrent().prop).toBe(10);
        });
    });
}());
(function () {
    "use strict";
    describe("Paginator datastructure", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var initArray;
        beforeEach(function () {
            initArray = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'eleventh', 'twelfth'];
        });
        it('should have accurate metadata', function () {
            var paginator = new HCTRA.Datastructure.Paginator(initArray, 6);
            expect(paginator.itemCount).toBe(12);
            expect(paginator.pageCount).toBe(2);
            expect(paginator.pageSize).toBe(6);
            var paginator2 = new HCTRA.Datastructure.Paginator(initArray, 11);
            expect(paginator2.itemCount).toBe(12);
            expect(paginator2.pageCount).toBe(2);
            expect(paginator2.pageSize).toBe(11);
            var paginator3 = new HCTRA.Datastructure.Paginator(initArray, 12);
            expect(paginator3.itemCount).toBe(12);
            expect(paginator3.pageCount).toBe(1);
            expect(paginator3.pageSize).toBe(12);
        });
        it('should return page items in correct order', function () {
            var paginator = new HCTRA.Datastructure.Paginator(initArray, 4);
            expect(paginator.getPage(1)[0]).toBe('first');
            expect(paginator.getPage(1)[1]).toBe('second');
            expect(paginator.getPage(1)[2]).toBe('third');
            expect(paginator.getPage(1)[3]).toBe('fourth');
            expect(paginator.getPage(3)[0]).toBe('ninth');
            expect(paginator.getPage(3)[1]).toBe('tenth');
            expect(paginator.getPage(3)[2]).toBe('eleventh');
            expect(paginator.getPage(3)[3]).toBe('twelfth');
        });
        it('should account for uneven division properly', function () {
            var paginator = new HCTRA.Datastructure.Paginator(initArray, 11);
            expect(paginator.getPage(1)[10]).toBe('eleventh');
            expect(paginator.getPage(1)[11]).toBeUndefined();
            expect(paginator.getPage(2)[0]).toBe('twelfth');
            expect(paginator.getPage(2)[1]).toBeUndefined();
            var paginator2 = new HCTRA.Datastructure.Paginator(initArray, 13);
            expect(paginator2.getPage(1)[10]).toBe('eleventh');
            expect(paginator2.getPage(1)[11]).toBe('twelfth');
            expect(paginator2.getPage(1)[12]).toBeUndefined();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: account-identification", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, routes, linkLookupService, validationObj, setUrl, displayedMessage;
        beforeEach(angular.mock.module(function () {
            validationObj = {};
            setUrl = {
                value: ""
            };
            displayedMessage = {
                value: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$window", hctraMocks.$window(setUrl));
            $provide.value("routes", hctraMocks.routes());
            $provide.value("validationService", hctraMocks.validationService(validationObj));
            $provide.value("removeDoubleCharService", hctraMocks.removeDoubleCharService());
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
            $provide.value("linkLookupService", hctraMocks.linkLookupService());
        }));
        beforeEach(angular.mock.inject(function (_linkLookupService_) {
            linkLookupService = _linkLookupService_;
            // make sure correct mocked method is called when spying
            spyOn(linkLookupService, "articleLookupById");
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $compile, $templateCache, _routes_) {
            routes = _routes_;
            scope = $rootScope.$new();
            scope.form = {};
            scope.details = {
                option: "test option",
                accountInfo: "account",
                personalInfo: "tag"
            };
            $templateCache.put("/app/directives/accountIdentificationTemplate.html", $templateCache.get("app/directives/accountIdentificationTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<account-identification id-info-object=\"details\" parent-form=\"form\" password-reset-option=\"details.option\">" +
                "</account-identification>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("should have some default values in the details object", function () {
            expect(scope.details.accountInfo).toBe("waterm");
            expect(scope.details.accountNumber).toBe("");
            expect(scope.details.tagNumber).toBe("");
            expect(scope.details.personalInfo).toBe("waterm");
            expect(scope.details.driversLicense).toBe("");
            expect(scope.details.taxIdNumber).toBe("");
            expect(scope.details.driverState).toBe("TX");
            expect(scope.details.eztagOrg).toBe("HCTR");
            expect(scope.details.option).toBe("test option");
        });
        it("should populate the states and authorities list", function () {
            expect(directiveScope.authorityList).toBeDefined();
            expect(directiveScope.authorityList[0]).toBe("HCTRA");
            expect(directiveScope.authorityList[1]).toBe("TEX");
            expect(directiveScope.stateList).toBeDefined();
            expect(directiveScope.stateList[0]).toBe("TX");
            expect(directiveScope.stateList[1]).toBe("OK");
            expect(directiveScope.stateList[2]).toBe("LA");
        });
        it("should redirect when need help", function () {
            directiveScope.needHelp();
            expect(linkLookupService.articleLookupById).toHaveBeenCalledWith(routes.needHelpCms);
        });
    });
}());
(function () {
    "use strict";
    describe("directive: address-display", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("capitalizeFilter", hctraMocks.capitalizeFilter());
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $compile, $templateCache) {
            scope = $rootScope.$new();
            scope.mailingAddress = {
                country: "USA",
                address1: "address line 1",
                address2: "address line 2",
                address3: "address line 3",
                address4: "address line 4",
                city: "Houston",
                name: "Test User",
                plus4: "1234",
                state: "TX",
                zip: "12345",
                international: false,
                internationalAddress: false
            };
            scope.displayCountry = false;
            scope.onMailingAddressEdit = function () {
                return "Edit mailing address info";
            };
            $templateCache.put("/app/directives/contactInfo/addressDisplayTemplate.html", $templateCache.get("app/directives/contactInfo/addressDisplayTemplate.html"));
            var el = angular.element("<address-display address=\"mailingAddress\" " +
                "international=\"mailingAddress.international\" display-country=\"displayCountry\" " +
                "on-address-edit=\"onMailingAddressEdit()\" show-edit></address-display>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(directiveScope).toBeDefined();
        });
        it("should have data that is passed in", function () {
            expect(directiveScope.address).toEqual({
                country: "USA",
                address1: "address line 1",
                address2: "address line 2",
                address3: "address line 3",
                address4: "address line 4",
                city: "Houston",
                name: "Test User",
                plus4: "1234",
                state: "TX",
                zip: "12345",
                international: false,
                internationalAddress: false
            });
            expect(directiveScope.international).toBeFalsy();
            expect(directiveScope.displayCountry).toBeFalsy();
            expect(directiveScope.showEdit).toBeTruthy();
        });
        it("should have a valid mailing address link", function () {
            var response = directiveScope.onAddressEdit();
            expect(response).toBe("Edit mailing address info");
        });
    });
}());
(function () {
    "use strict";
    describe("directive: address-entry", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope;
        var directiveScope;
        var billingInfoUtilitiesService;
        beforeEach(angular.mock.module(function ($provide) {
            billingInfoUtilitiesService = jasmine.createSpyObj('billingInfoUtilitiesService', ['isInternationalAddress', 'hasNoBillingInfo']);
            billingInfoUtilitiesService.isInternationalAddress.and.returnValue(false);
            $provide.value('billingInfoUtilitiesService', billingInfoUtilitiesService);
            $provide.value("validationService", function () { return {}; });
            $provide.value("countryConversionService", hctraMocks.countryConversionService());
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.validateAddress = true;
            scope.billingInfo = {
                cards: [{}]
            };
            scope.model = scope.billingInfo.cards[0];
            scope.billingType = "CREDIT";
            scope.stateList = ["AR", "TX"];
            scope.form = {};
            $templateCache.put("/app/directives/violations/step2/addressEntryTemplate.html", $templateCache.get("app/directives/Violations/step2/addressEntryTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<address-entry state-list=\"stateList\" address=\"billingInfo.cards[0]\" paymentsform=\"form\" " +
                "billingtype=\"billingType\" mailing-address=\"mailingAddress\" validate=\"validateAddress\">" +
                "</address-entry>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid address1", function () {
            scope.billingInfo.cards[0].address1 = "123 Test Ln#.:'-,";
            scope.$digest();
            expect(scope.form.addressLine1.$valid).toBeTruthy();
            expect(scope.form.addressLine1.$invalid).toBeFalsy();
        });
        it("should reject invalid address1", function () {
            scope.billingInfo.cards[0].address1 = "";
            scope.$digest();
            expect(scope.form.addressLine1.$valid).toBeFalsy();
            expect(scope.form.addressLine1.$invalid).toBeTruthy();
            scope.billingInfo.cards[0].address1 = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.addressLine1.$valid).toBeFalsy();
            expect(scope.form.addressLine1.$invalid).toBeTruthy();
        });
        it("should accept valid address2", function () {
            scope.billingInfo.cards[0].address2 = "123 Test Ln#.:'-,";
            scope.$digest();
            expect(scope.form.addressLine2.$valid).toBeTruthy();
            expect(scope.form.addressLine2.$invalid).toBeFalsy();
        });
        it("should reject invalid address2", function () {
            scope.billingInfo.cards[0].address2 = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.addressLine2.$valid).toBeFalsy();
            expect(scope.form.addressLine2.$invalid).toBeTruthy();
        });
        it("should accept valid zip", function () {
            scope.billingInfo.cards[0].zip = "12345";
            scope.$digest();
            expect(scope.form.zipCode.$valid).toBeTruthy();
            expect(scope.form.zipCode.$invalid).toBeFalsy();
        });
        it("should reject invalid zip", function () {
            scope.billingInfo.cards[0].zip = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.zipCode.$valid).toBeFalsy();
            expect(scope.form.zipCode.$invalid).toBeTruthy();
            scope.billingInfo.cards[0].zip = "1234";
            scope.$digest();
            expect(scope.form.zipCode.$valid).toBeFalsy();
            expect(scope.form.zipCode.$invalid).toBeTruthy();
            scope.billingInfo.cards[0].zip = "123456";
            scope.$digest();
            expect(scope.form.zipCode.$valid).toBeFalsy();
            expect(scope.form.zipCode.$invalid).toBeTruthy();
            scope.billingInfo.cards[0].zip = "";
            scope.$digest();
            expect(scope.form.zipCode.$valid).toBeFalsy();
            expect(scope.form.zipCode.$invalid).toBeTruthy();
        });
        it("should accept valid plus4", function () {
            scope.billingInfo.cards[0].plus4 = "1234";
            scope.$digest();
            expect(scope.form.plus4.$valid).toBeTruthy();
            expect(scope.form.plus4.$invalid).toBeFalsy();
        });
        it("should reject invalid plus4", function () {
            scope.billingInfo.cards[0].plus4 = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.plus4.$valid).toBeFalsy();
            expect(scope.form.plus4.$invalid).toBeTruthy();
            scope.billingInfo.cards[0].zip = "123";
            scope.$digest();
            expect(scope.form.plus4.$valid).toBeFalsy();
            expect(scope.form.plus4.$invalid).toBeTruthy();
            scope.billingInfo.cards[0].zip = "12345";
            scope.$digest();
            expect(scope.form.plus4.$valid).toBeFalsy();
            expect(scope.form.plus4.$invalid).toBeTruthy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: bank-account-entry", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, cmsLink;
        beforeEach(angular.mock.module(function () {
            cmsLink = {
                value: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", function () { return {}; });
            $provide.value("linkLookupService", hctraMocks.linkLookupService(cmsLink));
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.eft = {};
            scope.form = {};
            $templateCache.put("/app/directives/billingEntry/bankAccountEntryTemplate.html", $templateCache.get("app/directives/billingEntry/bankAccountEntryTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<bank-account-entry bank-details=\"eft\" paymentsform=\"form\" validate=\"true\" show-name>" +
                "</bank-account-entry>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid name on bank account", function () {
            scope.eft.name = "Abi Normal";
            scope.$digest();
            expect(scope.form.eftName.$valid).toBeTruthy();
            expect(scope.form.eftName.$invalid).toBeFalsy();
        });
        it("should reject name on bank account with special characters", function () {
            scope.eft.name = "@bi Normal";
            scope.$digest();
            expect(scope.form.eftName.$valid).toBeFalsy();
            expect(scope.form.eftName.$invalid).toBeTruthy();
        });
        it("should reject name on bank account with only numbers", function () {
            scope.eft.name = "123456";
            scope.$digest();
            expect(scope.form.eftName.$valid).toBeFalsy();
            expect(scope.form.eftName.$invalid).toBeTruthy();
        });
        it("should accept valid routing number", function () {
            scope.eft.routingNumber = 123456789;
            scope.$digest();
            expect(scope.form.routing.$valid).toBeTruthy();
            expect(scope.form.routing.$invalid).toBeFalsy();
        });
        it("should reject blank routing number", function () {
            scope.eft.routingNumber = "";
            scope.$digest();
            expect(scope.form.routing.$valid).toBeFalsy();
            expect(scope.form.routing.$invalid).toBeTruthy();
        });
        it("should reject routing number if not 9 digits long", function () {
            scope.eft.routingNumber = 12345678;
            scope.$digest();
            expect(scope.form.routing.$valid).toBeFalsy();
            expect(scope.form.routing.$invalid).toBeTruthy();
            scope.eft.routingNumber = 1234567890;
            scope.$digest();
            expect(scope.form.routing.$valid).toBeFalsy();
            expect(scope.form.routing.$invalid).toBeTruthy();
        });
        it("should accept valid account number", function () {
            scope.eft.accountNumber = 12345678901234567;
            scope.$digest();
            expect(scope.form.account.$valid).toBeTruthy();
            expect(scope.form.account.$invalid).toBeFalsy();
            scope.eft.accountNumber = 1;
            scope.$digest();
            expect(scope.form.account.$valid).toBeTruthy();
            expect(scope.form.account.$invalid).toBeFalsy();
        });
        it("should reject blank account number", function () {
            scope.eft.accountNumber = "";
            scope.$digest();
            expect(scope.form.account.$valid).toBeFalsy();
            expect(scope.form.account.$invalid).toBeTruthy();
        });
        it("should reject account number with non-numeric characters", function () {
            scope.eft.accountNumber = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.account.$valid).toBeFalsy();
            expect(scope.form.account.$invalid).toBeTruthy();
            scope.eft.accountNumber = "asdiojs5151";
            scope.$digest();
            expect(scope.form.account.$valid).toBeFalsy();
            expect(scope.form.account.$invalid).toBeTruthy();
        });
        it("should reject account number longer than 17 digits", function () {
            scope.eft.accountNumber = 123456789012345678;
            scope.$digest();
            expect(scope.form.account.$valid).toBeFalsy();
            expect(scope.form.account.$invalid).toBeTruthy();
        });
        it("should be invalid if confirm account number does not match account number", function () {
            scope.eft.accountNumber = 1234567;
            scope.eft.account2 = 123456789;
            scope.$digest();
            expect(scope.form.account2.$valid).toBeFalsy();
            expect(scope.form.account2.$invalid).toBeTruthy();
        });
        it("should be valid if confirm account number matches account number", function () {
            scope.eft.accountNumber = 1234567;
            scope.eft.account2 = 1234567;
            scope.$digest();
            expect(scope.form.account2.$valid).toBeTruthy();
            expect(scope.form.account2.$invalid).toBeFalsy();
        });
    });
}());
(function () {
    'use strict';
    describe('directive: capitalize-all', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, compile, el;
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            compile = $compile;
            el = angular.element('<input type="text" ng-model="model" capitalize-all></input>');
            scope = $rootScope.$new();
            scope.model = "";
            $compile(el)(scope);
            scope.$digest();
        }));
        it('should capitalize lowercase input', function () {
            scope.model = 'abcdef';
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toBe('ABCDEF');
        });
        it('should maintain uppercase input', function () {
            scope.model = 'ABCDEF';
            compile(el)(scope);
            scope.$digest();
            expect(scope.model).toBe('ABCDEF');
        });
    });
}());
(function () {
    "use strict";
    describe("directive: checkbox", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", function () { return {}; });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.activateEzTag = {};
            scope.activateEzTag.userHasConfirmed = false;
            scope.form = {};
            $templateCache.put("/app/directives/checkboxTemplate.html", $templateCache.get("app/directives/checkboxTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<checkbox checkbox-is-truthy=\"activateEzTag.userHasConfirmed\" parent-form=\"form\" " +
                "error-message=\"\"Please confirm EZ TAG Activation\"\">Confirm EZ TAGs Activation</checkbox>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("form should be invalid first", function () {
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("checking confirm box should validate form", function () {
            scope.activateEzTag.userHasConfirmed = true;
            scope.$digest();
            expect(scope.form.$invalid).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    describe("chooseDeliveryMethodController", function () {
        var component;
        var routes;
        var storeFrontService;
        var responseErrorService;
        var genericRepo;
        var environmentConfig;
        var $qMock;
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.inject(function ($injector) {
            environmentConfig = {
                tagDeliveryConfig: jasmine.createSpyObj("tagDeliveryConfig", ["AllowDeliveryByMail", "AllowPickup"])
            };
            genericRepo = {
                dataFactory: jasmine.createSpyObj("dataFactory", ["getCmsPageById"])
            };
            genericRepo.dataFactory.getCmsPageById.and.callFake(function () { return $qMock.resolve({}); });
            $qMock = $injector.get("$window")["Promise"];
            storeFrontService = jasmine.createSpyObj("storeFrontService", ["isEnabled"]);
            routes = jasmine.createSpyObj("routes", ["tagCheckoutCms"]);
            responseErrorService = jasmine.createSpyObj("responseErrorService", ["isErrorFree"]);
            component = new HCTRA.Controller.chooseDeliveryMethodController(undefined, //$window
            routes, storeFrontService, responseErrorService, undefined, //stringUtils,
            genericRepo, environmentConfig);
        }));
        it("can create a component", function () {
            expect(component).toBeDefined();
        });
        describe("onInit()", function () {
            it("should have environmentConfig.tagDeliveryConfig and its children defined", function () {
                return component
                    .$onInit()
                    .then(function () {
                    expect(environmentConfig.tagDeliveryConfig).toBeDefined();
                    expect(environmentConfig.tagDeliveryConfig.AllowDeliveryByMail).toBeDefined();
                    expect(environmentConfig.tagDeliveryConfig.AllowPickup).toBeDefined();
                })
                    .catch(function (e) { return fail(e); });
            });
            it("should call setDeliveryMethod", function () {
                spyOn(component, 'setDeliveryMethod');
                return component
                    .$onInit()
                    .then(function () {
                    expect(component.setDeliveryMethod).toHaveBeenCalledTimes(1);
                })
                    .catch(function (e) { return fail(e); });
            });
            it("should call getDeliveryMethodCMS", function () {
                spyOn(component, 'getDeliveryMethodCMS').and.callThrough();
                return component
                    .$onInit()
                    .then(function () {
                    expect(component.getDeliveryMethodCMS).toHaveBeenCalledTimes(1);
                })
                    .catch(function (e) { return fail(e); });
            });
        });
        describe("setDeliveryMethod()", function () {
            it("should set delivery to 'store' when storeFrontService is defined AND storeFrontService.IsEnabled() equals TRUE", function () {
                storeFrontService.isEnabled.and.returnValue(true);
                return component
                    .$onInit()
                    .then(function () {
                    expect(component.delivery).toBe("store");
                })
                    .catch(function (e) { return fail(e); });
            });
            it("should set delivery to 'store' when AllowDeliveryByMail equals FALSE AND AllowPickup equals TRUE", function () {
                environmentConfig.tagDeliveryConfig.AllowDeliveryByMail = false;
                environmentConfig.tagDeliveryConfig.AllowPickup = true;
                return component
                    .$onInit()
                    .then(function () {
                    expect(component.delivery).toBe("store");
                })
                    .catch(function (e) { return fail(e); });
            });
            it("should set delivery to 'mail' when AllowDeliveryByMail equals TRUE AND AllowPickup equals FALSE", function () {
                environmentConfig.tagDeliveryConfig.AllowDeliveryByMail = true;
                environmentConfig.tagDeliveryConfig.AllowPickup = false;
                return component
                    .$onInit()
                    .then(function () {
                    expect(component.delivery).toBe("mail");
                })
                    .catch(function (e) { return fail(e); });
            });
        });
        describe("getDeliveryMethodCMS()", function () {
            it("should call genericRepo.dataFactory.getCmsPageById() with correct parameters", function () {
                return component
                    .getDeliveryMethodCMS()
                    .then(function () {
                    expect(genericRepo.dataFactory.getCmsPageById).toHaveBeenCalledTimes(1);
                    expect(genericRepo.dataFactory.getCmsPageById).toHaveBeenCalledWith({
                        path: null,
                        itemId: routes.deliveryMethodCMS
                    });
                })
                    .catch(function (e) { return fail(e); });
            });
            it("should call populateCMSContent() 1 time", function () {
                responseErrorService.isErrorFree.and.returnValue(true);
                spyOn(component, 'populateCMSContent').and.callFake(function () { });
                return component
                    .getDeliveryMethodCMS()
                    .then(function () {
                    expect(component.populateCMSContent).toHaveBeenCalledTimes(1);
                })
                    .catch(function (e) { return fail(e); });
            });
        });
    });
})();
(function () {
    'use strict';
    describe('directive: compare-to', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, el;
        //beforeEach(angular.mock.module(function ($provide) {
        //    $provide.value('genericRepo', hctraMocks.genericRepo());
        //}));
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            el = angular.element('<input type="text" ng-model="model" compare-to="otherModelValue"></input>');
            scope = $rootScope.$new();
            scope.model = "";
            scope.otherModelValue = "";
            $compile(el)(scope);
            scope.$digest();
        }));
        it('should begin as valid', function () {
            // If used on a field that is not required, you don't want it to fail luhn
            scope.model = "";
            scope.otherModelValue = "";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should be valid if models match', function () {
            // If used on a field that is not required, you don't want it to fail luhn
            scope.model = "testvalue";
            scope.otherModelValue = "testvalue";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should be invalid if models do not match', function () {
            // If used on a field that is not required, you don't want it to fail luhn
            scope.model = "test";
            scope.otherModelValue = "value";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
        });
    });
}());
(function () {
    'use strict';
    describe('directive: convert-to-number', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, compile, el;
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            compile = $compile;
            el = angular.element('<input ng-model="data.pageSize" convert-to-number></input>');
            scope = $rootScope.$new();
            scope.data = {};
        }));
        it('model = null should make input empty string', function () {
            scope.data.pageSize = null;
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toEqual("");
        });
        it('model = undefined should make input empty string', function () {
            scope.data.pageSize = undefined;
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toEqual("");
        });
        it('model = 0 should make input empty string', function () {
            scope.data.pageSize = 0;
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toEqual("0");
        });
        it('model = not a number should make input empty string', function () {
            scope.data.pageSize = "whatup!";
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toEqual("");
        });
        it('model = integer > 0 should make input an integer', function () {
            scope.data.pageSize = 100;
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toEqual("100");
        });
        it('model = integer < 0 should make input an integer', function () {
            scope.data.pageSize = -100;
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toEqual("-100");
        });
        it('model = "" should make input an integer', function () {
            scope.data.pageSize = "";
            compile(el)(scope);
            scope.$digest();
            expect(el.val()).toEqual("");
        });
        it('input = null should make input empty string', function () {
            scope.data.pageSize = "";
            compile(el)(scope);
            scope.$digest();
            el.val(null);
            el.trigger('input');
            scope.$digest();
            expect(scope.data.pageSize).toEqual("");
        });
        it('input = undefined should make input empty string', function () {
            scope.data.pageSize = "";
            compile(el)(scope);
            scope.$digest();
            el.val(undefined);
            el.trigger('input');
            scope.$digest();
            expect(scope.data.pageSize).toEqual("");
        });
        it('input = "0" should make input empty string', function () {
            compile(el)(scope);
            scope.$digest();
            el.val("0");
            el.trigger('input');
            scope.$digest();
            expect(scope.data.pageSize).toEqual(0);
        });
        it('input = not a number should make input empty string', function () {
            compile(el)(scope);
            scope.$digest();
            el.val("whatup!");
            el.trigger('input');
            scope.$digest();
            expect(scope.data.pageSize).toEqual("");
        });
        it('input = integer > 0 should make input an integer', function () {
            compile(el)(scope);
            scope.$digest();
            el.val("100");
            el.trigger('input');
            scope.$digest();
            expect(scope.data.pageSize).toEqual(100);
        });
        it('input = integer < 0 should make input an integer', function () {
            compile(el)(scope);
            scope.$digest();
            el.val("-100");
            el.trigger('input');
            scope.$digest();
            expect(scope.data.pageSize).toEqual(-100);
        });
        it('input = "" should make input an integer', function () {
            scope.data.pageSize = "";
            compile(el)(scope);
            scope.$digest();
            el.val("");
            el.trigger('input');
            scope.$digest();
            expect(scope.data.pageSize).toEqual("");
        });
    });
}());
(function () {
    "use strict";
    describe("directive: credit-card-entry", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope;
        var rootScope;
        var directiveScope;
        var element;
        var compile;
        var responseErrorServiceMock;
        var creditCardInputService;
        var q;
        var expirationDateService;
        function flush() {
            rootScope.$apply();
        }
        var setup = function ($rootScope, $templateCache, $compile, $q) {
            rootScope = $rootScope;
            compile = $compile;
            q = $q;
            $templateCache.put("/app/directives/billingEntry/creditCardEntryTemplate.html", $templateCache.get("app/directives/billingEntry/creditCardEntryTemplate.html"));
        };
        function buildDirective() {
            scope = rootScope.$new();
            scope.creditCardTypes = ["VISA", "DISCOVER", "MASTERCARD", "AMEX"];
            scope.creditCard = {};
            scope.form = {};
            scope.suffix = 'theCreditCardDirective';
            var el = angular.element("<form name=\"form\">" +
                "<credit-card-entry on-setup-complete=\"onSetupComplete()\" credit-card=\"creditCard\" creditcardtypes=\"creditCardTypes\" " +
                "paymentsform=\"form\" validate=\"true\" name-suffix=\"suffix\">" +
                "</credit-card-entry>" +
                "</form>");
            element = compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
            directiveScope.$apply();
        }
        beforeEach(angular.mock.module(function ($provide) {
            responseErrorServiceMock = jasmine.createSpyObj("responseErrorService", ["displayAlertsFromResponse", "displayToast"]);
            creditCardInputService = jasmine.createSpyObj("creditCardInputService", ["setup", "update", "submit"]);
            expirationDateService = jasmine.createSpyObj('expirationDateService', ['isInternationalAddress']);
            $provide.value('expirationDateService', expirationDateService);
            $provide.value("creditCardInputService", creditCardInputService);
            $provide.value("validationService", {});
        }));
        beforeEach(angular.mock.inject(setup));
        describe("Non-kiosk configuration", function () {
            beforeEach(function () {
                creditCardInputService.setup.and.callFake(function (s) {
                    s.strategyUsed = HCTRA.Model.CreditCardInputStrategyEnum.Iframe;
                    return q.resolve();
                });
                creditCardInputService.update.and.callFake(function () {
                    return q.resolve();
                });
                creditCardInputService.submit.and.callFake(function () {
                    return q.resolve();
                });
                buildDirective();
            });
            it("should use iframe", function () {
                directiveScope.update();
                flush();
                expect(directiveScope.strategyUsed).toBe(HCTRA.Model.CreditCardInputStrategyEnum.Iframe);
                expect(angular.element("[class='vantivIframeWrapper']", element).length).toBe(1);
            });
            it("should have a defined scope", function () {
                expect(scope).toBeDefined("scope not defined");
                expect(directiveScope).toBeDefined("directiveScope not defined");
            });
            it("should start with an invalid form", function () {
                expect(scope.form.$valid).toBeFalsy();
                expect(scope.form.$invalid).toBeTruthy();
            });
            it("should accept valid card name", function () {
                scope.creditCard.nameOnCard = "First, L'ast-Last Esq.";
                scope.$digest();
                expect(scope.form.cardNametheCreditCardDirective.$valid).toBeTruthy();
                expect(scope.form.cardNametheCreditCardDirective.$invalid).toBeFalsy();
            });
            it("should reject a blank card name", function () {
                scope.creditCard.nameOnCard = "";
                scope.$digest();
                expect(scope.form.cardNametheCreditCardDirective.$valid).toBeFalsy();
                expect(scope.form.cardNametheCreditCardDirective.$invalid).toBeTruthy();
            });
            it("should reject card number in name field", function () {
                scope.creditCard.nameOnCard = "4916913787560670";
                scope.creditCard.cardNbr = "4916913787560670";
                scope.$digest();
                expect(scope.form.cardNametheCreditCardDirective.$valid).toBeFalsy();
                expect(scope.form.cardNametheCreditCardDirective.$invalid).toBeTruthy();
            });
        });
        describe("Kiosk configuration", function () {
            beforeEach(function () {
                creditCardInputService.setup.and.callFake(function (s) {
                    s.strategyUsed = HCTRA.Model.CreditCardInputStrategyEnum.Tripos;
                    return q.resolve();
                });
                creditCardInputService.update.and.callFake(function () {
                    return q.resolve();
                });
                creditCardInputService.submit.and.callFake(function () {
                    return q.resolve();
                });
                buildDirective();
            });
            it("should only show readonly CC info fields", function () {
                expect(angular.element("[name='cardNumbertheCreditCardDirective'][disabled]", element).length).toBe(1);
                expect(angular.element("[name='expMonththeCreditCardDirective'][disabled]", element).length).toBe(1);
                expect(angular.element("[name='expYeartheCreditCardDirective'][disabled]", element).length).toBe(1);
                expect(angular.element("[name='cardNametheCreditCardDirective'][disabled]", element).length).toBe(1);
            });
            it("should get tokenized data on update", function () {
                directiveScope.update();
                flush();
                expect(creditCardInputService.update).toHaveBeenCalled();
            });
        });
    });
}());
(function () {
    "use strict";
    describe("directive: current-password", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", function () { return {}; });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.form = {};
            scope.password = "";
            scope.confirmPassword = "";
            scope.inObj = {};
            $templateCache.put("/app/directives/currentPasswordTemplate.html", $templateCache.get("app/directives/currentPasswordTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<current-password show-current-password=\"true\" parent-form=\"form\" current-password=\"inObj\" " +
                "confirm-password=\"confirmPassword\" password=\"password\" tabindex=\"-1\">" +
                "</current-password>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid password", function () {
            scope.inObj.currentPassword = "password-_@.";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeTruthy();
            expect(scope.form.currentPassword.$invalid).toBeFalsy();
            scope.inObj.currentPassword = "12345678";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeTruthy();
            expect(scope.form.currentPassword.$invalid).toBeFalsy();
            scope.inObj.currentPassword = "1234567890123456";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeTruthy();
            expect(scope.form.currentPassword.$invalid).toBeFalsy();
        });
        it("should reject invalid password", function () {
            scope.inObj.currentPassword = "";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeFalsy();
            expect(scope.form.currentPassword.$invalid).toBeTruthy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: current-password-isolated", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", function () { return {}; });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.form = {};
            scope.password = "";
            scope.confirmPassword = "";
            scope.inObj = {};
            $templateCache.put("/app/directives/currentPasswordIsolatedTemplate.html", $templateCache.get("app/directives/currentPasswordIsolatedTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<current-password-isolated show-current-password=\"true\" parent-form=\"form\" current-password=\"inObj\" " +
                "confirm-password=\"confirmPassword\" password=\"password\" tabindex=\"-1\">" +
                "</current-password>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid password", function () {
            scope.inObj.currentPassword = "password-_@.";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeTruthy();
            expect(scope.form.currentPassword.$invalid).toBeFalsy();
            scope.inObj.currentPassword = "12345678";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeTruthy();
            expect(scope.form.currentPassword.$invalid).toBeFalsy();
            scope.inObj.currentPassword = "1234567890123456";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeTruthy();
            expect(scope.form.currentPassword.$invalid).toBeFalsy();
        });
        it("should reject invalid password", function () {
            scope.inObj.currentPassword = "";
            scope.$digest();
            expect(scope.form.currentPassword.$valid).toBeFalsy();
            expect(scope.form.currentPassword.$invalid).toBeTruthy();
        });
    });
}());
(function () {
    'use strict';
    describe('directive: email-valid', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, el;
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            el = angular.element('<input type="email" ng-model="model" email-valid></input>');
            scope = $rootScope.$new();
            scope.model = "";
            $compile(el)(scope);
            scope.$digest();
        }));
        it('should begin as valid', function () {
            // If used on a field that is not required, you don't want it to fail validation
            scope.model = "";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should begin as valid', function () {
            // If used on a field that is not required, you don't want it to fail validation
            scope.model = "";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should pass validation if given a valid email address', function () {
            // If used on a field that is not required, you don't want it to fail validation
            scope.model = "email@test.com";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should fail validation if given an invalid email address', function () {
            // If used on a field that is not required, you don't want it to fail validation
            scope.model = "!#$%^&*()";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
            scope.model = "email@test";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
            scope.model = "@test.com";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: files-upload", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.inject(function ($rootScope, $compile, $templateCache) {
            scope = $rootScope.$new();
            scope.form = {};
            scope.details = {
                validations: {
                    FileUploadSize: 20,
                    FileMaxUploads: 4,
                    FileExtensions: ".pdf,.png",
                    FieldValidationMessage: "invalid file type",
                    FieldRequiredValidationMessage: "size to large"
                },
                files: []
            };
            $templateCache.put("/app/directives/filesUploadTemplate.html", $templateCache.get("app/directives/filesUploadTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<files-upload validations=\"details.validations\" files=\"details.files\" form=\"form\" " +
                "></files-upload>" +
                +"</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("test parent scope", function () {
            expect(scope.details.validations.FileUploadSize).toEqual(20);
            expect(scope.details.validations.FileMaxUploads).toEqual(4);
            expect(scope.details.validations.FileExtensions).toEqual(".pdf,.png");
            expect(scope.details.validations.FieldValidationMessage).toEqual("invalid file type");
            expect(scope.details.validations.FieldRequiredValidationMessage).toEqual("size to large");
            expect(scope.details.files).toEqual([]);
        });
        it("test directive scope", function () {
            expect(directiveScope.validations.FileUploadSize).toEqual(20);
            expect(directiveScope.validations.FileMaxUploads).toEqual(4);
            expect(directiveScope.validations.FileExtensions).toEqual(".pdf,.png");
            expect(directiveScope.validations.FieldValidationMessage).toEqual("invalid file type");
            expect(directiveScope.validations.FieldRequiredValidationMessage).toEqual("size to large");
            expect(directiveScope.files).toEqual([]);
            expect(directiveScope.internalFiles.length).toBe(1);
            expect(directiveScope.internalFiles[0].data).toBeNull();
            expect(directiveScope.internalFiles[0].extension).toBeNull();
            expect(directiveScope.internalFiles[0].id).toEqual("fileUploadIdentification1");
            expect(directiveScope.updateFunc).toBeDefined();
            expect(directiveScope.processDelete).toBeDefined();
        });
        it("test updateFunc with less than max files", function () {
            expect(directiveScope.internalFiles.length).toEqual(1);
            expect(directiveScope.files.length).toEqual(0);
            directiveScope.internalFiles[0].data = "test";
            directiveScope.internalFiles[0].extension = ".loust";
            directiveScope.updateFunc();
            expect(directiveScope.internalFiles.length).toEqual(2);
            expect(directiveScope.files.length).toEqual(1);
            expect(directiveScope.internalFiles[0].data).toEqual("test");
            expect(directiveScope.internalFiles[0].extension).toEqual(".loust");
            expect(directiveScope.internalFiles[0].id).toEqual("fileUploadIdentification1");
            expect(directiveScope.internalFiles[1].data).toBeNull();
            expect(directiveScope.internalFiles[1].extension).toBeNull();
            expect(directiveScope.internalFiles[1].id).toEqual("fileUploadIdentification2");
            expect(directiveScope.files[0].data).toEqual("test");
            expect(directiveScope.files[0].extension).toEqual(".loust");
            expect(directiveScope.files[0].id).toEqual("fileUploadIdentification1");
        });
        it("test updateFunc when user updated an old file and there is already an open file", function () {
            directiveScope.internalFiles[0].data = "test";
            directiveScope.internalFiles[0].extension = ".loust";
            var newFile2 = {
                data: null,
                extension: null,
                id: "fileUploadIdentification2"
            };
            directiveScope.internalFiles.push(newFile2);
            expect(directiveScope.internalFiles.length).toEqual(2);
            directiveScope.files[0] = directiveScope.internalFiles[0];
            expect(directiveScope.files.length).toEqual(1);
            directiveScope.internalFiles[0].data = "newerValue";
            directiveScope.internalFiles[0].extension = ".superLoust";
            directiveScope.updateFunc();
            expect(directiveScope.internalFiles.length).toEqual(2);
            expect(directiveScope.files.length).toEqual(1);
            expect(directiveScope.internalFiles[0].data).toEqual("newerValue");
            expect(directiveScope.internalFiles[0].extension).toEqual(".superLoust");
            expect(directiveScope.internalFiles[0].id).toEqual("fileUploadIdentification1");
            expect(directiveScope.internalFiles[1].data).toBeNull();
            expect(directiveScope.internalFiles[1].extension).toBeNull();
            expect(directiveScope.internalFiles[1].id).toEqual("fileUploadIdentification2");
            expect(directiveScope.files[0].data).toEqual("newerValue");
            expect(directiveScope.files[0].extension).toEqual(".superLoust");
            expect(directiveScope.files[0].id).toEqual("fileUploadIdentification1");
        });
        it("test updateFunc with more or equal than max files", function () {
            var newFile2 = {
                data: "test",
                extension: ".incredible",
                id: "fileUploadIdentification2"
            };
            var newFile3 = {
                data: "test",
                extension: ".incredible",
                id: "fileUploadIdentification3"
            };
            var newFile4 = {
                data: "test",
                extension: ".incredible",
                id: "fileUploadIdentification4"
            };
            directiveScope.internalFiles[0].data = "test";
            directiveScope.internalFiles[0].extension = ".loust";
            directiveScope.internalFiles.push(newFile2);
            directiveScope.internalFiles.push(newFile3);
            directiveScope.internalFiles.push(newFile4);
            directiveScope.files.push(directiveScope.internalFiles[0]);
            directiveScope.files.push(directiveScope.internalFiles[1]);
            directiveScope.files.push(directiveScope.internalFiles[2]);
            expect(directiveScope.internalFiles.length).toEqual(4);
            expect(directiveScope.files.length).toEqual(3);
            directiveScope.updateFunc();
            expect(directiveScope.internalFiles.length).toEqual(4);
            expect(directiveScope.files.length).toEqual(4);
            expect(directiveScope.internalFiles[0].data).toEqual("test");
            expect(directiveScope.internalFiles[0].extension).toEqual(".loust");
            expect(directiveScope.internalFiles[0].id).toEqual("fileUploadIdentification1");
            expect(directiveScope.internalFiles[1].data).toEqual("test");
            expect(directiveScope.internalFiles[1].extension).toEqual(".incredible");
            expect(directiveScope.internalFiles[1].id).toEqual("fileUploadIdentification2");
            expect(directiveScope.internalFiles[2].data).toEqual("test");
            expect(directiveScope.internalFiles[2].extension).toEqual(".incredible");
            expect(directiveScope.internalFiles[2].id).toEqual("fileUploadIdentification3");
            expect(directiveScope.internalFiles[3].data).toEqual("test");
            expect(directiveScope.internalFiles[3].extension).toEqual(".incredible");
            expect(directiveScope.internalFiles[3].id).toEqual("fileUploadIdentification4");
            expect(directiveScope.files[0].data).toEqual("test");
            expect(directiveScope.files[0].extension).toEqual(".loust");
            expect(directiveScope.files[0].id).toEqual("fileUploadIdentification1");
            expect(directiveScope.files[1].data).toEqual("test");
            expect(directiveScope.files[1].extension).toEqual(".incredible");
            expect(directiveScope.files[1].id).toEqual("fileUploadIdentification2");
            expect(directiveScope.files[2].data).toEqual("test");
            expect(directiveScope.files[2].extension).toEqual(".incredible");
            expect(directiveScope.files[2].id).toEqual("fileUploadIdentification3");
            expect(directiveScope.files[3].data).toEqual("test");
            expect(directiveScope.files[3].extension).toEqual(".incredible");
            expect(directiveScope.files[3].id).toEqual("fileUploadIdentification4");
        });
        it("test processDelete correctly removes ids", function () {
            directiveScope.internalFiles[0].data = "test";
            directiveScope.internalFiles[0].extension = ".loust";
            var newFile2 = {
                data: null,
                extension: null,
                id: "fileUploadIdentification2"
            };
            directiveScope.internalFiles.push(newFile2);
            expect(directiveScope.internalFiles.length).toEqual(2);
            directiveScope.files[0] = directiveScope.internalFiles[0];
            expect(directiveScope.files.length).toEqual(1);
            directiveScope.processDelete("fileUploadIdentification1");
            expect(directiveScope.internalFiles.length).toEqual(1);
            expect(directiveScope.files.length).toEqual(0);
            expect(directiveScope.internalFiles[0].data).toBeNull();
            expect(directiveScope.internalFiles[0].extension).toBeNull();
            expect(directiveScope.internalFiles[0].id).toEqual("fileUploadIdentification2");
        });
    });
}());
(function () {
    "use strict";
    describe("directive: file-upload", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, validationObj;
        var deleteFlag = false;
        var deleteId = null;
        //let updateFlag: Boolean = false;
        var timeoutService;
        beforeEach(angular.mock.module(function () {
            validationObj = {};
            deleteFlag = false;
            deleteId = null;
            //updateFlag = false;
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", hctraMocks.validationService(validationObj));
        }));
        describe('process delete, update func, id and shouldShowDelete Func all have values', function () {
            beforeEach(angular.mock.inject(function ($rootScope, $compile, $templateCache, $timeout) {
                timeoutService = $timeout;
                scope = $rootScope.$new();
                scope.form = {};
                scope.details = {
                    validations: {
                        FileUploadSize: 20,
                        FileMaxUploads: 4,
                        FileExtensions: [".pdf", ".png"],
                        FieldValidationMessage: "invalid file type",
                        FieldRequiredValidationMessage: "size to large"
                    },
                    file: {
                        data: null,
                        extension: null,
                        id: "fileId1"
                    },
                    shouldShowDelete: true,
                    processDelete: function (id) {
                        deleteFlag = true;
                        deleteId = id;
                    },
                    updateFunc: function () {
                        //updateFlag = true;
                    }
                };
                $templateCache.put("/app/directives/fileUploadTemplate.html", $templateCache.get("app/directives/fileUploadTemplate.html"));
                var el = angular.element("<form name=\"form\">" +
                    "<file-upload id=\"details.file.id\" validations=\"details.validations\" file=\"details.file\" form=\"form\" should-show-delete=\"details.shouldShowDelete\" " +
                    "on-delete=\"details.processDelete\" on-update=\"details.updateFunc()\"></file-upload>" +
                    +"</form>");
                $compile(el)(scope);
                scope.$digest();
                directiveScope = el.children().isolateScope();
            }));
            it("should have a defined scope", function () {
                expect(scope).toBeDefined();
            });
            it("test parent scope", function () {
                expect(scope.details.validations.FileUploadSize).toEqual(20);
                expect(scope.details.validations.FileMaxUploads).toEqual(4);
                expect(scope.details.validations.FileExtensions).toEqual([".pdf", ".png"]);
                expect(scope.details.validations.FieldValidationMessage).toEqual("invalid file type");
                expect(scope.details.validations.FieldRequiredValidationMessage).toEqual("size to large");
                expect(scope.details.file.data).toBe(null);
                expect(scope.details.file.extension).toBe(null);
                expect(scope.details.file.id).toBe("fileId1");
                expect(scope.details.shouldShowDelete).toBeTruthy();
                expect(scope.details.processDelete).toBeDefined();
                expect(scope.details.updateFunc).toBeDefined();
            });
            it("test directive scope", function () {
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileId1");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.deleteFunc).toBeDefined();
                expect(directiveScope.updateFunc).toBeDefined();
            });
            it("test submit file with blank file", function () {
                directiveScope.submitFile(null);
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileId1");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeDefined();
                directiveScope.submitFile("");
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileId1");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeDefined();
                directiveScope.submitFile(undefined);
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileId1");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeDefined();
                directiveScope.submitFile();
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileId1");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeDefined();
            });
            it("test submit file with filled invalid file extension", function () {
                directiveScope.submitFile({ name: "test.zzz" });
                expect(directiveScope.showDeleteButton).toBeTruthy();
                expect(directiveScope.fileName).toEqual("test.zzz");
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showTypeValidationMessage).toBeTruthy();
                expect(directiveScope.file.data).toBeNull();
                expect(directiveScope.file.extension).toBeNull();
                expect(directiveScope.form.fileId1.$valid).toBeFalsy();
            });
            it("test submit file with filled invalid (blank) file extension", function () {
                directiveScope.submitFile({ name: "testz" });
                expect(directiveScope.showDeleteButton).toBeTruthy();
                expect(directiveScope.fileName).toEqual("testz");
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showTypeValidationMessage).toBeTruthy();
                expect(directiveScope.file.data).toBeNull();
                expect(directiveScope.file.extension).toBeNull();
                expect(directiveScope.form.fileId1.$valid).toBeFalsy();
            });
            it("test submit file with filled valid file extension and invalid file size", function () {
                directiveScope.submitFile({ name: "test.pdf", size: 99999999999999999 });
                expect(directiveScope.showDeleteButton).toBeTruthy();
                expect(directiveScope.fileName).toEqual("test.pdf");
                expect(directiveScope.showSizeValidationMessage).toBeTruthy();
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.file.data).toBeNull();
                expect(directiveScope.file.extension).toBeNull();
                expect(directiveScope.form.fileId1.$valid).toBeFalsy();
            });
            it("test submit file with filled valid file extension and valid file size", function () {
                var fileOptions = {
                    type: "application/pdf",
                    lastModified: new Date().getTime()
                };
                var file = new File(["test", "test", "test"], "test.pdf", fileOptions);
                directiveScope.submitFile(file);
                expect(directiveScope.showDeleteButton).toBeTruthy();
                expect(directiveScope.fileName).toEqual("test.pdf");
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.form.fileId1.$valid).toBeTruthy();
                //TODO: need to find way to verify file.data, file.extension and updateFunc were set/called
            });
            it("test deletion", function () {
                directiveScope.onDelete();
                expect(directiveScope.form.fileId1.$valid).toBeTruthy();
                expect(directiveScope.file.data).toBeNull();
                expect(directiveScope.file.extension).toBeNull();
                expect(deleteFlag).toBeTruthy();
                expect(deleteId).toEqual("fileId1");
            });
        });
        describe('process delete, update func, id and shouldShowDelete Func have NO values', function () {
            beforeEach(angular.mock.inject(function ($rootScope, $compile, $templateCache, $timeout) {
                timeoutService = $timeout;
                scope = $rootScope.$new();
                scope.form = {};
                scope.details = {
                    validations: {
                        FileUploadSize: 20,
                        FileMaxUploads: 4,
                        FileExtensions: [".pdf", ".png"],
                        FieldValidationMessage: "invalid file type",
                        FieldRequiredValidationMessage: "size to large"
                    },
                    file: {
                        data: null,
                        extension: null
                    }
                };
                $templateCache.put("/app/directives/fileUploadTemplate.html", $templateCache.get("app/directives/fileUploadTemplate.html"));
                var el = angular.element("<form name=\"form\">" +
                    "<file-upload validations=\"details.validations\" file=\"details.file\" form=\"form\" " +
                    "></file-upload>" +
                    +"</form>");
                $compile(el)(scope);
                scope.$digest();
                directiveScope = el.children().isolateScope();
            }));
            it("should have a defined scope", function () {
                expect(scope).toBeDefined();
            });
            it("test parent scope", function () {
                expect(scope.details.validations.FileUploadSize).toEqual(20);
                expect(scope.details.validations.FileMaxUploads).toEqual(4);
                expect(scope.details.validations.FileExtensions).toEqual([".pdf", ".png"]);
                expect(scope.details.validations.FieldValidationMessage).toEqual("invalid file type");
                expect(scope.details.validations.FieldRequiredValidationMessage).toEqual("size to large");
                expect(scope.details.file.data).toBe(null);
                expect(scope.details.file.extension).toBe(null);
                expect(scope.details.file.id).toBeUndefined();
                expect(scope.details.shouldShowDelete).toBeUndefined();
                expect(scope.details.processDelete).toBeUndefined();
                expect(scope.details.updateFunc).toBeUndefined();
            });
            it("test directive scope", function () {
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileUploadIdentifier0");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.deleteFunc).toBeUndefined();
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeUndefined();
            });
            it("test submit file with blank file", function () {
                directiveScope.submitFile(null);
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileUploadIdentifier0");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.deleteFunc).toBeUndefined();
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeUndefined();
                directiveScope.submitFile("");
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileUploadIdentifier0");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.deleteFunc).toBeUndefined();
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeUndefined();
                directiveScope.submitFile(undefined);
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileUploadIdentifier0");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.deleteFunc).toBeUndefined();
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeUndefined();
                directiveScope.submitFile();
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.id).toEqual("fileUploadIdentifier0");
                expect(directiveScope.fileName).toEqual("");
                expect(directiveScope.validation).toEqual("Uses validationService");
                expect(directiveScope.deleteFunc).toBeUndefined();
                expect(directiveScope.submitFile).toBeDefined();
                expect(directiveScope.onDelete).toBeDefined();
                expect(directiveScope.updateFunc).toBeUndefined();
            });
            it("test submit file with filled invalid file extension", function () {
                directiveScope.submitFile({ name: "test.zzz" });
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.fileName).toEqual("test.zzz");
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showTypeValidationMessage).toBeTruthy();
                expect(directiveScope.file.data).toBeNull();
                expect(directiveScope.file.extension).toBeNull();
                expect(directiveScope.form.fileUploadIdentifier0.$valid).toBeFalsy();
            });
            it("test submit file with filled valid file extension and invalid file size", function () {
                directiveScope.submitFile({ name: "test.pdf", size: 99999999999999999 });
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.fileName).toEqual("test.pdf");
                expect(directiveScope.showSizeValidationMessage).toBeTruthy();
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.file.data).toBeNull();
                expect(directiveScope.file.extension).toBeNull();
                expect(directiveScope.form.fileUploadIdentifier0.$valid).toBeFalsy();
            });
            it("test submit file with filled valid file extension and valid file size", function () {
                var fileOptions = {
                    type: "application/pdf",
                    lastModified: new Date().getTime()
                };
                var file = new File(["test", "test", "test"], "test.pdf", fileOptions);
                directiveScope.submitFile(file);
                expect(directiveScope.showDeleteButton).toBeFalsy();
                expect(directiveScope.fileName).toEqual("test.pdf");
                expect(directiveScope.showSizeValidationMessage).toBeFalsy();
                expect(directiveScope.showTypeValidationMessage).toBeFalsy();
                expect(directiveScope.form.fileUploadIdentifier0.$valid).toBeTruthy();
                //TODO: need to find way to verify file.data, file.extension and updateFunc were set/called
            });
            it("test deletion", function () {
                expect(function () { directiveScope.onDelete(); }).toThrow();
                expect(directiveScope.form.fileUploadIdentifier0.$valid).toBeTruthy();
                expect(directiveScope.file.data).toBeNull();
                expect(directiveScope.file.extension).toBeNull();
                expect(deleteFlag).toBeFalsy();
                expect(deleteId).toBeNull();
            });
        });
    });
}());
// (function (): void {
//     "use strict";
//     describe("directive: footer-desktop-view", () => {
//         beforeEach(angular.mock.module("HCTRATemplates"));
//         beforeEach(angular.mock.module("HCTRAModule"));
//         let scope,
//             directiveHtml,
//             onMobileClickCalled,
//             onDesktopClickCalled,
//             forceDesktopView,
//             recompileDirective;
//         beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//             $provide.value("toggleFullWebsiteService", {
//                 onMobileClick: () => { onMobileClickCalled = true },
//                 onDesktopClick: () => { onDesktopClickCalled = true }
//             });
//             $provide.value("desktopAutoRedirect", {
//                 isForcedDesktopView: () => forceDesktopView
//             });
//         }));
//         beforeEach(angular.mock.inject(($rootScope: angular.IRootScopeService,
//             $templateCache: angular.ITemplateCacheService,
//             $compile: angular.ICompileService) => {
//             scope = $rootScope.$new();
//             onMobileClickCalled = false;
//             onDesktopClickCalled = false;
//             $templateCache.put("/app/directives/footerDesktopViewTemplate.html",
//                 $templateCache.get("app/directives/footerDesktopViewTemplate.html"));
//             recompileDirective = () => {
//                 directiveHtml = angular.element("<footer-desktop-view></footer-desktop-view>");
//                 $compile(directiveHtml)(scope);
//                 scope.$digest();
//             };
//             recompileDirective();           
//         }));
//         it("canary", () => {
//             expect(true).toBe(true);
//         });
//         it("should call onMobileClick of toggleFullWebsiteService when mobileOnly button is clicked", () => {
//             expect(onMobileClickCalled).toBeFalsy();
//             directiveHtml.find(".mobileOnly")[0].click();
//             expect(onMobileClickCalled).toBeTruthy();
//         });
//         it("should call onDesktopClick of toggleFullWebsiteService when desktopOnly button is clicked", () => {
//             expect(onDesktopClickCalled).toBeFalsy();
//             directiveHtml.find(".desktopOnly")[0].click();
//             expect(onDesktopClickCalled).toBeTruthy();
//         });        
//         it("should show desktopOnly when desktop View forced", () => {
//             forceDesktopView = true;
//             recompileDirective();
//             expect(directiveHtml.find(".desktopOnly.ng-hide").length).toBe(0);
//         });
//         it("should hide desktopOnly when desktop View not forced", () => {
//             forceDesktopView = false;
//             recompileDirective();
//             expect(directiveHtml.find(".desktopOnly.ng-hide").length).toBe(1);
//         });
//     });
// }());
(function () {
    'use strict';
    describe('CreateAccountFromViolationsBillingInfoController', function () {
        var $location;
        var routes;
        var cmsUtilService;
        var AuthService;
        var marketingImageService;
        var rssService;
        var $window;
        var momentService;
        var genericRepo;
        var stringUtils;
        var $rootScope;
        var AUTH_EVENTS;
        var APP_LIFECYCLE_EVENTS;
        var $q;
        var component;
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.inject(function ($injector) {
            $q = $injector.get("replacementQService");
            $location = $injector.get("$location");
            routes = $injector.get("routes");
            cmsUtilService = jasmine.createSpyObj("cmsUtilService", ["generateFileSrc"]);
            AuthService = jasmine.createSpyObj("AuthService", ["isAuthenticated"]);
            marketingImageService = jasmine.createSpyObj("marketingImageService", ["processImagesToObj", "setImages"]);
            rssService = jasmine.createSpyObj("rssService", ["goToRssFeed"]);
            $window = jasmine.createSpyObj("$window", ["open"]);
            momentService = $injector.get("momentService");
            genericRepo = { dataFactory: jasmine.createSpyObj("dataFactory", ["getCmsPageById"]) };
            stringUtils = jasmine.createSpyObj("stringUtilsService", ["getParameterObject"]);
            $rootScope = $injector.get("$rootScope");
            AUTH_EVENTS = $injector.get("AUTH_EVENTS");
            APP_LIFECYCLE_EVENTS = $injector.get("APP_LIFECYCLE_EVENTS");
            genericRepo.dataFactory.getCmsPageById.and.callFake(function () { return $q.defer().promise; });
            component = new HCTRA.Controller.HomeClosuresController($location, routes, cmsUtilService, AuthService, marketingImageService, rssService, $window, momentService, genericRepo, stringUtils, $rootScope, AUTH_EVENTS, APP_LIFECYCLE_EVENTS);
        }));
        it("should navigate to the RSS feed", function () {
            component.goToRssFeedClosures();
            expect(rssService.goToRssFeed).toHaveBeenCalledTimes(1);
        });
        it("should grab closure data from CMS with genericRepo", function () {
            component.updateClosureTitle();
            expect(genericRepo.dataFactory.getCmsPageById).toHaveBeenCalledTimes(1);
        });
        it("data from genericRepo should parse correctly from res", function () {
            //component.showRSSClosure;
            var res = { "errors": [], "cmsResponse": "{ \"Parameters\":\"isRSSshow=false\",\"ShortDescription\":\"Tolls Waived\"}" };
            stringUtils.getParameterObject.and.returnValue({ isRSSshow: "true" });
            component.parseClosureTitle(res);
            expect(component.showRSSClosure).toEqual(true);
        });
    });
})();
(function () {
    "use strict";
    describe("directive: home-news", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, routes, mockWindow, mockRssService;
        beforeEach(angular.mock.module(function () {
            mockWindow = {
                open: function (z) { return z; }
            };
            mockRssService = {
                rssHomeNewsKey: "fake home news key",
                goToRssFeed: function (z) { return z; }
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("cmsUtilService", {});
            $provide.value("AuthService", {});
            $provide.value("AUTH_EVENTS", {});
            $provide.value("marketingImageService", {});
            $provide.value("$window", mockWindow);
            $provide.value("rssService", mockRssService);
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile, _routes_) {
            scope = $rootScope.$new();
            routes = _routes_;
            $templateCache.put("/app/directives/home/homeNewsTemplate.html", $templateCache.get("app/directives/home/homeNewsTemplate.html"));
            var el = angular.element("<home-news></home-news>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.isolateScope();
        }));
        describe("canary", function () {
            it("should pass", function () {
                expect(true).toBe(true);
            });
        });
        describe("goToRssFeedNews", function () {
            it("should navigate to the RSS feed", function () {
                spyOn(mockRssService, "goToRssFeed").and.returnValue(null);
                directiveScope.goToRssFeedNews();
                expect(mockRssService.goToRssFeed).toHaveBeenCalledWith("fake home news key");
                expect(mockRssService.goToRssFeed).toHaveBeenCalledTimes(1);
            });
        });
        describe("goToNewsArticle", function () {
            it("should open a new page using the articleId provided", function () {
                spyOn(mockWindow, "open").and.returnValue(null);
                routes.newsFeed = "fakeNewsFeedRoute";
                directiveScope.goToNewsArticle("fakeArticleId");
                expect(mockWindow.open).toHaveBeenCalledWith("fakeNewsFeedRoute#fakeArticleId", "_blank");
                expect(mockWindow.open).toHaveBeenCalledTimes(1);
            });
        });
    });
}());
(function () {
    "use strict";
    describe("directive: input-dropdown", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope;
        var directiveScope;
        var inputDropdownConstants = {
            inputDropdownItemIdPrefix: "#inputDropdownItem",
            inputDropdownBoxId: "#inputDropdownBox",
            preSubmitValidationErrorKey: "inputError",
            postSubmitValidationErrorKey: "submissionError"
        };
        var inputDropdownHelper = {
            runProcessesForInputChangeWithNoValidation: function (dirScope) { dirScope.userInput = "t"; },
            runProcessesWhenInputIsEmpty: function (dirScope) { dirScope.userInput = "t"; },
            runValidationProcesses: function (dirScope) { dirScope.userInput = "t"; },
            ensureElementFocus: function (elementIndex, keyType) { directiveScope.userInput = "t"; keyType.boundaryType = "top"; },
            setFormValidity: function (validationKey, dirScope) { dirScope.userInput = "t"; }
        };
        var downKeyFocus = {
            boundaryType: "bottom",
            comparisonSwitch: -1,
            scrollType: false
        };
        var upKeyFocus = {
            boundaryType: "top",
            comparisonSwitch: 1,
            scrollType: true
        };
        var validationObject = {};
        var validationServiceWasUsed;
        var validationService = function (valInput) {
            validationServiceWasUsed = true;
            return {
                isInvalidWithNullCheck: function (input) { return valInput.name === input ? true : false; },
                getErrorList: function (input) { return input ? validationObject : validationObject; },
                hasSubmitted: function () { return valInput.hasSubmitted; },
                getErrorStatusClassFastWithNullCheck: function (input) { return input ? "has-error" : "has-error"; }
            };
        };
        beforeEach(angular.mock.module(function () {
            validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = false;
            validationObject[inputDropdownConstants.postSubmitValidationErrorKey] = false;
            validationServiceWasUsed = false;
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", validationService);
            $provide.value("inputDropdownHelper", inputDropdownHelper);
            $provide.value("inputDropdownConstants", inputDropdownConstants);
        }));
        describe('scope tests: optional bindings specified', function () {
            beforeEach(angular.mock.inject(function ($rootScope, $compile, $templateCache) {
                scope = $rootScope.$new();
                scope.requiredInputDropdownProperties = {
                    name: "LicensePlateInputDropdownName",
                    id: "LicensePlateInputDropdownId",
                    getDefaultItem: function (fullList) {
                        return fullList[0];
                    },
                    getItemDisplayName: function (vehicle) {
                        return vehicle.text;
                    },
                    getPartialItemMatches: function (userInput, fullList) {
                        if (!userInput) {
                            return [];
                        }
                        var lowerCaseInput = userInput.toLowerCase();
                        return fullList.filter(function (element) {
                            if (!element || !element.text) {
                                return false;
                            }
                            return element.text.toLowerCase().indexOf(lowerCaseInput) !== -1;
                        });
                    },
                    getExactItemMatch: function (userInput, currentFilteredList) {
                        if (!userInput) {
                            return null;
                        }
                        var lowerCaseInput = userInput.toLowerCase();
                        for (var _i = 0, currentFilteredList_1 = currentFilteredList; _i < currentFilteredList_1.length; _i++) {
                            var element = currentFilteredList_1[_i];
                            if (!element || !element.text) {
                                continue;
                            }
                            if (element.text.toLowerCase() === lowerCaseInput) {
                                return element;
                            }
                        }
                        return null;
                    }
                };
                scope.optionalInputDropdownProperties = {
                    placeholder: "ex. TX-1234567",
                    tabIndex: 2,
                    title: "License Plate",
                    getItemFromNoList: function (userInput) {
                        var vehicle = {
                            text: userInput, value: "L"
                        };
                        return vehicle;
                    }
                };
                $templateCache.put("/app/directives/inputDropdown/inputDropdownTemplate.html", $templateCache.get("app/directives/inputDropdown/inputDropdownTemplate.html"));
                var el = angular.element("<form name=\"form\">" +
                    "<input-dropdown required-bindings=\"requiredInputDropdownProperties\" optional-bindings=\"optionalInputDropdownProperties\"></input-dropdown>" +
                    +"</form>");
                $compile(el)(scope);
                scope.$digest();
                directiveScope = el.children().isolateScope();
                spyOn(inputDropdownHelper, "ensureElementFocus");
                spyOn(inputDropdownHelper, "runProcessesWhenInputIsEmpty");
                spyOn(inputDropdownHelper, "runValidationProcesses");
                spyOn(inputDropdownHelper, "setFormValidity");
                spyOn(inputDropdownHelper, "runProcessesForInputChangeWithNoValidation");
            }));
            it("should have a defined scope", function () {
                expect(scope).toBeDefined();
            });
            it("should have a defined directiveScope", function () {
                expect(directiveScope).toBeDefined();
            });
            it("test setActive", function () {
                directiveScope.setActive(3);
                expect(directiveScope.activeItemIndex).toEqual(3);
            });
            it("keyActions should have correct upAction for valid index", function () {
                directiveScope.activeItemIndex = 1;
                directiveScope.keyActions.upAction();
                expect(inputDropdownHelper.ensureElementFocus).toHaveBeenCalledWith(0, upKeyFocus);
                expect(inputDropdownHelper.ensureElementFocus).toHaveBeenCalledTimes(1);
            });
            it("keyActions should have correct upAction for invalid index", function () {
                directiveScope.activeItemIndex = 0;
                directiveScope.keyActions.upAction();
                expect(inputDropdownHelper.ensureElementFocus).not.toHaveBeenCalled();
            });
            it("keyActions should have correct downAction for valid index", function () {
                directiveScope.activeItemIndex = 0;
                directiveScope.filteredItems = [1, 2];
                directiveScope.keyActions.downAction();
                expect(inputDropdownHelper.ensureElementFocus).toHaveBeenCalledWith(1, downKeyFocus);
                expect(inputDropdownHelper.ensureElementFocus).toHaveBeenCalledTimes(1);
            });
            it("keyActions should have correct downAction for invalid index", function () {
                directiveScope.activeItemIndex = 2;
                directiveScope.filteredItems = [1, 2];
                directiveScope.keyActions.downAction();
                expect(inputDropdownHelper.ensureElementFocus).not.toHaveBeenCalled();
            });
            it("keyActions should have correct enterAction when dropdown is not visible", function () {
                var preventDefaultWasCalled = false;
                var preventDefault = function () {
                    preventDefaultWasCalled = true;
                };
                directiveScope.dropdownVisible = false;
                directiveScope.activeItemIndex = 2;
                directiveScope.filteredItems = [1, 2];
                directiveScope.keyActions.enterAction({ preventDefault: preventDefault });
                expect(preventDefaultWasCalled).toBeFalsy();
            });
            it("test selectItem", function () {
                directiveScope.selectItem({ test: 500, text: "like a bat" });
                expect(inputDropdownHelper.setFormValidity).toHaveBeenCalledWith(null, directiveScope);
                expect(inputDropdownHelper.setFormValidity).toHaveBeenCalledTimes(1);
                expect(directiveScope.filteredItems).toEqual([{ test: 500, text: "like a bat" }]);
                expect(directiveScope.dropdownVisible).toBeFalsy();
                expect(directiveScope.userInput).toEqual("like a bat");
                expect(directiveScope.requiredBindings.selectedItem).toEqual({
                    test: 500, text: "like a bat"
                });
            });
            it("keyActions should have correct enterAction when dropdown is visible but activeIndex is not valid -- should never happen", function () {
                var preventDefaultWasCalled = false;
                var preventDefault = function () {
                    preventDefaultWasCalled = true;
                };
                directiveScope.dropdownVisible = true;
                directiveScope.activeItemIndex = -2;
                directiveScope.filteredItems = [1, 2];
                directiveScope.keyActions.enterAction({ preventDefault: preventDefault });
                expect(preventDefaultWasCalled).toBeTruthy();
                expect(inputDropdownHelper.setFormValidity).not.toHaveBeenCalled();
            });
            it("keyActions should have correct enterAction when dropdown is visible but activeIndex is valid", function () {
                var preventDefaultWasCalled = false;
                var preventDefault = function () {
                    preventDefaultWasCalled = true;
                };
                directiveScope.dropdownVisible = true;
                directiveScope.activeItemIndex = 0;
                directiveScope.filteredItems = [{ test: 500, text: "like a bat" }, { test: 5300, text: "liiiiike a bat" }];
                directiveScope.keyActions.enterAction({ preventDefault: preventDefault });
                expect(preventDefaultWasCalled).toBeTruthy();
                expect(inputDropdownHelper.setFormValidity).toHaveBeenCalledTimes(1);
                expect(directiveScope.filteredItems).toEqual([{ test: 500, text: "like a bat" }]);
            });
            it("verify that filtered items is defaulted to an empty array", function () {
                expect(directiveScope.filteredItems).toEqual([]);
            });
            it("verify that items is assigned to filtered items when it becomes populated -- and watch discontinues after", function () {
                scope.requiredInputDropdownProperties.items = [];
                scope.$digest();
                expect(directiveScope.filteredItems).toEqual([]);
                expect(directiveScope.requiredBindings.selectedItem).toBeUndefined();
                scope.requiredInputDropdownProperties.items = [1];
                scope.$digest();
                expect(directiveScope.filteredItems).toEqual([1]);
                expect(directiveScope.requiredBindings.selectedItem).toEqual(1);
                scope.requiredInputDropdownProperties.items = [2, 1];
                scope.$digest();
                expect(directiveScope.filteredItems).toEqual([1]);
                expect(directiveScope.requiredBindings.selectedItem).toEqual(1);
            });
            it("verify scope is initialized properly (with optional bindings)", function () {
                expect(directiveScope.validationService).toEqual(validationService);
                expect(directiveScope.inputDropdownItemIdPrefix).toEqual(inputDropdownConstants.inputDropdownItemIdPrefix.substring(1));
                expect(directiveScope.inputDropdownBoxId).toEqual(inputDropdownConstants.inputDropdownBoxId.substring(1));
                expect(directiveScope.placeholder).toEqual("ex. TX-1234567");
                expect(directiveScope.tabIndex).toEqual(2);
                expect(directiveScope.title).toEqual("License Plate");
                expect(directiveScope.dropdownVisible).toEqual(false);
                expect(directiveScope.activeItemIndex).toEqual(0);
                expect(directiveScope.userInput).toEqual("");
                expect(directiveScope.isFocused).toBeFalsy();
            });
            it("test setWidth", function () {
                var element = {
                    getBoundingClientRect: function () {
                        return { width: 50 };
                    }
                };
                var spy = spyOn(angular, "element").and.callFake(function (id) {
                    if ("#" + directiveScope.requiredBindings.id === id) {
                        return [element];
                    }
                    throw new Error("Test");
                });
                expect(directiveScope.setWidth()).toEqual({ "width": "50px" });
                spy.and.callThrough();
            });
            it("test showValidation: form is non-existent", function () {
                directiveScope.isFocused = false;
                directiveScope.requiredBindings.form = null;
                expect(directiveScope.showValidation()).toBeFalsy();
            });
            it("test showValidation: form is existent but isInvalidWithNullCheck returns false", function () {
                directiveScope.isFocused = false;
                var fakeForm = { name: "LicensePlateInputDropdownName1", hasSubmitted: true, list: [] };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.showValidation()).toBeFalsy();
            });
            it("test showValidation: getErrorList returns false for all", function () {
                directiveScope.isFocused = false;
                validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = false;
                validationObject[inputDropdownConstants.postSubmitValidationErrorKey] = false;
                var fakeForm = { name: "LicensePlateInputDropdownName", hasSubmitted: true };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.showValidation()).toBeFalsy();
            });
            it("test showValidation: getErrorList returns false for hasSubmitted", function () {
                directiveScope.isFocused = false;
                validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = false;
                validationObject[inputDropdownConstants.postSubmitValidationErrorKey] = true;
                var fakeForm = { name: "LicensePlateInputDropdownName", hasSubmitted: false };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.showValidation()).toBeFalsy();
            });
            it("test showValidation: getErrorList returns true for isFocused", function () {
                directiveScope.isFocused = true;
                validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = false;
                validationObject[inputDropdownConstants.postSubmitValidationErrorKey] = true;
                var fakeForm = { name: "LicensePlateInputDropdownName", hasSubmitted: true };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.showValidation()).toBeFalsy();
            });
            it("test showValidation: preSubmitValidationErrorKey is true", function () {
                directiveScope.isFocused = true;
                validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = true;
                validationObject[inputDropdownConstants.postSubmitValidationErrorKey] = false;
                var fakeForm = { name: "LicensePlateInputDropdownName", hasSubmitted: false };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.showValidation()).toBeTruthy();
            });
            it("test showValidation: postSubmitValidationErrorKey validation set is true", function () {
                directiveScope.isFocused = false;
                validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = false;
                validationObject[inputDropdownConstants.postSubmitValidationErrorKey] = true;
                var fakeForm = { name: "LicensePlateInputDropdownName", hasSubmitted: true };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.showValidation()).toBeTruthy();
            });
            it("test inputDropdownClass when showValidation is true", function () {
                directiveScope.dropdownVisible = true;
                validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = true;
                var fakeForm = { name: "LicensePlateInputDropdownName", hasSubmitted: true };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.inputDropdownClass()).toEqual("input-dropdown has-error");
                expect(validationServiceWasUsed).toBeTruthy();
                expect(directiveScope.dropdownVisible).toBeFalsy();
            });
            it("test inputDropdownClass when showValidation is false", function () {
                directiveScope.dropdownVisible = true;
                validationObject[inputDropdownConstants.preSubmitValidationErrorKey] = false;
                validationObject[inputDropdownConstants.postSubmitValidationErrorKey] = false;
                var fakeForm = { name: "LicensePlateInputDropdownName", hasSubmitted: false };
                directiveScope.requiredBindings.form = fakeForm;
                expect(directiveScope.inputDropdownClass()).toEqual("input-dropdown");
                expect(validationServiceWasUsed).toBeTruthy();
                expect(directiveScope.dropdownVisible).toBeTruthy();
            });
            it("test selectedItemClass when input equals activeItemIndex", function () {
                directiveScope.activeItemIndex = 0;
                expect(directiveScope.selectedItemClass(0)).toEqual({ "active": true });
            });
            it("test selectedItemClass when input does not equal activeItemIndex", function () {
                directiveScope.activeItemIndex = 1;
                expect(directiveScope.selectedItemClass(0)).toEqual({ "active": false });
            });
            it("test inputFocus when filteredItems = 0", function () {
                directiveScope.isFocused = false;
                directiveScope.dropdownVisible = true;
                directiveScope.activeItemIndex = 100;
                directiveScope.filteredItems = [];
                directiveScope.inputFocus();
                expect(directiveScope.dropdownVisible).toBeFalsy();
                expect(directiveScope.isFocused).toBeTruthy();
                expect(directiveScope.activeItemIndex).toEqual(100);
            });
            it("test inputFocus when getExactItemMatch returns a value", function () {
                directiveScope.requiredBindings.getExactItemMatch = function () {
                    return true;
                };
                directiveScope.isFocused = false;
                directiveScope.dropdownVisible = true;
                directiveScope.activeItemIndex = 100;
                directiveScope.filteredItems = [1, 2];
                directiveScope.inputFocus();
                expect(directiveScope.dropdownVisible).toBeFalsy();
                expect(directiveScope.isFocused).toBeTruthy();
                expect(directiveScope.activeItemIndex).toEqual(100);
            });
            it("test inputFocus when getExactItemMatch returns a value", function () {
                directiveScope.requiredBindings.getExactItemMatch = function () {
                    return false;
                };
                directiveScope.isFocused = false;
                directiveScope.dropdownVisible = true;
                directiveScope.activeItemIndex = 100;
                directiveScope.filteredItems = [1, 2];
                directiveScope.inputFocus();
                expect(directiveScope.dropdownVisible).toBeTruthy();
                expect(directiveScope.isFocused).toBeTruthy();
                expect(directiveScope.activeItemIndex).toEqual(0);
            });
            it("test inputChange when userInput is null", function () {
                directiveScope.requiredBindings.selectedItem = "yes";
                directiveScope.dropdownVisible = false;
                directiveScope.userInput = null;
                directiveScope.inputChange();
                expect(directiveScope.requiredBindings.selectedItem).toBeNull();
                expect(directiveScope.dropdownVisible).toBeTruthy();
                expect(inputDropdownHelper.runProcessesWhenInputIsEmpty).toHaveBeenCalledWith(directiveScope);
                expect(inputDropdownHelper.runProcessesWhenInputIsEmpty).toHaveBeenCalledTimes(1);
            });
            it("test inputChange when userInput is not null and optional bindings are null", function () {
                directiveScope.requiredBindings.selectedItem = "yes";
                directiveScope.dropdownVisible = false;
                directiveScope.userInput = "t";
                directiveScope.optionalBindings = null;
                directiveScope.inputChange();
                expect(directiveScope.requiredBindings.selectedItem).toBeNull();
                expect(directiveScope.dropdownVisible).toBeTruthy();
                expect(inputDropdownHelper.runProcessesForInputChangeWithNoValidation).toHaveBeenCalledWith(directiveScope);
                expect(inputDropdownHelper.runProcessesForInputChangeWithNoValidation).toHaveBeenCalledTimes(1);
            });
            it("test inputChange when userInput is not null and optional bindings are false", function () {
                directiveScope.requiredBindings.selectedItem = "yes";
                directiveScope.dropdownVisible = false;
                directiveScope.userInput = "t";
                directiveScope.optionalBindings.shouldValidate = false;
                directiveScope.inputChange();
                expect(directiveScope.requiredBindings.selectedItem).toBeNull();
                expect(directiveScope.dropdownVisible).toBeTruthy();
                expect(inputDropdownHelper.runProcessesForInputChangeWithNoValidation).toHaveBeenCalledWith(directiveScope);
                expect(inputDropdownHelper.runProcessesForInputChangeWithNoValidation).toHaveBeenCalledTimes(1);
            });
            it("test inputChange when userInput is not null and optional bindings are false", function () {
                directiveScope.requiredBindings.selectedItem = "yes";
                directiveScope.dropdownVisible = false;
                directiveScope.userInput = "t";
                directiveScope.optionalBindings.shouldValidate = true;
                directiveScope.inputChange();
                expect(directiveScope.requiredBindings.selectedItem).toBeNull();
                expect(directiveScope.dropdownVisible).toBeTruthy();
                expect(inputDropdownHelper.runValidationProcesses).toHaveBeenCalledWith(directiveScope);
                expect(inputDropdownHelper.runValidationProcesses).toHaveBeenCalledTimes(1);
            });
            it("test inputBlur", function () {
                directiveScope.isFocused = true;
                directiveScope.dropdownVisible = true;
                directiveScope.inputBlur();
                expect(directiveScope.isFocused).toBeFalsy();
                expect(directiveScope.dropdownVisible).toBeFalsy();
            });
        });
        describe('scope tests: optional bindings not specified', function () {
            beforeEach(angular.mock.inject(function ($rootScope, $compile, $templateCache) {
                scope = $rootScope.$new();
                scope.requiredInputDropdownProperties = {
                    name: "LicensePlateInputDropdownName",
                    id: "LicensePlateInputDropdownId",
                    getDefaultItem: function (fullList) {
                        return fullList[0];
                    },
                    getItemDisplayName: function (vehicle) {
                        return vehicle.text;
                    },
                    getPartialItemMatches: function (userInput, fullList) {
                        if (!userInput) {
                            return [];
                        }
                        var lowerCaseInput = userInput.toLowerCase();
                        return fullList.filter(function (element) {
                            if (!element || !element.text) {
                                return false;
                            }
                            return element.text.toLowerCase().indexOf(lowerCaseInput) !== -1;
                        });
                    },
                    getExactItemMatch: function (userInput, currentFilteredList) {
                        if (!userInput) {
                            return null;
                        }
                        var lowerCaseInput = userInput.toLowerCase();
                        for (var _i = 0, currentFilteredList_2 = currentFilteredList; _i < currentFilteredList_2.length; _i++) {
                            var element = currentFilteredList_2[_i];
                            if (!element || !element.text) {
                                continue;
                            }
                            if (element.text.toLowerCase() === lowerCaseInput) {
                                return element;
                            }
                        }
                        return null;
                    }
                };
                scope.optionalInputDropdownProperties = {
                    getItemFromNoList: function (userInput) {
                        var vehicle = {
                            text: userInput, value: "L"
                        };
                        return vehicle;
                    }
                };
                $templateCache.put("/app/directives/inputDropdown/inputDropdownTemplate.html", $templateCache.get("app/directives/inputDropdown/inputDropdownTemplate.html"));
                var el = angular.element("<form name=\"form\">" +
                    "<input-dropdown required-bindings=\"requiredInputDropdownProperties\" optional-bindings=\"optionalInputDropdownProperties\"></input-dropdown>" +
                    +"</form>");
                $compile(el)(scope);
                scope.$digest();
                directiveScope = el.children().isolateScope();
                spyOn(inputDropdownHelper, "ensureElementFocus");
                spyOn(inputDropdownHelper, "runProcessesWhenInputIsEmpty");
                spyOn(inputDropdownHelper, "runValidationProcesses");
                spyOn(inputDropdownHelper, "setFormValidity");
                spyOn(inputDropdownHelper, "runProcessesForInputChangeWithNoValidation");
            }));
            it("verify scope is initialized properly (with no optional bindings)", function () {
                expect(directiveScope.validationService).toEqual(validationService);
                expect(directiveScope.inputDropdownItemIdPrefix).toEqual(inputDropdownConstants.inputDropdownItemIdPrefix.substring(1));
                expect(directiveScope.inputDropdownBoxId).toEqual(inputDropdownConstants.inputDropdownBoxId.substring(1));
                expect(directiveScope.placeholder).toBeNull();
                expect(directiveScope.tabIndex).toBeNull();
                expect(directiveScope.title).toBeNull();
                expect(directiveScope.dropdownVisible).toEqual(false);
                expect(directiveScope.activeItemIndex).toEqual(0);
                expect(directiveScope.userInput).toEqual("");
                expect(directiveScope.isFocused).toBeFalsy();
            });
        });
    });
}());
(function () {
    "use strict";
    describe("inputDropdownHelper", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var service;
        var inputDropdownScope;
        var dictionary;
        var constants;
        beforeEach(angular.mock.module(function () {
            inputDropdownScope = {
                requiredBindings: {
                    items: [],
                    name: "element",
                    selectedItem: {},
                    form: {},
                    id: "",
                    getDefaultItem: function (fullList) { return fullList; },
                    getItemDisplayName: function (item) { return (item) ? "" : ""; },
                    getPartialItemMatches: function (userInput, fullList) { return userInput && fullList ? [] : []; },
                    getExactItemMatch: function (userInput, currentFilteredList) { return userInput && currentFilteredList ? "exact" : "exact"; }
                },
                optionalBindings: {
                    placeholder: "",
                    tabIndex: 0,
                    title: "",
                    shouldValidate: false,
                    getItemFromNoList: function (userInput) { return userInput; }
                },
                filteredItems: [],
                keyActions: {
                    upAction: function () { },
                    downAction: function () { },
                    enterAction: function (event) { if (!event) {
                        event = "false";
                    } }
                },
                inputDropdownItemIdPrefix: "",
                inputDropdownBoxId: "",
                userInput: "",
                dropdownVisible: false,
                inputChange: function () { },
                inputDropdownClass: function () { return ""; },
                setActive: function (index) { if (index === 500000) {
                    index = 1;
                } }
            };
            inputDropdownScope.requiredBindings.form["element"] = {
                $setValidity: function (key, isValid) {
                    dictionary[key] = isValid;
                }
            };
            dictionary = {};
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("inputDropdownHelper");
            constants = $injector.get("inputDropdownConstants");
        }));
        it("test setFormValidity with null", function () {
            service.setFormValidity(null, inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
        });
        it("test setFormValidity with preSubmitValidationErrorKey", function () {
            service.setFormValidity(constants.preSubmitValidationErrorKey, inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeFalsy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
        });
        it("test setFormValidity with postSubmitValidationErrorKey", function () {
            service.setFormValidity(constants.postSubmitValidationErrorKey, inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeFalsy();
        });
        it("test runProcessesForInputChangeWithNoValidation when getPartialItemMatches returns null", function () {
            inputDropdownScope.userInput = ".";
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) { return (fullList || userInput) ? null : null; };
            service.runProcessesForInputChangeWithNoValidation(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
            expect(inputDropdownScope.dropdownVisible).toBeFalsy();
            expect(inputDropdownScope.requiredBindings.selectedItem).toEqual(".");
            expect(inputDropdownScope.filteredItems).toEqual([]);
        });
        it("test runProcessesForInputChangeWithNoValidation when getPartialItemMatches returns []", function () {
            inputDropdownScope.userInput = ".";
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) { return fullList || userInput ? [] : []; };
            service.runProcessesForInputChangeWithNoValidation(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
            expect(inputDropdownScope.dropdownVisible).toBeFalsy();
            expect(inputDropdownScope.requiredBindings.selectedItem).toEqual(".");
            expect(inputDropdownScope.filteredItems).toEqual([]);
        });
        it("test runProcessesForInputChangeWithNoValidation when getPartialItemMatches returns array with single item", function () {
            inputDropdownScope.userInput = ".";
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) { return userInput || fullList ? [1] : [1]; };
            service.runProcessesForInputChangeWithNoValidation(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
            expect(inputDropdownScope.dropdownVisible).toBeFalsy();
            expect(inputDropdownScope.requiredBindings.selectedItem).toEqual("exact");
            expect(inputDropdownScope.filteredItems).toEqual([1]);
        });
        it("test runProcessesForInputChangeWithNoValidation when getPartialItemMatches returns array with multiple items", function () {
            inputDropdownScope.userInput = ".";
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) { return fullList || userInput ? [1, 2] : [1, 2]; };
            service.runProcessesForInputChangeWithNoValidation(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
            expect(inputDropdownScope.dropdownVisible).toBeTruthy();
            expect(inputDropdownScope.requiredBindings.selectedItem).toEqual(".");
            expect(inputDropdownScope.filteredItems).toEqual([1, 2]);
        });
        it("test runProcessesWhenInputIsEmpty", function () {
            var setActiveIndex = 3;
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.setActive = function (index) { setActiveIndex = index; };
            inputDropdownScope.requiredBindings.items = [1, 2, 3];
            service.runProcessesWhenInputIsEmpty(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
            expect(setActiveIndex).toEqual(0);
            expect(inputDropdownScope.dropdownVisible).toBeTruthy();
            expect(inputDropdownScope.requiredBindings.selectedItem).toEqual([1, 2, 3]);
            expect(inputDropdownScope.filteredItems).toEqual([1, 2, 3]);
        });
        it("test runValidationProcesses when preSubmit returns false", function () {
            var exactMatchWasCalled = false;
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) {
                if (userInput && fullList)
                    return null;
                return null;
            };
            inputDropdownScope.requiredBindings.getExactItemMatch = function (userInput, currentFilteredList) {
                if (currentFilteredList || userInput) {
                    exactMatchWasCalled = true;
                }
                exactMatchWasCalled = true;
                return "exact";
            };
            service.runValidationProcesses(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeFalsy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
            expect(inputDropdownScope.dropdownVisible).toBeFalsy();
            expect(inputDropdownScope.filteredItems).toEqual([]);
            expect(exactMatchWasCalled).toBeFalsy();
        });
        it("test runValidationProcesses when getExactItemMatch returns empty", function () {
            var exactMatchWasCalled = false;
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) { return userInput || fullList ? [1, 2] : [1, 2]; };
            inputDropdownScope.requiredBindings.getExactItemMatch = function (userInput, currentFilteredList) {
                if (currentFilteredList || userInput) {
                    exactMatchWasCalled = true;
                }
                exactMatchWasCalled = true;
                return null;
            };
            service.runValidationProcesses(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeFalsy();
            expect(inputDropdownScope.dropdownVisible).toBeTruthy();
            expect(inputDropdownScope.filteredItems).toEqual([1, 2]);
            expect(exactMatchWasCalled).toBeTruthy();
        });
        it("test runValidationProcesses when getExactItemMatch returns match and filteredItems are momre than 1 --> this should never happen", function () {
            var exactMatchWasCalled = false;
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) { return userInput || fullList ? [1, 2] : [1, 2]; };
            inputDropdownScope.requiredBindings.getExactItemMatch = function (userInput, currentFilteredList) {
                if (currentFilteredList) {
                    exactMatchWasCalled = true;
                }
                exactMatchWasCalled = true;
                return "cool man";
            };
            service.runValidationProcesses(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeFalsy();
            expect(inputDropdownScope.dropdownVisible).toBeTruthy();
            expect(inputDropdownScope.filteredItems).toEqual([1, 2]);
            expect(exactMatchWasCalled).toBeTruthy();
        });
        it("test runValidationProcesses when getExactItemMatch returns exact match", function () {
            var exactMatchWasCalled = false;
            inputDropdownScope.dropdownVisible = true;
            inputDropdownScope.requiredBindings.getPartialItemMatches = function (userInput, fullList) { return (fullList) ? [1] : [1]; };
            inputDropdownScope.requiredBindings.getExactItemMatch = function (userInput, currentFilteredList) {
                if (currentFilteredList) {
                    exactMatchWasCalled = true;
                }
                exactMatchWasCalled = true;
                return "cool man";
            };
            service.runValidationProcesses(inputDropdownScope);
            expect(dictionary[constants.preSubmitValidationErrorKey]).toBeTruthy();
            expect(dictionary[constants.postSubmitValidationErrorKey]).toBeTruthy();
            expect(inputDropdownScope.requiredBindings.selectedItem).toEqual("cool man");
            expect(inputDropdownScope.filteredItems).toEqual([1]);
            expect(inputDropdownScope.filteredItems).toEqual([1]);
            expect(exactMatchWasCalled).toBeTruthy();
        });
        it("test ensureElementFocus when findElementQuery is null", function () {
            var elementIndex = 1;
            var inputDropdownItemIdPrefix = false;
            var inputDropdownBoxId = false;
            var keyType = {
                boundaryType: "botom",
                comparisonSwitch: 1,
                scrollType: true
            };
            var elementGetBoundingClientRect = function () {
                return {
                    botom: 15
                };
            };
            var findDropdownQueryGetBoundingClientRect = function () {
                return {
                    botom: 11
                };
            };
            var scroll = false;
            var scrollIntoView = function (input) {
                scroll = input;
            };
            var spy = spyOn(angular, "element").and.callFake(function (id) {
                if (constants.inputDropdownItemIdPrefix + "" + elementIndex === id) {
                    inputDropdownItemIdPrefix = true;
                    return [{ getBoundingClientRect: elementGetBoundingClientRect, scrollIntoView: scrollIntoView }];
                }
                else if (constants.inputDropdownBoxId === id) {
                    inputDropdownBoxId = true;
                    return [{ getBoundingClientRect: findDropdownQueryGetBoundingClientRect }];
                }
                else {
                    return null;
                }
            });
            service.ensureElementFocus(elementIndex, keyType);
            expect(scroll).toBeFalsy();
            expect(inputDropdownItemIdPrefix).toBeTruthy();
            expect(inputDropdownBoxId).toBeTruthy();
            spy.and.callThrough();
        });
        it("test ensureElementFocus when findDropdownQuery is null", function () {
            var elementIndex = 1;
            var inputDropdownItemIdPrefix = false;
            var inputDropdownBoxId = false;
            var keyType = {
                boundaryType: "botom",
                comparisonSwitch: 1,
                scrollType: true
            };
            var elementGetBoundingClientRect = function () {
                return {
                    botom: 15
                };
            };
            var findDropdownQueryGetBoundingClientRect = function () {
                return {
                    botom: 11
                };
            };
            var scroll = false;
            var scrollIntoView = function (input) {
                scroll = input;
            };
            var spy = spyOn(angular, "element").and.callFake(function (id) {
                if (constants.inputDropdownItemIdPrefix + "" + elementIndex === id) {
                    inputDropdownItemIdPrefix = true;
                    return [{ getBoundingClientRect: elementGetBoundingClientRect, scrollIntoView: scrollIntoView }];
                }
                else if (constants.inputDropdownBoxId === id) {
                    inputDropdownBoxId = true;
                    return [{ getBoundingClientRect: findDropdownQueryGetBoundingClientRect }];
                }
                else {
                    return null;
                }
            });
            service.ensureElementFocus(elementIndex, keyType);
            expect(scroll).toBeFalsy();
            expect(inputDropdownItemIdPrefix).toBeTruthy();
            expect(inputDropdownBoxId).toBeTruthy();
            spy.and.callThrough();
        });
        it("test ensureElementFocus when findElementQuery is not an array", function () {
            var elementIndex = 1;
            var inputDropdownItemIdPrefix = false;
            var inputDropdownBoxId = false;
            var keyType = {
                boundaryType: "botom",
                comparisonSwitch: 1,
                scrollType: true
            };
            var elementGetBoundingClientRect = function () {
                return {
                    botom: 15
                };
            };
            var findDropdownQueryGetBoundingClientRect = function () {
                return {
                    botom: 11
                };
            };
            var scroll = false;
            var scrollIntoView = function (input) {
                scroll = input;
            };
            var spy = spyOn(angular, "element").and.callFake(function (id) {
                if (constants.inputDropdownItemIdPrefix + "" + elementIndex === id) {
                    inputDropdownItemIdPrefix = true;
                    return [{ getBoundingClientRect: elementGetBoundingClientRect, scrollIntoView: scrollIntoView }];
                }
                else if (constants.inputDropdownBoxId === id) {
                    inputDropdownBoxId = true;
                    return [{ getBoundingClientRect: findDropdownQueryGetBoundingClientRect }];
                }
                else {
                    return null;
                }
            });
            service.ensureElementFocus(elementIndex, keyType);
            expect(scroll).toBeFalsy();
            expect(inputDropdownItemIdPrefix).toBeTruthy();
            expect(inputDropdownBoxId).toBeTruthy();
            spy.and.callThrough();
        });
        it("test ensureElementFocus when findElementQuery is not an array", function () {
            var elementIndex = 1;
            var inputDropdownItemIdPrefix = false;
            var inputDropdownBoxId = false;
            var keyType = {
                boundaryType: "botom",
                comparisonSwitch: 1,
                scrollType: true
            };
            var elementGetBoundingClientRect = function () {
                return {
                    botom: 15
                };
            };
            var findDropdownQueryGetBoundingClientRect = function () {
                return {
                    botom: 11
                };
            };
            var scroll = false;
            var scrollIntoView = function (input) {
                scroll = input;
            };
            var spy = spyOn(angular, "element").and.callFake(function (id) {
                if (constants.inputDropdownItemIdPrefix + "" + elementIndex === id) {
                    inputDropdownItemIdPrefix = true;
                    return [{ getBoundingClientRect: elementGetBoundingClientRect, scrollIntoView: scrollIntoView }];
                }
                else if (constants.inputDropdownBoxId === id) {
                    inputDropdownBoxId = true;
                    return [{ getBoundingClientRect: findDropdownQueryGetBoundingClientRect }];
                }
                else {
                    return null;
                }
            });
            service.ensureElementFocus(elementIndex, keyType);
            expect(scroll).toBeFalsy();
            expect(inputDropdownItemIdPrefix).toBeTruthy();
            expect(inputDropdownBoxId).toBeTruthy();
            spy.and.callThrough();
        });
        it("test ensureElementFocus", function () {
            var elementIndex = 1;
            var inputDropdownItemIdPrefix = false;
            var inputDropdownBoxId = false;
            var keyType = {
                boundaryType: "botom",
                comparisonSwitch: 1,
                scrollType: true
            };
            var elementGetBoundingClientRect = function () {
                return {
                    botom: 10
                };
            };
            var findDropdownQueryGetBoundingClientRect = function () {
                return {
                    botom: 11
                };
            };
            var scroll = false;
            var scrollIntoView = function (input) {
                scroll = input;
            };
            var spy = spyOn(angular, "element").and.callFake(function (id) {
                if (constants.inputDropdownItemIdPrefix + "" + elementIndex === id) {
                    inputDropdownItemIdPrefix = true;
                    return [{ getBoundingClientRect: elementGetBoundingClientRect, scrollIntoView: scrollIntoView }];
                }
                else if (constants.inputDropdownBoxId === id) {
                    inputDropdownBoxId = true;
                    return [{ getBoundingClientRect: findDropdownQueryGetBoundingClientRect }];
                }
                else {
                    return null;
                }
            });
            service.ensureElementFocus(elementIndex, keyType);
            expect(inputDropdownItemIdPrefix).toBeTruthy();
            expect(inputDropdownBoxId).toBeTruthy();
            expect(scroll).toBeTruthy();
            spy.and.callThrough();
        });
        it("test ensureElementFocus scrollType = false", function () {
            var elementIndex = 1;
            var inputDropdownItemIdPrefix = false;
            var inputDropdownBoxId = false;
            var keyType = {
                boundaryType: "botom",
                comparisonSwitch: 1,
                scrollType: true
            };
            var elementGetBoundingClientRect = function () {
                return {
                    botom: 15
                };
            };
            var findDropdownQueryGetBoundingClientRect = function () {
                return {
                    botom: 11
                };
            };
            var scroll = false;
            var scrollIntoView = function (input) {
                scroll = input;
            };
            var spy = spyOn(angular, "element").and.callFake(function (id) {
                if (constants.inputDropdownItemIdPrefix + "" + elementIndex === id) {
                    inputDropdownItemIdPrefix = true;
                    return [{ getBoundingClientRect: elementGetBoundingClientRect, scrollIntoView: scrollIntoView }];
                }
                else if (constants.inputDropdownBoxId === id) {
                    inputDropdownBoxId = true;
                    return [{ getBoundingClientRect: findDropdownQueryGetBoundingClientRect }];
                }
                else {
                    return null;
                }
            });
            service.ensureElementFocus(elementIndex, keyType);
            expect(inputDropdownItemIdPrefix).toBeTruthy();
            expect(inputDropdownBoxId).toBeTruthy();
            expect(scroll).toBeFalsy();
            spy.and.callThrough();
        });
    });
}());
(function () {
    'use strict';
    describe('directive: luhn', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, el;
        //beforeEach(angular.mock.module(function ($provide) {
        //    $provide.value('genericRepo', hctraMocks.genericRepo());
        //}));
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            el = angular.element('<input type="text" ng-model="model" luhn></input>');
            scope = $rootScope.$new();
            scope.model = "";
            $compile(el)(scope);
            scope.$digest();
        }));
        it('should begin as valid', function () {
            // If used on a field that is not required, you don't want it to fail luhn
            scope.model = "";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should accept a valid credit card number', function () {
            scope.model = "4111111111111111";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should reject a credit card number that is off by one digit', function () {
            scope.model = "4111121111111111"; // The '2' should be a '1'
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
            scope.model = "411111111111111"; // Too short
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
            scope.model = "41111111111111111"; // Too long
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: module-button", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveHtml, onModuleClickFuncCalled, recompileDirective;
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            onModuleClickFuncCalled = false;
            scope = $rootScope.$new();
            scope.onModuleClickFunc = function () { return onModuleClickFuncCalled = true; };
            $templateCache.put("/app/directives/moduleButtonTemplate.html", $templateCache.get("app/directives/moduleButtonTemplate.html"));
            recompileDirective = function () {
                directiveHtml = angular.element("<module-button on-module-click='onModuleClickFunc()'>Some Content</module-button>");
                $compile(directiveHtml)(scope);
                scope.$digest();
            };
            recompileDirective();
        }));
        it("canary", function () {
            expect(true).toBe(true);
        });
        it("should call onModuleClickFunc when module is clicked", function () {
            expect(onModuleClickFuncCalled).toBeFalsy();
            directiveHtml.children()[0].click();
            expect(onModuleClickFuncCalled).toBeTruthy();
        });
        it("should retain content inside the directive tags", function () {
            expect(directiveHtml.children().first().children()[0].outerText).toBe("Some Content");
        });
    });
}());
(function () {
    "use strict";
    describe("directive: most-faq", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope;
        var directiveScope;
        var genericRepo;
        var linkLookupService;
        beforeEach(angular.mock.module(function ($provide) {
            genericRepo = {
                dataFactory: {
                    getCmsPageById: function () { }
                }
            };
            $provide.value("$state", hctraMocks.$state({}));
            $provide.value("$location", hctraMocks.$location());
            $provide.value('genericRepo', genericRepo);
            linkLookupService = jasmine.createSpyObj('linkLookupService', ['articleLookupById']);
            $provide.value('linkLookupService', linkLookupService);
        }));
        beforeEach(angular.mock.inject(function (_genericRepo_) {
            spyOn(genericRepo.dataFactory, "getCmsPageById").and.callFake(function () {
                return {
                    then: function (cb) {
                        cb({
                            cmsResponse: angular.toJson({
                                Query: {
                                    Results: [
                                        { Title: "faq 1" },
                                        { Title: "faq 2" },
                                        { Title: "faq 3" },
                                        { Title: "faq 4" },
                                        { Title: "faq 5" },
                                        { Title: "faq 6" }
                                    ]
                                }
                            }),
                            errors: [],
                            alerts: []
                        });
                    }
                };
            });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.form = {};
            $templateCache.put("/app/directives/helpAndSupport/mostFaqTemplate.html", $templateCache.get("app/directives/helpAndSupport/mostFaqTemplate.html"));
            var el = angular.element("<form name=\"form\"><most-faq></most-faq></form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should begin as defined", function () {
            expect(directiveScope).toBeDefined();
        });
        it("should begin as valid", function () {
            expect(directiveScope.mostFaq).toBeTruthy();
        });
        it("should have called linklookup service", function () {
            directiveScope.searchMostFaq({});
            expect(linkLookupService.articleLookupById).toHaveBeenCalled();
        });
        it("should not have called linklookup service", function () {
            var blank = undefined;
            directiveScope.searchMostFaq(blank);
            expect(linkLookupService.articleLookupById).not.toHaveBeenCalled();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: new-alternate-email", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("validationService", function () { return {}; });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.addMissingInformation = {};
            scope.addMissingInformation.alternateEmail = "";
            scope.addMissingInformation.confirmAlternateEmail = "";
            scope.form = {};
            $templateCache.put("/app/directives/newAlternateEmailTemplate.html", $templateCache.get("app/directives/newAlternateEmailTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<new-alternate-email parent-form=\"form\" alternate-email=\"addMissingInformation.alternateEmail\" " +
                "confirm-alternate-email=\"addMissingInformation.confirmAlternateEmail\">" +
                "</new-alternate-email>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an valid form", function () {
            expect(scope.form.$invalid).toBeFalsy();
            expect(scope.form.$valid).toBeTruthy();
        });
        it("should accept valid email", function () {
            scope.addMissingInformation.alternateEmail = "test@test.com";
            scope.$digest();
            expect(scope.form.alternateEmail.$valid).toBeTruthy();
            expect(scope.form.alternateEmail.$invalid).toBeFalsy();
            scope.addMissingInformation.alternateEmail = "test1-test2_test3@test.co.uk";
            scope.$digest();
            expect(scope.form.alternateEmail.$valid).toBeTruthy();
            expect(scope.form.alternateEmail.$invalid).toBeFalsy();
        });
        it("should reject invalid email", function () {
            scope.addMissingInformation.alternateEmail = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.alternateEmail.$valid).toBeFalsy();
            expect(scope.form.alternateEmail.$invalid).toBeTruthy();
            scope.addMissingInformation.alternateEmail = "test@test";
            scope.$digest();
            expect(scope.form.alternateEmail.$valid).toBeFalsy();
            expect(scope.form.alternateEmail.$invalid).toBeTruthy();
            scope.addMissingInformation.alternateEmail = "test@";
            scope.$digest();
            expect(scope.form.alternateEmail.$valid).toBeFalsy();
            expect(scope.form.alternateEmail.$invalid).toBeTruthy();
            scope.addMissingInformation.alternateEmail = "@test";
            scope.$digest();
            expect(scope.form.alternateEmail.$valid).toBeFalsy();
            expect(scope.form.alternateEmail.$invalid).toBeTruthy();
            scope.addMissingInformation.alternateEmail = "test.com";
            scope.$digest();
            expect(scope.form.alternateEmail.$valid).toBeFalsy();
            expect(scope.form.alternateEmail.$invalid).toBeTruthy();
        });
        it("should be invalid if confirm alternate email does not match alternate email", function () {
            scope.addMissingInformation.alternateEmail = "test@test.com";
            scope.addMissingInformation.confirmAlternateEmail = "different@test.com";
            scope.$digest();
            expect(scope.form.confirmAlternateEmail.$valid).toBeFalsy();
            expect(scope.form.confirmAlternateEmail.$invalid).toBeTruthy();
        });
        it("should be valid if confirm alternate email matches alternate email", function () {
            scope.addMissingInformation.alternateEmail = "test@test.com";
            scope.addMissingInformation.confirmAlternateEmail = "test@test.com";
            scope.$digest();
            expect(scope.form.confirmAlternateEmail.$valid).toBeTruthy();
            expect(scope.form.confirmAlternateEmail.$invalid).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: new-email", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("validationService", function () { return {}; });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.addMissingInformation = {};
            scope.addMissingInformation.email = "";
            scope.addMissingInformation.confirmEmail = "";
            scope.form = {};
            $templateCache.put("/app/directives/newEmailTemplate.html", $templateCache.get("app/directives/newEmailTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<new-email parent-form=\"form\" email=\"addMissingInformation.email\" " +
                "confirm-email=\"addMissingInformation.confirmEmail\">" +
                "</new-email>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid email", function () {
            scope.addMissingInformation.email = "test@test.com";
            scope.$digest();
            expect(scope.form.email.$valid).toBeTruthy();
            expect(scope.form.email.$invalid).toBeFalsy();
            scope.addMissingInformation.email = "test1-test2_test3@test.co.uk";
            scope.$digest();
            expect(scope.form.email.$valid).toBeTruthy();
            expect(scope.form.email.$invalid).toBeFalsy();
        });
        it("should reject invalid email", function () {
            scope.addMissingInformation.email = "";
            scope.$digest();
            expect(scope.form.email.$valid).toBeFalsy();
            expect(scope.form.email.$invalid).toBeTruthy();
            scope.addMissingInformation.email = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.email.$valid).toBeFalsy();
            expect(scope.form.email.$invalid).toBeTruthy();
            scope.addMissingInformation.email = "test@test";
            scope.$digest();
            expect(scope.form.email.$valid).toBeFalsy();
            expect(scope.form.email.$invalid).toBeTruthy();
            scope.addMissingInformation.email = "test@";
            scope.$digest();
            expect(scope.form.email.$valid).toBeFalsy();
            expect(scope.form.email.$invalid).toBeTruthy();
            scope.addMissingInformation.email = "@test";
            scope.$digest();
            expect(scope.form.email.$valid).toBeFalsy();
            expect(scope.form.email.$invalid).toBeTruthy();
            scope.addMissingInformation.email = "test.com";
            scope.$digest();
            expect(scope.form.email.$valid).toBeFalsy();
            expect(scope.form.email.$invalid).toBeTruthy();
        });
        it("should be invalid if confirm email does not match email", function () {
            scope.addMissingInformation.email = "test@test.com";
            scope.addMissingInformation.confirmEmail = "different@test.com";
            scope.$digest();
            expect(scope.form.confirmEmail.$valid).toBeFalsy();
            expect(scope.form.confirmEmail.$invalid).toBeTruthy();
        });
        it("should be valid if confirm email matches email", function () {
            scope.addMissingInformation.email = "test@test.com";
            scope.addMissingInformation.confirmEmail = "test@test.com";
            scope.$digest();
            expect(scope.form.confirmEmail.$valid).toBeTruthy();
            expect(scope.form.confirmEmail.$invalid).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: new-password", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", function () { return {}; });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.form = {};
            scope.password = "";
            scope.confirmPassword = "";
            $templateCache.put("/app/directives/newPasswordTemplate.html", $templateCache.get("app/directives/newPasswordTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<new-password parent-form=\"form\" confirm-password=\"confirmPassword\" password=\"password\">" +
                "</new-password>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid password", function () {
            scope.password = "password-_@.";
            scope.$digest();
            expect(scope.form.password.$valid).toBeTruthy();
            expect(scope.form.password.$invalid).toBeFalsy();
            scope.password = "12345678";
            scope.$digest();
            expect(scope.form.password.$valid).toBeTruthy();
            expect(scope.form.password.$invalid).toBeFalsy();
            scope.password = "1234567890123456";
            scope.$digest();
            expect(scope.form.password.$valid).toBeTruthy();
            expect(scope.form.password.$invalid).toBeFalsy();
        });
        it("should reject invalid password", function () {
            scope.password = "";
            scope.$digest();
            expect(scope.form.password.$valid).toBeFalsy();
            expect(scope.form.password.$invalid).toBeTruthy();
            scope.password = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.password.$valid).toBeFalsy();
            expect(scope.form.password.$invalid).toBeTruthy();
            scope.password = "1234567";
            scope.$digest();
            expect(scope.form.password.$valid).toBeFalsy();
            expect(scope.form.password.$invalid).toBeTruthy();
            scope.password = "12345678901234567";
            scope.$digest();
            expect(scope.form.password.$valid).toBeFalsy();
            expect(scope.form.password.$invalid).toBeTruthy();
        });
        it("should be invalid if confirm confirm password does not match password", function () {
            scope.password = "password-_@.";
            scope.confirmPassword = "nomatchpass";
            scope.$digest();
            expect(scope.form.confirmPassword.$valid).toBeFalsy();
            expect(scope.form.confirmPassword.$invalid).toBeTruthy();
        });
        it("should be valid if confirm password question matches password", function () {
            scope.password = "passmatch";
            scope.confirmPassword = "passmatch";
            scope.$digest();
            expect(scope.form.confirmPassword.$valid).toBeTruthy();
            expect(scope.form.confirmPassword.$invalid).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: new-security-question", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, displayedMessage;
        beforeEach(angular.mock.module(function () {
            displayedMessage = {
                value: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("validationService", function () { return {}; });
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
            $provide.value("serverErrorService", function () {
                return {
                    handleServerError: function () {
                        return;
                    }
                };
            });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.addMissingInformation = {};
            scope.form = {};
            $templateCache.put("/app/directives/newSecurityQuestionTemplate.html", $templateCache.get("app/directives/newSecurityQuestionTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<new-security-question parent-form=\"form\" security-answer=\"addMissingInformation.securityAnswer\" " +
                "confirm-security-answer=\"addMissingInformation.confirmSecurityAnswer\">" +
                "</new-security-question>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid security answer", function () {
            scope.addMissingInformation.securityAnswer = "My Answer.,?\"'";
            scope.$digest();
            expect(scope.form.securityAnswer.$valid).toBeTruthy();
            expect(scope.form.securityAnswer.$invalid).toBeFalsy();
            scope.addMissingInformation.securityAnswer = "12";
            scope.$digest();
            expect(scope.form.securityAnswer.$valid).toBeTruthy();
            expect(scope.form.securityAnswer.$invalid).toBeFalsy();
            scope.addMissingInformation.securityAnswer = "1234567890123456789";
            scope.$digest();
            expect(scope.form.securityAnswer.$valid).toBeTruthy();
            expect(scope.form.securityAnswer.$invalid).toBeFalsy();
        });
        it("should reject invalid security answer", function () {
            scope.addMissingInformation.securityAnswer = "";
            scope.$digest();
            expect(scope.form.securityAnswer.$valid).toBeFalsy();
            expect(scope.form.securityAnswer.$invalid).toBeTruthy();
            scope.addMissingInformation.securityAnswer = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.securityAnswer.$valid).toBeFalsy();
            expect(scope.form.securityAnswer.$invalid).toBeTruthy();
            scope.addMissingInformation.securityAnswer = "";
            scope.$digest();
            expect(scope.form.securityAnswer.$valid).toBeFalsy();
            expect(scope.form.securityAnswer.$invalid).toBeTruthy();
            scope.addMissingInformation.securityAnswer = "123456789012345678901";
            scope.$digest();
            expect(scope.form.securityAnswer.$valid).toBeFalsy();
            expect(scope.form.securityAnswer.$invalid).toBeTruthy();
        });
        it("should be invalid if confirm security question does not match security question", function () {
            scope.addMissingInformation.securityAnswer = "My Answer.,?\"'";
            scope.addMissingInformation.confirmSecurityAnswer = "does not match";
            scope.$digest();
            expect(scope.form.confirmSecurityAnswer.$valid).toBeFalsy();
            expect(scope.form.confirmSecurityAnswer.$invalid).toBeTruthy();
        });
        it("should be valid if confirm security question matches security question", function () {
            scope.addMissingInformation.securityAnswer = "matches";
            scope.addMissingInformation.confirmSecurityAnswer = "matches";
            scope.$digest();
            expect(scope.form.confirmSecurityAnswer.$valid).toBeTruthy();
            expect(scope.form.confirmSecurityAnswer.$invalid).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: not-equal-to", function () {
        var scope, compile;
        beforeEach(function () {
            angular.mock.module("HCTRAModule");
            angular.mock.inject(function ($rootScope, $compile) {
                scope = $rootScope.$new();
                compile = $compile;
            });
            compile(angular.element("<form name=\"testForm\">\n                    <input type=\"text\" name=\"original\" ng-model=\"pair.original\">\n                    <input type=\"text\" name=\"shouldMatch\" ng-model=\"pair.shouldMatch\" not-equal-to=\"pair.original\">\n                    </form>"))(scope);
            scope.$digest();
        });
        it("canary", function () {
            expect(true).toBe(true);
        });
        [undefined, "", "a", "some val", "$1$5 val"].forEach(function (shouldMatch) {
            it("should set validator notEqualTo to false when original undefined", function () {
                scope.testForm.original.$setViewValue(undefined);
                scope.testForm.shouldMatch.$setViewValue(shouldMatch);
                expect(scope.testForm.shouldMatch.$error["notEqualTo"]).toBeFalsy();
            });
        });
        [undefined, "", "a", "some val", "$1$5 val"].forEach(function (shouldMatch) {
            it("should set validator notEqualTo to false when original  is empty string", function () {
                scope.testForm.original.$setViewValue("");
                scope.testForm.shouldMatch.$setViewValue(shouldMatch);
                expect(scope.testForm.shouldMatch.$error["notEqualTo"]).toBeFalsy();
            });
        });
        [undefined, "", "a", "some val", "$1$5 val"].forEach(function (shouldMatch) {
            it("should set validator notEqualTo to false when shouldMatch does not equal orginal", function () {
                scope.testForm.original.$setViewValue("a value");
                scope.testForm.shouldMatch.$setViewValue(shouldMatch);
                expect(scope.testForm.shouldMatch.$error["notEqualTo"]).toBeFalsy();
            });
        });
        it("should set validator notEqualTo to true when shouldMatch equals orginal", function () {
            scope.testForm.original.$setViewValue("some value");
            scope.testForm.shouldMatch.$setViewValue("some value");
            expect(scope.testForm.shouldMatch.$error["notEqualTo"]).toBeTruthy();
        });
    });
})();
(function () {
    "use strict";
    describe("directive: one-time-enter-amount", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope;
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", function () { return {}; });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            $templateCache.put("/app/directives/account/makeOneTimePayment/oneTimeEnterAmount.html", $templateCache.get("app/directives/account/makeOneTimePayment/oneTimeEnterAmount.html"));
            var el = angular.element("<form name=\"form\">" +
                "<one-time-enter-amount form-name=\"form\" float-amount=\"floatAmount\" show-amount=\"showAmount\" " +
                "payment-amount=\"paymentAmount\" on-amount-change=\"onAmountChange\">" +
                "</one-time-enter-amount>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with valid default amount of 10", function () {
            expect(scope.form.$valid).toBeTruthy();
            expect(scope.form.$invalid).toBeFalsy();
            expect(scope.floatAmount).toBe(10);
        });
        it("should accept valid amounts and return proper float", function () {
            scope.paymentAmount = "$30.00";
            scope.$digest();
            scope.onAmountChange();
            scope.$digest();
            expect(scope.form.$valid).toBeTruthy();
            expect(scope.form.$invalid).toBeFalsy();
            expect(scope.floatAmount).toBe(30);
            scope.paymentAmount = "$30";
            scope.$digest();
            scope.onAmountChange();
            scope.$digest();
            expect(scope.form.$valid).toBeTruthy();
            expect(scope.form.$invalid).toBeFalsy();
            expect(scope.floatAmount).toBe(30);
            scope.paymentAmount = "30";
            scope.$digest();
            scope.onAmountChange();
            scope.$digest();
            expect(scope.form.$valid).toBeTruthy();
            expect(scope.form.$invalid).toBeFalsy();
            expect(scope.floatAmount).toBe(30);
            // scope.paymentAmount = "$.30";
            // scope.$digest();
            // scope.onAmountChange();
            // scope.$digest();
            // expect(scope.form.$valid).toBeTruthy();
            // expect(scope.form.$invalid).toBeFalsy();
            // expect(scope.floatAmount).toBe(.30);
            // scope.paymentAmount = ".30";
            // scope.$digest();
            // scope.onAmountChange();
            // scope.$digest();
            // expect(scope.form.$valid).toBeTruthy();
            // expect(scope.form.$invalid).toBeFalsy();
            // expect(scope.floatAmount).toBe(.30);
        });
        it("should reject invalid amounts", function () {
            scope.paymentAmount = "";
            scope.$digest();
            scope.onAmountChange();
            scope.$digest();
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
            scope.paymentAmount = "$";
            scope.$digest();
            scope.onAmountChange();
            scope.$digest();
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
            scope.paymentAmount = "$10.";
            scope.$digest();
            scope.onAmountChange();
            scope.$digest();
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
    });
}());
(function () {
    'use strict';
    describe('directive: optional-compare-to', function () {
        var scope, el;
        beforeEach(angular.mock.module('HCTRAModule'));
        //beforeEach(angular.mock.module(function ($provide) {
        //    $provide.value('genericRepo', hctraMocks.genericRepo());
        //}));
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            el = angular.element('<input type="text" ng-model="model" optional-compare-to="otherModelValue"></input>');
            scope = $rootScope.$new();
            scope.model = "";
            scope.otherModelValue = "";
            $compile(el)(scope);
            scope.$digest();
        }));
        it('should begin as valid', function () {
            // If used on a field that is not required, you don't want it to fail luhn
            scope.model = "";
            scope.otherModelValue = "";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should be valid if models match', function () {
            // If used on a field that is not required, you don't want it to fail luhn
            scope.model = "testvalue";
            scope.otherModelValue = "testvalue";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeTruthy();
            expect(el.hasClass("ng-invalid")).toBeFalsy();
        });
        it('should be invalid if models do not match', function () {
            // If used on a field that is not required, you don't want it to fail luhn
            scope.model = "test";
            scope.otherModelValue = "value";
            scope.$digest();
            expect(el.hasClass("ng-valid")).toBeFalsy();
            expect(el.hasClass("ng-invalid")).toBeTruthy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: paging-control", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, inState = {};
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("validationService", function () { return {}; });
            $provide.value("$state", hctraMocks.$state(inState));
            $provide.value("stateNames", hctraMocks.stateNames());
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.form = {};
            scope.pagingObject = {
                currentPage: 0,
                numberOfPages: 0,
                pageSize: ""
            };
            // scope.userInputData = { visiblePageNumber: (scope.data.currentPage) + 1 };
            scope.search = function () {
                scope.itWorked = true;
            };
            $templateCache.put("/app/directives/pagingControlTemplate.html", $templateCache.get("app/directives/pagingControlTemplate.html"));
            var element = angular.element("<form name=\"form\">" +
                "<paging-control data=\"pagingObject\" search-function=\"search()\" form=\"form\">" +
                "</paging-control>" +
                "</form>");
            $compile(element)(scope);
            scope.$digest();
            directiveScope = element.children().isolateScope();
        }));
        //todo: add unit test for watch of paging size
        it("ensure that visible page number variable has loaded correctly", function () {
            expect(directiveScope.userInputData.visiblePageNumber).toBe(1);
        });
        it("test lastPage functionality", function () {
            directiveScope.data.currentPage = 0;
            directiveScope.data.numberOfPages = 1;
            scope.itWorked = false;
            directiveScope.lastPage();
            expect(scope.itWorked).toBeFalsy();
            directiveScope.data.currentPage = 0;
            directiveScope.data.numberOfPages = 2;
            scope.itWorked = false;
            directiveScope.lastPage();
            expect(scope.itWorked).toBeTruthy();
        });
        it("test firstPage functionality", function () {
            directiveScope.data.currentPage = 0;
            scope.itWorked = false;
            directiveScope.firstPage();
            expect(scope.itWorked).toBeFalsy();
            directiveScope.data.currentPage = 1;
            scope.itWorked = false;
            directiveScope.firstPage();
            expect(scope.itWorked).toBeTruthy();
        });
        it("test manual update of page number (check currentVisiblePageNumber validation)", function () {
            directiveScope.data.numberOfPages = 2;
            directiveScope.userInputData.visiblePageNumber = 0;
            directiveScope.$digest();
            scope.itWorked = false;
            directiveScope.manualPageUpdate();
            expect(scope.itWorked).toBeFalsy();
            directiveScope.userInputData.visiblePageNumber = "";
            directiveScope.$digest();
            scope.itWorked = false;
            directiveScope.manualPageUpdate();
            expect(scope.itWorked).toBeFalsy();
            directiveScope.userInputData.visiblePageNumber = 3;
            directiveScope.$digest();
            scope.itWorked = false;
            directiveScope.manualPageUpdate();
            expect(scope.itWorked).toBeFalsy();
            directiveScope.userInputData.visiblePageNumber = 1;
            directiveScope.$digest();
            scope.itWorked = false;
            directiveScope.manualPageUpdate();
            expect(scope.itWorked).toBeTruthy();
        });
    });
}());
(function () {
    "use strict";
    describe("directive: paging infinite scroll", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, inState;
        beforeEach(angular.mock.module(function () {
            inState = {
                statePath: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$state", hctraMocks.$state(inState));
            $provide.value("stateNames", hctraMocks.stateNames());
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            $templateCache.put("/app/directives/pagingInfiniteScrollTemplate.html", $templateCache.get("app/directives/pagingInfiniteScrollTemplate.html"));
            var el = angular.element("<paging-infinite-scroll search=\"triggerPureSearchInChildState()\" " +
                "infinite-scroll-is-disabled=\"endOfDataReached || virtualScrollisPaused || isDesktop\" " +
                "title-type=\"titleType\" form=\"searchForm\" navigation-urls=\"navigationUrls\" " +
                "total-items=\"totalItems\" article-array=\"articleArray\" paging-object=\"pagingObject\" " +
                "title-id=\"search-results\" archive-type-checker=\"archiveTypeChecker\" " +
                "article-not-found-text=\"articleNotFoundText\" mobile-search=\"performSearch()\">" +
                "</paging-infinite-scroll>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.isolateScope();
        }));
        it("should be defined", function () {
            scope.totalItems = 1;
            scope.$digest();
            expect(directiveScope).toBeDefined();
        });
        it("should have articles when articles equals one", function () {
            scope.totalItems = 1;
            scope.$digest();
            expect(directiveScope.hasArticles).toBeTruthy();
        });
        it("should not have articles when articles equals zero", function () {
            scope.totalItems = 0;
            scope.$digest();
            expect(directiveScope.hasArticles).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    // describe("directive: readMoreOrLess", () => {
    //     beforeEach(angular.mock.module("HCTRATemplates"));
    //     beforeEach(angular.mock.module("HCTRAModule"));
    //     let scope,
    //         directiveScope;
    //     let READLESS: string = "Read Less";
    //     let READMORE: string = "Read More";
    //     let SHORTDESCRIPTION: string = "short Description";
    //     let LONGDESCRIPTION: string = "long Description";
    //     let TITLE: string = "Title";
    //     beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
    //         $provide.value("readMoreOrLessService", {
    //             readLess: "Read Less",
    //             readMore: "Read More",
    //             getReadMoreOrLessInitialState: function () {
    //                 return ({
    //                     content: LONGDESCRIPTION,
    //                     expanderText: READLESS,
    //                     displayBreakoutPageLink: false,
    //                     displayReadMoreOrLessLink: true,
    //                     articleUrl: "url"
    //                 });
    //             }
    //         });
    //     }));
    //     beforeEach(angular.mock.inject(($rootScope: angular.IRootScopeService,
    //         $templateCache: angular.ITemplateCacheService,
    //         $compile: angular.ICompileService) => {
    //         scope = $rootScope.$new();
    //         $templateCache.put("/app/directives/cms/readMoreOrLessTemplate.html",
    //             $templateCache.get("app/directives/cms/readMoreOrLessTemplate.html"));
    //         let el: angular.IAugmentedJQuery = angular.element("<read-more-or-less title-name=\"titleName\" " +
    //             "long-content=\"longDescription\" short-content=\"shortDescription\" default-to-more=\"defaultToMore\" " +
    //             "item-path=\"itemPath\" item-id=\"itemID\">" +
    //             "</read-more-or-less>");
    //         $compile(el)(scope);
    //         scope.$digest();
    //         directiveScope = el.isolateScope();
    //     }));
    //     it("should be defined", () => {
    //         expect(directiveScope).toBeDefined();
    //     });
    //     [
    //         "",
    //         undefined,
    //         null
    //     ].forEach((titleName) => {
    //         it(`should set vm to empty object when titleName "${titleName}"`, () => {
    //             scope.titleName = titleName;
    //             scope.defaultToMore = true;
    //             scope.shortDescription = SHORTDESCRIPTION;
    //             scope.longDescription = LONGDESCRIPTION;
    //             scope.itemPath = "something";
    //             scope.itemID = "something";
    //             scope.$digest();
    //             expect(directiveScope.vm).toEqual({});
    //         });
    //     });
    //     it("should be toggled when ExpanderClicked", function () {
    //         scope.titleName = TITLE;
    //         scope.defaultToMore = true;
    //         scope.shortDescription = SHORTDESCRIPTION;
    //         scope.longDescription = LONGDESCRIPTION;
    //         scope.itemPath = "something";
    //         scope.itemID = "something";
    //         scope.$digest();
    //         expect(directiveScope.vm).toEqual({
    //             content: LONGDESCRIPTION,
    //             expanderText: READLESS,
    //             displayBreakoutPageLink: false,
    //             displayReadMoreOrLessLink: true,
    //             articleUrl: "url"
    //         });
    //         directiveScope.expanderClicked();
    //         expect(directiveScope.vm).toEqual({
    //             content: SHORTDESCRIPTION,
    //             expanderText: READMORE,
    //             displayBreakoutPageLink: false,
    //             displayReadMoreOrLessLink: true,
    //             articleUrl: "url"
    //         });
    //         directiveScope.expanderClicked();
    //         expect(directiveScope.vm).toEqual({
    //             content: LONGDESCRIPTION,
    //             expanderText: READLESS,
    //             displayBreakoutPageLink: false,
    //             displayReadMoreOrLessLink: true,
    //             articleUrl: "url"
    //         });
    //     });
    // });
}());
(function () {
    'use strict';
    describe('directive: select-on-click', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, el;
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            el = angular.element('<input type="text" select-on-click></input>');
            scope = $rootScope.$new();
            $compile(el)(scope);
            scope.$digest();
        }));
        beforeEach(function () {
            spyOn(el[0], 'setSelectionRange');
        });
        it('input should be selected when clicked', function () {
            el.val("$0.00");
            el.click();
            expect(el.val()).toBe("$0.00");
            //expect(el.constructor.name).toBe("jQuery");
            //expect(el[0].constructor.name).toBe("HTMLInputElement");
            expect(el[0].setSelectionRange).toHaveBeenCalledWith(0, el.val().length);
        });
    });
}());
(function () {
    'use strict';
    describe('directive: storefront menu directive', function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, el, compile, rootScope, workItemElements;
        var storefrontService, storefrontModalService, $state, $q;
        var workItems, currentItem, taskNotCompleteIcon, taskCompleteIcon;
        function returnResolved(value) {
            return $q.resolve(value);
        }
        function returnRejected(obj) {
            return $q.reject(obj);
        }
        beforeEach(angular.mock.module(function ($provide) {
            try {
                storefrontService = jasmine.createSpyObj("storefrontService", ["currentWorkItem", "getTaskCompleteIcon", "getTaskNotCompleteIcon", "skip", "isWorkflowActive"]);
                storefrontService.isWorkflowActive.and.returnValue(true);
                storefrontService.currentWorkItem.and.callFake(function () {
                    return currentItem;
                });
                storefrontService.getTaskCompleteIcon.and.returnValue(taskCompleteIcon =
                    { Url: 'complete.ico', Alt: 'completeIcon' });
                storefrontService.getTaskNotCompleteIcon.and.returnValue(taskNotCompleteIcon =
                    { Url: 'notcomplete.ico', Alt: 'notCompleteIcon' });
                storefrontService.skip.and.callFake(function (id) {
                    currentItem = workItems.filter(function (w) { return w.id === id; })[0];
                    return currentItem ? returnResolved(currentItem.states[0]) : returnRejected(currentItem);
                });
                storefrontModalService = jasmine.createSpyObj("storefrontModalService", ["skipTaskMessage"]);
                $state = jasmine.createSpyObj("$state", ["go"]);
                $provide.value('StorefrontService', storefrontService);
                $provide.value('StorefrontModalService', storefrontModalService);
                $provide.value('$state', $state);
            }
            catch (e) {
                fail(e);
            }
        }));
        beforeEach(angular.mock.inject(function ($injector, $compile, $templateCache, $rootScope) {
            try {
                $q = $injector.get("$q");
                compile = $compile;
                rootScope = $rootScope;
                var templatePath = "app/directives/storefront/storefrontMenuTemplate.html";
                $templateCache.put("/" + templatePath, $templateCache.get(templatePath));
            }
            catch (e) {
                fail(e);
            }
        }));
        function buildDirective() {
            try {
                scope = rootScope.$new();
                el = angular.element("<div storefront-menu></div>");
                storefrontService.workItems = workItems;
                compile(el)(scope);
                scope.$digest();
                workItemElements = el.children();
            }
            catch (e) {
                fail(e);
            }
        }
        describe('basic functionality', function () {
            beforeEach(function () {
                currentItem = {
                    isSelected: true,
                    id: '1',
                    storefrontDisplayName: '1',
                    isSkippable: true,
                    selectedIcon: {
                        image: 'selected.ico',
                        alt: 'selected'
                    },
                    unselectedIcon: {
                        image: 'unselected.ico',
                        alt: 'unselected'
                    }
                };
                workItems = [currentItem, {
                        isSelected: false,
                        id: '2',
                        storefrontDisplayName: '2',
                        isSkippable: true,
                        selectedIcon: {
                            image: 'selected.ico',
                            alt: 'selected'
                        },
                        unselectedIcon: {
                            image: 'unselected.ico',
                            alt: 'unselected'
                        }
                    }, {
                        isSelected: true,
                        id: '3',
                        storefrontDisplayName: '3',
                        isSkippable: true,
                        selectedIcon: {
                            image: 'selected.ico',
                            alt: 'selected'
                        },
                        unselectedIcon: {
                            image: 'unselected.ico',
                            alt: 'unselected'
                        },
                        states: ['state']
                    }];
                buildDirective();
            });
            it('only shows selected workitems', function () {
                expect(workItemElements.length).toBe(3);
                var selected = workItemElements.filter(":not(.ng-hide)").find("label");
                expect(selected.length).toBe(2);
                var labels = selected.map(function (i, elm) { return angular.element(elm).text(); });
                expect(labels).toContain('1');
                expect(labels).toContain('3');
            });
            it('goes to item when clicked', function () {
                storefrontModalService.skipTaskMessage.and.returnValue(returnResolved(true));
                var elm = workItemElements.filter(":not(.ng-hide)").find("label:contains('3')").parent();
                elm.trigger('click');
                rootScope.$digest();
                expect(storefrontModalService.skipTaskMessage).toHaveBeenCalled();
                expect(storefrontService.skip).toHaveBeenCalledWith(workItems[2].id);
                rootScope.$digest();
                expect($state.go).toHaveBeenCalledWith(workItems[2].states[0]);
            });
            it('has active class when it is the current work item', function () {
                var text = currentItem.storefrontDisplayName;
                var elm = workItemElements.filter(":not(.ng-hide)").find("label:contains('" + text + "')").parent('.active');
                expect(elm.length).toBe(1);
            });
            it('shows correct icons when active or not active', function () {
                //active/inactive items use the existing selected/noselected icons, but reversed!!! this will ensure this is controlled
                var activeElms = workItemElements.filter(".active:not(.ng-hide)").find("img[src='unselected.ico'][alt='unselected']");
                var inactiveElms = workItemElements.filter(":not(.active):not(.ng-hide)").find("img[src='selected.ico'][alt='selected']");
                expect(activeElms.length).toBe(1);
                expect(inactiveElms.length).toBe(1);
            });
        });
        describe('work item statuses functionality', function () {
            beforeEach(function () {
                workItems = [{
                        isSelected: true,
                        id: '1',
                        storefrontDisplayName: '1',
                        isSkippable: true,
                        isCompleted: false,
                        isUnsaved: false
                    }, {
                        isSelected: true,
                        id: '2',
                        storefrontDisplayName: '2',
                        isSkippable: true,
                        isCompleted: false,
                        isUnsaved: true
                    }, {
                        isSelected: true,
                        id: '3',
                        storefrontDisplayName: '3',
                        isSkippable: true,
                        isCompleted: true,
                        isUnsaved: false
                    }];
                buildDirective();
            });
            it('renders unsaved and completed with proper css and image data', function () {
                var allItems = workItemElements.filter(":not(.ng-hide)");
                var untouched = workItemElements.filter(":not(.ng-hide)").find("label:contains('1')").parent(":not(.complete)").find(".workItemSaveState");
                var notsaved = workItemElements.filter(":not(.ng-hide)").find("label:contains('2')").parent(":not(.complete)")
                    .find(".workItemSaveState > img[src='" + taskNotCompleteIcon.Url + "'][alt='" + taskNotCompleteIcon.Alt + "']");
                var complete = workItemElements.filter(":not(.ng-hide)").find("label:contains('3')").parent('.complete')
                    .find(".workItemSaveState > img[src='" + taskCompleteIcon.Url + "'][alt='" + taskCompleteIcon.Alt + "']");
                expect(allItems.length).toBe(3);
                expect(untouched.length).toBe(0);
                expect(notsaved.length).toBe(1);
                expect(complete.length).toBe(1);
            });
        });
    });
}());
(function () {
    'use strict';
    describe('directive: storefront-navigation', function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, el, dScope, compile, rootScope;
        var modalService, storefrontService, Promise, $state, stateNames;
        var onProceed, onCancel, onPrevious;
        function returnResolved(value) {
            return new Promise(function (resolve) { return resolve(value); });
        }
        function flush(promise) {
            rootScope.$apply();
            return promise;
        }
        beforeEach(angular.mock.module(function ($provide) {
            storefrontService = jasmine.createSpyObj("storefrontService", ["haltRedirectsUntil", "completeWorkItem", "isEnabled", "reset", "skip", "currentWorkItem"]);
            modalService = jasmine.createSpyObj("modalService", ["showGotoCsr", "skipTaskMessage"]);
            $state = jasmine.createSpyObj("$state", ["go"]);
            $provide.value("StorefrontModalService", modalService);
            $provide.value("StorefrontService", storefrontService);
            $provide.value("$state", $state);
        }));
        beforeEach(angular.mock.inject(function ($injector, $compile, $templateCache, $rootScope) {
            try {
                compile = $compile;
                rootScope = $rootScope;
                var win = $injector.get('$window');
                Promise = win.Promise;
                stateNames = $injector.get('stateNames');
                storefrontService.haltRedirectsUntil.and.callFake(function (callback) {
                    return callback();
                });
                var templatePath = "app/directives/storefront/storefrontNavigationTemplate.html";
                $templateCache.put("/" + templatePath, $templateCache.get(templatePath));
            }
            catch (e) {
                fail(e);
            }
        }));
        function buildDirective(formCompletion, csrResponse, preserveWorkItem) {
            scope = rootScope.$new();
            onProceed = jasmine.createSpy("onProceed", function () { });
            onCancel = jasmine.createSpy("onCancel", function () { });
            onPrevious = jasmine.createSpy("onPrevious", function () { });
            el = angular.element("<div storefront-navigation on-proceed='onProceed()' preserve-work-item=preserveWorkItem on-cancel='onCancel()' on-previous='onPrevious()'>TEST</div>");
            if (formCompletion) {
                el.attr('is-form-completion', 'true');
            }
            if (csrResponse) {
                el.attr('see-csr-response', csrResponse);
            }
            scope.onProceed = onProceed;
            scope.onCancel = onCancel;
            scope.onPrevious = onPrevious;
            scope.preserveWorkItem = preserveWorkItem;
            var newElm = compile(el)(scope);
            scope.$digest();
            dScope = newElm.children().scope().$parent;
        }
        describe('basic navigation', function () {
            describe("storefront not enabled", function () {
                beforeEach(function () {
                    storefrontService.isEnabled.and.returnValue(false);
                    buildDirective();
                });
                it('should not define any scope level actions', function () {
                    expect(dScope.seeCsr).not.toBeDefined();
                    expect(dScope.cancelAction).not.toBeDefined();
                    expect(dScope.continueAction).not.toBeDefined();
                    expect(dScope.gotoPrevious).not.toBeDefined();
                });
            });
            describe("storefront enabled, fullsitemode", function () {
                beforeEach(function () {
                    storefrontService.isEnabled.and.returnValue(true);
                    storefrontService.fullSiteMode = true;
                    buildDirective();
                });
                it('should not define any scope level actions', function () {
                    expect(dScope.seeCsr).not.toBeDefined();
                    expect(dScope.cancelAction).not.toBeDefined();
                    expect(dScope.continueAction).not.toBeDefined();
                    expect(dScope.gotoPrevious).not.toBeDefined();
                });
            });
            describe("storefront enabled and not fullsitemode", function () {
                beforeEach(function () {
                    storefrontService.isEnabled.and.returnValue(true);
                    storefrontService.fullSiteMode = false;
                    storefrontService.completeWorkItem.and.returnValue(returnResolved());
                    storefrontService.skip.and.returnValue(returnResolved());
                    buildDirective();
                });
                it('can proceed', function () {
                    //arrange
                    //act
                    dScope.continueAction && dScope.continueAction();
                    //assert
                    expect(dScope.continueAction).toBeDefined();
                    expect(onProceed).toHaveBeenCalled();
                    expect(storefrontService.completeWorkItem).not.toHaveBeenCalled();
                });
                it('can go previous', function () {
                    //arrange
                    //act
                    dScope.gotoPrevious && dScope.gotoPrevious();
                    //assert
                    expect(dScope.gotoPrevious).toBeDefined();
                    expect(onPrevious).toHaveBeenCalled();
                    expect(storefrontService.completeWorkItem).not.toHaveBeenCalled();
                    expect(storefrontService.skip).not.toHaveBeenCalled();
                });
                it('can cancel', function () {
                    //arrange
                    //act
                    var obj = dScope.cancelAction && dScope.cancelAction();
                    //assert
                    expect(dScope.cancelAction).toBeDefined();
                    expect(obj).toBeDefined();
                    obj && obj
                        .then(function () {
                        expect(onCancel).toHaveBeenCalled();
                        expect(storefrontService.skip).toHaveBeenCalled();
                    })
                        .catch(function (e) {
                        fail('should have been rejected: ' + e);
                    });
                });
                it('can cancel while preserving work item', function () {
                    //arrange
                    buildDirective(null, null, true);
                    //act
                    dScope.cancelAction && dScope.cancelAction();
                    //assert
                    expect(dScope.cancelAction).toBeDefined();
                    expect(onCancel).toHaveBeenCalled();
                    expect(storefrontService.completeWorkItem).not.toHaveBeenCalled();
                    expect(storefrontService.skip).not.toHaveBeenCalled();
                });
            });
            describe("storefront enabled and not fullsitemode, form completion", function () {
                beforeEach(function () {
                    storefrontService.isEnabled.and.returnValue(true);
                    storefrontService.fullSiteMode = false;
                    storefrontService.completeWorkItem.and.returnValue(returnResolved());
                    storefrontService.skip.and.returnValue(returnResolved());
                    buildDirective(true);
                });
                it('can continue', function () {
                    //arrange
                    //act
                    var promise = dScope.continueAction && dScope.continueAction();
                    //assert
                    expect(dScope.continueAction).toBeDefined();
                    expect(promise).toBeDefined();
                    flush(promise)
                        .then(function () {
                        expect(onProceed).toHaveBeenCalled();
                        expect(storefrontService.completeWorkItem).toHaveBeenCalled();
                    })
                        .catch(function (e) {
                        fail("should not have failed " + e);
                    });
                });
            });
        });
        describe('csr stuff', function () {
            beforeEach(function () {
                storefrontService.isEnabled.and.returnValue(true);
                storefrontService.fullSiteMode = false;
                storefrontService.reset.and.returnValue(returnResolved());
                modalService.showGotoCsr.and.returnValue(returnResolved(true));
                buildDirective(null, "this is a test");
            });
            it('can direct to csr', function () {
                //arrange
                $state.go.and.returnValue(returnResolved());
                storefrontService.reset.and.returnValue(returnResolved());
                //act
                var promise = dScope.showLoginHelpMessage && dScope.showLoginHelpMessage();
                //assert
                expect(dScope.showLoginHelpMessage).toBeDefined();
                expect(promise).toBeDefined();
                flush(promise)
                    .then(function () {
                    expect(modalService.showGotoCsr).toHaveBeenCalled();
                    expect(storefrontService.completeWorkItem).not.toHaveBeenCalled();
                    expect($state.go).toHaveBeenCalledWith(stateNames.storefrontSurvey);
                })
                    .catch(function (e) {
                    fail('should not have failed: ' + e);
                });
            });
        });
    });
}());
(function () {
    'use strict';
    xdescribe('directive: storefront ui directive', function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module('HCTRAModule'));
        var scope, el, compile, rootScope;
        var controller;
        beforeEach(angular.mock.module(function ($provide) {
            //replace with fake controller
            controller = jasmine.createSpyObj("StorefrontController", ["onCompletedWorkItem"]);
            $provide.value('StorefrontController', controller);
        }));
        beforeEach(angular.mock.inject(function ($injector, $compile, $templateCache, $rootScope) {
            try {
                compile = $compile;
                rootScope = $rootScope;
                var templatePath = "app/directives/storefront/storefrontUiTemplate.html";
                $templateCache.put("/" + templatePath, $templateCache.get(templatePath));
            }
            catch (e) {
                fail(e);
            }
        }));
        function buildDirective() {
            scope = rootScope.$new();
            el = angular.element("<storefront-ui></storefront-ui>");
            //scope. = ;
            compile(el)(scope);
            scope.$digest();
            // = el.children();
        }
        describe('basic functionality', function () {
            beforeEach(function () {
                buildDirective();
            });
            it('', function () {
            });
        });
    });
}());
(function () {
    "use strict";
    describe("directive: up-down-enter-interceptor", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, element;
        beforeEach(angular.mock.inject(function ($rootScope, $compile) {
            scope = $rootScope.$new();
            scope.keyActions = {
                upAction: function () { },
                downAction: function () { },
                enterAction: function (event) { if (event) {
                    scope.isDummy = true;
                } }
            };
            element = angular.element("<div up-down-enter-interceptor=\"keyActions\" \>");
            $compile(element)(scope);
            scope.$digest();
            spyOn(scope.keyActions, "upAction");
            spyOn(scope.keyActions, "downAction");
            spyOn(scope.keyActions, "enterAction");
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("keypress: verify correct method is called for 38 = up key", function () {
            var event = angular.element.Event("keypress");
            event.which = 38;
            element.triggerHandler(event);
            expect(scope.keyActions.upAction).toHaveBeenCalledTimes(1);
            expect(scope.keyActions.downAction).not.toHaveBeenCalled();
            expect(scope.keyActions.enterAction).not.toHaveBeenCalled();
        });
        it("keydown: verify correct method is called for 38 = up key", function () {
            var event = angular.element.Event("keydown");
            event.which = 38;
            element.triggerHandler(event);
            expect(scope.keyActions.upAction).toHaveBeenCalledTimes(1);
            expect(scope.keyActions.downAction).not.toHaveBeenCalled();
            expect(scope.keyActions.enterAction).not.toHaveBeenCalled();
        });
        it("keypress: verify correct method is called for 40 = down key", function () {
            var event = angular.element.Event("keypress");
            event.which = 40;
            element.triggerHandler(event);
            expect(scope.keyActions.upAction).not.toHaveBeenCalled();
            expect(scope.keyActions.downAction).toHaveBeenCalledTimes(1);
            expect(scope.keyActions.enterAction).not.toHaveBeenCalled();
        });
        it("keydown: verify correct method is called for 40 = down key", function () {
            var event = angular.element.Event("keydown");
            event.which = 40;
            element.triggerHandler(event);
            expect(scope.keyActions.upAction).not.toHaveBeenCalled();
            expect(scope.keyActions.downAction).toHaveBeenCalledTimes(1);
            expect(scope.keyActions.enterAction).not.toHaveBeenCalled();
        });
        it("keypress: verify correct method is called for 13 = enter key", function () {
            var event = angular.element.Event("keypress");
            event.which = 13;
            element.triggerHandler(event);
            expect(scope.keyActions.upAction).not.toHaveBeenCalled();
            expect(scope.keyActions.downAction).not.toHaveBeenCalled();
            expect(scope.keyActions.enterAction).toHaveBeenCalledTimes(1);
            expect(scope.keyActions.enterAction).toHaveBeenCalledWith(event);
        });
        it("keydown: verify correct method is called for 13 = enter key", function () {
            var event = angular.element.Event("keydown");
            event.which = 13;
            element.triggerHandler(event);
            expect(scope.keyActions.upAction).not.toHaveBeenCalled();
            expect(scope.keyActions.downAction).not.toHaveBeenCalled();
            expect(scope.keyActions.enterAction).toHaveBeenCalledTimes(1);
            expect(scope.keyActions.enterAction).toHaveBeenCalledWith(event);
        });
    });
}());
(function () {
    'use strict';
    describe('directive: validate-driver-license', function () {
        var scope, compile;
        var statesExceptTexas = [
            'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
            'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
            'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
            'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
            'SD', 'TN', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY', 'US'
        ];
        var allStates = Array.prototype.concat(statesExceptTexas, ['TX']);
        beforeEach(function () {
            angular.mock.module('HCTRAModule');
            angular.mock.inject(function ($rootScope, $compile) {
                scope = $rootScope.$new();
                compile = $compile;
            });
            compile(angular.element("<form name=\"driverLicenseForm\">\n                    <input type=\"text\" name=\"licenseState\" ng-model=\"customer.driverLicenseState\">\n                    <input type=\"text\" name=\"licenseNumber\" ng-model=\"customer.driverLicenseNumber\" validate-driver-license=\"customer.driverLicenseState\">\n                    </form>"))(scope);
            scope.$digest();
        });
        it('canary', function () {
            expect(true).toBe(true);
        });
        //alphaNumeric
        allStates.forEach(function (stateAbbreviation) {
            [
                '123abc',
                '123456',
                'abcdef',
                ''
            ].forEach(function (licenseNumber) {
                it("validator alphaNumeric is falsy for licenseNumber \"" + licenseNumber + "\" and state " + stateAbbreviation, function () {
                    scope.driverLicenseForm.licenseState.$setViewValue(stateAbbreviation);
                    scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                    expect(scope.driverLicenseForm.licenseNumber.$error['alphaNumeric']).toBeFalsy();
                });
            });
            [
                '123abc*#',
                '12.',
                'ab@',
                '&',
                '('
            ].forEach(function (licenseNumber) {
                it("validator alphaNumeric is true for licenseNumber \"" + licenseNumber + "\" and state " + stateAbbreviation, function () {
                    scope.driverLicenseForm.licenseState.$setViewValue(stateAbbreviation);
                    scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                    expect(scope.driverLicenseForm.licenseNumber.$error['alphaNumeric']).toBe(true);
                });
            });
        });
        //numericTexasDl
        statesExceptTexas.forEach(function (stateAbbreviation) {
            [
                '123456',
                '123abc*#',
                '12.', 'ab@',
                '&',
                '(',
                '123abc',
                '123456',
                'abcdef',
                ''
            ].forEach(function (licenseNumber) {
                it("validator numericTexasDl is falsy for licenseNumber \"" + licenseNumber + "\" and state " + stateAbbreviation, function () {
                    scope.driverLicenseForm.licenseState.$setViewValue(stateAbbreviation);
                    scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                    expect(scope.driverLicenseForm.licenseNumber.$error['numericTexasDl']).toBeFalsy();
                });
            });
        });
        [
            '0123456789',
            '9876543210',
            '12',
            '34',
            '7',
            ''
        ].forEach(function (licenseNumber) {
            it("validator numericTexasDl is falsy for licenseNumber \"" + licenseNumber + "\" and state TX", function () {
                scope.driverLicenseForm.licenseState.$setViewValue('TX');
                scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                expect(scope.driverLicenseForm.licenseNumber.$error['numericTexasDl']).toBeFalsy();
            });
        });
        [
            'abc',
            '123abc',
            '$$',
            '12#',
            'xyz'
        ].forEach(function (licenseNumber) {
            it("validator numericTexasDl is true for licenseNumber \"" + licenseNumber + "\" and state TX", function () {
                scope.driverLicenseForm.licenseState.$setViewValue('TX');
                scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                expect(scope.driverLicenseForm.licenseNumber.$error['numericTexasDl']).toBe(true);
            });
        });
        //firstDigitLessThanFiveTexasDL
        statesExceptTexas.forEach(function (stateAbbreviation) {
            [
                '923456',
                '623abc*#',
                '82.', 'ab@',
                '&',
                'a',
                ''
            ].forEach(function (licenseNumber) {
                it("validator firstDigitLessThanFiveTexasDl is falsy for licenseNumber \"" + licenseNumber + "\" and state " + stateAbbreviation, function () {
                    scope.driverLicenseForm.licenseState.$setViewValue(stateAbbreviation);
                    scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                    expect(scope.driverLicenseForm.licenseNumber.$error['firstDigitLessThanFiveTexasDl']).toBeFalsy();
                });
            });
        });
        [
            '0',
            '1',
            '2',
            '37',
            '45',
            ''
        ].forEach(function (licenseNumber) {
            it("validator firstDigitLessThanFiveTexasDl is falsy for licenseNumber \"" + licenseNumber + "\" and state TX", function () {
                scope.driverLicenseForm.licenseState.$setViewValue('TX');
                scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                expect(scope.driverLicenseForm.licenseNumber.$error['firstDigitLessThanFiveTexasDl']).toBeFalsy();
            });
        });
        [
            '5',
            '61',
            '732',
            '89',
            '912'
        ].forEach(function (licenseNumber) {
            it("validator firstDigitLessThanFiveTexasDl is true for licenseNumber \"" + licenseNumber + "\" and state TX", function () {
                scope.driverLicenseForm.licenseState.$setViewValue('TX');
                scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                expect(scope.driverLicenseForm.licenseNumber.$error['firstDigitLessThanFiveTexasDl']).toBe(true);
            });
        });
        //eightDigitTexasDl
        statesExceptTexas.forEach(function (stateAbbreviation) {
            [
                '923456',
                '623abc*#',
                '82.', 'ab@',
                '&',
                'a',
                ''
            ].forEach(function (licenseNumber) {
                it("validator eightDigitTexasDl is falsy for licenseNumber \"" + licenseNumber + "\" and state " + stateAbbreviation, function () {
                    scope.driverLicenseForm.licenseState.$setViewValue(stateAbbreviation);
                    scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                    expect(scope.driverLicenseForm.licenseNumber.$error['eightDigitTexasDl']).toBeFalsy();
                });
            });
        });
        [
            '01234567',
            '12345678',
            '25545646',
            ''
        ].forEach(function (licenseNumber) {
            it("validator eightDigitTexasDl is falsy for licenseNumber \"" + licenseNumber + "\" and state TX", function () {
                scope.driverLicenseForm.licenseState.$setViewValue('TX');
                scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                expect(scope.driverLicenseForm.licenseNumber.$error['eightDigitTexasDl']).toBeFalsy();
            });
        });
        [
            '0123456',
            '123456785',
            '2554564a',
            'asd'
        ].forEach(function (licenseNumber) {
            it("validator eightDigitTexasDl is true for licenseNumber \"" + licenseNumber + "\" and state TX", function () {
                scope.driverLicenseForm.licenseState.$setViewValue('TX');
                scope.driverLicenseForm.licenseNumber.$setViewValue(licenseNumber);
                expect(scope.driverLicenseForm.licenseNumber.$error['eightDigitTexasDl']).toBe(true);
            });
        });
        //changes to state cause validate to be called on licence number
        it("$validate called on licenseNumber once when state changed once", function () {
            spyOn(scope.driverLicenseForm.licenseNumber, '$validate');
            scope.driverLicenseForm.licenseState.$setViewValue('TX');
            expect(scope.driverLicenseForm.licenseNumber.$validate).toHaveBeenCalledTimes(1);
        });
        it("$validate called on licenseNumber twice when state changed twice", function () {
            spyOn(scope.driverLicenseForm.licenseNumber, '$validate');
            scope.driverLicenseForm.licenseState.$setViewValue('TX');
            scope.driverLicenseForm.licenseState.$setViewValue('TN');
            expect(scope.driverLicenseForm.licenseNumber.$validate).toHaveBeenCalledTimes(2);
        });
    });
})();
(function () {
    "use strict";
    describe("directive: vehicle-information", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, directiveScope, displayedMessage;
        beforeEach(angular.mock.module(function () {
            displayedMessage = {
                value: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
            $provide.value("validationService", function () { return {}; });
            $provide.value("localDataRepo", {
                getClasses: function () { },
                getModelYears: function () { }
            });
            $provide.value("manageVehiclesPaperPlateService", {});
            $provide.constant("environmentConfig", {});
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $templateCache, $compile) {
            scope = $rootScope.$new();
            scope.vehicleInfo = {};
            scope.isEdit = false;
            scope.form = {};
            $templateCache.put("/app/directives/vehicleInformationTemplate.html", $templateCache.get("app/directives/vehicleInformationTemplate.html"));
            var el = angular.element("<form name=\"form\">" +
                "<vehicle-information is-edit=\"isEdit\" parent-form=\"form\" vehicle-info=\"vehicleInfo\">" +
                "</vehicle-information>" +
                "</form>");
            $compile(el)(scope);
            scope.$digest();
            directiveScope = el.children().isolateScope();
        }));
        it("canary", function () {
            expect(true).toBe(true);
        });
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
            expect(directiveScope).toBeDefined();
        });
        it("should start with an invalid form", function () {
            expect(scope.form.$valid).toBeFalsy();
            expect(scope.form.$invalid).toBeTruthy();
        });
        it("should accept valid license plate numbers", function () {
            scope.vehicleInfo.licPlate = "aAa451234512345";
            scope.$digest();
            expect(scope.form.licPlate.$valid).toBeTruthy();
            expect(scope.form.licPlate.$invalid).toBeFalsy();
        });
        it("should reject invalid license plate numbers", function () {
            scope.vehicleInfo.licPlate = "";
            scope.$digest();
            expect(scope.form.licPlate.$valid).toBeFalsy();
            expect(scope.form.licPlate.$invalid).toBeTruthy();
            scope.vehicleInfo.licPlate = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.licPlate.$valid).toBeFalsy();
            expect(scope.form.licPlate.$invalid).toBeTruthy();
            scope.vehicleInfo.licPlate = "1234512345123451";
            scope.$digest();
            expect(scope.form.licPlate.$valid).toBeFalsy();
            expect(scope.form.licPlate.$invalid).toBeTruthy();
        });
        it("should reject null value for paper plate question", function () {
            scope.vehicleInfo.temporaryLicPlate = null;
            scope.$digest();
            expect(scope.form.paperPlateOptions.$valid).toBeFalsy();
            expect(scope.form.paperPlateOptions.$invalid).toBeTruthy();
        });
        it("should set temporaryLicPlate to null when onBlur() is called and licPlate is changed", function () {
            scope.vehicleInfo.licPlate = "MYPLATE123";
            directiveScope.onBlur();
            scope.vehicleInfo.temporaryLicPlate = true;
            scope.$digest();
            expect(scope.form.paperPlateOptions.$valid).toBeTruthy();
            expect(scope.form.paperPlateOptions.$invalid).toBeFalsy();
            scope.vehicleInfo.licPlate = "MYPLATE123CHANGED";
            directiveScope.onBlur();
            scope.$digest();
            expect(scope.vehicleInfo.temporaryLicPlate).toBeNull();
            expect(scope.form.paperPlateOptions.$valid).toBeFalsy();
            expect(scope.form.paperPlateOptions.$invalid).toBeTruthy();
        });
        it("should accept 'Yes' for paper plate question", function () {
            scope.vehicleInfo.temporaryLicPlate = true;
            scope.$digest();
            expect(scope.form.paperPlateOptions.$valid).toBeTruthy();
            expect(scope.form.paperPlateOptions.$invalid).toBeFalsy();
        });
        it("should accept 'No' for paper plate question", function () {
            scope.vehicleInfo.temporaryLicPlate = false;
            scope.$digest();
            expect(scope.form.paperPlateOptions.$valid).toBeTruthy();
            expect(scope.form.paperPlateOptions.$invalid).toBeFalsy();
        });
        it("should accept valid vehicle model", function () {
            scope.vehicleInfo.vehicleModel = "Ranger 57-,.'";
            scope.$digest();
            expect(scope.form.vehicleModel.$valid).toBeTruthy();
            expect(scope.form.vehicleModel.$invalid).toBeFalsy();
            scope.vehicleInfo.vehicleModel = "123456789012345678901234567890";
            scope.$digest();
            expect(scope.form.vehicleModel.$valid).toBeTruthy();
            expect(scope.form.vehicleModel.$invalid).toBeFalsy();
        });
        it("should reject invalid vehicle model", function () {
            scope.vehicleInfo.vehicleModel = "";
            scope.$digest();
            expect(scope.form.vehicleModel.$valid).toBeFalsy();
            expect(scope.form.vehicleModel.$invalid).toBeTruthy();
            scope.vehicleInfo.vehicleModel = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.vehicleModel.$valid).toBeFalsy();
            expect(scope.form.vehicleModel.$invalid).toBeTruthy();
            scope.vehicleInfo.vehicleModel = "1234567890123456789012345678901";
            scope.$digest();
            expect(scope.form.vehicleModel.$valid).toBeFalsy();
            expect(scope.form.vehicleModel.$invalid).toBeTruthy();
        });
        it("should accept valid vehicle color", function () {
            scope.vehicleInfo.vehicleColor = "Blue";
            scope.$digest();
            expect(scope.form.vehicleColor.$valid).toBeTruthy();
            expect(scope.form.vehicleColor.$invalid).toBeFalsy();
            scope.vehicleInfo.vehicleColor = "Blue42";
            scope.$digest();
            expect(scope.form.vehicleColor.$valid).toBeFalsy();
            expect(scope.form.vehicleColor.$invalid).toBeTruthy();
            scope.vehicleInfo.vehicleColor = "12345678901234567890";
            scope.$digest();
            expect(scope.form.vehicleColor.$valid).toBeFalsy();
            expect(scope.form.vehicleColor.$invalid).toBeTruthy();
        });
        it("should reject invalid vehicle color", function () {
            scope.vehicleInfo.vehicleColor = "";
            scope.$digest();
            expect(scope.form.vehicleColor.$valid).toBeFalsy();
            expect(scope.form.vehicleColor.$invalid).toBeTruthy();
            scope.vehicleInfo.vehicleColor = "123456789012345678901";
            scope.$digest();
            expect(scope.form.vehicleColor.$valid).toBeFalsy();
            expect(scope.form.vehicleColor.$invalid).toBeTruthy();
        });
        it("should accept valid vehicle nickname", function () {
            scope.vehicleInfo.nickname = "";
            scope.$digest();
            expect(scope.form.nickname.$valid).toBeTruthy();
            expect(scope.form.nickname.$invalid).toBeFalsy();
            scope.vehicleInfo.nickname = "Ranger 57-,.'";
            scope.$digest();
            expect(scope.form.nickname.$valid).toBeTruthy();
            expect(scope.form.nickname.$invalid).toBeFalsy();
            scope.vehicleInfo.nickname = "123456789012345678901234567890";
            scope.$digest();
            expect(scope.form.nickname.$valid).toBeTruthy();
            expect(scope.form.nickname.$invalid).toBeFalsy();
        });
        it("should reject invalid vehicle nickname", function () {
            scope.vehicleInfo.nickname = "!@#$%^&*";
            scope.$digest();
            expect(scope.form.nickname.$valid).toBeFalsy();
            expect(scope.form.nickname.$invalid).toBeTruthy();
            scope.vehicleInfo.nickname = "1234567890123456789012345678901";
            scope.$digest();
            expect(scope.form.nickname.$valid).toBeFalsy();
            expect(scope.form.nickname.$invalid).toBeTruthy();
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('bankFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should mask all but two digits of bank accounts <= 6 digits long', function () {
            var filteredBank = filter('bankAccount')("123456");
            expect(filteredBank).toBeDefined();
            expect(filteredBank).toBe("****56");
            expect(filteredBank).not.toBe("***56");
            expect(filteredBank).not.toBe("*****56");
            expect(filteredBank).not.toBe("123456");
        });
        it('should mask all but four digits of bank accounts > 6 digits long', function () {
            var filteredBank = filter('bankAccount')("1234567");
            expect(filteredBank).toBeDefined();
            expect(filteredBank).toBe("***4567");
            expect(filteredBank).not.toBe("**4567");
            expect(filteredBank).not.toBe("****4567");
            expect(filteredBank).not.toBe("1234567");
        });
        it('should accept masked bank accounts', function () {
            var filteredBank = filter('bankAccount')("******1234567");
            expect(filteredBank).toBeDefined();
            expect(filteredBank).toBe("*********4567");
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('capitalizeFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should transform "simple" into "Simple"', function () {
            var filteredWord = filter('capitalize')("simple");
            expect(filteredWord).toBe("Simple");
            expect(filteredWord).not.toBe("simple");
            expect(filteredWord).not.toBe("SIMPLE");
        });
        it('should transform "not as simple" into "Not As Simple"', function () {
            var filteredWord = filter('capitalize')("not as simple");
            expect(filteredWord).toBe("Not As Simple");
            expect(filteredWord).not.toBe("not as simple");
            expect(filteredWord).not.toBe("NOT AS SIMPLE");
        });
        it('should return empty string if input is null or undefined', function () {
            var filteredWord = filter('capitalize')(undefined);
            expect(filteredWord).toBe("");
            filteredWord = filter('capitalize')(null);
            expect(filteredWord).toBe("");
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('charReplaceFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should replace first occurrence of second argument with third argument', function () {
            var filteredWord = filter('charReplace')("racecar", "r", "h");
            expect(filteredWord).toBe("hacecar");
            expect(filteredWord).not.toBe("hacecah");
            expect(filteredWord).not.toBe("racecar");
            filteredWord = filter('charReplace')("\"test\"", '"', "!");
            expect(filteredWord).toBe("!test\"");
            expect(filteredWord).not.toBe("!test!");
            expect(filteredWord).not.toBe("\"test\"");
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('creditCardFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should mask all but last 4 digits of credit card given type', function () {
            var filteredCard = filter('creditCard')("4111111111111111", "visa");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-****-****-1111");
            expect(filteredCard).not.toBe("4111111111111111");
            expect(filteredCard).not.toBe("************-1111");
            expect(filteredCard).not.toBe("************1111");
            filteredCard = filter('creditCard')("5269654606884640", "mastercard");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-****-****-4640");
            expect(filteredCard).not.toBe("5269654606884640");
            expect(filteredCard).not.toBe("************-4640");
            expect(filteredCard).not.toBe("************4640");
            filteredCard = filter('creditCard')("6011493679021924", "discover");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-****-****-1924");
            expect(filteredCard).not.toBe("6011493679021924");
            expect(filteredCard).not.toBe("************-1924");
            expect(filteredCard).not.toBe("************1924");
            filteredCard = filter('creditCard')("343679032473180", "americanexpress");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-******-*3180");
            expect(filteredCard).not.toBe("343679032473180");
            expect(filteredCard).not.toBe("************-3180");
            expect(filteredCard).not.toBe("************3180");
        });
        it('should mask all but last 4 digits of credit card given type code', function () {
            var filteredCard = filter('creditCardCode')("4111111111111111", "v");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-****-****-1111");
            expect(filteredCard).not.toBe("4111111111111111");
            expect(filteredCard).not.toBe("************-1111");
            expect(filteredCard).not.toBe("************1111");
            filteredCard = filter('creditCardCode')("5269654606884640", "m");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-****-****-4640");
            expect(filteredCard).not.toBe("5269654606884640");
            expect(filteredCard).not.toBe("************-4640");
            expect(filteredCard).not.toBe("************4640");
            filteredCard = filter('creditCardCode')("6011493679021924", "d");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-****-****-1924");
            expect(filteredCard).not.toBe("6011493679021924");
            expect(filteredCard).not.toBe("************-1924");
            expect(filteredCard).not.toBe("************1924");
            filteredCard = filter('creditCardCode')("343679032473180", "a");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("****-******-*3180");
            expect(filteredCard).not.toBe("343679032473180");
            expect(filteredCard).not.toBe("************-3180");
            expect(filteredCard).not.toBe("************3180");
        });
        it('should mask return correct card name corresponse to the card code', function () {
            var filteredCard = filter('creditCardCodeToName')("V");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("VISA");
            expect(filteredCard).not.toBe("MASTERCARD");
            expect(filteredCard).not.toBe("AMERICAN EXPRESS");
            expect(filteredCard).not.toBe("DISCOVER");
            filteredCard = filter('creditCardCodeToName')("M");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("MASTERCARD");
            expect(filteredCard).not.toBe("VISA");
            expect(filteredCard).not.toBe("AMERICAN EXPRESS");
            expect(filteredCard).not.toBe("DISCOVER");
            filteredCard = filter('creditCardCodeToName')("D");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("DISCOVER");
            expect(filteredCard).not.toBe("MASTERCARD");
            expect(filteredCard).not.toBe("AMERICAN EXPRESS");
            expect(filteredCard).not.toBe("VISA");
            filteredCard = filter('creditCardCodeToName')("A");
            expect(filteredCard).toBeDefined();
            expect(filteredCard).toBe("AMERICAN EXPRESS");
            expect(filteredCard).not.toBe("MASTERCARD");
            expect(filteredCard).not.toBe("VISA");
            expect(filteredCard).not.toBe("DISCOVER");
        });
    });
}());
// (function () {
//     'use strict';
//     //describe() begins a unit testing fixture
//     describe('driversLicenseFilter', function () {
//         //module() is registered on window and is a shortcut to angular.mock.module()
//         //use it to mock the main app module
//         //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
//         // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
//         // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
//         beforeEach(angular.mock.module('HCTRAModule'));
//         var filter;
//         beforeEach(angular.mock.inject(function ($injector) {
//             filter = $injector.get('$filter');
//         }));
//         it('should mask all but the last 3 digits of drivers license numbers', function () {
//             var filteredNumber = filter('driversLicense')("1234567");
//             expect(filteredNumber).toBeDefined();
//             expect(filteredNumber).toBe("***-567");
//             expect(filteredNumber).not.toBe("1234567");
//         });
//     });
// }());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('expDateFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should conditionally add "0" to beginning of card expiration date', function () {
            var filteredDate = filter('expDate')("9/2016");
            expect(filteredDate).toBeDefined();
            expect(filteredDate).toBe("09/2016");
            expect(filteredDate).not.toBe("9/2016");
            expect(filteredDate).not.toBe("009/2016");
            filteredDate = filter('expDate')("10/2016");
            expect(filteredDate).toBeDefined();
            expect(filteredDate).toBe("10/2016"); // unchanged
            expect(filteredDate).not.toBe("010/2016");
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('fileSizeFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should round and apply proper unit to file size given in bytes', function () {
            var filteredSize = filter('fileSize')("1"); // 1,024 bytes or 1 kB
            expect(filteredSize).toBeDefined();
            expect(filteredSize).toBe("1 B");
            expect(filteredSize).not.toBe("1");
            expect(filteredSize).not.toBe("0 KB");
            filteredSize = filter('fileSize')("1024"); // 1,024 bytes or 1 kB
            expect(filteredSize).toBeDefined();
            expect(filteredSize).toBe("1 KB");
            expect(filteredSize).not.toBe("1024");
            filteredSize = filter('fileSize')("1023"); // 1,023 bytes
            expect(filteredSize).toBeDefined();
            expect(filteredSize).toBe("1023 B");
            expect(filteredSize).not.toBe("1023");
            expect(filteredSize).not.toBe("1 KB");
            expect(filteredSize).not.toBe("0 KB");
            filteredSize = filter('fileSize')("1048576"); // 1,024 kilobytes or 1 MB
            expect(filteredSize).toBeDefined();
            expect(filteredSize).toBe("1 MB");
            expect(filteredSize).not.toBe("1048576");
            expect(filteredSize).not.toBe("1024 KB");
            filteredSize = filter('fileSize')("1048575"); // 1,023 kilobytes
            expect(filteredSize).toBeDefined();
            expect(filteredSize).toBe("1023 KB"); // just shy of 1 MB
            expect(filteredSize).not.toBe("1 MB");
            expect(filteredSize).not.toBe("1048575");
            expect(filteredSize).not.toBe("1024 KB");
            filteredSize = filter('fileSize')("1073741824"); // 1,024 megabytes or 1 GB
            expect(filteredSize).toBeDefined();
            expect(filteredSize).toBe("1 GB");
            expect(filteredSize).not.toBe("1073741824");
            expect(filteredSize).not.toBe("1024 MB");
            filteredSize = filter('fileSize')("1073741823"); // 1,023 megabytes
            expect(filteredSize).toBeDefined();
            expect(filteredSize).toBe("1023 MB"); // just shy of 1 GB
            expect(filteredSize).not.toBe("1 GB");
            expect(filteredSize).not.toBe("1073741823");
            expect(filteredSize).not.toBe("1024 MB");
        });
    });
}());
/// <reference path="../../directives/home/homeNewsDirective.js" />
(function () {
    'use strict';
    describe('homeNewsDateFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //    $provide.value('momentDate', hctraMocks.momentDate(dateInput, outFormat, inFormat));
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('homeNewsDateFilter');
        }));
        // dateInput is in local time for testing purposes
        // in production it is using 'Z' for UTC standard
        it('should return the date in the correct format for HH 00', function () {
            expect(service('20160714T000000')).toEqual('July 14, 2016');
        });
        it('should return the date in the correct format for HH 06', function () {
            expect(service('20160714T060000')).toEqual('July 14, 2016');
        });
        it('should return the date in the correct format for HH 12', function () {
            expect(service('20160714T120000')).toEqual('July 14, 2016');
        });
        it('should return the date in the correct format for HH 18', function () {
            expect(service('20160714T180000')).toEqual('July 14, 2016');
        });
        it('should return the date in the correct format for HH 24', function () {
            expect(service('20160714T240000')).toEqual('July 15, 2016');
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('spaceReplaceFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should result in no change in a string without spaces', function () {
            var filteredString = filter('spaceReplace')("no-change");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("no-change");
            filteredString = filter('spaceReplace')("no-change", "!");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("no-change");
        });
        it('should remove spaces if no second argument', function () {
            var filteredString = filter('spaceReplace')("space removed");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("spaceremoved");
            expect(filteredString).not.toBe("space removed");
        });
        it('should replace spaces with second argument', function () {
            var filteredString = filter('spaceReplace')("space replaced", "!");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("space!replaced");
            expect(filteredString).not.toBe("space replaced");
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('taxIdFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should mask all but last 3 digits of tax id', function () {
            var filteredString = filter('taxId')("123456789");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("******789");
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('telephoneFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('$filter');
        }));
        it('should mask 10 digit phone numbers to (###) ###-####', function () {
            var filteredString = filter('telephone')("1234567890");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("(123) 456-7890");
        });
        it('should mask 11 digit phone numbers to (###) ###-#### if country is 1', function () {
            var filteredString = filter('telephone')("11234567890");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("(123) 456-7890");
        });
        it('should mask 11 digit phone numbers to # (###) ###-#### if country is not 1', function () {
            var filteredString = filter('telephone')("21234567890");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("2 (123) 456-7890");
        });
        it('should mask 12 digit phone numbers to ### (##) ###-####', function () {
            var filteredString = filter('telephone')("121234567890");
            expect(filteredString).toBeDefined();
            expect(filteredString).toBe("121 (23) 456-7890");
        });
    });
}());
(function () {
    'use strict';
    describe('telephoneWithExtFilter test test', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var $filter, telFilter;
        beforeEach(angular.mock.inject(function ($injector) {
            $filter = $injector.get('$filter');
            telFilter = $filter('telephoneWithExt');
        }));
        it('should mask 10 digit phone numbers to (###) ###-#### ext ####', function () {
            var filteredString = telFilter("1234567890 ext 1234");
            expect(filteredString).toBe("(123) 456-7890 ext 1234");
        });
        it('should mask 11 digit phone numbers to (###) ###-#### ext #### if country is 1', function () {
            var filteredString = telFilter("11234567890 ext 1234");
            expect(filteredString).toBe("(123) 456-7890 ext 1234");
        });
        it('should mask 11 digit phone numbers to # (###) ###-#### ext #### if country is not 1', function () {
            var filteredString = telFilter("21234567890 ext 1234");
            expect(filteredString).toBe("2 (123) 456-7890 ext 1234");
        });
        it('should mask 12 digit phone numbers to ### (##) ###-#### ext ####', function () {
            var filteredString = telFilter("121234567890 ext 1234");
            expect(filteredString).toBe("121 (23) 456-7890 ext 1234");
        });
    });
}());
describe("paymentPlanDataService", function () {
    beforeEach(angular.mock.module('HCTRAModule'));
    var filter;
    var $ace = {
        trustAsHtml: function () { return ''; },
        trustAsResourceUrl: function () { return ''; }
    };
    beforeEach(angular.mock.module(function ($provide) {
        $provide.value('$sce', $ace);
    }));
    beforeEach(angular.mock.inject(function ($injector) {
        filter = $injector.get("$filter");
    }));
    it('should trust html if type string', function () {
        spyOn($ace, "trustAsHtml").and.returnValue("value");
        spyOn($ace, "trustAsResourceUrl").and.returnValue("value");
        expect(filter("trusted")("value")).toEqual("value");
        expect($ace.trustAsHtml).toHaveBeenCalledTimes(1);
        expect($ace.trustAsResourceUrl).toHaveBeenCalledTimes(0);
    });
    it('should NOT trust html if type is NOT string', function () {
        spyOn($ace, "trustAsHtml").and.returnValue("value");
        spyOn($ace, "trustAsResourceUrl").and.returnValue("value");
        filter("trusted")(5000);
        expect($ace.trustAsHtml).toHaveBeenCalledTimes(0);
        expect($ace.trustAsResourceUrl).toHaveBeenCalledTimes(0);
    });
    it('should trust html if type is string, and call https function if it starts with https', function () {
        spyOn($ace, "trustAsHtml").and.returnValue("value");
        spyOn($ace, "trustAsResourceUrl").and.returnValue("value");
        filter("trusted")("https://somewebsite.com");
        expect($ace.trustAsHtml).toHaveBeenCalledTimes(0);
        expect($ace.trustAsResourceUrl).toHaveBeenCalledTimes(1);
    });
});
(function () {
    'use strict';
    describe('usPhoneFilter', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var filter;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            filter = $injector.get('usPhoneFilter');
        }));
        it('should create hyphens in the us phone number', function () {
            expect(filter('5555555555')).toEqual('555-555-5555');
        });
        it('should return string if it doesnt have digits', function () {
            expect(filter('test')).toEqual('test');
        });
    });
}());
(function () {
    'use strict';
    describe('FPAccountController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, forgotPWaccountController, templateCache, compile, location = {}, rootScope, stateVals = {
            val: []
        };
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('$location', hctraMocks.$location(location));
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('hctraSessionLogin', hctraMocks.hctraSessionLogin());
            $provide.value('routes', hctraMocks.routes());
            $provide.value('webStorage', hctraMocks.webStorage());
            $provide.value('responseErrorService', hctraMocks.responseErrorService());
            $provide.value('validationService', hctraMocks.validationService());
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, $templateCache, $compile) {
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            templateCache = $templateCache;
            compile = $compile;
            rootScope = _$rootScope_;
            scope.$parent.initializeForgotPasswordProcess = function () { return; };
            forgotPWaccountController = $controller('ForgotPasswordAccountController', { $scope: scope, $rootScope: rootScope });
            $templateCache.put('forgotPasswordAccount.html', '<base href="/"></base><div class="row"> <div class="col-md-3"> <h4>Forgot Your Username and Password?</h4> </div></div><br /><div class="row"> <form name="forgotpwform" novalidate> <div class="col-md-6 form-group"> <label for="resetOption">Select an option below to reset your login</label> <select name="resetOption" ng-model="forgot.option" class="form-control" ng-change="changePage()" id="resetOption" tabindex="1" aria-required="true"> <option value="email">Using your email address</option> <option value="account" selected>Using your EZ TAG account</option> </select> </div> <br /> <div class="col-md-6 form-group"> <label for="accountInfo">Please provide the following information to locate your account and verify your identity.</label> <select name="accountInfo" ng-model="forgot.accountInfo" class="form-control" ng-change="changeAccountInfo()" id="accountInfo" tabindex="2"> <option value="account" selected>Account Number</option> <option value="tag">EZ Tag number</option> </select> <div ng-show="forgot.showAccount" ng-class="getErrorStatusClass(forgotpwform,\'accountNumber\')"> <input type="number" name="accountNumber" ng-model="forgot.accountNumber" ng-maxlength="12" class="form-control" placeholder="Enter Account Number" id="accountNumber" tabindex="3" /> <div ng-messages="getErrorList(forgotpwform, \'accountNumber\')" ng-if="hasSubmitted(forgotpwform)" role="alert"> <p ng-message="maxlength" class="help-block">Must be no more than 16 characters</p> </div> <h5>Your account number is located on your statement. <a href="/FindAccountNumber">Need Help?</a></h5> <br /> </div> <div ng-hide="forgot.showAccount" class="row form-group"> <div class="col-xs-4"> <select name="eztagOrg" id="eztagOrg" class="form-control" tabindex="4" ng-options="org.authorityCode for org in authorityList track by org.authorityCode" ng-model="selectedAuthority"></select> </div> <div class="col-xs-8" ng-class="getErrorStatusClass(forgotpwform,\'tagNumber\')"> <label for="tagNumber" class="sr-only">Enter your EZ Tag number.</label> <input type="text" name="tagNumber" ng-model="forgot.tagNumber" ng-maxlength="13" ng-change="removeDoubles(forgot.tagNumber, \'tagNumber\')" class="form-control" placeholder="000000000" id="tagNumber" tabindex="5" /> <div ng-messages="getErrorList(forgotpwform, \'tagNumber\')" ng-if="hasSubmitted(forgotpwform)" role="alert"> <p ng-message="maxlength" class="help-block">Must be no more than 13 characters</p> </div> </div> <h5>Your EZ TAG number is located on your EZ TAG. <a href="/FindEZTagNumber">Need Help?</a></h5> </div> <br /> <select name="personalInfo" ng-model="forgot.personalInfo" ng-change="changeDriverLicense()" class="form-control" id="personalInfo" tabindex="6"> <option value="driversLicense" selected>Driver\'s License Number</option> <option value="taxId">Tax ID Number</option> </select> <div ng-show="forgot.showDriverLicense" class="row form-group"> <div class="col-xs-4"> <select name="driverState" id="driverState" class="form-control" tabindex="7" ng-options="state.stateCode for state in stateList track by state.stateCode" ng-model="selectedState"> </select> </div> <div class="col-xs-8" ng-class="getErrorStatusClass(forgotpwform,\'driversLicense\')"> <label for="driversLicense" class="sr-only">Enter your driver\'s license number.</label> <input type="text" name="driversLicense" ng-model="forgot.driversLicense" ng-maxlength="25" ng-change="removeDoubles(forgot.driversLicense, \'driversLicense\')" class="form-control" placeholder="999999999" id="driversLicense" tabindex="8" /> <div ng-messages="getErrorList(forgotpwform, \'driversLicense\')" ng-if="hasSubmitted(forgotpwform)" role="alert"> <p ng-message="maxlength" class="help-block">Must be no more than 25 characters</p> </div> </div> </div> <div ng-hide="forgot.showDriverLicense" class="row form-group"> <div class="col-md-12" ng-class="getErrorStatusClass(forgotpwform, \'taxIdNumber\')"> <label for="taxIdNumber" class="sr-only">Enter your tax ID number.</label> <input type="text" name="taxIdNumber" ng-model="forgot.taxIdNumber" ng-minlength="9" ng-maxlength="11" ng-change="removeDoubles(forgot.taxIdNumber, \'taxIdNumber\')" class="form-control" placeholder="000-000-000/000" id="taxIdNumber" tabindex="9" /> <div ng-messages="getErrorList(forgotpwform, \'taxIdNumber\')" ng-if="hasSubmitted(forgotpwform)" role="alert"> <p ng-message="minlength" class="help-block">Must be at least 6 characters</p> <p ng-message="maxlength" class="help-block">Must be no more than 16 characters</p> </div> </div> </div> </div> <div class="container"> <div class="pull-right"> <button type="submit" ng-click="submitInfo(forgotpwform.$valid)" class="btn btn-group-sm" tabindex="3">Submit</button> </div> </div> </form></div>');
            //TODO Remove this line
            scope.stateList = stateVals.val;
            var templateHtml = templateCache.get('forgotPasswordAccount.html');
            var formElem = angular.element(templateHtml);
            compile(formElem)(scope);
            scope.$digest();
        }));
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        //the way this form works, no fields are required since the user can mix and match what they use
        it('should be valid at first', function () {
            expect(scope.forgotpwform.$valid).toBeTruthy();
        });
        it('should not have an invalid form at first', function () {
            expect(scope.forgotpwform.$invalid).toBeFalsy();
        });
        it('should get the list of states on start-up', function () {
            expect(stateVals.val).toBeDefined();
        });
        it('test that parent scope variables are set after submit info', function () {
            var test = { object: {} };
            var expectedObject = {
                securityQuestionId: 4,
                dbSessionId: "DFNHSETH356SRHSDRH",
                userName: "hellome",
                securityQuestion: "What is life?",
                accountId: 51651681,
                emailAddress: "j@j.com"
            };
            scope.$parent.setSessionInformation = function (newObj) { test.object = newObj; };
            scope.submitInfo(true);
            expect(test.object).toEqual(expectedObject);
        });
        it('test that parent scope variables are not set after submit info false', function () {
            var test = { object: {} };
            //var expectedObject = {
            //    securityQuestionId: 4,
            //    dbSessionId: "DFNHSETH356SRHSDRH",
            //    userName: "hellome",
            //    securityQuestion: "What is life?",
            //    accountId: 51651681,
            //    emailAddress: "j@j.com"
            //};
            scope.$parent.setSessionInformation = function (newObj) { test.object = newObj; };
            scope.submitInfo(false);
            expect(test.object.securityQuestionId).toBeUndefined();
            expect(test.object.dbSessionId).toBeUndefined();
            expect(test.object.userName).toBeUndefined();
            expect(test.object.securityQuestion).toBeUndefined();
            expect(test.object.accountId).toBeUndefined();
            expect(test.object.emailAddress).toBeUndefined();
        });
        ////test validations with conditions that should cause them to pass
        //it('should validate with a username and password', function () {
        //    scope.login = {};
        //    scope.login.userName = "someUser";
        //    scope.login.password = "somePassword";
        //    scope.$digest();
        //    expect(scope.loginForm.$valid).toBeTruthy();
        //});
        ////begin testing controller functionality
        //it('should set currentUser with the correct username and password entered in the UI', function () {
        //    scope.login = {};
        //    scope.login.userName = "rightUser";
        //    scope.login.password = "rightPw";
        //    scope.getLogin(true);
        //    expect(currentUser).toBe(999999);
        //});
        ////use the spy defined in the controller injection beforeEach to test if the $broadcast event was raised
        //it('should call $rootScope.$broadcast() with the correct username and password entered in the UI', function () {
        //    scope.login = {};
        //    scope.login.userName = "rightUser";
        //    scope.login.password = "rightPw";
        //    scope.getLogin(true);
        //    expect(rootScope.$broadcast).toHaveBeenCalled();
        //});
        //it('should send the user to the next page with the correct username and password entered in the UI', function () {
        //    scope.login = {};
        //    scope.login.userName = "rightUser";
        //    scope.login.password = "rightPw";
        //    scope.getLogin(true);
        //    expect(setUrl).toBe('/AccountSummary');
        //});
        ////be sure to test error conditions
        //it('should display an error message if the user enters the wrong username and password in the UI', function () {
        //    displayedMessage = "";
        //    scope.login = {};
        //    scope.login.userName = "wrong";
        //    scope.login.password = "wrong";
        //    scope.getLogin(true);
        //    expect(displayedMessage).toBe("Displayed a list of errors");
        //});
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('FPEmailController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, ForgotPasswordEmailController, templateCache, compile, setUrl = {
            value: ""
        }, displayedMessage = {
            value: ""
        }, inStore = {}, currentSession = { thisSession: {} };
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('usSpinnerService', hctraMocks.usSpinnerService());
            $provide.value('$location', hctraMocks.$location(setUrl));
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('routes', hctraMocks.routes());
            $provide.value('webStorage', hctraMocks.webStorage(inStore));
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('validationService', function () { return {}; });
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, $templateCache, $compile) {
            //create new, empty ng scope and controller objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            templateCache = $templateCache;
            compile = $compile;
            scope.$parent.initializeForgotPasswordProcess = function () { };
            scope.$parent.setSessionInformation = function (newSession) { currentSession.thisSession = newSession; };
            //grab an instance of the actual LoginController and fill its scope
            ForgotPasswordEmailController = $controller('ForgotPasswordEmailController', { $scope: scope });
            //scope.$parent = {
            //    logAction: function () { }
            //};
            scope.$parent.logAction = function () { };
            //add template to the cache
            $templateCache.put('forgotPasswordAccount.html', '<base href="/"></base><div class="row"><div class="col-md-3"><h4>Forgot Your Username and Password?</h4></div></div><br /><div class="row"><form name="forgotpwform" novalidate><div class="col-md-6 form-group"><label for="resetOption">Select an option below to reset your login</label><select name="resetOption" ng-model="forgot.option" class="form-control" ng-change="changePage()" required id="resetOption" tabindex="1" aria-required="true"><option value="email" selected>Using your email address</option><option value="account">Using your EZ Tag account</option></select></div><br /><div class="col-md-6 form-group" ng-class="getErrorStatusClass(forgotpwform, \'emailAddress\')"><label for="emailAddress">Please enter email address associated with your EZ Tag account.</label><input type="email" name="emailAddress" ng-model="forgot.EmailAddress" class="form-control" required placeholder="username@domain.com" id="emailAddress" /><!--<set-email-address ng-model="forgot.email" ></set-email-address>--><div ng-messages="getErrorList(forgotpwform, \'emailAddress\')" ng-if="hasSubmitted(forgotpwform)" role="alert"><p ng-message="required" class="help-block">Please enter an email address</p></div></div><div class="container"><div class="pull-right"><button type="submit" ng-click="submitEmail(forgotpwform.$valid)" class="btn btn-group-sm" tabindex="3">Submit</button></div></div></form></div>');
            var templateHtml = templateCache.get('forgotPasswordAccount.html');
            var formElem = angular.element(templateHtml);
            compile(formElem)(scope);
            scope.$digest();
        }));
        //begin an actual test
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        //Begin testing validations
        it('should invalidate form at first', function () {
            expect(scope.forgotpwform.$invalid).toBeTruthy();
        });
        //reverse of last test
        it('should not have a valid form at first', function () {
            expect(scope.forgotpwform.$valid).toBeFalsy();
        });
        it('should validate with an email address', function () {
            scope.forgot.EmailAddress = "dfssa@dfgds.com";
            scope.$digest();
            expect(scope.forgotpwform.$valid).toBeTruthy();
        });
        //Begin testing services and controller functions
        it('should be able to call submitEmail() and set URL in $location', function () {
            setUrl.value = "";
            scope.forgot.test = "correct";
            scope.submitEmail(true);
            expect(setUrl.value).toBeDefined();
        });
        it('should display an error when submitEmail() returns an error', function () {
            displayedMessage.value = "";
            scope.forgot.test = "badData";
            scope.submitEmail(true);
            expect(displayedMessage.value).toBe("Displayed a list of errors");
        });
        it('should set the URL to account page if pageChange() is called', function () {
            setUrl.value = "";
            scope.changePage();
            expect(setUrl.value).toBe('/ForgotPasswordAccount');
        });
        it('verify email is saved when page is submitted successfully', function () {
            delete currentSession.thisSession.emailAddress;
            scope.forgot.test = "correct";
            scope.submitEmail(true);
            expect(currentSession.thisSession.emailAddress).toBe('somebody@gmasil.com');
        });
        it('test that parent scope variables are not set after submit info false', function () {
            delete currentSession.thisSession.emailAddress;
            scope.forgot.test = "correct";
            scope.submitEmail(false);
            expect(currentSession.thisSession.emailAddress).toBeUndefined();
        });
    });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('FPEmailSentController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, FPEmailSentController, templateCache, compile, setUrl = {
            value: ""
        }, currentSession = {
            emailAddress: 'j@j.com'
        };
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            var inStore = {};
            var displayedMessage = {
                value: ""
            };
            $provide.value('usSpinnerService', hctraMocks.usSpinnerService());
            $provide.value('$location', hctraMocks.$location(setUrl));
            $provide.value('genericRepo', hctraMocks.genericRepo());
            $provide.value('routes', hctraMocks.routes());
            $provide.value('webStorage', hctraMocks.webStorage(inStore));
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('validationService', function () { return {}; });
        }));
        //inject() is a window-registered global for angular.mock.inject
        //it injects the root scope and controller-grabbing services into your test
        //the injector unwraps the underscores
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, $templateCache, $compile) {
            //create new, empty ng scope and controller objects
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            templateCache = $templateCache;
            compile = $compile;
            scope.$parent.redirectOccurredDueToInvalidState = function () { return false; };
            scope.$parent.getSessionInformation = function () { return currentSession; };
            //grab an instance of the actual LoginController and fill its scope
            FPEmailSentController = $controller('ForgotPasswordEmailSentController', { $scope: scope });
            scope.$parent.logAction = function () { };
            //add template to the cache
            $templateCache.put('forgotPasswordAccount.html', '<base href="/"></base><div class="row"><div class="col-md-3"><h4>Forgot Your Username and Password?</h4></div></div><br /><div class="row"><form name="forgotpwform" novalidate><div class="col-md-6 form-group"><label for="resetOption">Select an option below to reset your login</label><select name="resetOption" ng-model="forgot.option" class="form-control" ng-change="changePage()" required id="resetOption" tabindex="1" aria-required="true"><option value="email" selected>Using your email address</option><option value="account">Using your EZ Tag account</option></select></div><br /><div class="col-md-6 form-group" ng-class="getErrorStatusClass(forgotpwform, \'emailAddress\')"><label for="emailAddress">Please enter email address associated with your EZ Tag account.</label><input type="email" name="emailAddress" ng-model="forgot.EmailAddress" class="form-control" required placeholder="username@domain.com" id="emailAddress" /><!--<set-email-address ng-model="forgot.email" ></set-email-address>--><div ng-messages="getErrorList(forgotpwform, \'emailAddress\')" ng-if="hasSubmitted(forgotpwform)" role="alert"><p ng-message="required" class="help-block">Please enter an email address</p></div></div><div class="container"><div class="pull-right"><button type="submit" ng-click="submitEmail(forgotpwform.$valid)" class="btn btn-group-sm" tabindex="3">Submit</button></div></div></form></div>');
            var templateHtml = templateCache.get('forgotPasswordAccount.html');
            var formElem = angular.element(templateHtml);
            compile(formElem)(scope);
            scope.$digest();
        }));
        it('verify init initializes email', function () {
            expect(scope.email).toBe(currentSession.emailAddress);
        });
        it('verify goToHelpAndSupport goes to contact us', function () {
            scope.goToHelpAndSupport();
            expect(setUrl.value).toBe("/HelpAndSupport#email-us");
        });
    });
}());
(function () {
    'use strict';
    describe('ForgotPasswordParentController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        //var stateGo;
        var $controller, ForgotPasswordParentController, scope, stateNames, inState = {
            current: {
                value: '',
                name: ''
            },
            go: function () {
                //stateGo = stateName;
            }
        };
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('$state', hctraMocks.fake$state(inState));
            $provide.value('stateNames', hctraMocks.stateNames());
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, _stateNames_) {
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            stateNames = _stateNames_;
            ForgotPasswordParentController = $controller('ForgotPasswordParentController', { $scope: scope });
        }));
        it('verify scope.initializeForgotPasswordProcess clears session information', function () {
            scope.setSessionInformation({ securityQuestionId: 4 });
            scope.initializeForgotPasswordProcess();
            expect(scope.getSessionInformation()).toBe(null);
        });
        it('verify scope.redirectOccurredDueToInvalidState works for attemptedState = forgotPasswordEmailSent', function () {
            inState.current.name = stateNames.forgotPasswordEmail;
            scope.initializeForgotPasswordProcess();
            inState.current.name = stateNames.forgotPasswordEmailSent;
            var redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeTruthy();
            scope.setSessionInformation({ emailAddress: 'j@j.com' });
            redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeFalsy();
        });
        it('verify scope.redirectOccurredDueToInvalidState works for attemptedState = forgotPasswordValidateAccount', function () {
            inState.current.name = stateNames.forgotPasswordEmail;
            scope.initializeForgotPasswordProcess();
            inState.current.name = stateNames.forgotPasswordValidateAccount;
            var redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeTruthy();
            inState.current.name = stateNames.forgotPasswordAccount;
            scope.initializeForgotPasswordProcess();
            scope.setSessionInformation({ dbSessionId: 'ASFHBZSFB654SGZSDG' });
            inState.current.name = stateNames.forgotPasswordValidateAccount;
            redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeFalsy();
            inState.current.name = stateNames.forgotPasswordReset;
            scope.initializeForgotPasswordProcess();
            scope.setSessionInformation({ dbSessionId: 'ASFHBZSFB654SGZSDG' });
            inState.current.name = stateNames.forgotPasswordValidateAccount;
            redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeFalsy();
        });
        it('verify scope.redirectOccurredDueToInvalidState works for attemptedState = forgotPasswordValidateAccountEmail', function () {
            inState.current.name = stateNames.forgotPasswordEmail;
            scope.initializeForgotPasswordProcess();
            inState.current.name = stateNames.forgotPasswordValidateAccountEmail;
            var redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeFalsy();
        });
        it('verify scope.redirectOccurredDueToInvalidState works for attemptedState = forgotPasswordReset', function () {
            inState.current.name = stateNames.forgotPasswordEmail;
            scope.initializeForgotPasswordProcess();
            inState.current.name = stateNames.forgotPasswordValidateAccount;
            var redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeTruthy();
            inState.current.name = stateNames.forgotPasswordValidateAccount;
            scope.initializeForgotPasswordProcess();
            scope.setSessionInformation({ dbSessionId: 'ASFHBZSFB654SGZSDG' });
            inState.current.name = stateNames.forgotPasswordReset;
            redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeFalsy();
            inState.current.name = stateNames.forgotPasswordValidateAccountEmail;
            scope.initializeForgotPasswordProcess();
            scope.setSessionInformation({ dbSessionId: 'ASFHBZSFB654SGZSDG' });
            inState.current.name = stateNames.forgotPasswordReset;
            redirectOccured = scope.redirectOccurredDueToInvalidState();
            expect(redirectOccured).toBeFalsy();
        });
    });
}());
(function () {
    "use strict";
    describe("PasswordResetController", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, rootScope, q, setUrl, displayedMessage, inStorage, inTimer, inState, inSession, inInvoiced, inSession2, sessionInformation, repoInObject, authObj, linkLookupServiceMock, dataFactoryMock, routes;
        beforeEach(angular.mock.module(function () {
            setUrl = {
                value: ""
            };
            displayedMessage = {
                value: ""
            };
            inStorage = {};
            inTimer = {
                func: null,
                value: -1
            };
            inState = {
                value: ""
            };
            inSession = {
                value: ""
            };
            inInvoiced = {
                value: false
            };
            inSession2 = {
                acctActivity: ""
            };
            sessionInformation = {
                dbSessionId: "ASRBHSDFHW45SHN",
                userName: "tset03",
                accountId: 651654161,
                emailAddress: "j@j.com",
                securityAnswer: "Yes",
                securityQuestionId: 1
            };
            repoInObject = {
                requestData: null
            };
            authObj = {
                isAuthenticated: false
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            // "$scope", "$location", "responseErrorService", "$stateParams", "$timeout", "genericRepo", "routes", "webStorage", 
            // "hctraSessionLogin", "$rootScope", "AUTH_EVENTS", "validationService", "$state", "Session", "USER_ROLES", "AuthService",
            // "suspendedAccountService", "CurrentUser", "isInvoicedService"
            $provide.value("$location", hctraMocks.$location(setUrl));
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayedMessage));
            $provide.value("$stateParams", hctraMocks.$stateParams);
            $provide.value("$timeout", hctraMocks.$timeout(inTimer));
            $provide.value("webStorage", hctraMocks.webStorage(inStorage));
            $provide.value("hctraSessionLogin", hctraMocks.hctraSessionLogin(inSession));
            $provide.value("AUTH_EVENTS", hctraMocks.AUTH_EVENTS());
            $provide.value("validationService", hctraMocks.validationService());
            $provide.value("$state", hctraMocks.$state(inState));
            $provide.value("SessionService", hctraMocks.Session(inSession2));
            $provide.value("AuthService", hctraMocks.AuthService(authObj));
            $provide.value("suspendedAccountService", hctraMocks.suspendedAccountService());
            $provide.value("CurrentUser", hctraMocks.CurrentUser());
            $provide.value("isInvoicedService", hctraMocks.isInvoicedService(inInvoiced));
            $provide.value("accountBlockPopupService", hctraMocks.accountBlockPopupService());
            linkLookupServiceMock = jasmine.createSpyObj("linkLookupService", ["articleLookupById"]);
            $provide.value("linkLookupService", linkLookupServiceMock);
            var dFMock = jasmine.createSpyObj("dataFactory", ["resetPassword", "getSecurityQuestions", "getCmsPageById"]);
            var genericRepo = hctraMocks.genericRepo(repoInObject);
            dFMock.getSecurityQuestions.and.callFake(function () { return genericRepo.dataFactory.getSecurityQuestions(); });
            dFMock.getCmsPageById.and.callFake(function (request) { return genericRepo.dataFactory.getCmsPageById(request); });
            dataFactoryMock = dFMock;
            $provide.value("genericRepo", { dataFactory: dataFactoryMock });
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile, $injector, $q) {
            routes = $injector.get("routes");
            scope = $rootScope.$new();
            rootScope = $rootScope;
            q = $q;
            // set the base object on scope
            scope.forgot = {};
            scope.forgotpwform = {};
            scope.$parent.redirectOccurredDueToInvalidState = function () { return false; };
            scope.$parent.getSessionInformation = function () { return sessionInformation; };
            spyOn(rootScope, "$broadcast");
            $controller("PasswordResetController", { $scope: scope, $rootScope: rootScope });
            var templateHtml = $templateCache.get("app/templates/forgotPassword/passwordReset.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("should be invalid at first", function () {
            expect(scope.forgotpwform.$invalid).toBeTruthy();
        });
        it("test init", function () {
            scope.init();
            expect(scope.forgot.user).toBe(sessionInformation.userName);
        });
        it("should have a valid form after entering data", function () {
            scope.forgot.password = "watermelon1";
            scope.forgot.password2 = "watermelon1";
            scope.forgot.securityQuestionAnswer = "HelloWorld";
            scope.forgot.confirmYourAnswer = "HelloWorld";
            scope.$digest();
            expect(scope.forgotpwform.$valid).toBeTruthy();
        });
        it("should call to change the URL when submitted", function () {
            setUrl.value = "";
            scope.submitInfo(true);
            expect(setUrl.value).toBeDefined();
        });
        it("should get the security questions and set them on scope", function () {
            scope.init();
            expect(scope.securityQuestions.length).toBe(3);
        });
        describe("test submit with valid form", function () {
            beforeEach(function () {
                scope.forgot.password = "password";
                scope.forgot.password2 = "password";
                scope.forgot.securityQuestionAnswer = "answer";
                scope.forgot.confirmYourAnswer = "answer";
                scope.forgot.securityQuestionID = "1";
                scope.$digest();
            });
            it("should log the user in through hctraSessionLogin service", function () {
                dataFactoryMock.resetPassword.and.callFake(function (request) { return hctraMocks.genericRepo(repoInObject)
                    .dataFactory.resetPassword(request); });
                scope.submitInfo(true);
                expect(inSession.value + "").toBe("999999");
            });
            it("should call $broadcast on submission", function () {
                dataFactoryMock.resetPassword.and.callFake(function (request) { return hctraMocks.genericRepo(repoInObject)
                    .dataFactory.resetPassword(request); });
                scope.submitInfo(true);
                expect(rootScope.$broadcast).toHaveBeenCalled();
            });
            it("should log the user in on submission", function () {
                dataFactoryMock.resetPassword.and.callFake(function (request) { return hctraMocks.genericRepo(repoInObject)
                    .dataFactory.resetPassword(request); });
                scope.submitInfo(true);
                expect(rootScope.$broadcast).toHaveBeenCalledWith(hctraMocks.AUTH_EVENTS().loginSuccess, {
                    acctId: 999999, acctActivity: "P",
                    newAccountStep: { currentStep: 2 },
                    errors: []
                });
            });
            it("should wait 4 secods before forwarding to account summary page", function () {
                dataFactoryMock.resetPassword.and.callFake(function (request) { return hctraMocks.genericRepo(repoInObject)
                    .dataFactory.resetPassword(request); });
                scope.submitInfo(true);
                expect(inTimer.value).toBe(4000);
            });
            it("test submit with no security change", function () {
                dataFactoryMock.resetPassword.and.callFake(function (request) { return hctraMocks.genericRepo(repoInObject)
                    .dataFactory.resetPassword(request); });
                scope.forgot.securityQuestionAnswer = false;
                repoInObject.requestData = null;
                scope.submitInfo(true);
                var dataDrawnFromMemory = angular.fromJson(repoInObject.requestData);
                expect(dataDrawnFromMemory.dbSessionId).toBe(sessionInformation.dbSessionId);
                expect(dataDrawnFromMemory.userName).toBe(sessionInformation.userName);
                expect(dataDrawnFromMemory.accountId).toBe(sessionInformation.accountId);
                expect(dataDrawnFromMemory.email).toBe(sessionInformation.emailAddress);
                expect(dataDrawnFromMemory.securityQuestionAnswer).toBe(sessionInformation.securityAnswer);
                expect(dataDrawnFromMemory.securityQuestionID).toBe(sessionInformation.securityQuestionId);
            });
            it("should redirect to express redirect page", function () {
                scope.forgot.securityQuestionAnswer = false;
                dataFactoryMock.resetPassword.and.returnValue(q.resolve({
                    errors: [],
                    isExpressAccount: true,
                    fromMobileApp: true
                }));
                scope.submitInfo(true);
                scope.$apply();
                expect(linkLookupServiceMock.articleLookupById)
                    .toHaveBeenCalledWith(routes.mobileExpressAppPasswordReset);
            });
            it("should redirect to non-express redirect page", function () {
                scope.forgot.securityQuestionAnswer = false;
                dataFactoryMock.resetPassword.and.returnValue(q.resolve({
                    errors: [],
                    isExpressAccount: false,
                    fromMobileApp: true
                }));
                scope.submitInfo(true);
                scope.$apply();
                expect(linkLookupServiceMock.articleLookupById)
                    .toHaveBeenCalledWith(routes.mobileAppPasswordReset);
            });
        });
    });
}());
(function () {
    'use strict';
    describe('ValidateAccountController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, validateAccountController, templateCache, compile, setUrl, displayedMessage, inStorage, currentSession, currentSessionGetter, inRepo;
        beforeEach(angular.mock.module(function ($provide) {
            setUrl = {
                value: ""
            };
            displayedMessage = {
                value: ""
            };
            inStorage = {};
            currentSession = {
                information: {}
            };
            currentSessionGetter = {
                securityQuestion: "What up dude?",
                dbSessionId: "ABAB23235235SDFBAFB",
                accountId: 6516189
            };
            inRepo = {
                information: {}
            };
            //'$scope', '$location', '$stateParams', 'responseErrorService', 'genericRepo', 'routes', 'webStorage',
            $provide.value('genericRepo', hctraMocks.genericRepo(inRepo));
            $provide.value('responseErrorService', hctraMocks.responseErrorService(displayedMessage));
            $provide.value('routes', hctraMocks.routes());
            $provide.value('webStorage', hctraMocks.webStorage(inStorage));
            $provide.value('$location', hctraMocks.$location(setUrl));
            $provide.value('$stateParams', hctraMocks.$stateParams);
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, $templateCache, $compile) {
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            templateCache = $templateCache;
            compile = $compile;
            //set the base object on scope
            scope.forgot = {};
            scope.$parent.redirectOccurredDueToInvalidState = function () { return false; };
            scope.$parent.getSessionInformation = function () { return currentSessionGetter; };
            scope.$parent.setSessionInformation = function (setSessionObject) { currentSession.information = setSessionObject; };
            validateAccountController = $controller('ValidateAccountController', { $scope: scope });
            $templateCache.put('validateAccount.html', '<base href="/"></base><span us-spinner="{scale: 1.2}" spinner-key="globalSpinner"></span><div class="row"> <div class="col-md-3"> <h4>Validate Account Identity</h4> </div></div><br /><div> <form name="forgotpwform" novalidate> <h5>Please answer your security question to validate your identity.</h5><br /> <h5>Security Question</h5> <h4>{{question}}</h4> <br /> <div ng-class="getErrorStatusClass(forgotpwform, \'questionAnswer\')"> <label for="questionAnswer">Your answer</label> <input type="password" name="questionAnswer" ng-model="forgot.answer" class="form-control" required id="questionAnswer" tabindex="1" /> <div ng-messages="getErrorList(forgotpwform, \'questionAnswer\')" ng-if="hasSubmitted(forgotpwform)" role="alert"> <p ng-message="required" class="help-block">Please enter a value</p> </div> </div> <br /> <div class="container"> <div class="pull-right"> <button type="submit" ng-click="submitAnswer(forgotpwform.$valid)" class="btn btn-group-sm" tabindex="2">Submit</button> </div> </div> </form></div>');
            var templateHtml = templateCache.get('validateAccount.html');
            var formElem = angular.element(templateHtml);
            compile(formElem)(scope);
            scope.$digest();
        }));
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        it('should be invalid at first', function () {
            expect(scope.forgotpwform.$invalid).toBeTruthy();
        });
        it('should have a valid form after entering data', function () {
            scope.forgot.answer = "black";
            scope.$digest();
            expect(scope.forgotpwform.$valid).toBeTruthy();
        });
        it('should call to change the URL when the correct answer is given', function () {
            setUrl.value = "";
            scope.forgot.answer = "black";
            scope.submitAnswer(true);
            expect(setUrl.value).toBeDefined();
        });
        it('should set the correct session information when the correct answer is given', function () {
            setUrl.value = "";
            scope.forgot.answer = "black";
            scope.submitAnswer(true);
            expect(currentSession.information.securityAnswer).toBe('whatupdude');
        });
        it('should display an error with an incorrect answer', function () {
            setUrl.value = "";
            scope.forgot.answer = "red";
            scope.submitAnswer(true);
            expect(displayedMessage.value).toBe("Displayed a list of errors");
        });
        it('verify that existing session information is sent and sbumitted to the WS', function () {
            setUrl.value = "";
            scope.forgot.answer = "black";
            scope.submitAnswer(true);
            expect(scope.forgot.dbSessionId).toBe(currentSessionGetter.dbSessionId);
            expect(scope.forgot.accountId).toBe(currentSessionGetter.accountId);
        });
        it('verify that init gets current session information - no security answer available', function () {
            scope.forgot.answer = "";
            expect(scope.question).toBe(currentSessionGetter.securityQuestion);
            expect(scope.forgot.answer).toBe("");
        });
        it('verify that init gets current session information - security answer available', function () {
            scope.forgot.answer = "";
            currentSessionGetter.securityAnswer = "ThisisTheLife!";
            validateAccountController = $controller('ValidateAccountController', { $scope: scope });
            expect(scope.question).toBe(currentSessionGetter.securityQuestion);
            expect(scope.forgot.answer).toBe(currentSessionGetter.securityAnswer);
        });
    });
}());
(function () {
    'use strict';
    describe('ValidateAccountEmailController', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var $controller, scope, validateAccountEmailController, templateCache, compile, setUrl, responseErrorService, inStorage, currentSession, currentSessionGetter, inRepo, stateNames, $state;
        beforeEach(angular.mock.module(function ($provide) {
            //'$scope', '$location', 'responseErrorService', 'genericRepo', 'routes', 'webStorage',
            setUrl = {
                value: ""
            };
            inStorage = {};
            currentSession = {
                information: {}
            };
            currentSessionGetter;
            inRepo = {
                information: {}
            };
            currentSessionGetter = {
                securityQuestion: "What up dude?",
                dbSessionId: "ABAB23235235SDFBAFB",
                accountId: 6516189
            };
            stateNames = {
                forgotPasswordEmail: "fake forgot password email state"
            };
            $state = jasmine.createSpyObj("$state", ["go"]);
            responseErrorService = jasmine.createSpyObj("responseErrorService", ["displayErrorsFromResponse"]);
            $provide.value('genericRepo', hctraMocks.genericRepo(inRepo));
            $provide.value('responseErrorService', responseErrorService);
            $provide.value('routes', hctraMocks.routes());
            $provide.value('webStorage', hctraMocks.webStorage(inStorage));
            $provide.value('$location', hctraMocks.$location(setUrl));
            $provide.value('$stateParams', hctraMocks.$stateParams);
            $provide.constant('stateNames', stateNames);
            $provide.value('$state', $state);
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_, $templateCache, $compile) {
            scope = _$rootScope_.$new();
            $controller = _$controller_;
            templateCache = $templateCache;
            compile = $compile;
            //set the base object on scope
            scope.forgot = {};
            scope.$parent.redirectOccurredDueToInvalidState = function () { return false; };
            scope.$parent.getSessionInformation = function () { return currentSessionGetter; };
            scope.$parent.setSessionInformation = function (setSessionObject) { currentSession.information = setSessionObject; };
            validateAccountEmailController = $controller('ValidateAccountEmailController', { $scope: scope });
            $templateCache.put('validateAccount.html', '<base href="/"></base><span us-spinner="{scale: 1.2}" spinner-key="globalSpinner"></span><div class="row"> <div class="col-md-3"> <h4>Validate Account Identity</h4> </div></div><br /><div> <form name="forgotpwform" novalidate> <h5>Please answer your security question to validate your identity.</h5><br /> <h5>Security Question</h5> <h4>{{question}}</h4> <br /> <div ng-class="getErrorStatusClass(forgotpwform, \'questionAnswer\')"> <label for="questionAnswer">Your answer</label> <input type="password" name="questionAnswer" ng-model="forgot.answer" class="form-control" required id="questionAnswer" tabindex="1" /> <div ng-messages="getErrorList(forgotpwform, \'questionAnswer\')" ng-if="hasSubmitted(forgotpwform)" role="alert"> <p ng-message="required" class="help-block">Please enter a value</p> </div> </div> <br /> <div class="container"> <div class="pull-right"> <button type="submit" ng-click="submitAnswer(forgotpwform.$valid)" class="btn btn-group-sm" tabindex="2">Submit</button> </div> </div> </form></div>');
            var templateHtml = templateCache.get('validateAccount.html');
            var formElem = angular.element(templateHtml);
            compile(formElem)(scope);
            scope.$digest();
        }));
        it('should have a defined scope', function () {
            expect(scope).toBeDefined();
        });
        it('should be invalid at first', function () {
            expect(scope.forgotpwform.$invalid).toBeTruthy();
        });
        it('should have a valid form after entering data', function () {
            scope.forgot.answer = "black";
            scope.$digest();
            expect(scope.forgotpwform.$valid).toBeTruthy();
        });
        it('should send the email ID to the server', function () {
            expect(scope.sentEmailId).toBe('45DSGFTG7876GHH456HDWRS2');
        });
        it('should set the returned security question to scope', function () {
            expect(scope.question).toBe('What is your favorite color?');
        });
        it('should set the correct session information when the correct answer is given from data in session information storage', function () {
            setUrl.value = "";
            scope.forgot.answer = "black";
            scope.submitAnswer(true);
            expect(currentSession.information.securityAnswer).toBe('whatupdude');
        });
        it('should display an error message with an incorrect answer', function () {
            scope.forgot.answer = "red";
            scope.submitAnswer(true);
            expect(responseErrorService.displayErrorsFromResponse).toHaveBeenCalledWith({ userId: '', errors: ['Some error'] });
            expect(responseErrorService.displayErrorsFromResponse).toHaveBeenCalledTimes(1);
        });
        it('verify that existing session information is sent and submitted to the WS', function () {
            setUrl.value = "";
            scope.forgot.answer = "black";
            scope.submitAnswer(true);
            expect(scope.forgot.dbSessionId).toBe(currentSessionGetter.dbSessionId);
            expect(scope.forgot.accountId).toBe(currentSessionGetter.accountId);
        });
        it('verify that init gets current session information - no security answer available', function () {
            scope.forgot.answer = "";
            expect(scope.question).toBe('What is your favorite color?');
            expect(currentSession.information.accountId).toBe(999999);
            expect(currentSession.information.securityQuestionId).toBe(4);
            expect(currentSession.information.dbSessionId).toBe('68168ARHARFHB64684');
            expect(currentSession.information.emailAddress).toBe('j@j.com');
            expect(currentSession.information.userName).toBe('tset03');
            expect(scope.forgot.answer).toBe("");
            expect($state.go).toHaveBeenCalledTimes(0);
        });
        it('verify that init gets current session information - security answer available', function () {
            scope.forgot.answer = "";
            currentSessionGetter.securityAnswer = "ThisisTheLife!";
            validateAccountEmailController = $controller('ValidateAccountEmailController', { $scope: scope });
            expect(scope.question).toBe('What is your favorite color?');
            expect(currentSession.information.accountId).toBe(999999);
            expect(currentSession.information.securityQuestionId).toBe(4);
            expect(currentSession.information.dbSessionId).toBe('68168ARHARFHB64684');
            expect(currentSession.information.emailAddress).toBe('j@j.com');
            expect(currentSession.information.userName).toBe('tset03');
            expect(scope.forgot.answer).toBe(currentSessionGetter.securityAnswer);
        });
        describe("processEmaiSecurityQuestionResponse", function () {
            it("should go to state forgotPasswordEmail if reponse has errors", function () {
                scope.question = "";
                spyOn(scope.$parent, "setSessionInformation");
                scope.processEmaiSecurityQuestionResponse({
                    errors: ["fake error"]
                });
                expect(scope.question).toBe("");
                expect(scope.$parent.setSessionInformation).toHaveBeenCalledTimes(0);
                expect($state.go).toHaveBeenCalledTimes(1);
                expect($state.go).toHaveBeenCalledWith("fake forgot password email state");
                expect(responseErrorService.displayErrorsFromResponse).toHaveBeenCalledTimes(1);
                expect(responseErrorService.displayErrorsFromResponse).toHaveBeenCalledWith({ errors: ["fake error"] }, true);
            });
        });
    });
}());
(function () {
    'use strict';
    xdescribe('', function () { });
}());
(function () {
    "use strict";
    describe("HelpAndSupportService", function () {
        var stringUtilsSpy;
        var service;
        beforeEach(angular.mock.module("HCTRAModule"));
        beforeEach(angular.mock.module(function () {
            stringUtilsSpy = jasmine.createSpyObj("stringUtilsService", ["getParameterObject"]);
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("stringUtilsService", stringUtilsSpy);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            stringUtilsSpy.getParameterObject.and.returnValue({ data: "value" });
            service = $injector.get("helpAndSupportService");
        }));
        describe("mapLocationTitle", function () {
            it("mapLocationTitle return region and subregion if avaliable", function () {
                var test = service.mapLocationTitle("Southwest Area (located inside Toll Plaza)");
                expect(test).toEqual(({
                    region: 'Southwest Area',
                    subregion: '(located inside Toll Plaza)'
                }));
            });
            it("mapLocationTitle should return region if there isnt a subregion", function () {
                var test = service.mapLocationTitle("Southwest Area");
                expect(test).toEqual(({
                    region: 'Southwest Area',
                    subregion: ''
                }));
            });
        });
        describe("mapLocations", function () {
            it("mapLocations parse data from and give output", function () {
                var data = [{
                        Title: "Tittle",
                        ShortDescription: "Some short description data",
                        LongDescription: "1234 Test Road, Houston, TX 77777"
                    }];
                var result = service.mapLocations(data);
                expect(result).toEqual([({
                        ariaAddressStreet: 'Some short description data',
                        addressStreet: '1234 Test Road',
                        addressCity: 'Houston, TX 77777',
                        mapLink: '<iframe src="https://www.google.com/maps?q=1234 Test Road, Houston, TX 77777&amp;output=embed"  width="320" height="160" frameborder="0" style="border:0" allowfullscreen=""></iframe>',
                        region: 'Tittle',
                        subregion: ''
                    })
                ]);
            });
        });
        describe("transformKeyValuePair", function () {
            it("transformKeyValuePair with Regex output", function () {
                var key = "FieldValidationRegex";
                var data = {
                    FieldValidationRegex: "^.{0,50}$",
                    FileTypes: "",
                    FileExtensions: ""
                };
                var result = service.transformKeyValuePair(key, data);
                expect(result).toEqual({ key: 'FieldValidationRegex', value: /^.{0,50}$/ });
            });
            it("returns correct values when field.Children exists and & field.Type is 'Dropdown' and key is 'Children'", function () {
                var key = "Children";
                var data = {
                    FieldValidationRegex: "^.{0,50}$",
                    FileTypes: "",
                    FileExtensions: "",
                    Children: [],
                    Type: 'Dropdown'
                };
                var result = service.transformKeyValuePair(key, data);
                expect(result).toEqual({
                    key: "Options",
                    value: data.Children
                });
            });
            it("returns correct values when field.Children exists and & field.Type is 'Dropdown' and key is not 'Children'", function () {
                var key = "NotChildren";
                var data = {
                    FieldValidationRegex: "^.{0,50}$",
                    FileTypes: "",
                    FileExtensions: "",
                    Children: [],
                    Type: 'Dropdown'
                };
                var result = service.transformKeyValuePair(key, data);
                expect(result).toEqual({
                    key: key,
                    value: data[key]
                });
            });
            it("returns correct values when field.Children does not exists and & field.Type is not 'Dropdown' and transformationFunctions[key] does not exist", function () {
                var key = "NotChildren";
                var data = {
                    FieldValidationRegex: "^.{0,50}$",
                    FileTypes: "",
                    FileExtensions: "",
                    Children: [],
                    Type: 'NotDropdown'
                };
                var result = service.transformKeyValuePair(key, data);
                expect(result).toEqual({
                    key: key,
                    value: data[key]
                });
            });
        });
        describe("mapFields", function () {
            it("mapFields with parsing", function () {
                var data = [
                    {
                        "ItemID": "bfe97991 - f6bd - 457b - bd21 - bbe70940e7f6",
                        "ItemName": "Email",
                        "ItemPath": " / sitecore / content / HCTRA / HelpAndSupport / HelpAndSupportPageV2 / Email Us / FieldTypes / Email",
                        "ParentID": "cf55d44d - 80ee - 4c43 - 91cf - 7fa941d87eed",
                        "TemplateID": "96060c4c - 4dcb - 4ebd - 8391 - c1607612e081",
                        "TemplateName": "FieldType",
                        "CloneSource": null,
                        "ItemLanguage": "en",
                        "ItemVersion": "1",
                        "DisplayName": "Email",
                        "HasChildren": "False",
                        "ItemIcon": " / temp / iconcache / software / 32x32 / element_copy.png",
                        "ItemMedialUrl": " / ~/icon/Software / 48x48 / element_copy.png.aspx",
                        "ItemUrl": "~/link.aspx?_id=BFE97991F6BD457BBD21BBE70940E7F6&amp;_z=z",
                        "Comments": "",
                        "Properties": ""
                    }
                ];
                var result = service.mapFields(data);
                var resultComparison = { Email: { ItemName: 'Email', ItemPath: ' / sitecore / content / HCTRA / HelpAndSupport / HelpAndSupportPageV2 / Email Us / FieldTypes / Email', ParentID: 'cf55d44d - 80ee - 4c43 - 91cf - 7fa941d87eed', TemplateID: '96060c4c - 4dcb - 4ebd - 8391 - c1607612e081', TemplateName: 'FieldType', ItemLanguage: 'en', ItemVersion: '1', DisplayName: 'Email', HasChildren: 'False', ItemIcon: ' / temp / iconcache / software / 32x32 / element_copy.png', ItemMedialUrl: ' / ~/icon/Software / 48x48 / element_copy.png.aspx', ItemUrl: '~/link.aspx?_id=BFE97991F6BD457BBD21BBE70940E7F6&amp;_z=z' } };
                expect(result).toEqual(resultComparison);
            });
        });
        describe("createFormMapping", function () {
            it("createFormMapping with Regex output", function () {
                var data = [{
                        ItemName: "Topic",
                        Title: "Topic",
                        Children: [
                            {
                                ItemName: "FAQs",
                                HasChildren: "True",
                                Children: [
                                    {
                                        Field: "stuff",
                                        IsRequired: "1"
                                    }
                                ]
                            },
                            {
                                ItemName: "Fields",
                                HasChildren: "True",
                                Children: [
                                    {
                                        Title: "Title Fields",
                                        ShortDescription: "Some Data"
                                    }
                                ]
                            }
                        ]
                    }];
                var result = service.createFormMapping(data);
                var stuff = {
                    Topic: {
                        ShortDescription: undefined,
                        LongDescription: undefined,
                        Title: 'Topic',
                        Fields: [{
                                Field: undefined,
                                IsRequired: false
                            }],
                        FAQs: [{
                                Title: undefined,
                                ItemName: undefined,
                                Purpose: undefined,
                                ShortDescription: undefined,
                                LongDescription: undefined,
                                LastUpdate: undefined
                            }]
                    }
                };
                expect(result).toEqual(stuff);
            });
            it("returns empty arrays", function () {
                var data = [{
                        ItemName: "Topic",
                        Title: "Topic",
                        Children: [
                            {
                                ItemName: "FAQs",
                                HasChildren: "False"
                            },
                            {
                                ItemName: "Fields",
                                HasChildren: "False"
                            }
                        ]
                    }];
                var result = service.createFormMapping(data);
                var stuff = {
                    Topic: {
                        ShortDescription: undefined,
                        LongDescription: undefined,
                        Title: 'Topic',
                        Fields: [],
                        FAQs: []
                    }
                };
                expect(result).toEqual(stuff);
            });
        });
    });
})();
// (function () {
//     'use strict';
//     describe('MobileAppRedirectController', function () {
//         beforeEach(angular.mock.module('HCTRAModule'));
//         var $controller,
//             MobileAppRedirectController,
//             scope,
//             locationUrl,
//             searchWasCalled,
//             urlWasCalled,
//             searchObject = {},
//             location = {
//                 url: function (inUrl) {
//                     urlWasCalled = true;
//                     locationUrl = inUrl;
//                 },
//                 search: function () {
//                     searchWasCalled = true;
//                     return searchObject;
//                 }
//             },
//             $window = {
//                 location: {
//                     href: ""
//                 }
//             };
//         beforeEach(angular.mock.module(function ($provide) {
//             locationUrl = null;
//             searchWasCalled = false;
//             urlWasCalled = false;
//             $window.location.href = null;
//             searchObject = {};
//             $provide.value('$location', location);
//             $provide.value('routes', hctraMocks.routes());
//             $provide.value('$window', $window);
//         }));
//         beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
//             scope = _$rootScope_.$new();
//             $controller = _$controller_;
//         }));
//         it('verify search goes home when urlParams is undefined', function () {
//             searchObject = undefined;
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes home when urlParams is null', function () {
//             searchObject = null;
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes home when urlParams is an empty string', function () {
//             searchObject = "";
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes home when urlParams is an empty object', function () {
//             searchObject = {};
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes home when urlParams is an object containing a null webUrl', function () {
//             searchObject = { webUrl: null};
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes home when urlParams is an object containing an undefined webUrl', function () {
//             searchObject = { webUrl: undefined };
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes home when urlParams is an object containing an empty string webUrl', function () {
//             searchObject = { webUrl: "" };
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes home when urlParams is an object containing an object webUrl', function () {
//             searchObject = { webUrl: {} };
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(locationUrl).toEqual('/Home');
//             expect(urlWasCalled).toBeTruthy();
//             expect($window.location.href).toBeNull();
//         });
//         it('verify search goes redirect window when urlParams is an object containing an url string webUrl', function () {
//             searchObject = { webUrl: "/Login" };
//             MobileAppRedirectController = $controller('MobileAppRedirectController', { $scope: scope });
//             expect(searchWasCalled).toBeTruthy();
//             expect(urlWasCalled).toBeFalsy();
//             expect($window.location.href).toEqual("/Login");
//         });
//     });
// }());
(function () {
    "use strict";
    describe("accountBlockPopupService", function () {
        var stringUtilsMock = hctraMocks.stringUtilsService();
        beforeEach(angular.mock.module("HCTRAModule"));
        var service, osSnifferConfig = {
            osName: "Name",
            deviceName: "Device"
        }, mockModalService = {
            showModal: function () {
            }
        }, arg1 = { backdrop: true, keyboard: true, modalFade: true, templateUrl: '/app/templates/common/modalAlert.html' }, arg2 = { closeButtonText: 'Close', headerText: null, bodyText: 'test_browser_message' };
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("operatingSystemSnifferService", hctraMocks.operatingSystemSnifferService(osSnifferConfig));
            spyOn(mockModalService, 'showModal');
            spyOn(stringUtilsMock, 'getUrlParameter').and.callFake(function (a, b) {
                var val;
                switch (a) {
                    case 'MAPP_Login_Android':
                        val = 'test_android_message';
                        break;
                    case 'MAPP_Login_IOS':
                        val = 'test_ios_message';
                        break;
                    case 'MAPP_Login_Other':
                        val = 'test_other_message';
                        break;
                    case 'MAPP_Login_Browser':
                        val = 'test_browser_message';
                        break;
                }
                return val;
            });
            $provide.value("modalService", mockModalService);
            $provide.value('stringUtilsService', stringUtilsMock);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("accountBlockPopupService");
        }));
        it("should save popup messages from CMS with correct key and value", function () {
            service.savePopupMessages("MAPP_Login_Android=test_android_message&MAPP_Login_IOS=test_ios_message&MAPP_Login_Other=test_other_message&MAPP_Login_Browser=test_browser_message");
            expect(service.getPopupMessages().android).toBe("test_android_message");
            expect(service.getPopupMessages().ios).toBe("test_ios_message");
            expect(service.getPopupMessages().other).toBe("test_other_message");
            expect(service.getPopupMessages().browser).toBe("test_browser_message");
        });
        it("should display popup message for android", function () {
            service.savePopupMessages("MAPP_Login_Android=test_android_message&MAPP_Login_IOS=test_ios_message&MAPP_Login_Other=test_other_message&MAPP_Login_Browser=test_browser_message");
            osSnifferConfig.osName = "android";
            arg2.bodyText = "test_android_message";
            service.displayBlockPopup();
            expect(mockModalService.showModal).toHaveBeenCalledWith(arg1, arg2);
        });
        it("should display popup message for iOS", function () {
            service.savePopupMessages("MAPP_Login_Android=test_android_message&MAPP_Login_IOS=test_ios_message&MAPP_Login_Other=test_other_message&MAPP_Login_Browser=test_browser_message");
            osSnifferConfig.osName = "ios";
            arg2.bodyText = "test_ios_message";
            service.displayBlockPopup();
            expect(mockModalService.showModal).toHaveBeenCalledWith(arg1, arg2);
        });
        it("should display popup message for browser", function () {
            osSnifferConfig.deviceName = "Unknown";
            arg2.bodyText = "test_browser_message";
            service.savePopupMessages("MAPP_Login_Android=test_android_message&MAPP_Login_IOS=test_ios_message&MAPP_Login_Other=test_other_message&MAPP_Login_Browser=test_browser_message");
            osSnifferConfig.osName = "windows";
            service.displayBlockPopup();
            expect(mockModalService.showModal).toHaveBeenCalledWith(arg1, arg2);
            osSnifferConfig.osName = "macos";
            service.displayBlockPopup();
            expect(mockModalService.showModal).toHaveBeenCalledWith(arg1, arg2);
            osSnifferConfig.osName = "linux";
            service.displayBlockPopup();
            expect(mockModalService.showModal).toHaveBeenCalledWith(arg1, arg2);
        });
        it("should display popup message for 'other'", function () {
            service.savePopupMessages("MAPP_Login_Android=test_android_message&MAPP_Login_IOS=test_ios_message&MAPP_Login_Other=test_other_message&MAPP_Login_Browser=test_browser_message");
            osSnifferConfig.osName = "whatever";
            arg2.bodyText = "test_other_message";
            service.displayBlockPopup();
            expect(mockModalService.showModal).toHaveBeenCalledWith(arg1, arg2);
        });
    });
}());
(function () {
    'use strict';
    // describe('accountSummaryAlertFilterService', function () {
    //     //module() is registered on window and is a shortcut to angular.mock.module()
    //     //use it to mock the main app module
    //     //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
    //     // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
    //     // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
    //     beforeEach(angular.mock.module('HCTRAModule'));
    //     var service,
    //         inStorage = {},
    //         inAlertArr = [];
    //     beforeEach(angular.mock.module(function () {
    //         inStorage = {};
    //         inAlertArr = [{ alertMsg: 'test', alertId: 1 }];
    //     }));
    //     //$provide is a module-level object, and thus must get its own 
    //     //injection through the module() function
    //     beforeEach(angular.mock.module(function ($provide) {
    //         $provide.value('webStorage', hctraMocks.webStorage(inStorage));
    //     }));
    //     beforeEach(angular.mock.inject(function ($injector) {
    //         service = $injector.get('accountSummaryAlertFilterService');
    //     }));
    //     describe('filterAccountSummaryAlerts', function () {
    //         it('should not have alertStore inStorage', function () {
    //             expect(inStorage.alertStore).toBeUndefined();
    //         });
    //         it('should have test in alertStore inStorage', function () {
    //             service.filterAccountSummaryAlerts(inAlertArr);
    //             expect(inStorage.alertStore).toBeDefined();
    //             expect(inStorage.alertStore.test).toEqual(1);
    //         });
    //         it('should remove test from alertStore inStorage', function () {
    //             inStorage.alertStore = { test: 1 };
    //             service.filterAccountSummaryAlerts(inAlertArr);
    //             expect(inStorage.alertStore).toBeDefined();
    //             expect(inAlertArr).toBeDefined();
    //             expect(inAlertArr).not.toContain({ alertMsg: 'test', alertId: 1 });
    //         });
    //     });
    //     describe('filterEmailConfirmationAlert', function () {
    //         it('should store email and status in inStorage', function () {
    //             var emailAddress = 'test',
    //                 status = 'status';
    //             expect(service.filterEmailConfirmationAlert(emailAddress, status)).toBeTruthy();
    //             expect(inStorage.alertStore['emailConfirm:test:status']).toEqual('true');
    //         });
    //         it('should have email and status in inStorage', function () {
    //             var emailAddress = 'test',
    //                 status = 'status';
    //             service.filterEmailConfirmationAlert(emailAddress, status);
    //             expect(service.filterEmailConfirmationAlert(emailAddress, status)).toBeFalsy();
    //         });
    //     });
    //     describe('removeEntry', function () {
    //         it('should delete the alertStore', function () {
    //             inStorage.alertStore = 'true';
    //             service.removeAccountSummaryAlerts();
    //             expect(inStorage.alertStore).toBeUndefined();
    //         });
    //     });
    // });
}());
(function () {
    "use strict";
    describe("apiDateStringToJsObjectService", function () {
        var mockDateWithTimeZone;
        beforeEach(angular.mock.module("HCTRAModule"));
        var service;
        //getDate = ({ year, month, day, hour, minute, second }) => new Date(year, (month - 1), day, hour, minute, second);
        beforeEach(angular.mock.module(function ($provide) {
            mockDateWithTimeZone = jasmine.createSpy("dateWithTimeZoneFilter");
            $provide.value("dateWithTimeZoneFilter", mockDateWithTimeZone);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("apiDateStringToJsObjectService");
        }));
        describe("canary", function () {
            it("canary", function () {
                expect(true).toBe(true);
            });
        });
        describe("convertApiDateToJsObject", function () {
            it("should call convertStringToDate with the property named in propIn for each record in passed array", function () {
                mockDateWithTimeZone.and.returnValue("test");
                service.convertApiDateToJsObject([{ in: "1" }, { in: "2" }, { in: "3" }], "in", "out");
                expect(mockDateWithTimeZone).toHaveBeenCalledTimes(3);
                expect(mockDateWithTimeZone).toHaveBeenCalledWith("1", "dateTimeFull");
                expect(mockDateWithTimeZone).toHaveBeenCalledWith("2", "dateTimeFull");
                expect(mockDateWithTimeZone).toHaveBeenCalledWith("3", "dateTimeFull");
            });
            it("should assign value returned by convertStringToDate to property named in propOut for each record in passed array", function () {
                mockDateWithTimeZone.and.returnValues("first", "second", "third");
                var obj = [{ in: "1" }, { in: "2" }, { in: "3" }];
                expect(service.convertApiDateToJsObject(obj, "in", "out")).toEqual([
                    { in: "1", out: "first" },
                    { in: "2", out: "second" },
                    { in: "3", out: "third" }
                ]);
            });
        });
    });
})();
(function () {
    "use strict";
    describe("ArrayUtilService", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var _responseErrorService, service, equal = function (u, v) { return u === v; };
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("arrayUtilService");
        }));
        describe("intersect", function () {
            it("should return correct intersect of primitive types", function () {
                // Sets are identical
                var result = service.intersect([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], equal);
                expect(result).toEqual([1, 2, 3, 4, 5]);
                // Second set is subset of first set
                result = service.intersect([1, 2, 3, 4, 5], [1, 2, 3, 4], equal);
                expect(result).toEqual([1, 2, 3, 4]);
                // First set is subset of second set
                result = service.intersect([1, 2, 3, 4], [1, 2, 3, 4, 5], equal);
                expect(result).toEqual([1, 2, 3, 4]);
                // Second set is empty
                result = service.intersect([1, 2, 3, 4, 5], [], equal);
                expect(result).toEqual([]);
                // First set is empty
                result = service.intersect([], [1, 2, 3, 4, 5], equal);
                expect(result).toEqual([]);
                // Both sets are empty
                result = service.intersect([], [], equal);
                expect(result).toEqual([]);
            });
            it("should return correct intersect of identical object types", function () {
                // Arrays of same object type
                var result = service.intersect([
                    new TestObj(1, "test1"),
                    new TestObj(2, "test2")
                ], [
                    new TestObj(1, "test1"),
                    new TestObj(3, "test3")
                ], TestObj.areEqual);
                expect(result.length).toBe(1);
                expect(result[0].prop1).toBe(1);
                expect(result[0].prop2).toBe("test1");
            });
            it("should return correct intersect of different object types where 'equality' is defined", function () {
                // Arrays of different object types
                var result = service.intersect([
                    new TestObj(1, "test1"),
                    new TestObj(2, "test2")
                ], [
                    new TestObj2("test1", 1),
                    new TestObj2("test3", 3)
                ], function (u, v) { return u.prop1 === v.prop2 && u.prop2 === v.prop1; }); // Function must define "equality"
                expect(result.length).toBe(1);
                expect(result[0].prop1).toBe(1);
                expect(result[0].prop2).toBe("test1");
            });
        });
        // Tests needed for difference - none exists because difference is not being used at the moment
        xdescribe("difference", function () { });
        describe("find", function () {
            it("should return the first primitive to match the predicate function", function () {
                var result1 = service.find([1, 2, 3], function (u) { return u === 3; });
                expect(result1).toBe(3);
                var result2 = service.find([1, 2, 2, 2, 2], function (u) { return u === 2; });
                expect(result2).toBe(2);
            });
            it("should return the first object for which the predicate function is true", function () {
                var result1 = service.find([new TestObj(6, "test1"), new TestObj(8, "test2")], function (u) { return u.prop1 === 8; });
                expect(result1.prop1).toBe(8);
                expect(result1.prop2).toBe("test2");
                var result2 = service.find([new TestObj(6, "test1"), new TestObj(8, "test2"), new TestObj(8, "test3")], function (u) { return u.prop1 === 8; });
                expect(result2.prop1).toBe(8);
                expect(result2.prop2).toBe("test2");
            });
            it("should return undefined if the predicate function returns false for every element", function () {
                var result1 = service.find([1, 2, 3], function (u) { return u === 10; });
                expect(result1).not.toBeDefined();
                var result2 = service.find([1, 2, 2, 2, 2], function (u) { return u === 10; });
                expect(result2).not.toBeDefined();
            });
        });
        describe("toDictionary", function () {
            it("should correctly map the simple array of objects to a dictionary", function () {
                var testArr = [
                    { prop1: 'val1' },
                    { prop1: 'val2' },
                    { prop1: 'val3' }
                ];
                var testDict = service.toDictionary(testArr, function (u) { return u.prop1; });
                expect(testDict.val1.prop1).toBe('val1');
                expect(testDict.val2.prop1).toBe('val2');
                expect(testDict.val3.prop1).toBe('val3');
            });
            it("should correctly map the simple array of numbers to a dictionary", function () {
                var testArr = [
                    5,
                    8,
                    10
                ];
                var testDict = service.toDictionary(testArr, function (u) { return u; });
                expect(testDict[5]).toBe(5);
                expect(testDict[8]).toBe(8);
                expect(testDict[10]).toBe(10);
            });
            it("should correctly map the simple array of strings to a dictionary", function () {
                var testArr = [
                    "one",
                    "two",
                    "three"
                ];
                var testDict = service.toDictionary(testArr, function (u) { return u; });
                expect(testDict.one).toBe("one");
                expect(testDict.two).toBe("two");
                expect(testDict.three).toBe("three");
            });
            it("should overwrite duplicate keys with last value encountered", function () {
                var testArr = [
                    { prop1: 'val1', prop2: 'one' },
                    { prop1: 'val1', prop2: 'two' },
                    { prop1: 'val3', prop2: 'three' }
                ];
                var testDict = service.toDictionary(testArr, function (u) { return u.prop1; });
                expect(testDict.val1.prop1).toBe('val1');
                expect(testDict.val1.prop2).toBe('two');
                expect(testDict.val3.prop1).toBe('val3');
                expect(testDict.val3.prop2).toBe('three');
            });
            it("should be able to modify key used by dictionary", function () {
                var testArr = [
                    { prop1: 'val1' },
                    { prop1: 'val2' },
                    { prop1: 'val3' }
                ];
                var testDict = service.toDictionary(testArr, function (u) { return u.prop1 + '90'; });
                expect(testDict.val190.prop1).toBe('val1');
                expect(testDict.val290.prop1).toBe('val2');
                expect(testDict.val390.prop1).toBe('val3');
            });
        });
        var TestObj = /** @class */ (function () {
            function TestObj(prop1, prop2) {
                this.prop1 = prop1;
                this.prop2 = prop2;
            }
            TestObj.areEqual = function (u, v) {
                return u.prop1 === v.prop1 && u.prop2 === v.prop2;
            };
            return TestObj;
        }());
        var TestObj2 = /** @class */ (function () {
            function TestObj2(prop1, prop2) {
                this.prop1 = prop1;
                this.prop2 = prop2;
            }
            TestObj2.areEqual = function (u, v) {
                return u.prop1 === v.prop1 && u.prop2 === v.prop2;
            };
            return TestObj2;
        }());
    });
}());
(function () {
    'use strict';
    describe('bowserService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('bowserService');
        }));
        it('should return the browser summary', function () {
            expect(service.getUserBrowserInfo()).toBeDefined();
        });
    });
}());
(function () {
    "use strict";
    describe("BroadcastSubmissionService", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var _responseErrorService, service;
        describe("registerSubmitter", function () {
            var childScope;
            var rootScope;
            beforeEach(angular.mock.inject(function ($injector, _$rootScope_) {
                service = $injector.get("broadcastSubmissionService");
                rootScope = _$rootScope_;
                childScope = _$rootScope_.$new(true, rootScope);
            }));
            it("should broadcast submissionIdentifier provided and return a promise which can be resolved by a listener", function (done) {
                childScope.$on("aSubmission", function (event, deferred) {
                    deferred.resolve();
                });
                service.broadcast("aSubmission")
                    .then(done)
                    .catch(function () { return fail("expected promise to resolve"); });
                rootScope.$apply();
            }, 100);
            it("should broadcast submissionIdentifier provided and return a promise which can be rejected by a listener", function (done) {
                childScope.$on("aSubmission", function (event, deferred) {
                    deferred.reject();
                });
                service.broadcast("aSubmission")
                    .then(function () { return fail("expected promise to reject"); })
                    .catch(done);
                rootScope.$apply();
            }, 100);
        });
    });
})();
/*
declare var hctraMocks: any;

(function () {
    "use strict";

    describe("browserExtensionHandlerService", function () {

        beforeEach(angular.mock.module("HCTRAModule"));

        var service: HCTRA.Service.BrowserExtensionHandlerService,
            state: angular.ui.IState,
            omnitureService: HCTRA.Service.IOmnitureService,
            googleAnalyticsService: HCTRA.Service.IGoogleAnalyticsService;


        beforeEach(function () {
            state = {};
        });

        describe("all files are loaded", function () {

            beforeEach(angular.mock.module(function ($provide: angular.auto.IProvideService) {
                googleAnalyticsService = hctraMocks.googleAnalyticsService();
                omnitureService = hctraMocks.omnitureService();

                $provide.value("omnitureService", omnitureService);
                $provide.value("googleAnalyticsService", googleAnalyticsService);
                $provide.value("errorLogService", hctraMocks.errorLogService());

                spyOn(googleAnalyticsService, "sendTag");
                spyOn(omnitureService, "sendTag");
            }));

            beforeEach(angular.mock.inject(function ($injector: angular.auto.IInjectorService) {
                service = $injector.get<HCTRA.Service.BrowserExtensionHandlerService>("browserExtensionHandlerService");
                spyOn(service, "errorLogService").and.callFake(hctraMocks.errorLogService());
            }));

            it("should call omniture normally", function () {
                service.sendTag(state, "test string");
                expect(omnitureService.sendTag).toHaveBeenCalledWith(state, "test string");
                expect(googleAnalyticsService.sendTag).toHaveBeenCalledWith("test string");
                expect(service.errorLogService).not.toHaveBeenCalled();
            });
        });



        describe("some files are excluded", function () {
            var injector: angular.auto.IInjectorService;

            beforeEach(angular.mock.module(function ($provide: angular.auto.IProvideService) {
                $provide.value("omnitureService", undefined);
                $provide.value("googleAnalyticsService", hctraMocks.googleAnalyticsService());
                $provide.value("errorLogService", hctraMocks.errorLogService());
            }));

            beforeEach(angular.mock.inject(function ($injector: angular.auto.IInjectorService) {
                injector = $injector;
                service = injector.get<HCTRA.Service.BrowserExtensionHandlerService>("browserExtensionHandlerService");
            }));

            beforeEach(function () {
                spyOn(service, "errorLogService").and.callFake(hctraMocks.errorLogService());
            });


            it("should error out when calling omniture", function () {
                service.sendTag(state, "test string");
                expect(service.errorLogService).toHaveBeenCalled();
            });

            it("should error out only once when calling omniture many times", function () {
                service.sendTag(state, "test string");
                expect(service.errorLogService.calls.count()).toBe(1);

                service.sendTag(state, "test string");
                expect(service.errorLogService.calls.count()).toBe(1);
            });
        });

    });
} ());
 */ 
(function () {
    'use strict';
    describe('conditionalStylesService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('conditionalStylesService');
        }));
        it('should return empty if isHidden is true', function () {
            expect(service.formWidth(true)).toEqual('');
        });
        it('should return form-entry-width if isHidden is false', function () {
            expect(service.formWidth(false)).toEqual('form-entry-width');
        });
    });
}());
(function () {
    'use strict';
    describe('accountSummaryAlertFilterService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('creditCardTypes', hctraMocks.creditCardTypes);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('creditCardConversionService');
        }));
        it('should convert "V" to "VISA"', function () {
            expect(service.convertCodeToString('V')).toEqual('VISA');
        });
        it('should convert "M" to "MASTERCARD"', function () {
            expect(service.convertCodeToString('M')).toEqual('MASTERCARD');
        });
        it('should convert "D" to "DISCOVER"', function () {
            expect(service.convertCodeToString('D')).toEqual('DISCOVER');
        });
        it('should convert "A" to "AMERICAN EXPRESS"', function () {
            expect(service.convertCodeToString('A')).toEqual('AMERICAN EXPRESS');
        });
    });
}());
// (function (): void {
//     "use strict";
//     describe("service: creditCardInputService", () => {
//         beforeEach(angular.mock.module("HCTRAModule"));
//         let scope;
//         let rootScope;
//         let storefrontUtilityService;
//         let service;
//         let dataFactoryMock;
//         let vantivPaymentServiceMock;
//         let responseErrorServiceMock;
//         let modalServiceMock;
//         let envConfig;
//         let q;
//         function flush() {
//             if (rootScope)
//                 rootScope.$apply();
//             if (scope)
//                 scope.$apply();
//         }
//         function buildScope(creditCard = null) {
//             scope = rootScope.$new();
//             scope.creditCardTypes = ["VISA", "DISCOVER", "MASTERCARD", "AMEX"];
//             scope.creditCard = creditCard || {};
//             scope.form = {};
//             scope.suffix = 'theCreditCardDirective';
//             scope.useExistingCard = true;
//             return service.setup(scope);
//             //flush();
//         }
//         beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//             storefrontUtilityService = {
//                 isRunningAsKiosk: false,
//                 isSecureCardInputAvailable: false,
//                 storefrontLocation: HCTRA.Model.StoreLocations.UKN,
//                 machineName: null,
//                 webStoreData: null,
//                 defaultMachineName: "Default",
//                 delay: {
//                     short: 100,
//                     long: 1000
//                 }
//             };
//             dataFactoryMock = jasmine.createSpyObj("dataFactory", ["TriPosConfiguration", "TriPosStatus"]);
//             vantivPaymentServiceMock = jasmine.createSpyObj("vativPayment", ["getTokenizedCreditCardData"]);
//             responseErrorServiceMock = jasmine.createSpyObj("responseErrorService", ["displayAlertsFromResponse", "displayToast"]);
//             modalServiceMock = jasmine.createSpyObj("modalService", ["creditCardPromptModal", "closeByName", "newModalScope", "isModalOpen"]);
//             modalServiceMock.modalNames = {
//                 CreditCardPrompt: "CreditCardPrompt"
//             };
//             $provide.factory("$q", ["replacementQService", function (replacementQService) {            
//                 return replacementQService;
//             }]);
//             $provide.value("StorefrontUtilityService", storefrontUtilityService);
//             envConfig = hctraMocks.environmentConfig();
//             envConfig.storefrontConfigs = { KioskConfigs : {} };
//             envConfig.storefrontConfigs.KioskConfigs[storefrontUtilityService.defaultMachineName] = {};
//             $provide.constant("environmentConfig", envConfig);
//             $provide.value("modalService", modalServiceMock);
//             $provide.value("responseErrorService", responseErrorServiceMock);
//             $provide.value("genericRepo", { dataFactory: dataFactoryMock });
//             $provide.value("validationService", {});
//             $provide.value("iFrameService", {
//                 getIFrameServiceInstance: () => {
//                     return {
//                         loadIFrame: () => { },
//                         getPaypageRegistrationId: () => { }
//                     }
//                 }
//             });
//             $provide.value("creditCardConversionService", {
//                 convertCodeToString: (cardCode) => { return cardCode; }
//             });
//             $provide.value("pciInfoService", {
//                 isMasked: () => { return true; }
//             });
//             $provide.value("vantivPaymentService", vantivPaymentServiceMock);
//         }));
//         beforeEach(angular.mock.inject(($injector, $rootScope: angular.IRootScopeService) => {
//             rootScope = $rootScope;
//             service = $injector.get('creditCardInputService');
//             q = $injector.get('$q');
//         }));
//         beforeEach(() => {
//             modalServiceMock.creditCardPromptModal.and.returnValue(q.resolve(true));
//             modalServiceMock.newModalScope.and.returnValue(rootScope.$new());
//             modalServiceMock.isModalOpen.and.returnValue(true);
//         });
//         describe("Non-kiosk configuration", () => {
//             it("should use iframe", () => {
//                 storefrontUtilityService.isRunningAsKiosk = false;
//                 envConfig.vantivConfig.IFrameEnabled = true;
//                 return buildScope().then(() => {
//                     expect(scope.strategyUsed).toBe(HCTRA.Model.CreditCardInputStrategyEnum.Iframe);
//                     expect(scope.creditCardNameDisabled).toBeFalsy();
//                     expect(scope.creditCardNumberDisabled).toBeFalsy();
//                     expect(scope.creditCardExpYearDisabled).toBeFalsy();
//                     expect(scope.creditCardExpMothDisabled).toBeFalsy();
//                 }).catch(e => {
//                     fail(e);
//                 });
//             });
//             it("should use litel", () => {
//                 storefrontUtilityService.isRunningAsKiosk = false;
//                 envConfig.vantivConfig.IFrameEnabled = false;
//                 return buildScope().then(() => {
//                     expect(scope.strategyUsed).toBe(HCTRA.Model.CreditCardInputStrategyEnum.Litel);
//                     expect(scope.creditCardNameDisabled).toBeFalsy();
//                     expect(scope.creditCardNumberDisabled).toBeFalsy();
//                     expect(scope.creditCardExpYearDisabled).toBeFalsy();
//                     expect(scope.creditCardExpMothDisabled).toBeFalsy();
//                 }).catch(e => {
//                     fail(e);
//                 });
//             });
//         });
//         describe("Kiosk configuration", () => {
//             const triPosConfig: HCTRA.Model.VantivTriPosConfiguration = {
//                 acceptorId: null,
//                 accountId: null,
//                 errors: null,
//                 laneId: 9999,
//                 url: "https://localhost:789",
//                 accountStatus: null,
//                 applicationId: null,
//                 accountToken: null,
//                 applicationName: "name",
//                 applicationVersion: "version",
//                 authorization: null,
//                 alerts: null,
//                 exception: null,
//                 requestId: null,
//                 sessionTimedOut: null,
//                 vaultId: null
//             };
//             const triPosStatus: HCTRA.Model.VantivTriPosStatus = {
//                 errors: null,
//                 alerts: null,
//                 exception: null,
//                 active: null,
//                 allowCreditCardInputWhenDeviceDisabled: false,
//                 sessionTimedOut: null,
//                 accountStatus: null,
//                 getCardNameFromTriPos: true
//             };
//             let vantivPaymentServiceResponse: HCTRA.Model.VantivTriPosCreateOmniTokenResponse;
//             beforeEach(() => {
//                 triPosStatus.getCardNameFromTriPos = true;
//                 triPosStatus.allowCreditCardInputWhenDeviceDisabled = false;
//                 vantivPaymentServiceResponse = {
//                     accountNumber: null,
//                     binValue: null,
//                     cardHolderName: null,
//                     cardLogo: "",
//                     entryMode: null,
//                     expirationMonth: "1",
//                     expirationYear: "20",
//                     isOffline: null,
//                     merchantId: null,
//                     transactionDateTime: null,
//                     tokenId: null,
//                     tokenProvider: null
//                 };
//                 dataFactoryMock.TriPosConfiguration.and.callFake(() => {
//                     return q.resolve(triPosConfig);
//                 });
//                 dataFactoryMock.TriPosStatus.and.callFake(() => {
//                     return q.resolve(triPosStatus);
//                 });
//                 vantivPaymentServiceMock.getTokenizedCreditCardData.and.callFake(() => {
//                     return q.resolve(vantivPaymentServiceResponse);
//                 });
//             });
//             it("should disable all CC info fields", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = true;
//                 vantivPaymentServiceResponse.cardLogo = "VISA";
//                 return buildScope().then(() => {
//                     expect(scope.creditCardNumberDisabled).toBeTruthy();
//                     expect(scope.creditCardExpYearDisabled).toBeTruthy();
//                     expect(scope.creditCardExpMothDisabled).toBeTruthy();
//                 }).catch(e => {
//                     fail(e);
//                 });
//             });
//             it("should get tokenized data on update", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = true;
//                 vantivPaymentServiceResponse.cardLogo = "VISA";
//                 vantivPaymentServiceResponse.cardHolderName = "TESTER";
//                 vantivPaymentServiceResponse.binValue = "314159";
//                 vantivPaymentServiceResponse.accountNumber = "************-3141";
//                 vantivPaymentServiceResponse.expirationMonth = "3";
//                 vantivPaymentServiceResponse.expirationYear = "2025";
//                 return buildScope().then(() => {
//                     return service.update(scope)
//                 }).then(() => {
//                     expect(vantivPaymentServiceMock.getTokenizedCreditCardData).toHaveBeenCalled();
//                     expect(scope.creditCard.omniToken).toBe(vantivPaymentServiceResponse.tokenId);
//                     expect(scope.creditCard.cardNbr).toBe(vantivPaymentServiceResponse.accountNumber);
//                     expect(scope.creditCard.cardCode).toBe('V');
//                     expect(scope.creditCard.cardTypeDisplay).toBe('V');
//                     expect(scope.creditCard.isNewCard).toBe(true);
//                     expect(scope.creditCard.nameOnCard).toBe(vantivPaymentServiceResponse.cardHolderName);
//                     expect(scope.creditCard.expMonth).toBe(+vantivPaymentServiceResponse.expirationMonth);
//                     expect(scope.creditCard.selectedYear).toBe(vantivPaymentServiceResponse.expirationYear);
//                     }).catch(e => {
//                         fail(e);
//                     });
//             });
//             it("should use empty string for card name when status demands it", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = true;
//                 triPosStatus.getCardNameFromTriPos = false;
//                 vantivPaymentServiceResponse.cardHolderName = "TESTER";
//                 return buildScope().then(() => {
//                     return service.update(scope);
//                 }).then(() => {
//                     scope.$apply();
//                     expect(scope.creditCard.nameOnCard).toBe("");
//                 });
//             });
//             it("should rotate lastname/firstname I", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = true;
//                 vantivPaymentServiceResponse.cardHolderName = "Lastname/Firstname I";
//                 return buildScope().then(() => {
//                     scope.$apply();
//                     return service.update(scope);
//                 }).then(() => {
//                     scope.$apply();
//                     expect(scope.creditCard.nameOnCard).toBe("Firstname I Lastname");
//                     });
//             });
//             it("should block CC input if device is down", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = false;
//                 vantivPaymentServiceResponse.cardLogo = "VISA";
//                 return buildScope().then(() => {
//                     return service.update(scope)
//                         .then(() => {
//                             fail("update should have failed");
//                         })
//                         .catch(() => {
//                             expect(vantivPaymentServiceMock.getTokenizedCreditCardData).not.toHaveBeenCalled();
//                         })
//                         .finally(() => {
//                             expect(scope.creditCardNumberDisabled).toBeTruthy();
//                             expect(scope.creditCardExpYearDisabled).toBeTruthy();
//                             expect(scope.creditCardExpMothDisabled).toBeTruthy();
//                         });
//                 }).catch(e => {
//                     fail(e);
//                 });
//             });
//             it("should allow CC input if device is down but configured to accept", () => {
//                 envConfig.vantivConfig.IFrameEnabled = true;
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = false;
//                 triPosStatus.allowCreditCardInputWhenDeviceDisabled = true;
//                 vantivPaymentServiceResponse.cardLogo = "VISA";
//                 return buildScope().then(() => {
//                     expect(scope.strategyUsed).toBe(HCTRA.Model.CreditCardInputStrategyEnum.Iframe);
//                     expect(scope.creditCardNumberDisabled).toBeFalsy();
//                     expect(scope.creditCardExpYearDisabled).toBeFalsy();
//                     expect(scope.creditCardExpMothDisabled).toBeFalsy();
//                 }).catch(e => {
//                     fail(e);
//                 });
//             });
//             it("should block CC input if default and configured so", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = storefrontUtilityService.defaultMachineName;
//                 envConfig.storefrontConfigs.KioskConfigs = {};
//                 envConfig.storefrontConfigs.KioskConfigs[storefrontUtilityService.defaultMachineName] = {}
//                 envConfig.storefrontConfigs.KioskConfigs[storefrontUtilityService.defaultMachineName].AllowCreditCardInputWhenDeviceDisabled = false;
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = false;
//                 vantivPaymentServiceResponse.cardLogo = "VISA";
//                 return buildScope().then(() => {
//                     return service.update(scope)
//                         .then(() => {
//                             fail("update should have failed");
//                         })
//                         .catch(() => {
//                             expect(vantivPaymentServiceMock.getTokenizedCreditCardData).not.toHaveBeenCalled();
//                         })
//                         .finally(() => {
//                             expect(scope.creditCardNumberDisabled).toBeTruthy();
//                             expect(scope.creditCardExpYearDisabled).toBeTruthy();
//                             expect(scope.creditCardExpMothDisabled).toBeTruthy();
//                         });
//                 }).catch(e => {
//                     fail(e);
//                 });
//             });
//             it("should allow CC input if default is configured so", () => {
//                 envConfig.vantivConfig.IFrameEnabled = true;
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = storefrontUtilityService.defaultMachineName;
//                 envConfig.storefrontConfigs.KioskConfigs = {};
//                 envConfig.storefrontConfigs.KioskConfigs[storefrontUtilityService.defaultMachineName] = {}
//                 envConfig.storefrontConfigs.KioskConfigs[storefrontUtilityService.defaultMachineName].AllowCreditCardInputWhenDeviceDisabled = true;
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = false;
//                 triPosStatus.allowCreditCardInputWhenDeviceDisabled = true;
//                 vantivPaymentServiceResponse.cardLogo = "VISA";
//                 return buildScope().then(() => {
//                     expect(scope.strategyUsed).toBe(HCTRA.Model.CreditCardInputStrategyEnum.Iframe);
//                     expect(scope.creditCardNumberDisabled).toBeFalsy();
//                     expect(scope.creditCardExpYearDisabled).toBeFalsy();
//                     expect(scope.creditCardExpMothDisabled).toBeFalsy();
//                 }).catch(e => {
//                     fail(e);
//                 });
//             });
//             it("should not wipe credit card name if change was detected", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = true;
//                 vantivPaymentServiceResponse.cardHolderName = "Lastname/Firstname I";
//                 //set
//                 return buildScope({
//                     nameOnCard: "TEST TEST"
//                 }).then(() => {
//                     //change
//                     scope.$apply();
//                     expect(scope.detectedCreditCardNameChange).toBe(false);                    
//                     scope.creditCard.nameOnCard = "TEST2 TEST2";
//                     scope.$apply();
//                     expect(scope.detectedCreditCardNameChange).toBe(true);
//                     return service.update(scope);
//                     }).then(() => {
//                         scope.$apply();
//                         expect(scope.creditCard.nameOnCard).toBe("TEST2 TEST2");
//                     });
//             });
//             it("should wipe credit card name if no change was detected", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = true;
//                 vantivPaymentServiceResponse.cardHolderName = "Lastname/Firstname I";
//                 //set
//                 return buildScope({
//                     nameOnCard: "TEST TEST"
//                 }).then(() => {
//                     //no change!
//                     scope.$apply();
//                     return service.update(scope);
//                     }).then(() => {  
//                         scope.$apply();                  
//                     expect(scope.creditCard.nameOnCard).toBe("Firstname I Lastname");
//                     });
//             });
//             it("should flag use existing card as false if swipe changes card number", () => {
//                 storefrontUtilityService.isRunningAsKiosk = true;
//                 storefrontUtilityService.isSecureCardInputAvailable = true;
//                 storefrontUtilityService.storefrontLocation = HCTRA.Model.StoreLocations.TNO;
//                 storefrontUtilityService.machineName = "TestKiosk";
//                 storefrontUtilityService.webStoreData = {
//                     sessionId: 0,
//                     selectedItemIds: [],
//                     currentItemName: "name",
//                     currentItemId: 1,
//                     fullSiteMode: false,
//                     completedItemIds: [],
//                     shellUserInitialized: true
//                 } as HCTRA.Storefront.Service.IStorefrontWebStorage;
//                 triPosStatus.active = true;
//                 vantivPaymentServiceResponse.cardHolderName = "Lastname/Firstname I";
//                 vantivPaymentServiceResponse.accountNumber = "************-1234";
//                 //set
//                 return buildScope({
//                     nameOnCard: "TEST TEST",
//                     cardNbr: "************-5309"
//                 }).then(() => {
//                     scope.$apply();
//                     expect(scope.useExistingCard).toBe(true);
//                     expect(scope.creditCard.cardNbr).toBe("************-5309");
//                     return service.update(scope);
//                     }).then(() => {
//                         scope.$apply();
//                         expect(scope.useExistingCard).toBe(false);
//                         expect(scope.creditCard.cardNbr).toBe("************-1234");
//                     });
//             });
//         });
//     });
// }());
(function () {
    'use strict';
    // describe('dateWithTimeZoneService', () => {
    //     beforeEach(angular.mock.module('HCTRAModule'));
    //     let _responseErrorService,
    //         service: HCTRA.Service.IDateWithTimeZoneService;
    //     beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //         service = $injector.get<HCTRA.Service.IDateWithTimeZoneService>('dateWithTimeZoneService');
    //     }));
    //     describe('canary', () => {
    //         it('should pass', () => {
    //             expect(true).toBe(true);
    //         });
    //     });
    //     describe('withOffsetToCentral', () => {
    //         [
    //             ["YYYY-MM-DDTHH:mm", "2019-04-05 09:30:26.123+03:00", "2019-04-05T01:30"],
    //             ["YYYY-MM-DDTHH:mm", "2015-05-15T12:00:50-00:00", "2015-05-15T07:00"],
    //             ["YYYY-MM-DDTHH:mm", "2019-12-01T12:00:50-12:00", "2019-12-01T18:00"],
    //             ["YYYY-MM-DDTHH:mm", "09/30/2019 12:00 PM -05:00", "2019-09-30T12:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "2019-04-05 07:30:26.123+03:00", "2019-04-04T23:30:26-05:00"],
    //             ["YYYY-MM-DDTHH:mm", "09/30/2019 02:00 AM -00:00", "2019-09-29T21:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "2019-04-05 09:30:26.123+03:00", "2019-04-05T01:30:26-05:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "2015-05-15T12:00:50-00:00", "2015-05-15T07:00:50-05:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "2019-12-01T12:00:50-12:00", "2019-12-01T18:00:50-06:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "09/30/2019 12:00 PM -05:00", "2019-09-30T12:00:00-05:00"]
    //         ].forEach(([format, dateWithOffSet, expected]) => {
    //             it(`should convert ${dateWithOffSet} to ${expected} when requested format is ${format}`, () => {
    //                 expect(service.withOffsetToCentral(dateWithOffSet, format)).toBe(expected);
    //             });
    //         });
    //     });
    //     describe('withoutOffsetToCentral', () => {
    //         [
    //             ["YYYY-MM-DDTHH:mm:ssZ", "2019-04-05 09:30:26.123", "2019-04-05T09:30:26-05:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "2015-05-15T12:00:50", "2015-05-15T12:00:50-05:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "2019-12-01T12:00:50", "2019-12-01T12:00:50-06:00"],
    //             ["YYYY-MM-DDTHH:mm:ssZ", "09/30/2019 12:00 PM", "2019-09-30T12:00:00-05:00"],
    //             ["YYYY-MM-DDTHH:mm:ss z", "2019-04-05 09:30:26.123", "2019-04-05T09:30:26 CDT"],
    //             ["YYYY-MM-DDTHH:mm:ss z", "2015-05-15T12:00:50", "2015-05-15T12:00:50 CDT"],
    //             ["YYYY-MM-DDTHH:mm:ss z", "2019-12-01T12:00:50", "2019-12-01T12:00:50 CST"],
    //             ["YYYY-MM-DDTHH:mm:ss z", "09/30/2019 12:00 PM", "2019-09-30T12:00:00 CDT"]
    //         ].forEach(([format, dateWithoutOffSet, expected]) => {
    //             it(`should convert ${dateWithoutOffSet} to ${expected} when requested format is ${format}`, () => {
    //                 expect(service.withoutOffsetToCentral(dateWithoutOffSet, format)).toBe(expected);
    //             });
    //         });
    //     });
    // });
})();
(function () {
    'use strict';
    describe('DesktopMenuRouteService', function () {
        var mockGenericRepo = {
            dataFactory: {
                getToggleStatus: function () {
                    return {
                        toggleStatus: true,
                        toggleName: "someToggle"
                    };
                }
            }
        };
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('genericRepo', mockGenericRepo);
            $provide.value('$state', hctraMocks.fake$state());
            $provide.value('urlManagerService', hctraMocks.urlManagerService());
            $provide.value('MegaMenuCache', hctraMocks.megaMenuCache());
            $provide.value('responseErrorService', hctraMocks.responseErrorService());
            $provide.value('AuthService', hctraMocks.AuthService());
            $provide.value('routes', hctraMocks.routes());
            $provide.value('isInvoicedService', hctraMocks.isInvoicedService());
            $provide.value('USER_ROLES', hctraMocks.USER_ROLES());
            $provide.value('futureRoutes', {});
        }));
        beforeEach(function () {
            spyOn(mockGenericRepo.dataFactory, "getToggleStatus").and.callThrough();
        });
        var service;
        describe('authorizeRoute', function () {
            var mockedAuthService = hctraMocks.AuthService();
            var authServiceSpy;
            beforeEach(angular.mock.module(function ($provide) {
                $provide.value('AuthService', mockedAuthService);
                $provide.value('USER_ROLES', { anonymous: 'anonymous' });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                authServiceSpy = spyOn(mockedAuthService, 'isAuthorized');
            }));
            it('should return true when AuthService.isAuthorized() returns true and passed array does not contain USER_ROLES', function () {
                authServiceSpy.and.returnValue(true);
                expect(service.authorizeRoute({ authorizedRoles: [] })).toBe(true);
            });
            it('should return true when AuthService.isAuthorized() returns false and passed array contains USER_ROLES', function () {
                authServiceSpy.and.returnValue(false);
                expect(service.authorizeRoute({ authorizedRoles: ['anonymous'] })).toBe(true);
            });
            it('should return true when AuthService.isAuthorized() returns true and passed array contains USER_ROLES', function () {
                authServiceSpy.and.returnValue(true);
                expect(service.authorizeRoute({ authorizedRoles: ['anonymous'] })).toBe(true);
            });
            it('should return false when AuthService.isAuthorized() returns false and passed array does not contain USER_ROLES', function () {
                authServiceSpy.and.returnValue(false);
                expect(service.authorizeRoute({ authorizedRoles: [] })).toBe(false);
            });
        });
        describe('isInvoicedAndLinkUpdateReplenishAmount ', function () {
            var mockedAuthService = hctraMocks.AuthService();
            var mockedisInvoicedService = hctraMocks.isInvoicedService();
            var mockedRoutes = hctraMocks.routes();
            var profileRoutes = { UpdateReplenishmentAmount: '/UpdateReplenishAmount' };
            var accountActivityRoutes = { accountActivityInvoices: '/AccountActivityInvoices' };
            var isAuthenticatedSpy;
            var isInvoicedSpy;
            beforeEach(angular.mock.module(function ($provide) {
                $provide.value('AuthService', mockedAuthService);
                $provide.value('isInvoicedService', mockedisInvoicedService);
                $provide.constant('routes', mockedRoutes);
                $provide.constant('profileRoutes', profileRoutes);
                $provide.constant('accountActivityRoutes', accountActivityRoutes);
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                isAuthenticatedSpy = spyOn(mockedAuthService, 'isAuthenticated');
                isInvoicedSpy = spyOn(mockedisInvoicedService, 'isAccountInvoiced');
            }));
            it("should return true when isAuthenticated true and isAccountInvoiced true and linkUrl updateReplenishAmount", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(true);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(profileRoutes.UpdateReplenishmentAmount)).toBe(true);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced true and linkUrl updateReplenishAmount", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(true);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(profileRoutes.UpdateReplenishmentAmount)).toBe(false);
            });
            it("should return false when isAuthenticated true and isAccountInvoiced false and linkUrl updateReplenishAmount", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(profileRoutes.UpdateReplenishmentAmount)).toBe(false);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced false and linkUrl updateReplenishAmount", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(profileRoutes.UpdateReplenishmentAmount)).toBe(false);
            });
            it("should return false when isAuthenticated true and isAccountInvoiced true and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(true);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount('something else')).toBe(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(accountActivityRoutes.accountActivityInvoices)).toBe(false);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced true and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(true);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount('something else')).toBe(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(accountActivityRoutes.accountActivityInvoices)).toBe(false);
            });
            it("should return false when isAuthenticated true and isAccountInvoiced false and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount('something else')).toBe(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(accountActivityRoutes.accountActivityInvoices)).toBe(false);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced false and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount('something else')).toBe(false);
                expect(service.isInvoicedAndLinkUpdateReplenishAmount(accountActivityRoutes.accountActivityInvoices)).toBe(false);
            });
        });
        describe('notInvoicedAndLinkAccountActivityInvoices ', function () {
            var mockedAuthService = hctraMocks.AuthService();
            var mockedisInvoicedService = hctraMocks.isInvoicedService();
            var mockedRoutes = hctraMocks.routes();
            var profileRoutes = { UpdateReplenishmentAmount: '/UpdateReplenishAmount' };
            var accountActivityRoutes = { accountActivityInvoices: '/AccountActivityInvoices' };
            var isAuthenticatedSpy;
            var isInvoicedSpy;
            beforeEach(angular.mock.module(function ($provide) {
                $provide.value('AuthService', mockedAuthService);
                $provide.value('isInvoicedService', mockedisInvoicedService);
                $provide.constant('routes', mockedRoutes);
                $provide.constant('profileRoutes', profileRoutes);
                $provide.constant('accountActivityRoutes', accountActivityRoutes);
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                isAuthenticatedSpy = spyOn(mockedAuthService, 'isAuthenticated');
                isInvoicedSpy = spyOn(mockedisInvoicedService, 'isAccountInvoiced');
            }));
            it("should return true when isAuthenticated true and isAccountInvoiced false and linkUrl accountActivityInvoices", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(accountActivityRoutes.accountActivityInvoices)).toBe(true);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced false and linkUrl accountActivityInvoices", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(accountActivityRoutes.accountActivityInvoices)).toBe(false);
            });
            it("should return false when isAuthenticated true and isAccountInvoiced true and linkUrl accountActivityInvoices", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(true);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(accountActivityRoutes.accountActivityInvoices)).toBe(false);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced true and linkUrl accountActivityInvoices", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(true);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(accountActivityRoutes.accountActivityInvoices)).toBe(false);
            });
            it("should return false when isAuthenticated true and isAccountInvoiced false and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices('something else')).toBe(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(profileRoutes.UpdateReplenishmentAmount)).toBe(false);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced false and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices('something else')).toBe(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(profileRoutes.UpdateReplenishmentAmount)).toBe(false);
            });
            it("should return false when isAuthenticated true and isAccountInvoiced true and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(true);
                isInvoicedSpy.and.returnValue(true);
                expect(service.notInvoicedAndLinkAccountActivityInvoices('something else')).toBe(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(profileRoutes.UpdateReplenishmentAmount)).toBe(false);
            });
            it("should return false when isAuthenticated false and isAccountInvoiced true and linkUrl something else", function () {
                isAuthenticatedSpy.and.returnValue(false);
                isInvoicedSpy.and.returnValue(true);
                expect(service.notInvoicedAndLinkAccountActivityInvoices('something else')).toBe(false);
                expect(service.notInvoicedAndLinkAccountActivityInvoices(profileRoutes.UpdateReplenishmentAmount)).toBe(false);
            });
        });
        describe('isAccountPaymentPlanUrlAndNoPaymentPlansAvailable ', function () {
            var mockedAuthService = hctraMocks.AuthService();
            var paymentPlansRoutes = { accountOverviewSummary: '/fakeRoute' };
            var isAuthenticatedSpy;
            beforeEach(angular.mock.module(function ($provide) {
                $provide.value('AuthService', mockedAuthService);
                $provide.constant('paymentPlansRoutes', paymentPlansRoutes);
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                service['$rootScope'].currentUser = { hasPaymentPlans: false };
                isAuthenticatedSpy = spyOn(mockedAuthService, 'isAuthenticated');
            }));
            it("should return true when isAuthenticated true and linkUrl paymentPlanRoutes.accountOverviewSummary and no payment plans", function () {
                isAuthenticatedSpy.and.returnValue(true);
                service['$rootScope'].currentUser.hasPaymentPlans = false;
                expect(service.isAccountPaymentPlanUrlAndNoPaymentPlansAvailable('/fakeRoute')).toBe(true);
            });
            [
                [false, '/something', false],
                [false, '/something', true],
                [false, '/fakeRoute', false],
                [false, '/fakeRoute', true],
                [true, '/something', false],
                [true, '/something', true],
                //[true, '/fakeRoute', false],
                [true, '/fakeRoute', true],
            ].forEach(function (_a) {
                var isAuthenticated = _a[0], link = _a[1], hasPaymentPlans = _a[2];
                it("should return false when isAuthenticated false or linkUrl not paymentPlanRoutes.accountOverviewSummary or payment plans present", function () {
                    isAuthenticatedSpy.and.returnValue(isAuthenticated);
                    service['$rootScope'].currentUser.hasPaymentPlans = hasPaymentPlans;
                    expect(service.isAccountPaymentPlanUrlAndNoPaymentPlansAvailable(link)).toBe(false);
                });
            });
        });
        describe('isLinkAuthorized ', function () {
            var mockedAuthorizeRoute;
            var mockedIsInvoicedAndLinkUpdateReplenishAmount;
            var mockedNotInvoicedAndLinkAccountActivityInvoices;
            var mockedIsAccountPaymentPlanUrlAndNoPaymentPlansAvailable;
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                mockedAuthorizeRoute = spyOn(service, 'authorizeRoute');
                mockedIsInvoicedAndLinkUpdateReplenishAmount = spyOn(service, 'isInvoicedAndLinkUpdateReplenishAmount');
                mockedNotInvoicedAndLinkAccountActivityInvoices = spyOn(service, 'notInvoicedAndLinkAccountActivityInvoices');
                mockedIsAccountPaymentPlanUrlAndNoPaymentPlansAvailable = spyOn(service, 'isAccountPaymentPlanUrlAndNoPaymentPlansAvailable');
            }));
            it('should call authorizeRoute with link\'s authorizedRoles, isInvoicedAndLinkUpdateReplenishAmount with link\'s url and notInvoicedAndLinkAccountActivityInvoices with link\'s url', function () {
                mockedAuthorizeRoute.and.returnValue(true);
                mockedIsInvoicedAndLinkUpdateReplenishAmount.and.returnValue(false);
                mockedNotInvoicedAndLinkAccountActivityInvoices.and.returnValue(false);
                mockedIsAccountPaymentPlanUrlAndNoPaymentPlansAvailable.and.returnValue(false);
                service.isLinkAuthorized({ url: 'myUrl', authorizedRoles: ['1', '009'] });
                expect(mockedAuthorizeRoute).toHaveBeenCalledWith({ url: 'myUrl', authorizedRoles: ['1', '009'] });
                expect(mockedIsInvoicedAndLinkUpdateReplenishAmount).toHaveBeenCalledWith('myUrl');
                expect(mockedNotInvoicedAndLinkAccountActivityInvoices).toHaveBeenCalledWith('myUrl');
                expect(mockedIsAccountPaymentPlanUrlAndNoPaymentPlansAvailable).toHaveBeenCalledWith('myUrl');
            });
            it("should return true when link Authorized and not (isInvoicedAndLinkUpdateReplenishAmount or notInvoicedAndLinkAccountActivityInvoices or isAccountPaymentPlanUrlAndNoPaymentPlansAvailable)", function () {
                mockedAuthorizeRoute.and.returnValue(true);
                mockedIsInvoicedAndLinkUpdateReplenishAmount.and.returnValue(false);
                mockedNotInvoicedAndLinkAccountActivityInvoices.and.returnValue(false);
                mockedIsAccountPaymentPlanUrlAndNoPaymentPlansAvailable.and.returnValue(false);
                expect(service.isLinkAuthorized({})).toBe(true);
            });
            [
                [false, false, false, false],
                [false, false, false, true],
                [false, false, true, false],
                [false, false, true, true],
                [false, true, false, false],
                [false, true, false, true],
                [false, true, true, false],
                [false, true, true, true],
                //[true, false, false, false],
                [true, false, false, true],
                [true, false, true, false],
                [true, false, true, true],
                [true, true, false, false],
                [true, true, false, true],
                [true, true, true, false],
                [true, true, true, true],
            ].forEach(function (_a) {
                var authorizeRoute = _a[0], isInvoicedAndLinkUpdateReplenishAmount = _a[1], notInvoicedAndLinkAccountActivityInvoices = _a[2], isAccountPaymentPlanUrlAndNoPaymentPlansAvailable = _a[3];
                it("should return false when authorizeRoute false or isInvoicedAndLinkUpdateReplenishAmount true or notInvoicedAndLinkAccountActivityInvoices true or isAccountPaymentPlanUrlAndNoPaymentPlansAvailable true", function () {
                    mockedAuthorizeRoute.and.returnValue(authorizeRoute);
                    mockedIsInvoicedAndLinkUpdateReplenishAmount.and.returnValue(isInvoicedAndLinkUpdateReplenishAmount);
                    mockedNotInvoicedAndLinkAccountActivityInvoices.and.returnValue(notInvoicedAndLinkAccountActivityInvoices);
                    mockedIsAccountPaymentPlanUrlAndNoPaymentPlansAvailable.and.returnValue(isAccountPaymentPlanUrlAndNoPaymentPlansAvailable);
                    expect(service.isLinkAuthorized({})).toBe(false);
                });
            });
        });
        describe('getAuthorizedMegaMenuHelper', function () {
            var authorizeRouteSpy;
            var isLinkAuthorizedSpy;
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                authorizeRouteSpy = spyOn(service, 'authorizeRoute');
                isLinkAuthorizedSpy = spyOn(service, 'isLinkAuthorized');
            }));
            it('should remove megaMenu item when authorize route return false', function () {
                isLinkAuthorizedSpy.and.returnValue(true);
                authorizeRouteSpy.and.returnValues(false, true, false);
                var megaMenu = [
                    { authorizedRoles: '1', menuColumns: [{ subMenus: [{ links: [1, 2] }] }] },
                    { authorizedRoles: '2', menuColumns: [{ subMenus: [{ links: [1, 2] }] }] },
                    { authorizedRoles: '3', menuColumns: [{ subMenus: [{ links: [1, 2] }] }] }
                ];
                expect(service.getAuthorizedMegaMenuHelper(megaMenu)).toEqual([{ authorizedRoles: '2', menuColumns: [{ subMenus: [{ links: [1, 2] }] }] }]);
                expect(authorizeRouteSpy).toHaveBeenCalledWith({ authorizedRoles: '1', menuColumns: [{ subMenus: [{ links: [1, 2] }] }] }, 0, megaMenu);
                expect(authorizeRouteSpy).toHaveBeenCalledWith({ authorizedRoles: '2', menuColumns: [{ subMenus: [{ links: [1, 2] }] }] }, 1, megaMenu);
                expect(authorizeRouteSpy).toHaveBeenCalledWith({ authorizedRoles: '3', menuColumns: [{ subMenus: [{ links: [1, 2] }] }] }, 2, megaMenu);
                expect(authorizeRouteSpy).toHaveBeenCalledTimes(3);
            });
            it('should remove menuColumn when subMenus array empty', function () {
                isLinkAuthorizedSpy.and.returnValue(true);
                authorizeRouteSpy.and.returnValue(true);
                var megaMenu = [{ authorizedRoles: '', menuColumns: [
                            { id: 1, subMenus: [{ links: [1, 2] }] },
                            { id: 2, subMenus: [] },
                            { id: 3, subMenus: [{ links: [1, 2] }] }
                        ] }];
                expect(service.getAuthorizedMegaMenuHelper(megaMenu)).toEqual([{
                        authorizedRoles: '', menuColumns: [
                            { id: 1, subMenus: [{ links: [1, 2] }] },
                            { id: 3, subMenus: [{ links: [1, 2] }] }
                        ]
                    }]);
            });
            it('should remove subMenus when links array empty', function () {
                isLinkAuthorizedSpy.and.returnValue(true);
                authorizeRouteSpy.and.returnValue(true);
                var megaMenu = [{ authorizedRoles: '', menuColumns: [{ subMenus: [{ id: 1, links: [1, 2] }, { id: 2, links: [1, 2] }, { id: 3, links: [] }] }] }];
                expect(service.getAuthorizedMegaMenuHelper(megaMenu)).toEqual([{ authorizedRoles: '', menuColumns: [{ subMenus: [{ id: 1, links: [1, 2] }, { id: 2, links: [1, 2] }] }] }]);
            });
            it('should remove links when isLinkAuthorized returns false', function () {
                isLinkAuthorizedSpy.and.returnValues(true, false, true);
                authorizeRouteSpy.and.returnValue(true);
                var megaMenu = [{ authorizedRoles: '', menuColumns: [{ subMenus: [{ links: [1, 2, 3] }] }] }];
                expect(service.getAuthorizedMegaMenuHelper(megaMenu)).toEqual([{ authorizedRoles: '', menuColumns: [{ subMenus: [{ links: [1, 3] }] }] }]);
                expect(isLinkAuthorizedSpy).toHaveBeenCalledWith(1, 0, [1, 2, 3]);
                expect(isLinkAuthorizedSpy).toHaveBeenCalledWith(2, 1, [1, 2, 3]);
                expect(isLinkAuthorizedSpy).toHaveBeenCalledWith(3, 2, [1, 2, 3]);
            });
        });
        describe('getAuthorizedMegaMenu', function () {
            var getAuthorizeMegaMenuHelperSpy;
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                getAuthorizeMegaMenuHelperSpy = spyOn(service, 'getAuthorizedMegaMenuHelper');
            }));
            it('should return results from authorizeMegaMenuHelper when routesIn defined', function () {
                getAuthorizeMegaMenuHelperSpy.and.returnValue(['result']);
                expect(service.getAuthorizedMegaMenu(['input'])).toEqual(['result']);
                expect(getAuthorizeMegaMenuHelperSpy).toHaveBeenCalledWith(['input']);
            });
            it('should return undefined when routesIn undefined and not call authorizeMegaMenuHelper', function () {
                expect(service.getAuthorizedMegaMenu(undefined)).toEqual(undefined);
                expect(getAuthorizeMegaMenuHelperSpy).not.toHaveBeenCalled();
            });
        });
        describe('getFullUrl', function () {
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
            }));
            it('should return empty string when name has no periods and not in statelist', function () {
                expect(service.getFullUrl('test', [{ name: 'notTest', url: 'a' }])).toEqual('');
            });
            it('should return empty string when name has no periods and statelist without url', function () {
                expect(service.getFullUrl('test', [{ name: '' }, { name: 'notTest', url: 'a' }])).toEqual('');
            });
            it('should return url when name has no periods and in statelist with url', function () {
                expect(service.getFullUrl('test', [{ name: 'test', url: 'a' }])).toEqual('a');
            });
            it('should return url when name has one period and in statelist with url and parent not in statelist', function () {
                expect(service.getFullUrl('parent.test', [{ name: 'parent.test', url: 'a' }])).toEqual('a');
            });
            it('should return url when name has one period and in statelist with url and parent in statelist without url', function () {
                expect(service.getFullUrl('parent.test', [{ name: 'parent.test', url: 'a' }, { name: 'parent' }])).toEqual('a');
            });
            it('should return concatenation of parent url and own url when name has one period and in statelist with url and parent in statelist with url', function () {
                expect(service.getFullUrl('parent.test', [{ name: 'parent.test', url: 'a' }, { name: 'parent', url: 'parent_' }])).toEqual('parent_a');
            });
            it('should return concatenation of parent url and own url when name has two periods and in statelist with url, parent in statelist with url, grandparent in statelist without url', function () {
                expect(service.getFullUrl('grandparent.parent.test', [{ name: 'grandparent.parent.test', url: 'a' }, { name: 'grandparent.parent', url: 'parent_' }, { name: 'grandparent' }]))
                    .toEqual('parent_a');
            });
            it('should return concatenation of grandparent url and own url when name has two periods and in statelist with url, parent in statelist without url, grandparent in statelist with url', function () {
                expect(service.getFullUrl('grandparent.parent.test', [{ name: 'grandparent.parent.test', url: 'a' }, { name: 'grandparent.parent' }, { name: 'grandparent', url: 'grandparent_' }]))
                    .toEqual('grandparent_a');
            });
            it('should return concatenation of grandparent url, parent url and own url when name has two periods and in statelist with url, parent in statelist with url, grandparent in statelist with url', function () {
                expect(service.getFullUrl('grandparent.parent.test', [{ name: 'grandparent.parent.test', url: 'a' }, { name: 'grandparent.parent', url: 'parent_' }, { name: 'grandparent', url: 'grandparent_' }]))
                    .toEqual('grandparent_parent_a');
            });
        });
        describe('getAuthorizedRoles', function () {
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
            }));
            it('should return authorized roles from angularjs route', function () {
                expect(service.getAuthorizedRoles({ data: { authorizedRoles: ['1', '2'] } })).toEqual(['1', '2']);
            });
            it('should return authorized roles from angular route', function () {
                expect(service.getAuthorizedRoles({ resolve: [{ authorizedRoles: ['3', '2'] }] })).toEqual(['3', '2']);
            });
            it('should return authorized roles from angular route when both angular and angularjs style authorizedRoles present', function () {
                expect(service.getAuthorizedRoles({ data: { authorizedRoles: ['1', '4'] }, resolve: [{ authorizedRoles: ['3', '2'] }] })).toEqual(['3', '2']);
            });
            [
                {},
                { data: {} },
                { data: { authorizedRoles: [] } },
                { resolve: [] },
                { resolve: [{}] },
                { resolve: [{ authorizedRoles: [] }] }
            ].forEach(function (state) {
                it('should return empty list when no authorized roles', function () {
                    expect(service.getAuthorizedRoles(state)).toEqual([]);
                });
            });
        });
        describe('configUrlWithStateName', function () {
            var getFullUrlSpy;
            var getAuthorizedRolesSpy;
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
                getFullUrlSpy = spyOn(service, 'getFullUrl');
                getAuthorizedRolesSpy = spyOn(service, 'getAuthorizedRoles');
            }));
            it('should call getFullUrl and getAuthorizedRouteService with correct arguments', function () {
                getFullUrlSpy.and.returnValue('fullUrl');
                getAuthorizedRolesSpy.and.returnValue([1, 2, 3]);
                service.getFullUrlToAuthorizedRolesDictionary([{ url: 'theUrl', name: 'theName' }]);
                expect(getFullUrlSpy).toHaveBeenCalledWith('theName', [{ url: 'theUrl', name: 'theName' }]);
                expect(getAuthorizedRolesSpy).toHaveBeenCalledWith({ url: 'theUrl', name: 'theName' });
            });
            it('should return empty object when statesWithNames have blank, null or undefined urls only', function () {
                var result = service.getFullUrlToAuthorizedRolesDictionary([{ url: '', name: 'theName' }, { url: null, name: 'theName' }, { url: undefined, name: 'theName' }]);
                expect(result).toEqual({});
            });
            it('should return empty object when statesWithNames have urls with empty authorization roles', function () {
                getFullUrlSpy.and.returnValue('fullUrl');
                getAuthorizedRolesSpy.and.returnValue([]);
                var result = service.getFullUrlToAuthorizedRolesDictionary([{ url: 'a', name: 'theName' }, { url: 'b', name: 'theName' }]);
                expect(result).toEqual({});
            });
            it('should return dictionary where keys are fullUrls and values authorized roles when statesWithNames have valid urls with non-empty authorization roles', function () {
                getFullUrlSpy.and.returnValues('fullUrl1', 'fullUrl2');
                getAuthorizedRolesSpy.and.returnValues([1, 2], [3, 4]);
                var result = service.getFullUrlToAuthorizedRolesDictionary([{ url: 'a', name: 'theName' }, { url: 'b', name: 'theName' }]);
                expect(result).toEqual({ fullUrl1: [1, 2], fullUrl2: [3, 4] });
            });
        });
        describe('addAuthorizedRolesToMegaMenuNavRoutes', function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.value('USER_ROLES', { anonymous: 'anonymous' });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
            }));
            it('should add anonymous role to top level routes when no matching keys in fullUrlToAuthorizedRolesDictionary', function () {
                var topRoute1 = { url: 'a' };
                var topRoute2 = { url: 'b' };
                var topRoute3 = { url: 'c' };
                expect(service.getMegaMenuNavRoutesWithAuthorizedRoles([topRoute1, topRoute2, topRoute3], {}, {}))
                    .toEqual([{ url: 'a', authorizedRoles: ['anonymous'] }, { url: 'b', authorizedRoles: ['anonymous'] }, { url: 'c', authorizedRoles: ['anonymous'] }]);
            });
            it('should add matching roles to top level routes when matching keys in fullUrlToAuthorizedRolesDictionary', function () {
                var topRoute1 = { url: 'a' };
                var topRoute2 = { url: 'b' };
                var topRoute3 = { url: 'c' };
                expect(service.getMegaMenuNavRoutesWithAuthorizedRoles([topRoute1, topRoute2, topRoute3], { a: [1, 3], b: [2, 4], c: [9] }, {}))
                    .toEqual([{ url: 'a', authorizedRoles: [1, 3] }, { url: 'b', authorizedRoles: [2, 4] }, { url: 'c', authorizedRoles: [9] }]);
            });
            it('should add authorized roles to links', function () {
                var link1 = { url: 'a', openNewTab: true };
                var link2 = { url: 'b', openNewTab: false };
                var link3 = { url: 'c', openNewTab: true };
                var topRoute = [{ url: '', menuColumns: [{ subMenus: [{ links: [link1, link2, link3] }] }] }];
                expect(service.getMegaMenuNavRoutesWithAuthorizedRoles(topRoute, { a: [1, 3], b: [2, 4], c: [9] }, { selfTarget: 'self', openTabTarget: 'openTabTarget' })).
                    toEqual([{
                        url: '',
                        authorizedRoles: ['anonymous'],
                        menuColumns: [{
                                subMenus: [{
                                        links: [
                                            { url: 'a', openNewTab: true, target: 'openTabTarget', authorizedRoles: [1, 3] },
                                            { url: 'b', openNewTab: false, target: 'self', authorizedRoles: [2, 4] },
                                            { url: 'c', openNewTab: true, target: 'openTabTarget', authorizedRoles: [9] }
                                        ]
                                    }]
                            }]
                    }]);
            });
        });
        describe('getMegaMenu', function () {
            var responseErrorServiceSpy;
            beforeEach(angular.mock.module(function ($provide) {
                var mockedResponseErrorService = hctraMocks.responseErrorService();
                $provide.value('responseErrorService', mockedResponseErrorService);
                responseErrorServiceSpy = spyOn(mockedResponseErrorService, 'displayAlertsFromResponse');
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('desktopMenuRouteService');
            }));
            it('should call aresponseErrorService.displayAlertsFromResponse with correct argument', function () {
                service.getMegaMenu('response');
                expect(responseErrorServiceSpy).toHaveBeenCalledWith('response');
            });
            it('should return response.navBar when no error', function () {
                expect(service.getMegaMenu({ navBar: ['navBar'] })).toEqual(['navBar']);
            });
            it('should return empty Array when error', function () {
                expect(service.getMegaMenu({ navBar: ['navBar'], errors: 'some error' })).toEqual([]);
            });
        });
    });
})();
(function () {
    'use strict';
    // describe('editInvoicedMessageService', function () {
    //     //module() is registered on window and is a shortcut to angular.mock.module()
    //     //use it to mock the main app module
    //     //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
    //     // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
    //     // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
    //     beforeEach(angular.mock.module('HCTRAModule'));
    //     var service,
    //         inModal = {},
    //         modalOptions = {};
    //     beforeEach(angular.mock.module(function () {
    //         inModal = {};
    //         modalOptions = {};
    //     }));
    //     //$provide is a module-level object, and thus must get its own 
    //     //injection through the module() function
    //     beforeEach(angular.mock.module(function ($provide) {
    //         $provide.value('modalService', hctraMocks.modalService(inModal, modalOptions));
    //     }));
    //     beforeEach(angular.mock.inject(function ($injector) {
    //         service = $injector.get('editInvoicedMessageService');
    //     }));
    //     it('should store inModal value', function () {
    //         service('555-555-5555').invoicedMessage();
    //         expect(inModal.value).toBeDefined();
    //         expect(inModal.value).toEqual('called');
    //     });
    //     it('should store modalOptions optionA', function () {
    //         service('555-555-5555').invoicedMessage();
    //         expect(modalOptions.A).toBeDefined();
    //         expect(modalOptions.A.backdrop).toEqual(true);
    //         expect(modalOptions.A.keyboard).toEqual(true);
    //         expect(modalOptions.A.modalFade).toEqual(true);
    //         expect(modalOptions.A.templateUrl).toEqual('/app/templates/common/modalAlert.html');
    //     });
    //     it('should store modalOptions optionB', function () {
    //         service('555-555-5555').invoicedMessage();
    //         expect(modalOptions.B).toBeDefined();
    //         expect(modalOptions.B.closeButtonText).toEqual('Close');
    //         expect(modalOptions.B.headerText).toEqual('Invoiced Account');
    //         expect(modalOptions.B.bodyText).toEqual('Billing related information cannot be modified because the account is invoiced, please call ' + '555-555-5555' + ' for further assistance.');
    //     });
    // });
}());
(function () {
    'use strict';
    // describe('EventTrackingService', function () {
    //     beforeEach(angular.mock.module("HCTRAModule"));
    //     let service: HCTRA.Service.EventTrackingService;
    //     const getNumInvoicesWithCollectionFeeOut = { value: 0 };
    //     const mockViolationsUtilService = {
    //             getNumInvoicesWithCollectionFee: function () {
    //                 return getNumInvoicesWithCollectionFeeOut.value;
    //             }
    //         };
    //     const mockBrowserExtensionHandlerService = {
    //             sendEvent: () => { }
    //         };
    //         //clickEventListener = null,
    //     const mockDomUtilService = {
    //             //documentAddClickEventListener: cb => clickEventListener = cb
    //             documentAddClickEventListener: cb => cb
    //         };
    //     beforeEach(angular.mock.module(function ($provide: angular.auto.IProvideService) {
    //         spyOn(mockBrowserExtensionHandlerService, 'sendEvent');
    //         $provide.value("browserExtensionHandlerService", mockBrowserExtensionHandlerService);
    //         $provide.value("violationsUtilService", mockViolationsUtilService);
    //         $provide.value("domUtilService", mockDomUtilService);
    //     }));
    //     beforeEach(angular.mock.inject(function ($injector: angular.auto.IInjectorService) {
    //         service = $injector.get<HCTRA.Service.EventTrackingService>("eventTrackingService");
    //     }));
    //     describe('violationsTrackViolationsCounts method', function () {
    //         it('should not track if no invoices', function () {
    //             getNumInvoicesWithCollectionFeeOut.value = 0;
    //             service.violationsTrackViolationCounts([]);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).not.toHaveBeenCalled();
    //         });
    //         it('should track collection invoices', function () {
    //             getNumInvoicesWithCollectionFeeOut.value = 3;
    //             service.violationsTrackViolationCounts([null, null, null]);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'violations_payment', 'collections-invoices', 3);
    //         });
    //         it('should track non-collection invoices', function () {
    //             getNumInvoicesWithCollectionFeeOut.value = 0;
    //             service.violationsTrackViolationCounts([null, null, null]);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'violations_payment', 'non-collections-invoices', 3);
    //         });
    //         it('should track collection and non-collection invoices together', function () {
    //             getNumInvoicesWithCollectionFeeOut.value = 3;
    //             service.violationsTrackViolationCounts([null, null, null, null, null, null]);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(2);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'violations_payment', 'collections-invoices', 3);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'violations_payment', 'non-collections-invoices', 3);
    //         });
    //     });
    //     describe('suspendedAccountTrackViolationCounts method', function () {
    //         describe('FRP eligible', function () {
    //             it('should track successful FRP eligible payments if all succeed', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [
    //                         chargesByPlateFactory('AB', '1234', [null], [null]),
    //                         chargesByPlateFactory('CD', '5678', [null, null], [null, null]),
    //                         chargesByPlateFactory('EF', '9012', [null, null, null], [null, null, null])
    //                     ],
    //                     ineligibleChargesByPlateList: []
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'AB-1234' },
    //                         { label: 'CD-5678' },
    //                         { label: 'EF-9012' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(2);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-invoices', 6);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-violations', 6);
    //             });
    //             it('should track successful FRP eligible payments even if some fail', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [
    //                         chargesByPlateFactory('AB', '1234', [null], [null]),
    //                         chargesByPlateFactory('CD', '5678', [null, null], [null, null]),
    //                         chargesByPlateFactory('EF', '9012', [null, null, null], [null, null, null])
    //                     ],
    //                     ineligibleChargesByPlateList: []
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'CD-5678' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(2);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-invoices', 2);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-violations', 2);
    //             });
    //             it('should not track FRP eligible payments if none succeed', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [
    //                         chargesByPlateFactory('AB', '1234', [null], [null]),
    //                         chargesByPlateFactory('CD', '5678', [null, null], [null, null]),
    //                         chargesByPlateFactory('EF', '9012', [null, null, null], [null, null, null])
    //                     ],
    //                     ineligibleChargesByPlateList: []
    //                 };
    //                 const response: any = {
    //                     successfulPayments: []
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).not.toHaveBeenCalled();
    //             });
    //             it('should track successful FRP eligible payments for invoices w/ no violations', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [
    //                         chargesByPlateFactory('CD', '5678', [null, null], [])
    //                     ],
    //                     ineligibleChargesByPlateList: []
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'CD-5678' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-invoices', 2);
    //             });
    //             it('should track successful FRP eligible payments for invoices w/ no violations', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [
    //                         chargesByPlateFactory('CD', '5678', [], [null, null])
    //                     ],
    //                     ineligibleChargesByPlateList: []
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'CD-5678' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-violations', 2);
    //             });
    //         });
    //         describe('FRP ineligible', function () {
    //             it('should track successful FRP inligible payments if all succeed', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [],
    //                     ineligibleChargesByPlateList: [
    //                         chargesByPlateFactory('AB', '1234', [null], []),
    //                         chargesByPlateFactory('CD', '5678', [null, null], []),
    //                         chargesByPlateFactory('EF', '9012', [null, null, null], [])
    //                     ]
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'AB-1234' },
    //                         { label: 'CD-5678' },
    //                         { label: 'EF-9012' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-ineligible-plate-invoices', 6);
    //             });
    //             it('should track successful FRP inligible payments even if some fail', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [],
    //                     ineligibleChargesByPlateList: [
    //                         chargesByPlateFactory('AB', '1234', [null], []),
    //                         chargesByPlateFactory('CD', '5678', [null, null], []),
    //                         chargesByPlateFactory('EF', '9012', [null, null, null], [])
    //                     ]
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'CD-5678' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-ineligible-plate-invoices', 2);
    //             });
    //             it('should not track FRP ineligible payments if none succeed', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [],
    //                     ineligibleChargesByPlateList: [
    //                         chargesByPlateFactory('AB', '1234', [null], [null]),
    //                         chargesByPlateFactory('CD', '5678', [null, null], [null, null]),
    //                         chargesByPlateFactory('EF', '9012', [null, null, null], [null, null, null])
    //                     ]
    //                 };
    //                 const response: any = {
    //                     successfulPayments: []
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).not.toHaveBeenCalled();
    //             });
    //             it('should track successful FRP ineligible payments for invoices w/ no violations', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [],
    //                     ineligibleChargesByPlateList: [
    //                         chargesByPlateFactory('CD', '5678', [null, null], [])
    //                     ]
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'CD-5678' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-ineligible-plate-invoices', 2);
    //             });
    //             it('should not track FRP ineligible payments for violations w/ no invoices because this situation should not exist', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [],
    //                     ineligibleChargesByPlateList: [
    //                         chargesByPlateFactory('CD', '5678', [], [null, null])
    //                     ]
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'CD-5678' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).not.toHaveBeenCalled();
    //             });
    //         });
    //         describe('FRP eligible and FRP ineligible together', function () {
    //             it('should track all three if successful', function () {
    //                 const request: any = {
    //                     frpChargesByPlateList: [
    //                         chargesByPlateFactory('AB', '1234', [null, null], [null])
    //                     ],
    //                     ineligibleChargesByPlateList: [
    //                         chargesByPlateFactory('CD', '5678', [null, null, null], [])
    //                     ]
    //                 };
    //                 const response: any = {
    //                     successfulPayments: [
    //                         { label: 'AB-1234' },
    //                         { label: 'CD-5678' }
    //                     ]
    //                 };
    //                 service.suspendedAccountTrackViolationCounts(request, response);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(3);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-invoices', 2);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-eligible-plate-violations', 1);
    //                 expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'suspended_payment', 'frp-ineligible-plate-invoices', 3);
    //             });
    //         });
    //         function chargesByPlateFactory(licensePlateState: string, licensePlateNumber: string, invoices: any[], violations: any[]) {
    //             return { licensePlateState, licensePlateNumber, frpCheckEligibilityResult: { invoices, violations } };
    //         }
    //     });
    //     describe('frpTrackViolationCounts method', function () {
    //         it('should track FRP violations and invoices if both present', function () {
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(4, 2, 1), uninvoicedViolationsFactory(4, 2, 1));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 0, 1), uninvoicedViolationsFactory(0, 0, 1));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 2, 0), uninvoicedViolationsFactory(0, 2, 0));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(4, 0, 0), uninvoicedViolationsFactory(4, 0, 0));
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(8);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 7);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 1);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 2);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 4);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 7);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 1);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 2);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 4);
    //         });
    //         it('should track FRP invoices', function () {
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(4, 2, 1), uninvoicedViolationsFactory(0, 0, 0));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 0, 1), uninvoicedViolationsFactory(0, 0, 0));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 2, 0), uninvoicedViolationsFactory(0, 0, 0));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(4, 0, 0), uninvoicedViolationsFactory(0, 0, 0));
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(4);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 7);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 1);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 2);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-invoices', 4);
    //         });
    //         it('should track FRP violations', function () {
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 0, 0), uninvoicedViolationsFactory(4, 2, 1));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 0, 0), uninvoicedViolationsFactory(0, 0, 1));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 0, 0), uninvoicedViolationsFactory(0, 2, 0));
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 0, 0), uninvoicedViolationsFactory(4, 0, 0));
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(4);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 7);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 1);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 2);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'frp_payment', 'frp-violations', 4);
    //         });
    //         it('should not track if no invoices or violations; should not occur', function () {
    //             service.frpTrackViolationCounts(invoicedViolationsFactory(0, 0, 0), uninvoicedViolationsFactory(0, 0, 0));
    //             expect(mockBrowserExtensionHandlerService.sendEvent).not.toHaveBeenCalled();
    //         });
    //         function invoicedViolationsFactory(numHData: number, numFData: number, numMData: number) {
    //             return {
    //                 hData: genNullArray(numHData),
    //                 fData: genNullArray(numFData),
    //                 mData: genNullArray(numMData)
    //             };
    //         }
    //         function uninvoicedViolationsFactory(numHData: number, numFData: number, numMData: number) {
    //             return {
    //                 invoices: {
    //                     hData: genNullArray(numHData),
    //                     fData: genNullArray(numFData),
    //                     mData: genNullArray(numMData)
    //                 }
    //             };
    //         }
    //         function genNullArray(nullCount: number) {
    //             const outArr: null[] = [];
    //             for (let i = 0; i < nullCount; i++) {
    //                 outArr.push(null);
    //             }
    //             return outArr;
    //         }
    //     });
    //     describe('matTrackViolationCounts method', function () {
    //         it('should track successful MAT violation payments', function () {
    //             service.matTrackViolationCounts([null, null]);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledTimes(1);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).toHaveBeenCalledWith('violations', 'mat_payment', 'mat-violations', 2);
    //         });
    //         it('should not track unsuccessful MAT violation payments', function () {
    //             service.matTrackViolationCounts([]);
    //             expect(mockBrowserExtensionHandlerService.sendEvent).not.toHaveBeenCalled();
    //         });
    //     });
    //     describe('getPathname method', function () {
    //         it('should return the first history entry url if only one history entry exists', function () {
    //             const pathname = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 999), [
    //                 { oldUrl: 'old_url', newUrl: 'new_url', date: new Date(2000, 5, 8, 0, 0, 0, 0) }
    //             ], 1000);
    //             expect(pathname).toBe('new_url');
    //             const pathname2 = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 1000), [
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 0) }
    //             ], 1000);
    //             expect(pathname2).toBe('new_url2');
    //             const pathname3 = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 1001), [
    //                 { oldUrl: 'old_url3', newUrl: 'new_url3', date: new Date(2000, 5, 8, 0, 0, 0, 0) }
    //             ], 1000);
    //             expect(pathname3).toBe('new_url3');
    //         });
    //         it('should return the second history entry url if the first entry is less than the sensitivity and less than the second', function () {
    //             const pathname = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 1000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 501) }, // on this page for less time
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 0) } // on this page for more time
    //             ], 1000);
    //             expect(pathname).toBe('new_url2');
    //         });
    //         it('should return the first history entry url if the first entry is longer duration than the the second', function () {
    //             const pathname = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 1000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 499) }, // on this page for more time
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 0) } // on this page for less time
    //             ], 1000);
    //             expect(pathname).toBe('new_url1');
    //         });
    //         it('should return the first history entry url if the first entry exceeds the sensitivity, even if the second is longer duration', function () {
    //             const pathname = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 1999) }, // on this page past the sensitivity
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 0) } // on this page for more time
    //             ], 1000);
    //             expect(pathname).toBe('new_url1');
    //             const pathname2 = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2000) }, // on this page within sensitivity
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 0) } // on this page for more time
    //             ], 1000);
    //             expect(pathname2).toBe('new_url1');
    //         });
    //         it('should return the second history entry url if the first entry does not exceed the sensitivity, even if the second causes the sum to exceed', function () {
    //             const pathname2 = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2001) }, // on this page within sensitivity
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 0) } // on this page for more time
    //             ], 1000);
    //             expect(pathname2).toBe('new_url2');
    //         });
    //         it('should return the later history entry urls if the first are lower duration and don\'t exceed the sensitivity', function () {
    //             const pathname = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2500) },
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 2001) },
    //                 { oldUrl: 'old_url3', newUrl: 'new_url3', date: new Date(2000, 5, 8, 0, 0, 0, 0) }
    //             ], 1000);
    //             expect(pathname).toBe('new_url3');
    //             const pathname2 = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2999) },
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 2998) },
    //                 { oldUrl: 'old_url3', newUrl: 'new_url3', date: new Date(2000, 5, 8, 0, 0, 0, 0) }
    //             ], 1000);
    //             expect(pathname2).toBe('new_url3');
    //             const pathname3 = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2999) },
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 2998) },
    //                 { oldUrl: 'old_url3', newUrl: 'new_url3', date: new Date(2000, 5, 8, 0, 0, 0, 2997) },
    //                 { oldUrl: 'old_url4', newUrl: 'new_url4', date: new Date(2000, 5, 8, 0, 0, 0, 2996) },
    //                 { oldUrl: 'old_url5', newUrl: 'new_url5', date: new Date(2000, 5, 8, 0, 0, 0, 0) }
    //             ], 1000);
    //             expect(pathname3).toBe('new_url5');
    //         });
    //         it('should select middle entry if it has the longest duration', function () {
    //             const pathname = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2999) },
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 2998) },
    //                 { oldUrl: 'old_url3', newUrl: 'new_url3', date: new Date(2000, 5, 8, 0, 0, 0, 2500) },
    //                 { oldUrl: 'old_url4', newUrl: 'new_url4', date: new Date(2000, 5, 8, 0, 0, 0, 2499) },
    //                 { oldUrl: 'old_url5', newUrl: 'new_url5', date: new Date(2000, 5, 8, 0, 0, 0, 2498) }
    //             ], 1000);
    //             expect(pathname).toBe('new_url3');
    //         });
    //         it('should not consider entries beyond the sensitivity, even if they are longer in duration', function () {
    //             const pathname = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2999) },
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 2998) },
    //                 { oldUrl: 'old_url3', newUrl: 'new_url3', date: new Date(2000, 5, 8, 0, 0, 0, 2000) }, // duration of 1999, pushes out of sensitivity
    //                 { oldUrl: 'old_url4', newUrl: 'new_url4', date: new Date(2000, 5, 8, 0, 0, 0, 0) } // duration of 2000, outside sensitivity
    //             ], 1000);
    //             expect(pathname).toBe('new_url3');
    //             const pathname2 = service.getPathname(new Date(2000, 5, 8, 0, 0, 0, 3000), [
    //                 { oldUrl: 'old_url1', newUrl: 'new_url1', date: new Date(2000, 5, 8, 0, 0, 0, 2999) },
    //                 { oldUrl: 'old_url2', newUrl: 'new_url2', date: new Date(2000, 5, 8, 0, 0, 0, 2998) },
    //                 { oldUrl: 'old_url3', newUrl: 'new_url3', date: new Date(2000, 5, 8, 0, 0, 0, 2000) },
    //                 { oldUrl: 'old_url4', newUrl: 'new_url4', date: new Date(2000, 5, 8, 0, 0, 0, 2000) },
    //                 { oldUrl: 'old_url5', newUrl: 'new_url5', date: new Date(2000, 5, 8, 0, 0, 0, 0) }
    //             ], 1000);
    //             expect(pathname2).toBe('new_url3');
    //         });
    //     });
    // });
}());
(function () {
    "use strict";
    describe("fileDownloadService", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var header = {
            header: (function () { })
        };
        var service;
        var _window;
        var _state;
        var _currentUser;
        var _storefrontUtilityService;
        var inDoc;
        beforeEach(angular.mock.module(function () {
            _state = {
                go: function () { return; },
                current: { name: "test" }
            };
            _window = {
                open: function () { return; }
            };
            _currentUser = {
                currentUserIsInSyncAcrossTabs: function () { return true; }
            };
            _storefrontUtilityService = {
                isRunningAsKiosk: null,
                storefrontLocation: 1,
                machineName: "TestKiosk",
                webStoreData: null
            };
            inDoc = {};
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("serverConstants", { currentlyDownloadedWebUiVersion: "WEBUI_VERSION" });
            $provide.value("$state", _state);
            $provide.value("$window", _window);
            $provide.value("CurrentUser", _currentUser);
            $provide.value("StorefrontUtilityService", _storefrontUtilityService);
            $provide.value('$document', hctraMocks.$document(inDoc));
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("fileDownloadService");
        }));
        it('should output correct uri', function () {
            var url = "/api/PDF/TestApi";
            var testObj = {
                test: "test"
            };
            expect(service.getUrl(url, testObj)).toBe("/api/PDF/TestApi?test=test&angularState=test&clientVersion=WEBUI_VERSION");
        });
        it('window.open should be called if currentUserIsInSynceAcrossTabs() returns true', function () {
            _currentUser.currentUserIsInSyncAcrossTabs = function () { return true; };
            spyOn(_window, 'open');
            service.downloadFile("testUrl", { test: "test" });
            expect(_window.open).toHaveBeenCalledWith("testUrl?test=test&angularState=test&clientVersion=WEBUI_VERSION", "_blank");
        });
        it('return correct fileName', function () {
            spyOn(header, "header").and.returnValue("attachment; filename=PaymentPlan_503784.pdf");
            var result = service.getFileNameFromHeader(header.header);
            expect(result).toEqual("PaymentPlan_503784.pdf");
        });
    });
}());
/*
declare var hctraMocks: any;

(function () {
    "use strict";

    describe("GoogleAnalyticsService", function () {

        beforeEach(angular.mock.module("HCTRAModule"));

        var envConfig,
            //_location,
            _window,
            _injector: angular.auto.IInjectorService;

        beforeEach(angular.mock.module(function ($provide: angular.auto.IProvideService) {

            envConfig = {
                googleAnalyticsID: "12345"
            };

//            _location = {
//                myPath: "path",
//                path: function () {
//                    return this.myPath;
//                }
//            };

            _window = {
                gtag: function () { },
                dataLayer: []
            }

            $provide.constant("environmentConfig", envConfig);
            $provide.value("$window", _window);
            $provide.value("$location", hctraMocks.$location({testPath : "path"}));

        }));

        beforeEach(angular.mock.inject(function ($injector: angular.auto.IInjectorService) {
            _injector = $injector;
        }));

        it("should  not add event if environmentConfig.googleAnalyticsID set to empty string from beginning as script is not loaded", function () {

            envConfig.googleAnalyticsID = "";

            let service = _injector.get<HCTRA.Service.GoogleAnalyticsService>("googleAnalyticsService");

            service.sendTag();

            expect(_window.dataLayer.length).toBe(0);
        });

        it("should not add event if environmentConfig.googleAnalyticsID set to empty string after init as script is loaded bt googleAnalyticsID is empty", function () {

            let service = _injector.get<HCTRA.Service.GoogleAnalyticsService>("googleAnalyticsService");

            envConfig.googleAnalyticsID = "";

            service.sendTag();

            expect(_window.dataLayer.length).toBe(2);
        });

        it("should call GA once if environmentConfig.googleAnalyticsID set to value", function () {

            let service = _injector.get<HCTRA.Service.GoogleAnalyticsService>("googleAnalyticsService");

            service.sendTag();

            // 2 extra event by default from GA
            expect(_window.dataLayer.length).toBe(3);
        });

        it("should add event in the datalayer", function () {

            let service = _injector.get<HCTRA.Service.GoogleAnalyticsService>("googleAnalyticsService");

            service.sendTag('suffix');
            // 2 extra event by default from GA
            expect(_window.dataLayer.length).toBe(3);
        });

    });
} ());
*/ 
// declare var hctraMocks: any;
// (() => {
//     'use strict';
//     describe('IFrameService', () => {
//         beforeEach(angular.mock.module('HCTRAModule'));
//         beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//             $provide.value('genericRepo', {});
//             $provide.value('responseErrorService', jasmine.createSpyObj('responseErrorService', ['displayToast']));
//         }));
//         let service: HCTRA.Service.IFrameService;
//         describe('getConfiguration', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//             }));
//             it('should return correct configuration object', () => {
//                 const getPaypageRegistrationIdCallback = () => { };
//                 const inputsEmptyCallback = () => { };
//                 expect(service.getConfiguration('myStyle', '1000', 'theDiv', 'cardNumber', getPaypageRegistrationIdCallback, inputsEmptyCallback)).toEqual({
//                     paypageId: mockEnvironmentConfigService.vantivConfig.PayPageID,
//                     style: 'myStyle',
//                     height: '1000',
//                     reportGroup: mockEnvironmentConfigService.vantivConfig.ReportGroup,
//                     timeout: mockEnvironmentConfigService.vantivConfig.TimeoutMilliSeconds,
//                     div: 'theDiv',
//                     callback: getPaypageRegistrationIdCallback,
//                     inputsEmptyCallback: inputsEmptyCallback,
//                     showCvv: false,
//                     htmlTimeout: mockEnvironmentConfigService.vantivConfig.TimeoutMilliSeconds,
//                     placeholderText: {
//                         accountNumber: 'cardNumber'
//                     },
//                     enhancedUxFeatures: {
//                         inlineFieldValidations: true,
//                         numericInputsOnly: true
//                     }
//                 });
//             });
//         });
//         describe('generatePseudoRandomNumber', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//             }));
//             it('should return a pseduoRandom number', () => {
//                 const now = new Date();
//                 const expectedResult = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds(), now.getMilliseconds());
//                 expect(service.generatePseudoRandomNumber(now)).toEqual(expectedResult);
//             });
//         });
//         describe('getMessage', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//             }));
//             [
//                 [1, { id: 'T1', orderId: 1 }],
//                 [2, { id: 'T2', orderId: 2 }],
//                 [3, { id: 'T3', orderId: 3 }],
//                 [4, { id: 'T4', orderId: 4 }]
//             ].forEach((input: [number, { id: string, orderId: number }]) => {
//                 const randomNumber = input[0] as number;
//                 const message = input[1];
//                 it(`should return ${message} when ${randomNumber} supplied`, () => {
//                     expect(service.getMessage(randomNumber)).toEqual(message);
//                 });
//             });
//         });
//         describe('logRequest', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let mockGenericRepo;
//             let genericRepoSpy;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 mockGenericRepo = hctraMocks.genericRepo();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//                 $provide.value('genericRepo', mockGenericRepo);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 genericRepoSpy = spyOn(mockGenericRepo.dataFactory, 'LogVantivRequest');
//             }));
//             it('should log the request when this.environmentConfig.vantivConfig.InfoToggle true', () => {
//                 mockEnvironmentConfigService.vantivConfig.InfoToggle = true;
//                 service.logRequest({ id: 'id', orderId: 'orderId' });
//                 expect(genericRepoSpy).toHaveBeenCalledWith({
//                     'paypageId': mockEnvironmentConfigService.vantivConfig.PayPageID,
//                     'reportGroup': mockEnvironmentConfigService.vantivConfig.ReportGroup,
//                     'requestId': 'id',
//                     'orderId': 'orderId',
//                     'url': mockEnvironmentConfigService.vantivConfig.IFrameUrl
//                 });
//             });
//             it('should not log the request when this.environmentConfig.vantivConfig.InfoToggle false', () => {
//                 mockEnvironmentConfigService.vantivConfig.InfoToggle = false;
//                 service.logRequest({ id: 'id', orderId: 'orderId' });
//                 expect(genericRepoSpy).not.toHaveBeenCalled();
//             });
//         });
//         describe('getPaypageRegistrationId', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let getMessageSpy;
//             let generatePseudoRandomNumberSpy;
//             let generateSeedDateSpy;
//             let logRequestSpy;
//             let $scope;
//             let serviceInstance;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService, _$rootScope_) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 serviceInstance = service.getIFrameServiceInstance();
//                 $scope = _$rootScope_.$new();
//                 getMessageSpy = spyOn(service, 'getMessage');
//                 generatePseudoRandomNumberSpy = spyOn(service, 'generatePseudoRandomNumber');
//                 generateSeedDateSpy = spyOn(service, 'generateSeedDate');
//                 logRequestSpy = spyOn(service, 'logRequest');
//             }));
//             it('should call functions with correct arguments when not isBlocked ', (done) => {
//                 generateSeedDateSpy.and.returnValue('seedDate');
//                 generatePseudoRandomNumberSpy.and.returnValue('randomNumber');
//                 getMessageSpy.and.returnValue('message');
//                 serviceInstance.isBlocked = false;
//                 serviceInstance.payframeClient = {
//                     getPaypageRegistrationId: (message) => {
//                         expect(serviceInstance.isBlocked).toBe(true);
//                         expect(serviceInstance.message).toEqual('message');
//                         expect(generateSeedDateSpy).toHaveBeenCalledWith();
//                         expect(generatePseudoRandomNumberSpy).toHaveBeenCalledWith('seedDate');
//                         expect(getMessageSpy).toHaveBeenCalledWith('randomNumber');
//                         expect(logRequestSpy).toHaveBeenCalledWith('message');
//                         expect(message).toEqual('message');
//                         done();
//                     }
//                 }
//                 serviceInstance.getPaypageRegistrationId();
//             }, 100);
//             it('should set the serviceInstance.deferGetPaypageRegistrationId and return the promise on the serviceInstance.deferGetPaypageRegistrationId property when not isBlocked ', (done) => {
//                 generateSeedDateSpy.and.returnValue('seedDate');
//                 generatePseudoRandomNumberSpy.and.returnValue('randomNumber');
//                 getMessageSpy.and.returnValue('message');
//                 serviceInstance.isBlocked = false;
//                 serviceInstance.payframeClient = { getPaypageRegistrationId: () => { } }
//                 const promise = serviceInstance.getPaypageRegistrationId();
//                 promise.then(
//                     () => done(),
//                     () => fail('serviceInstance.deferGetPaypageRegistrationId was rejected unexpectedly'));
//                 serviceInstance.deferGetPaypageRegistrationId.resolve();
//                 $scope.$apply();
//             }, 100);
//             it('should return a rejected promise without doing anything when isBlocked', (done) => {
//                 generateSeedDateSpy.and.callFake(() => fail('generateSeedDate was called when blocked'));
//                 generatePseudoRandomNumberSpy.and.callFake(() => fail('generatePseudoRandomNumber was called when blocked'));
//                 getMessageSpy.and.callFake(() => fail('getMessage was called when blocked'));
//                 logRequestSpy.and.callFake(() => fail('logRequest was called when blocked'));
//                 serviceInstance.isBlocked = true;
//                 serviceInstance.payframeClient = {
//                     getPaypageRegistrationId: () => {
//                         fail('Called payframeClient.getPaypageRegistrationId when blocked');
//                     }
//                 }
//                 const promise = serviceInstance.getPaypageRegistrationId();
//                 promise.then(
//                     () => fail('returned promise was resolved when it should have been rejected'),
//                     () => done());
//                 $scope.$apply();
//             }, 100);
//             it('should throw an exception when service.payframeClient not defined', () => {
//                 generateSeedDateSpy.and.returnValue('seedDate');
//                 generatePseudoRandomNumberSpy.and.returnValue('randomNumber');
//                 getMessageSpy.and.returnValue('message');
//                 serviceInstance.isBlocked = false;
//                 expect(() => serviceInstance.getPaypageRegistrationId()).toThrowError();
//             });
//         });
//         describe('isTimeoutError', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//             }));
//             [
//                 { response: '884', timeout: true },
//                 { response: '1', timeout: true },
//                 { response: '884', timeout: false },
//                 { timeout: true },
//                 { response: '884' }
//             ].forEach((response: any) => {
//                 it(`should return true when response.response === '${response.response}' and response.timeout'${response.timeout}' `, () => {
//                     expect(service.isTimeoutError(response)).toBe(true);
//                 });
//             });
//             [
//                 { response: '885', timeout: false },
//                 { response: '1' },
//                 { timeout: false },
//                 {}
//             ].forEach((response: any) => {
//                 it(`should return false when response.response === '${response.response}' and response.timeout'${response.timeout}' `, () => {
//                     expect(service.isTimeoutError(response)).toBe(false);
//                 });
//             });
//         });
//         describe('isSuccess', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//             }));
//             it(`should return true when response.response === '870'`, () => {
//                 expect(service.isSuccess({ response: '870' } as HCTRA.Model.VantivResponse)).toBe(true);
//             });
//             [
//                 { response: '884' },
//                 { response: '1' },
//                 { response: '871' },
//                 { response: '814' },
//                 {}
//             ].forEach((response: any) => {
//                 it(`should return false when response.response === '${response.response}'`, () => {
//                     expect(service.isSuccess(response)).toBe(false);
//                 });
//             });
//         });
//         describe('isResponseToBeLogged', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let isSuccessSpy;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 isSuccessSpy = spyOn(service, 'isSuccess');
//             }));
//             [
//                 { infoToggle: false, errorToggle: true, isSuccess: false },
//                 { infoToggle: true, errorToggle: false, isSuccess: true },
//                 { infoToggle: true, errorToggle: false, isSuccess: false },
//                 { infoToggle: true, errorToggle: true, isSuccess: true },
//                 { infoToggle: true, errorToggle: true, isSuccess: false }
//             ].forEach((input) => {
//                 it(`should return true when vantivConfig.InfoToggle === ${input.infoToggle}, vantivConfig.ErrorToggle ${input.errorToggle} and isTimeoutError return ${input.isSuccess}`, () => {
//                     mockEnvironmentConfigService.vantivConfig.InfoToggle = input.infoToggle;
//                     mockEnvironmentConfigService.vantivConfig.ErrorToggle = input.errorToggle;
//                     isSuccessSpy.and.returnValue(input.isSuccess);
//                     expect(service.isResponseToBeLogged({} as HCTRA.Model.VantivResponse)).toBe(true);
//                 });
//             });
//             [
//                 { infoToggle: false, errorToggle: false, isSuccess: true },
//                 { infoToggle: false, errorToggle: false, isSuccess: false },
//                 { infoToggle: false, errorToggle: true, isSuccess: true }
//             ].forEach((input) => {
//                 it(`should return true when vantivConfig.InfoToggle === ${input.infoToggle}, vantivConfig.ErrorToggle ${input.errorToggle} and isTimeoutError return ${input.isSuccess}`, () => {
//                     mockEnvironmentConfigService.vantivConfig.InfoToggle = input.infoToggle;
//                     mockEnvironmentConfigService.vantivConfig.ErrorToggle = input.errorToggle;
//                     isSuccessSpy.and.returnValue(input.isSuccess);
//                     expect(service.isResponseToBeLogged({} as HCTRA.Model.VantivResponse)).toBe(false);
//                 });
//             });
//         });
//         describe('logResponse', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let mockGenericRepo;
//             let genericRepoSpy;
//             let isResponseToBeLoggedSpy;
//             let isSuccessSpy;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 mockGenericRepo = hctraMocks.genericRepo();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//                 $provide.value('genericRepo', mockGenericRepo);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 genericRepoSpy = spyOn(mockGenericRepo.dataFactory, 'LogVantivResponse');
//                 isResponseToBeLoggedSpy = spyOn(service, 'isResponseToBeLogged');
//                 isSuccessSpy = spyOn(service, 'isSuccess');
//             }));
//             it('should not log the response when isResponseToBeLogged returns false', () => {
//                 isResponseToBeLoggedSpy.and.returnValue(false);
//                 service.logResponse({ id: 'id', orderId: 'orderId' } as HCTRA.Model.VantivResponse, {});
//                 expect(genericRepoSpy).not.toHaveBeenCalled();
//             });
//             it('should log message as \'Request for Paypage Registration Id Timed Out\' when response.timeout is true', (done) => {
//                 isResponseToBeLoggedSpy.and.returnValue(true);
//                 genericRepoSpy.and.callFake((response) => {
//                     expect(response.message).toEqual('Request for Paypage Registration Id Timed Out');
//                     done();
//                 })
//                 service.logResponse({ timeout: true } as HCTRA.Model.VantivResponse, {});
//             }, 100);
//             it('should log isError false when isSuccess returns false', (done) => {
//                 isResponseToBeLoggedSpy.and.returnValue(true);
//                 isSuccessSpy.and.returnValue(false);
//                 genericRepoSpy.and.callFake((response) => {
//                     expect(response.isError).toEqual(true);
//                     done();
//                 })
//                 service.logResponse({} as HCTRA.Model.VantivResponse, {});
//             }, 100);
//             it('should log isError false when isSuccess returns true', (done) => {
//                 isResponseToBeLoggedSpy.and.returnValue(true);
//                 isSuccessSpy.and.returnValue(true);
//                 genericRepoSpy.and.callFake((response) => {
//                     expect(response.isError).toEqual(false);
//                     done();
//                 })
//                 service.logResponse({} as HCTRA.Model.VantivResponse, {});
//             }, 100);
//             it('should log data when available', () => {
//                 isResponseToBeLoggedSpy.and.returnValue(true);
//                 isSuccessSpy.and.returnValue(false);
//                 const response = {
//                     'reportGroup': 'responsereportGroup',
//                     'response': 'response',
//                     'message': 'message',
//                     'responseTime': 'responseTime',
//                     'vantivTxnId': 'vantivTxnId',
//                     'paypageRegistrationId': 'paypageRegistrationId',
//                     'targetServer': 'targetServer',
//                     'type': 'type'
//                 } as HCTRA.Model.VantivResponse;
//                 const message = {
//                     'id': 'responseid',
//                     'orderId': 'responseorderId'
//                 }
//                 service.logResponse(response, message);
//                 expect(genericRepoSpy).toHaveBeenCalledWith({
//                     'id': message.id,
//                     'orderId': message.orderId,
//                     'reportGroup': mockEnvironmentConfigService.vantivConfig.ReportGroup,
//                     'response': response.response,
//                     'message': response.message,
//                     'responseTime': response.responseTime,
//                     'vantivTxnId': response.vantivTxnId,
//                     'paypageRegistrationId': response.paypageRegistrationId,
//                     'targetServer': response.targetServer,
//                     'type': response.type,
//                     'isError': true,
//                     'violationsData': null
//                 });
//             });
//         });
//         describe('callbackWithLogger', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let mockSiteVerbiage;
//             let mockResponseErrorService;
//             let logResponseSpy;
//             let isSuccessSpy;
//             let isTimeoutErrorSpy;
//             let displayToastSpy;
//             let $scope;
//             let $q;
//             let serviceInstance;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 mockResponseErrorService = hctraMocks.responseErrorService();
//                 mockSiteVerbiage = hctraMocks.siteVerbiage();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//                 $provide.value('responseErrorService', mockResponseErrorService);
//                 $provide.constant('siteVerbiage', mockSiteVerbiage);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService, _$rootScope_, _$q_) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 serviceInstance = service.getIFrameServiceInstance();
//                 $scope = _$rootScope_.$new();
//                 $q = _$q_
//                 logResponseSpy = spyOn(service, 'logResponse');
//                 isSuccessSpy = spyOn(service, 'isSuccess');
//                 isTimeoutErrorSpy = spyOn(service, 'isTimeoutError');
//                 displayToastSpy = spyOn(mockResponseErrorService, 'displayToast')
//             }));
//             it('should call logResponse with response and reset isBlocked ', () => {
//                 serviceInstance.isBlocked = true;
//                 serviceInstance.message = {};
//                 serviceInstance.callbackWithLogger('response');
//                 expect(logResponseSpy).toHaveBeenCalledWith('response', {});
//                 expect(serviceInstance.isBlocked).toBe(false);
//             });
//             it('should call displayToast when isTimeout returns true ', () => {
//                 isTimeoutErrorSpy.and.returnValue(true);
//                 serviceInstance.message = {};
//                 serviceInstance.callbackWithLogger('response', {});
//                 expect(isTimeoutErrorSpy).toHaveBeenCalledWith('response');
//                 expect(displayToastSpy).toHaveBeenCalledWith(mockSiteVerbiage.genericErrorMsg, 'error', false);
//             });
//             it('should not call displayToast when isTimeout returns false ', () => {
//                 isTimeoutErrorSpy.and.returnValue(false);
//                 serviceInstance.message = {};
//                 serviceInstance.callbackWithLogger('response');
//                 expect(isTimeoutErrorSpy).toHaveBeenCalledWith('response');
//                 expect(displayToastSpy).not.toHaveBeenCalled();
//             });
//             it('should call resolve on serviceInstance.deferGetPaypageRegistrationId when isSuccess returns true ', (done) => {
//                 isSuccessSpy.and.returnValue(true);
//                 serviceInstance.message = {};
//                 serviceInstance.deferGetPaypageRegistrationId = $q.defer();
//                 serviceInstance.callbackWithLogger({ response: '870' });
//                 serviceInstance.deferGetPaypageRegistrationId.promise.then(
//                     () => done(),
//                     () => fail('serviceInstance.deferGetPaypageRegistrationId was rejected unexpectedly'));
//                 $scope.$apply();
//             }, 100);
//             it(`should call reject when isSuccess returns false`, (done) => {
//                 isSuccessSpy.and.returnValue(false);
//                 serviceInstance.message = {};
//                 serviceInstance.deferGetPaypageRegistrationId = $q.defer();
//                 serviceInstance.callbackWithLogger('response');
//                 serviceInstance.deferGetPaypageRegistrationId.promise.then(
//                     () => fail('promise was resolved when it should have been rejected'),
//                     () => done());
//                 $scope.$apply();
//             }, 100);
//         });
//         describe('inputsEmptyCallback', () => {
//             let $scope;
//             let $q;
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let serviceInstance;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService, _$rootScope_, _$q_) => {
//                 $scope = _$rootScope_.$new();
//                 $q = _$q_;
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 serviceInstance = service.getIFrameServiceInstance();
//             }));
//             it('should resolve deferInputsEmpty with allInputsEmpty property from the passed argument', (done) => {
//                 serviceInstance.deferInputsEmpty = $q.defer();
//                 serviceInstance.deferInputsEmpty.promise.then(
//                     (response) => {
//                         expect(response).toBe(true);
//                         done()
//                     },
//                     () => fail('should never reject'));
//                 serviceInstance.inputsEmptyCallback({ allInputsEmpty: true });
//                 $scope.$apply();
//             }, 100);
//         });
//         describe('creditCardFieldEmpty', () => {
//             let $scope;
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let serviceInstance;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService, _$rootScope_) => {
//                 $scope = _$rootScope_.$new();
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 serviceInstance = service.getIFrameServiceInstance();
//             }));
//             it('should return a promise if iFrameServiceInstance isBlocked ', () => {
//                 serviceInstance.isBlocked = true;
//                 serviceInstance.payframeClient = {
//                     allInputsEmpty: () => { }
//                 }
//                 serviceInstance.creditCardFieldEmpty().then(
//                     () => fail('promise was resolved when nothing should have happended'),
//                     () => fail('promise was rejected when nothing should have happended'));
//                 const tryResolve = () => serviceInstance.deferInputsEmpty && serviceInstance.deferInputsEmpty.resolve();
//                 tryResolve();
//                 $scope.$apply();
//             });
//             it('should set deferInputsEmpty and call allInputsEmpty method of payframeClient when not blocked', (done) => {
//                 let allInputsEmptyCalled = false;
//                 serviceInstance.isBlocked = false;
//                 serviceInstance.payframeClient = {
//                     allInputsEmpty: () => allInputsEmptyCalled = true
//                 }
//                 serviceInstance.creditCardFieldEmpty().then(
//                     () => {
//                         expect(allInputsEmptyCalled).toBe(true);
//                         done();
//                     },
//                     () => fail('promise was rejected when it should have been resolved'));
//                 serviceInstance.deferInputsEmpty.resolve();
//                 $scope.$apply();
//             }, 100);
//         });
//         describe('loadIFrame', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let getConfigurationSpy;
//             let eprotectIframeClientServiceSpy;
//             let serviceInstance;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 serviceInstance = service.getIFrameServiceInstance();
//                 getConfigurationSpy = spyOn(service, 'getConfiguration');
//                 eprotectIframeClientServiceSpy = spyOn(mockEprotectIframeClientService, 'EprotectIframeClient');
//             }));
//             it('should call functions with correct arguments, reset isBlocked and set serviceInstance.payframeClient', () => {
//                 const payframeClient = {};
//                 getConfigurationSpy.and.returnValue('configuration');
//                 eprotectIframeClientServiceSpy.and.returnValue(payframeClient);
//                 expect(serviceInstance.loadIFrame('myStyle', '1000', 'theDiv', '')).toEqual(undefined);
//                 expect(serviceInstance.isBlocked).toBe(false);
//                 expect(getConfigurationSpy).toHaveBeenCalledWith('myStyle', '1000', 'theDiv', '', serviceInstance.callbackWithLogger, serviceInstance.inputsEmptyCallback);
//                 expect(serviceInstance.payframeClient).toEqual(payframeClient);
//             });
//         });
//         describe('getIFrameServiceInstance', () => {
//             let mockEprotectIframeClientService;
//             let mockEnvironmentConfigService;
//             let $scope;
//             let serviceInstance;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//                 mockEprotectIframeClientService = hctraMocks.eprotectIframeClientService();
//                 mockEnvironmentConfigService = hctraMocks.environmentConfig();
//                 $provide.value('eprotectIframeClientService', mockEprotectIframeClientService);
//                 $provide.constant('environmentConfig', mockEnvironmentConfigService);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService, _$rootScope_) => {
//                 service = $injector.get<HCTRA.Service.IFrameService>('iFrameService');
//                 serviceInstance = service.getIFrameServiceInstance();
//                 $scope = _$rootScope_.$new();
//             }));
//             it('should be blocked when created', () => {
//                 expect(serviceInstance.isBlocked).toBe(true);
//             });
//             it('should set message to empty object', () => {
//                 expect(serviceInstance.message).toEqual({});
//             });
//             it('should set serviceInstance.deferGetPaypageRegistrationId to a deferred object', (done) => {
//                 const deferred = serviceInstance.deferGetPaypageRegistrationId;
//                 deferred.promise.then(
//                     () => fail('returned promise was resolved when it should have been rejected'),
//                     () => done());
//                 deferred.reject();
//                 $scope.$apply();
//             }, 100);
//             it('should set payframe client undefined', () => {
//                 expect(serviceInstance.payframeClient).toBe(undefined);
//             });
//         });
//     });
// })();
(function () {
    'use strict';
    describe('inputCcDetectionService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var name, zip, service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('inputCcDetectionService');
            name = null;
            zip = null;
        }));
        describe('nameIsCc', function () {
            it('should be true if name equals 6 consecutive digits', function () {
                name = 123456;
                var cc = service.nameIsCc(name);
                expect(cc).toBeDefined();
                expect(cc).toBeTruthy();
            });
            it('should be true if name is more then 6 consecutive digits', function () {
                name = 1234567;
                var cc = service.nameIsCc(name);
                expect(cc).toBeDefined();
                expect(cc).toBeTruthy();
            });
            it('should be false if name is less then 6 consecutive digits', function () {
                name = 12345;
                var cc = service.nameIsCc(name);
                expect(cc).toBeDefined();
                expect(cc).toBeFalsy();
            });
        });
        describe('zipIsCc', function () {
            it('should be true if name equals 10 consecutive digits', function () {
                zip = 1234567890;
                var cc = service.zipIsCc(zip);
                expect(cc).toBeDefined();
                expect(cc).toBeTruthy();
            });
            it('should be true if name is more then 10 consecutive digits', function () {
                zip = 12345678901;
                var cc = service.zipIsCc(zip);
                expect(cc).toBeDefined();
                expect(cc).toBeTruthy();
            });
            it('should be false if name is less then 10 consecutive digits', function () {
                zip = 123456789;
                var cc = service.zipIsCc(zip);
                expect(cc).toBeDefined();
                expect(cc).toBeFalsy();
            });
        });
    });
}());
(function () {
    'use strict';
    // describe('isInvoicedService', function () {
    //     //module() is registered on window and is a shortcut to angular.mock.module()
    //     //use it to mock the main app module
    //     //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
    //     // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
    //     // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
    //     beforeEach(angular.mock.module('HCTRAModule'));
    //     var service,
    //         inStorage = {};
    //     beforeEach(angular.mock.module(function () {
    //         inStorage = {};
    //     }));
    //     //$provide is a module-level object, and thus must get its own 
    //     //injection through the module() function
    //     beforeEach(angular.mock.module(function ($provide) {
    //         $provide.value('webStorage', hctraMocks.webStorage(inStorage));
    //     }));
    //     beforeEach(angular.mock.inject(function ($injector) {
    //         service = $injector.get('isInvoicedService');
    //     }));
    //     it('should return false if the invoice is empty', function () {
    //         inStorage.inv = '';
    //         expect(inStorage.inv).toBeDefined();
    //         expect(service.isAccountInvoiced()).toBeFalsy();
    //     });
    //     it('should return false if the invoice is undefined', function () {
    //         expect(inStorage.inv).toBeUndefined();
    //         expect(service.isAccountInvoiced()).toBeFalsy();
    //     });
    //     it('should return false if the invoice is "noninvoiced"', function () {
    //         inStorage.inv = 'noninvoiced';
    //         expect(inStorage.inv).toBeDefined();
    //         expect(service.isAccountInvoiced()).toBeFalsy();
    //     });
    //     it('should return true if the invoice is "invoiced"', function () {
    //         inStorage.inv = 'invoiced';
    //         expect(inStorage.inv).toBeDefined();
    //         expect(service.isAccountInvoiced()).toBeTruthy();
    //     });
    //     it('should set inStorage.inv to invoiced', function () {
    //         service.setAccountInvoiced(true);
    //         expect(inStorage.inv).toBeDefined();
    //         expect(inStorage.inv).toEqual('invoiced');
    //     });
    //     it('should set inStorage.inv to noninvoiced', function () {
    //         service.setAccountInvoiced(false);
    //         expect(inStorage.inv).toBeDefined();
    //         expect(inStorage.inv).toEqual('noninvoiced');
    //     });
    //     it('should remove inStorage.inv', function () {
    //         service.removeAccountInvoiced();
    //         expect(inStorage.inv).toBeUndefined();
    //     });
    // });
}());
(function () {
    'use strict';
    //describe() begins a unit testing fixture
    describe('loggingService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service, inState = {
            value: ""
        };
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('stateStackMemoryService', hctraMocks.stateStackMemoryService());
            $provide.value('$window', hctraMocks.$window(inState));
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            var ssms = $injector.get("stateStackMemoryService");
            var w = $injector.get("$window");
            var s = $injector.get("sniffrjs");
            var sc = $injector.get("serverConstants");
            service = new HCTRA.Service.LoggingService(ssms, w, s, sc); // $injector.get('loggingService');
        }));
        it('errorMessage.length > 500 should be trimmed', function () {
            var testObject = {
                errorMessage: // string with 502 characters
                "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
            };
            service.checkStringLengthsAndEraseIfNeeded(testObject);
            expect(testObject.errorMessage.length).toBe(500);
        });
        it('stateStack.length > 500 should be trimmed', function () {
            var testObject = {
                stateStack: // string with 502 characters
                "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
            };
            service.checkStringLengthsAndEraseIfNeeded(testObject);
            expect(testObject.stateStack.length).toBe(500);
        });
        it('cause.length > 500 should be trimmed', function () {
            var testObject = {
                cause: // string with 502 characters
                "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
            };
            service.checkStringLengthsAndEraseIfNeeded(testObject);
            expect(testObject.cause.length).toBe(500);
        });
    });
}());
(function () {
    "use strict";
    // describe("MaintenanceService", () => {
    //     beforeEach(angular.mock.module("HCTRAModule"));
    //     let _responseErrorService: HCTRA.Service.IResponseErrorService;
    //     let _state: angular.ui.IStateService;
    //     let _genericRepo: HCTRA.Service.IGenericRepo;
    //     let service: HCTRA.Service.IMaintenanceService;
    //     let maintenanceResponse: HCTRA.Model.MaintenanceResponse;
    //     let _q: angular.IQService;
    //     let _rootScope: angular.IRootScopeService;
    //     beforeEach(angular.mock.module(() => {
    // _responseErrorService = {
    //     isErrorFree: (): boolean => { return true; },
    //     displayErrorsFromResponse: (): ng.IPromise <any> => { return; },
    //     displayToast: (): void => { return; },
    //     displayAlertsFromResponse: (): ng.IPromise<any> => { return; },
    //     handleMaintenanceErrors: (): void => { return; },
    //     formatErrorMessages: (): string[] => { return []; },
    //     clearToasts: ():void => {}
    // } as HCTRA.Service.IResponseErrorService;
    //         //_state = <angular.ui.IStateService>{
    //         //    go: (to: string, params?: {}, options?: angular.ui.IStateOptions): angular.IPromise<any> => { return; }
    //         //};
    //         _state = {
    //             go: (): angular.IPromise<any> => { return; }
    //         } as any;
    //         _genericRepo = {} as HCTRA.Service.IGenericRepo;
    //         spyOn(_responseErrorService, "displayErrorsFromResponse");
    //         spyOn(_state as any, "go");
    //     }));
    //     beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
    //         $provide.value("serverConstants", { maintenanceKey: "MAINTENANCE_KEY" });
    //         $provide.value("responseErrorService", _responseErrorService);
    //         $provide.value("$state", _state);
    //         $provide.value("genericRepo", _genericRepo);
    //         $provide.value("modalService", hctraMocks.modalService({}));
    //         $provide.constant("homeStates", { Frame: "HOME" });
    //     }));
    //     beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService,
    //         $rootScope: angular.IRootScopeService,
    //         $q: angular.IQService) => {
    //         service = $injector.get<HCTRA.Service.IMaintenanceService>("maintenanceService");
    //         _q = $q;
    //         _rootScope = $rootScope;
    //         maintenanceResponse = new HCTRA.Model.MaintenanceResponse();
    //         maintenanceResponse.errors = [];
    //         _genericRepo.dataFactory = {
    //             getMaintenanceDetails: (): angular.IPromise<HCTRA.Model.MaintenanceResponse> => {
    //                 return _q.resolve(maintenanceResponse);
    //             }
    //         } as any;
    //     }));
    //     xdescribe("handleMaintenanceErrors", () => {
    //         it("should display error and navigate to HOME if maintenance key present", () => {
    //             const baseResponse = new HCTRA.Model.BaseResponse();
    //             baseResponse.errors.push({ key: "MAINTENANCE_KEY", message: "MESSAGE" });
    //             // service.handleMaintenanceErrors(baseResponse);
    //             expect(_responseErrorService.displayErrorsFromResponse).toHaveBeenCalledWith(baseResponse, true);
    //             expect(_state.go).toHaveBeenCalledWith("HOME");
    //         });
    //         it("should not display errors or navigate if response is null or undefined", () => {
    //             //let baseResponse: HCTRA.Model.BaseResponse = null;
    //             // service.handleMaintenanceErrors(baseResponse);
    //             expect(_responseErrorService.displayErrorsFromResponse).not.toHaveBeenCalled();
    //             expect(_state.go).not.toHaveBeenCalled();
    //             //baseResponse = undefined;
    //             // service.handleMaintenanceErrors(baseResponse);
    //             expect(_responseErrorService.displayErrorsFromResponse).not.toHaveBeenCalled();
    //             expect(_state.go).not.toHaveBeenCalled();
    //         });
    //         it("should not display errors or navigate if response errors collection is null or undefined", () => {
    //             const baseResponse = new HCTRA.Model.BaseResponse();
    //             baseResponse.errors = null;
    //             // service.handleMaintenanceErrors(baseResponse);
    //             expect(_responseErrorService.displayErrorsFromResponse).not.toHaveBeenCalled();
    //             expect(_state.go).not.toHaveBeenCalled();
    //             baseResponse.errors = undefined;
    //             // service.handleMaintenanceErrors(baseResponse);
    //             expect(_responseErrorService.displayErrorsFromResponse).not.toHaveBeenCalled();
    //             expect(_state.go).not.toHaveBeenCalled();
    //         });
    //     });
    //     describe("resolveMaintenanceStatus", () => {
    //         let navFeatures: Array<HCTRA.Model.MaintenanceFeature>;
    //         beforeEach(() => {
    //             navFeatures = [
    //                 HCTRA.Model.MaintenanceFeature.Account
    //             ];
    //             maintenanceResponse.errors = [];
    //             maintenanceResponse.featureStates = [];
    //             maintenanceResponse.featureStates.push(
    //                 {
    //                     feature: HCTRA.Model.MaintenanceFeature.Account,
    //                     inMaintenance: false,
    //                     message: "ERROR MESSAGE"
    //                 }
    //             );
    //         });
    //         it("should resolve successfully if none of the nav features are in maintenance", (done) => {
    //             service.resolveMaintenanceStatus(navFeatures, "").then(
    //                 (/*resolve: any*/) => {
    //                     expect(true).toBeTruthy();
    //                     expect(_responseErrorService.displayErrorsFromResponse).not.toHaveBeenCalled();
    //                     done();
    //                 },
    //                 (/*reject: any*/) => {
    //                     expect(false).toBeTruthy();
    //                     done();
    //                 });
    //             _rootScope.$digest();
    //         });
    //         it("should resolve successfully if there are no nav features even if features in maintenance", (done) => {
    //             navFeatures = [];
    //             maintenanceResponse.featureStates[0].inMaintenance = true;
    //             service.resolveMaintenanceStatus(navFeatures, "").then(
    //                 (/*resolve: any*/) => {
    //                     expect(true).toBeTruthy();
    //                     expect(_responseErrorService.displayErrorsFromResponse).not.toHaveBeenCalled();
    //                     done();
    //                 },
    //                 (/*reject: any*/) => {
    //                     expect(false).toBeTruthy();
    //                     done();
    //                 });
    //             _rootScope.$digest();
    //         });
    //         it("should reject if a nav feature is in maintenance", (done) => {
    //             maintenanceResponse.featureStates[0].inMaintenance = true;
    //             service.resolveMaintenanceStatus(navFeatures, "").then(
    //                 (/*resolve: any*/) => {
    //                     expect(false).toBeTruthy();
    //                     done();
    //                 },
    //                 (/*reject: any*/) => {
    //                     expect(true).toBeTruthy();
    //                     expect(_responseErrorService.displayErrorsFromResponse).toHaveBeenCalled();
    //                     done();
    //                 });
    //             _rootScope.$digest();
    //         });
    //         it("should reject if a nav feature is in maintenance and navigate home if previousState is unknown (empty string)", (done) => {
    //             maintenanceResponse.featureStates[0].inMaintenance = true;
    //             service.resolveMaintenanceStatus(navFeatures, "").then(
    //                 (/*resolve: any*/) => {
    //                     expect(false).toBeTruthy();
    //                     done();
    //                 },
    //                 (/*reject: any*/) => {
    //                     expect(true).toBeTruthy();
    //                     expect(_responseErrorService.displayErrorsFromResponse).toHaveBeenCalled();
    //                     expect(_state.go).toHaveBeenCalledWith("HOME");
    //                     done();
    //                 });
    //             _rootScope.$digest();
    //         });
    //         it("should reject if a nav feature is in maintenance and navigate home if previousState is unknown (undefined)", (done) => {
    //             maintenanceResponse.featureStates[0].inMaintenance = true;
    //             service.resolveMaintenanceStatus(navFeatures, undefined).then(
    //                 (/*resolve: any*/) => {
    //                     expect(false).toBeTruthy();
    //                     done();
    //                 },
    //                 (/*reject: any*/) => {
    //                     expect(true).toBeTruthy();
    //                     expect(_responseErrorService.displayErrorsFromResponse).toHaveBeenCalled();
    //                     expect(_state.go).toHaveBeenCalledWith("HOME");
    //                     done();
    //                 });
    //             _rootScope.$digest();
    //         });
    //         it("should reject if a nav feature is in maintenance and navigate home if previousState is unknown (null)", (done) => {
    //             maintenanceResponse.featureStates[0].inMaintenance = true;
    //             service.resolveMaintenanceStatus(navFeatures, null).then(
    //                 (/*resolve: any*/) => {
    //                     expect(false).toBeTruthy();
    //                     done();
    //                 },
    //                 (/*reject: any*/) => {
    //                     expect(true).toBeTruthy();
    //                     expect(_responseErrorService.displayErrorsFromResponse).toHaveBeenCalled();
    //                     expect(_state.go).toHaveBeenCalledWith("HOME");
    //                     done();
    //                 });
    //             _rootScope.$digest();
    //         });
    //         it("should reject if a nav feature is in maintenance and navigate to previousState if previousState is known", (done) => {
    //             maintenanceResponse.featureStates[0].inMaintenance = true;
    //             service.resolveMaintenanceStatus(navFeatures, "somePreviousState").then(
    //                 (/*resolve: any*/) => {
    //                     expect(false).toBeTruthy();
    //                     done();
    //                 },
    //                 (/*reject: any*/) => {
    //                     expect(true).toBeTruthy();
    //                     expect(_responseErrorService.displayErrorsFromResponse).toHaveBeenCalled();
    //                     expect(_state.go).toHaveBeenCalledWith("somePreviousState");
    //                     done();
    //                 });
    //             _rootScope.$digest();
    //         });
    //     });
    // });
}());
(function () {
    'use strict';
    describe('marketingImageService', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var service, marketingImages = [], imageObj = {};
        beforeEach(angular.mock.module(function () {
            marketingImages = [];
            imageObj = {
                articles: 0,
                startIndex: 0,
                maxArticles: 1,
                maxSmall: 1,
                logIn: {
                    small: [],
                    large: []
                },
                logOut: {
                    small: [],
                    large: []
                },
                defaultObj: {
                    small: [],
                    large: []
                }
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('cmsUtilService', hctraMocks.cmsUtilService());
        }));
        beforeEach(angular.mock.inject(function (_marketingImageService_) {
            service = _marketingImageService_;
        }));
        describe('getObj', function () {
            it('should not contain anything', function () {
                marketingImages.push({ ShowInHomePage: 1 });
                marketingImages.push({ ShowInHomePage: 0, UserLoggedIn: 1, isLargeImage: 1 });
                marketingImages.push({ ShowInHomePage: 0, UserLoggedIn: 1, isLargeImage: 0 });
                marketingImages.push({ ShowInHomePage: 0, UserLoggedIn: 0, isLargeImage: 1 });
                marketingImages.push({ ShowInHomePage: 0, UserLoggedIn: 0, isLargeImage: 0 });
                var obj = service.getObj(true, marketingImages);
                expect(obj.small).toBeDefined();
                expect(obj.large).toBeDefined();
                expect(obj.small).toEqual([]);
                expect(obj.large).toEqual([]);
            });
            it('should contain logged in and large', function () {
                marketingImages.push({ ShowInHomePage: 1, UserLoggedIn: 1, isLargeImage: 1 });
                var obj = service.getObj(true, marketingImages);
                expect(obj.large).toBeDefined();
                expect(obj.large).toEqual([{ ShowInHomePage: 1, UserLoggedIn: 1, isLargeImage: 1 }]);
            });
            it('should contain logged in and small', function () {
                marketingImages.push({ ShowInHomePage: 1, UserLoggedIn: 1, isLargeImage: 0 });
                var obj = service.getObj(true, marketingImages);
                expect(obj.small).toBeDefined();
                expect(obj.small).toEqual([{ ShowInHomePage: 1, UserLoggedIn: 1, isLargeImage: 0 }]);
            });
            it('should contain logged out and large', function () {
                marketingImages.push({ ShowInHomePage: 1, UserLoggedIn: 0, isLargeImage: 1 });
                var obj = service.getObj(false, marketingImages);
                expect(obj.large).toBeDefined();
                expect(obj.large).toEqual([{ ShowInHomePage: 1, UserLoggedIn: 0, isLargeImage: 1 }]);
            });
            it('should contain logged out and small', function () {
                marketingImages.push({ ShowInHomePage: 1, UserLoggedIn: 0, isLargeImage: 0 });
                var obj = service.getObj(false, marketingImages);
                expect(obj.small).toBeDefined();
                expect(obj.small).toEqual([{ ShowInHomePage: 1, UserLoggedIn: 0, isLargeImage: 0 }]);
            });
        });
        describe('defaultObj', function () {
            it('should not contain anything', function () {
                marketingImages.push({});
                var obj = service.getDefaultObj(marketingImages);
                expect(obj.large).toBeDefined();
                expect(obj.small).toBeDefined();
                expect(obj.large).toEqual([]);
                expect(obj.small).toEqual([]);
            });
            it('should contain large image', function () {
                marketingImages.push({ isLargeImage: 1 });
                var obj = service.getDefaultObj(marketingImages);
                expect(obj.large).toBeDefined();
                expect(obj.small).toBeDefined();
                expect(obj.large).toEqual([{ isLargeImage: 1 }]);
                expect(obj.small).toEqual([]);
            });
            it('should contain small image', function () {
                marketingImages.push({ isLargeImage: 0 });
                var obj = service.getDefaultObj(marketingImages);
                expect(obj.large).toBeDefined();
                expect(obj.small).toBeDefined();
                expect(obj.large).toEqual([]);
                expect(obj.small).toEqual([{ isLargeImage: 0 }]);
            });
            it('should contain large and small image', function () {
                marketingImages.push({ isLargeImage: 1 });
                marketingImages.push({ isLargeImage: 0 });
                var obj = service.getDefaultObj(marketingImages);
                expect(obj.large).toBeDefined();
                expect(obj.small).toBeDefined();
                expect(obj.large).toEqual([{ isLargeImage: 1 }]);
                expect(obj.small).toEqual([{ isLargeImage: 0 }]);
            });
        });
        describe('setImages', function () {
            it('should not contain anything', function () {
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array).toEqual([]);
            });
            it('should not display image if two articles', function () {
                imageObj.articles = 2;
                imageObj.logIn.large.push('test1');
                imageObj.logIn.large.push('test2');
                imageObj.defaultObj.large.push('test1');
                imageObj.defaultObj.large.push('test2');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(0);
                expect(array).toEqual([]);
            });
            //---------------------------------------------------------------------------
            it('should contain logged in large image if zero articles', function () {
                imageObj.logIn.large.push('test');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            it('should contain logged in small image if zero articles', function () {
                imageObj.logIn.small.push('test');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            it('should contain logged in small image x2 if zero articles', function () {
                imageObj.maxSmall = 2;
                imageObj.logIn.small.push('test1');
                imageObj.logIn.small.push('test2');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(2);
                expect(array).toEqual(['test1', 'test2']);
            });
            it('should contain logged in small image if one articles', function () {
                imageObj.articles = 1;
                imageObj.logIn.small.push('test');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            //---------------------------------------------------------------------------
            it('should contain logged out large image if zero articles', function () {
                imageObj.logOut.large.push('test');
                var array = service.setImages('logOut', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            it('should contain logged out small image if zero articles', function () {
                imageObj.logOut.small.push('test');
                var array = service.setImages('logOut', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            it('should contain logged out small image x2 if zero articles', function () {
                imageObj.maxSmall = 2;
                imageObj.logOut.small.push('test1');
                imageObj.logOut.small.push('test2');
                var array = service.setImages('logOut', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(2);
                expect(array).toEqual(['test1', 'test2']);
            });
            it('should contain logged out small image if one articles', function () {
                imageObj.articles = 1;
                imageObj.logOut.small.push('test');
                var array = service.setImages('logOut', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            //--------------------------------------------------------------------------
            it('should contain default large image if zero articles', function () {
                imageObj.defaultObj.large.push('test');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            it('should contain default small image if zero articles', function () {
                imageObj.defaultObj.small.push('test');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
            it('should contain default small image if one articles', function () {
                imageObj.defaultObj.small.push('test');
                var array = service.setImages('logIn', imageObj);
                expect(array).toBeDefined();
                expect(array.length).toEqual(1);
                expect(array).toEqual(['test']);
            });
        });
    });
}());
(function () {
    'use strict';
    describe('MegaMenuCache', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('MegaMenuCache');
        }));
        it('should return cache', function () {
            var megaMenu = [1, 2, 3];
            service.cacheMegaMenu(megaMenu);
            expect(service.getCachedMegaMenu()).toEqual(megaMenu);
        });
    });
})();
// declare var hctraMocks: any;
// (() => {
//     'use strict';
//     describe('MobileMenuRouteService', () => {
//         beforeEach(angular.mock.module('HCTRAModule'));
//         beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
//             $provide.value('AuthService', hctraMocks.AuthService());
//         }));
//         let service;
//         describe('isAuthorized', () => {
//             const mockedAuthService = hctraMocks.AuthService();
// 			let authServiceSpy;			
//             let fakeRoute;
//             beforeEach(angular.mock.module(($provide: angular.auto.IProvideService) => {
// 				$provide.factory("$q", ["$window", function ($window) {
// 					return $window["Promise"];
// 				}]);
//                 $provide.value('AuthService', mockedAuthService);
//                 $provide.value('USER_ROLES', { anonymous: 'anonymous' });
// 				$provide.value('router', hctraMocks.router());	
// 				$provide.value('featureToggleResolver', jasmine.createSpyObj('featureToggleResolver', ['resolveFeatureToggle', 'isResolvedFeatureToggle']));				
//                 $provide.value('responseErrorService', hctraMocks.responseErrorService({
//                     value: ""
//                 }));
//                 $provide.value('MegaMenuCache', hctraMocks.megaMenuCache());
//                 $provide.value('$state', hctraMocks.$state({
//                     value: ""
//                 }));
//                 $provide.value('urlManagerService', hctraMocks.urlManagerService());
//                 $provide.value('futureRoutes', {});
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
// 				service = $injector.get('mobileMenuRouteService');
//                 authServiceSpy = spyOn(mockedAuthService, 'isAuthorized');
//                 fakeRoute = {
//                     config: {
// 						data: {
// 							authorizedRoles: []
// 						}
//                     }
//                 };
//             }));
//             it('should return true when AuthService.isAuthorized() returns true and passed array does not contain USER_ROLES', () => {
//                 authServiceSpy.and.returnValue(true);
//                 expect(service.isAuthorized(fakeRoute)).toBe(true);
//                 expect(authServiceSpy).toHaveBeenCalledWith([]);
//             });
//             it('should return true when AuthService.isAuthorized() returns false and passed array contains USER_ROLES', () => {
//                 authServiceSpy.and.returnValue(false);
//                 fakeRoute.config.data.authorizedRoles = ['anonymous'];
//                 expect(service.isAuthorized(fakeRoute)).toBe(true);
//                 expect(authServiceSpy).toHaveBeenCalledWith(['anonymous']);
//             });
//             it('should return true when AuthService.isAuthorized() returns true and passed array contains USER_ROLES', () => {
//                 authServiceSpy.and.returnValue(true);
//                 fakeRoute.config.data.authorizedRoles = ['anonymous'];
//                 expect(service.isAuthorized(fakeRoute)).toBe(true);
//                 expect(authServiceSpy).toHaveBeenCalledWith(['anonymous']);
//             });
//             it('should return false when AuthService.isAuthorized() returns false and passed array does not contain USER_ROLES', () => {
//                 authServiceSpy.and.returnValue(false);
//                 expect(service.isAuthorized(fakeRoute)).toBe(false);
//                 expect(authServiceSpy).toHaveBeenCalledWith([]);
//             });
//         });
//         describe('getHierarchicalRoutes', () => {
//             beforeEach(angular.mock.module(function ($provide) {
// 				$provide.factory("$q", ["$window", function ($window) {
// 					return $window["Promise"];
// 				}]);
//                 $provide.value('AuthService', hctraMocks.AuthService({
//                     isAuthenticated: false
//                 }));
//                 $provide.value('USER_ROLES', hctraMocks.USER_ROLES());
//                 $provide.value('router', hctraMocks.router());
//                 $provide.value('genericRepo', hctraMocks.genericRepo());
//                 $provide.value('responseErrorService', hctraMocks.responseErrorService({
//                     value: ""
//                 }));
//                 $provide.value('MegaMenuCache', hctraMocks.megaMenuCache());
//                 $provide.value('$state', hctraMocks.$state({
//                     value: ""
//                 }));
//                 $provide.value('urlManagerService', hctraMocks.urlManagerService());
//                 $provide.value('futureRoutes', {});
//             }));
//             let theRouter;
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get('mobileMenuRouteService');
//                 const child1 = { name: 'child1', config: { settings: { parent: 'parent1' } } };
//                 const child2 = { name: 'child2', config: { settings: { parent: 'parent1' } } };
//                 const child3 = { name: 'child3', config: { settings: { parent: 'parent2' } } };
//                 const parent1 = { name: 'parent1', config: { settings: { parent: 'grandParent1' } } };
//                 const parent2 = { name: 'parent2', config: { settings: { parent: 'grandParent1' } } };
//                 const grandParent1 = { name: 'grandParent1', config: { settings: { navlevel: 0 } } };
//                 const grandParent2 = { name: 'grandParent2', config: { settings: { navlevel: 0 } } }
//                 theRouter = [
//                     child3, grandParent2, child1, parent2, grandParent1, child2, parent1
//                 ];
//             }));
//             it('should add children to routes with children', () => {
//                 const expectedChild1 = { name: 'child1', config: { settings: { parent: 'parent1', children: [] } } };
//                 const expectedChild2 = { name: 'child2', config: { settings: { parent: 'parent1', children: [] } } };
//                 const expectedChild3 = { name: 'child3', config: { settings: { parent: 'parent2', children: [] } } };
//                 const expectedParent1 = { name: 'parent1', config: { settings: { parent: 'grandParent1', children: [expectedChild1, expectedChild2] } } };
//                 const expectedParent2 = { name: 'parent2', config: { settings: { parent: 'grandParent1', children: [expectedChild3] } } };
//                 const expectedGrandParent1 = { name: 'grandParent1', config: { settings: { navlevel: 0, children: [expectedParent2, expectedParent1] } } };
//                 const expectedGrandParent2 = { name: 'grandParent2', config: { settings: { navlevel: 0, children: [] } } }
//                 expect(service.getHierarchicalRoutes(theRouter)).toEqual([expectedChild3, expectedGrandParent2, expectedChild1, expectedParent2, expectedGrandParent1, expectedChild2, expectedParent1]);
//             });
//         });
//         describe('sortChildren', () => {
//             beforeEach(angular.mock.module(function($provide) {
// 				$provide.factory("$q", ["$window", function ($window) {
// 					return $window["Promise"];
// 				}]);
//                 $provide.value('AuthService', hctraMocks.AuthService({
//                     isAuthenticated: false
//                 }));
//                 $provide.value('USER_ROLES', hctraMocks.USER_ROLES());
//                 $provide.value('router', hctraMocks.router());
//                 $provide.value('genericRepo', hctraMocks.genericRepo());
//                 $provide.value('responseErrorService', hctraMocks.responseErrorService({
//                     value: ""
//                 }));
//                 $provide.value('MegaMenuCache', hctraMocks.megaMenuCache());
//                 $provide.value('$state', hctraMocks.$state({
//                     value: ""
//                 }));
//                 $provide.value('urlManagerService', hctraMocks.urlManagerService());
//                 $provide.value('futureRoutes', {});
//             }));
//             let hierarchicalRoutes;
//             let child1; let child2; let child3;
//             let parent1; let parent2;
//             let grandParent1; let grandParent2;
//             beforeEach(() => {
//                 child1 = { config: { settings: { nav: 1, children: [] } } };
//                 child2 = { config: { settings: { nav: 2, children: [] } } };
//                 child3 = { config: { settings: { nav: 3, children: [] } } };
//                 parent1 = { config: { settings: { nav: 1, children: [child2, child3, child1] } } };
//                 parent2 = { config: { settings: { nav: 2, children: [] } } };
//                 grandParent1 = { config: { settings: { nav: 1, children: [parent2, parent1] } } };
//                 grandParent2 = { config: { settings: { nav: 2, children: [] } } }
//                 hierarchicalRoutes = [child1, child2, child3, parent1, parent2, grandParent2, grandParent1];
//             })
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get('mobileMenuRouteService');
//             }));
//             it('should sort children of routes in hierarchicalRoutes', () => {
//                 const expectedChild1 = { config: { settings: { nav: 1, children: [] } } };
//                 const expectedChild2 = { config: { settings: { nav: 2, children: [] } } };
//                 const expectedChild3 = { config: { settings: { nav: 3, children: [] } } };
//                 const expectedParent1 = { config: { settings: { nav: 1, children: [expectedChild1, expectedChild2, expectedChild3] } } };
//                 const expectedParent2 = { config: { settings: { nav: 2, children: [] } } };
//                 const expectedGrandParent1 = { config: { settings: { nav: 1, children: [expectedParent1, expectedParent2] } } };
//                 const expectedGrandParent2 = { config: { settings: { nav: 2, children: [] } } }
//                 expect(service.sortChildren(hierarchicalRoutes))
//                     .toEqual([expectedChild1, expectedChild2, expectedChild3, expectedParent1, expectedParent2, expectedGrandParent2, expectedGrandParent1]);
//             });
//         });
//         describe('mergeRoutes', () => {
//             beforeEach(angular.mock.module(function ($provide) {
//                 $provide.factory("$q", ["$window", function ($window) {
//                     return $window["Promise"];
//                 }]);
//                 $provide.value('AuthService', hctraMocks.AuthService({
//                     isAuthenticated: false
//                 }));
//                 $provide.value('USER_ROLES', hctraMocks.USER_ROLES());
//                 $provide.value('router', hctraMocks.router());
//                 $provide.value('genericRepo', hctraMocks.genericRepo());
//                 $provide.value('responseErrorService', hctraMocks.responseErrorService({
//                     value: ""
//                 }));
//                 $provide.value('MegaMenuCache', hctraMocks.megaMenuCache());
//                 $provide.value('$state', hctraMocks.$state({
//                     value: ""
//                 }));
//                 $provide.value('urlManagerService', hctraMocks.urlManagerService());
//                 $provide.value('futureRoutes', {});
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get('mobileMenuRouteService');
//             }));
//             it('should return loadedRoutes and futureRoutes not present in loaded routes', () => {
//                 const result = service.mergeRoutes([{ name: 'fake1' }, { name: 'fake4' }], [{ name: 'fake2' }, { name: 'fake3' }, { name: 'fake4' }, { name: 'fake5' }]);
//                 expect(result).toEqual([{ name: 'fake1' }, { name: 'fake4' }, { name: 'fake2' }, { name: 'fake3' }, { name: 'fake5' }]);
//             });
//         });
//         describe('mobileMenuRouteService', function () {
//             let fakeState;
//             let fakeFutureRoutes;
//             beforeEach(angular.mock.module(function ($provide) {
// 				$provide.factory("$q", ["$window", function ($window) {
// 					return $window["Promise"];
// 				}]);
//                 $provide.value('AuthService', hctraMocks.AuthService({
//                     isAuthenticated: false
//                 }));
//                 $provide.value('USER_ROLES', hctraMocks.USER_ROLES());
//                 $provide.value('router', hctraMocks.router());
//                 $provide.value('genericRepo', hctraMocks.genericRepo());
//                 $provide.value('responseErrorService', hctraMocks.responseErrorService({
//                     value: ""
//                 }));
//                 $provide.value('MegaMenuCache', hctraMocks.megaMenuCache());
//                 $provide.value('$state', hctraMocks.$state({
//                     value: ""
//                 }));
//                 $provide.value('urlManagerService', hctraMocks.urlManagerService());
//                 fakeState = jasmine.createSpyObj('$state', ['get']);
//                 $provide.value('$state', fakeState);
//                 fakeFutureRoutes = jasmine.createSpyObj('futureRoutes', ['get']);
//                 $provide.value('futureRoutes', fakeFutureRoutes);
//             }));
//             beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
//                 service = $injector.get('mobileMenuRouteService');
//             }));
//             it('should match sort and hierarchy for hamburger menu', function () {
//                 fakeState.get.and.returnValue([
//                     {
//                         name: "Home",
//                         url: "home",
//                         templateUrl: "/app/templates/home/home.html",
//                         controller: "HomeController",
//                         settings: {
//                             navlevel: 0,
//                             children: [],
//                             nav: 1,
//                             content: "<img src='../Content/icons/menu/hm_home.png' alt='Click to go to home page'>   HOME"
//                         },
//                         data: { authorizedRoles: ["anonymous"] }, quickLink: {}
//                     }]);
//                 fakeFutureRoutes.get.and.returnValue([{
//                         name: "eZTagAccount",
//                         settings: {
//                             navlevel: 0,
//                             nav: 2,
//                             content: "<img src='../Content/icons/menu/hm_ez_tag_acct.png' alt='Click to see account options'>   EZ TAG ACCOUNT",
//                             children: []
//                         },
//                         data: { authorizedRoles: ["anonymous"] }
//                     }
//                 ]);
//                 const test = [
//                     {
//                         name: "Home",
//                         config: {
//                             name: "Home",
//                             url: "home",
//                             templateUrl: "/app/templates/home/home.html",
//                             controller: "HomeController",
//                             settings: {
//                                 navlevel: 0,
//                                 children: [],
//                                 nav: 1,
//                                 content: "<img src='../Content/icons/menu/hm_home.png' alt='Click to go to home page'>   HOME"
//                             },
//                             data: { authorizedRoles: ["anonymous"] }, quickLink: {}
//                         },
//                         toggleResolved: true
//                     }, {
//                         name: "eZTagAccount",
//                         config: {
//                             name: "eZTagAccount",
//                             settings: {
//                                 navlevel: 0,
//                                 nav: 2,
//                                 content: "<img src='../Content/icons/menu/hm_ez_tag_acct.png' alt='Click to see account options'>   EZ TAG ACCOUNT",
//                                 children: []
//                             },
//                             data: { authorizedRoles: ["anonymous"] }
//                         },
//                         toggleResolved: true
//                     }
//                 ];
//                 //var routeObject = service.getNavRoutes();
//                 //expect(routeObject).toEqual(test);
// 				return service
//                     .getNavRoutes()
//                     .then(r => expect(r).toEqual(test));				
//             });
//         });
//     });
// })();
(function () {
    'use strict';
    describe('ModalService', function () {
        var modalService;
        var modalServiceInstance;
        var $q;
        var errorDisplayService;
        var materialDialogService;
        function returnResolved(obj) {
            return $q.resolve(obj);
        }
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.module(function ($provide) {
            materialDialogService = jasmine.createSpyObj('materialDialogService', ['closeAll']);
            modalServiceInstance = jasmine.createSpyObj("modalServiceInstance", ["open"]);
            errorDisplayService = jasmine.createSpyObj('errorDisplayService', ['displayToasts']);
            $provide.value("$uibModal", modalServiceInstance);
            $provide.factory('$q', ['replacementQService', function (replacementQService) { return replacementQService; }]);
            $provide.value('operatingSystemSnifferService', hctraMocks.operatingSystemSnifferService());
            $provide.value('storefrontMaterialDialogWrapper', materialDialogService);
            $provide.value('errorDisplayService', errorDisplayService);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            $q = $injector.get('$q');
            modalService = $injector.get("modalService");
        }));
        it('can create a modal service', function () {
            //assert
            expect(modalService).toBeDefined();
        });
        it('can show a generic modal', function () {
            var modalInstance = jasmine.createSpy("modalInstance", {});
            modalServiceInstance.open.and.returnValue(modalInstance);
            modalInstance.result = returnResolved('ok');
            //act
            modalService.showModal({}, {}, "somemodalname")
                .then(function () {
                //assert
                expect(modalServiceInstance.open).toHaveBeenCalled();
            })
                .catch(function () { fail("show not have failed."); });
        });
        it('can show a sliding modal with name parameter default to component name', function () {
            spyOn(modalService, "showModal");
            //Act
            modalService.showSlidingModal('TestComponent', { test: 'test' });
            //Assert
            var expectedDefaults = {
                backdrop: true,
                keyboard: true,
                modalFade: true,
                component: 'TestComponent',
                windowClass: 'side-drawer',
                resolve: {
                    test: 'test'
                }
            };
            expect(modalService.showModal).toHaveBeenCalledTimes(1);
            expect(modalService.showModal).toHaveBeenCalledWith(expectedDefaults, {}, 'TestComponent');
        });
        it('can show a sliding modal with name parameter provided', function () {
            spyOn(modalService, "showModal");
            //Act
            modalService.showSlidingModal('TestComponent', { test: 'test' }, 'ModalName');
            //Assert
            var expectedDefaults = {
                backdrop: true,
                keyboard: true,
                modalFade: true,
                component: 'TestComponent',
                windowClass: 'side-drawer',
                resolve: {
                    test: 'test'
                }
            };
            expect(modalService.showModal).toHaveBeenCalledTimes(1);
            expect(modalService.showModal).toHaveBeenCalledWith(expectedDefaults, {}, 'ModalName');
        });
        it('can suppress vehicle violations modal by default', function () {
            //act
            return modalService.violationsCannotAddVehicleModal()
                .then(function () {
                //assert
                expect(modalServiceInstance.open).not.toHaveBeenCalled();
            })
                .catch(function () { fail("show not have failed."); });
        });
        it('can suppress vehicle violations modal after reset', function () {
            //act
            modalService.resetSettings();
            return modalService.violationsCannotAddVehicleModal()
                .then(function () {
                //assert
                expect(modalServiceInstance.open).not.toHaveBeenCalled();
            })
                .catch(function () { fail("show not have failed."); });
        });
        it('can track open modals', function () {
            var modalInstance = jasmine.createSpy("modalInstance", {});
            modalServiceInstance.open.and.returnValue(modalInstance);
            //arrange
            modalInstance.result = {
                "catch": function () { },
                "finally": function (callback) {
                    expect(modalService.isModalOpen("mymodal")).toBeTruthy();
                    callback();
                    expect(modalService.isModalOpen("mymodal")).toBeFalsy();
                }
            };
            //assert
            expect(modalService.isModalOpen("mymodal")).toBeFalsy();
            modalService.showModal({}, {}, "mymodal");
        });
        it('can allow listeners to watch modals opening', function () {
            //arrange
            var modalInstance = jasmine.createSpy("modalInstance", {});
            modalServiceInstance.open.and.returnValue(modalInstance);
            modalInstance.result = returnResolved();
            var listener = jasmine.createSpy("listener", function () { });
            modalService.onOpening(listener);
            //act
            return modalService.showModal({}, {}, "mymodal")
                .then(function () {
                //assert
                expect(listener).toHaveBeenCalled();
                var args = listener.calls.argsFor(0);
                expect(args[1]).toBe('mymodal');
            })
                .catch(function () { fail("show not have failed."); });
        });
        it('can allow listeners to cancel modals opening', function () {
            //arrange
            var modalInstance = jasmine.createSpy("modalInstance", {});
            modalServiceInstance.open.and.returnValue(modalInstance);
            modalInstance.result = returnResolved();
            var listener = jasmine.createSpy("listener", function () { });
            listener.and.callFake(function (evt) {
                //cancel modal
                evt.preventDefault();
            });
            modalService.onOpening(listener);
            //act
            return modalService.showModal({}, {}, "mymodal")
                .then(function () {
                //assert
                expect(modalServiceInstance.open).not.toHaveBeenCalled();
            })
                .catch(function () { fail("should not have failed."); });
        });
        it('can clear all listeners', function () {
            //arrange
            var modalInstance = jasmine.createSpy("modalInstance", {});
            modalServiceInstance.open.and.returnValue(modalInstance);
            modalInstance.result = returnResolved();
            var listener = jasmine.createSpy("listener", function () { });
            //act
            modalService.onOpening(listener);
            modalService.clearListeners();
            return modalService.showModal({}, {}, "mymodal")
                .then(function () {
                //assert
                expect(listener).not.toHaveBeenCalled();
            });
        });
        it('clears before resetting', function () {
            //arrange
            spyOn(modalService, "clearListeners");
            //act
            modalService.resetSettings();
            //assert
            expect(modalService.clearListeners).toHaveBeenCalled();
        });
        it('can close all modals', function () {
            //arrange
            modalServiceInstance.open.and.callFake(function (notUsed1, notUsed2, name) {
                var modalInstance = jasmine.createSpyObj("modalInstance " + name, ["close", "dismiss"]);
                modalInstance.dismiss.and.callFake(function () {
                    fail('should not have called dismiss');
                });
                modalInstance.result = {
                    "catch": function () { },
                    "finally": function () {
                        //stop from deleting reference on flush
                    }
                };
                return modalInstance;
            });
            //assert
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal2")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal3")).toBeFalsy();
            modalService.showModal({}, {}, "mymodal1");
            modalService.showModal({}, {}, "mymodal2");
            modalService.showModal({}, {}, "mymodal3");
            expect(modalService.isModalOpen("mymodal1")).toBeTruthy();
            expect(modalService.isModalOpen("mymodal2")).toBeTruthy();
            expect(modalService.isModalOpen("mymodal3")).toBeTruthy();
            modalService.closeAll();
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal2")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal3")).toBeFalsy();
        });
        it('can dismiss all modals', function () {
            //arrange
            modalServiceInstance.open.and.callFake(function (notUsed1, notUsed2, name) {
                var modalInstance = jasmine.createSpyObj("modalInstance " + name, ["close", "dismiss"]);
                modalInstance.close.and.callFake(function () {
                    fail('should not have called close');
                });
                modalInstance.result = {
                    "catch": function () { },
                    "finally": function () {
                        //stop from deleting reference on flush
                    }
                };
                return modalInstance;
            });
            //assert
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal2")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal3")).toBeFalsy();
            modalService.showModal({}, {}, "mymodal1");
            modalService.showModal({}, {}, "mymodal2");
            modalService.showModal({}, {}, "mymodal3");
            expect(modalService.isModalOpen("mymodal1")).toBeTruthy();
            expect(modalService.isModalOpen("mymodal2")).toBeTruthy();
            expect(modalService.isModalOpen("mymodal3")).toBeTruthy();
            modalService.closeAll(true);
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal2")).toBeFalsy();
            expect(modalService.isModalOpen("mymodal3")).toBeFalsy();
        });
        it('can close a modal by name', function () {
            //arrange
            var modalInstance = jasmine.createSpyObj("modalInstance", ["close", "dismiss"]);
            modalInstance.result = $q(function (resolve, reject) {
                modalInstance.close.and.callFake(function () {
                    resolve();
                });
                modalInstance.dismiss.and.callFake(function () {
                    reject();
                    fail("dismiss should not have been called");
                });
            });
            modalServiceInstance.open.and.callFake(function () {
                return modalInstance;
            });
            //assert
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
            modalService.showModal({}, {}, "mymodal1");
            expect(modalService.isModalOpen("mymodal1")).toBeTruthy();
            modalService.closeByName("mymodal1");
            expect(modalInstance.close).toHaveBeenCalled();
            expect(modalInstance.dismiss).not.toHaveBeenCalled();
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
        });
        it('can dismiss a modal by name', function () {
            //arrange
            var modalInstance = jasmine.createSpyObj("modalInstance", ["close", "dismiss"]);
            modalInstance.result = $q(function (resolve, reject) {
                modalInstance.close.and.callFake(function () {
                    resolve();
                    fail("close should not have been called");
                });
                modalInstance.dismiss.and.callFake(function () {
                    reject();
                });
            });
            modalServiceInstance.open.and.callFake(function () {
                return modalInstance;
            });
            //assert
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
            modalService.showModal({}, {}, "mymodal1");
            expect(modalService.isModalOpen("mymodal1")).toBeTruthy();
            modalService.closeByName("mymodal1", true);
            expect(modalInstance.dismiss).toHaveBeenCalled();
            expect(modalInstance.close).not.toHaveBeenCalled();
            expect(modalService.isModalOpen("mymodal1")).toBeFalsy();
        });
    });
})();
(function () {
    'use strict';
    describe('monthListService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('monthListService');
        }));
        it('should contain an object within months', function () {
            expect(service.months).toBeDefined();
            expect(service.months).toContain({ value: 5, label: 'May' });
        });
        it('should return a correct month number from monthList', function () {
            expect(service.getMonthNumber('November')).toBeDefined();
            expect(service.getMonthNumber('November')).toEqual(11);
        });
        it('should be undefined if incorrect month is entered', function () {
            expect(service.getMonthNumber('Test')).toBeUndefined();
        });
    });
}());
/* eslint-disable no-useless-escape */
(function () {
    'use strict';
    describe('objectUtilService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service, inStorage = {};
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('objectUtilService');
            // Clears all properties from inStorage before each test
            for (var prop in inStorage) {
                // eslint-disable-next-line no-prototype-builtins
                if (inStorage.hasOwnProperty(prop)) {
                    delete inStorage[prop];
                }
            }
        }));
        describe('areEqual', function () {
            describe('null and empty inputs', function () {
                it('should be true if both are empty objects', function () {
                    expect(service.areEqual({}, {})).toBeTruthy();
                });
                it('should be true if both inputs are null or undefined', function () {
                    expect(service.areEqual(null, null)).toBeTruthy();
                    expect(service.areEqual(null, undefined)).toBeTruthy();
                    expect(service.areEqual(undefined, null)).toBeTruthy();
                    expect(service.areEqual(undefined, undefined)).toBeTruthy();
                });
                it('should be false if one input is null or undefined', function () {
                    expect(service.areEqual({}, null)).toBeFalsy();
                    expect(service.areEqual(null, {})).toBeFalsy();
                });
            });
            describe('shallow objects', function () {
                it('should be true if objects are identical', function () {
                    expect(service.areEqual({ x: 1, y: 2 }, { x: 1, y: 2 })).toBeTruthy();
                    expect(service.areEqual({ x: "test", y: 1.23 }, { x: "test", y: 1.23 })).toBeTruthy();
                });
                it('should be \'order\' independent', function () {
                    expect(service.areEqual({ y: 1, x: 2 }, { x: 2, y: 1 })).toBeTruthy();
                    expect(service.areEqual({ x: 1, y: 2 }, { y: 2, x: 1 })).toBeTruthy();
                });
                it('should be false if one input has more properties', function () {
                    expect(service.areEqual({ x: 1 }, { x: 1, y: 2 })).toBeFalsy();
                    expect(service.areEqual({ x: 1, y: 2 }, { x: 1 })).toBeFalsy();
                });
                it('should be false if objects have same properties with different values', function () {
                    expect(service.areEqual({ x: 1, y: 2 }, { x: 3, y: 4 })).toBeFalsy();
                    expect(service.areEqual({ x: 1, y: 2 }, { x: "1", y: "2" })).toBeFalsy();
                    expect(service.areEqual({ x: true, y: 2 }, { x: false, y: 2 })).toBeFalsy();
                });
                it('should be false if objects have different property names', function () {
                    expect(service.areEqual({ x: 1, y: 2 }, { z: 1, w: 2 })).toBeFalsy();
                });
            });
            describe('deep objects', function () {
                it('should be true if objects are identical', function () {
                    expect(service.areEqual({ x: 1, y: 2, z: { prop1: "hello" } }, { x: 1, y: 2, z: { prop1: "hello" } })).toBeTruthy();
                    expect(service.areEqual({ x: "test", y: 1.23, q: ["this", 2, "test"] }, { x: "test", y: 1.23, q: ["this", 2, "test"] })).toBeTruthy();
                    expect(service.areEqual({ x: 1, y: 2, z: { prop1: { prop11: "ohyeah" } } }, { x: 1, y: 2, z: { prop1: { prop11: "ohyeah" } } })).toBeTruthy();
                    expect(service.areEqual({ x: 1, y: 2, z: {} }, { x: 1, y: 2, z: {} })).toBeTruthy();
                });
                it('should be false if nested objects are different', function () {
                    expect(service.areEqual({ x: 1, y: 2, z: { prop1: "hello" } }, { x: 1, y: 2, z: { prop1: "goodbye" } })).toBeFalsy();
                    expect(service.areEqual({ x: "test", y: 1.23, q: ["this", 2, "test"] }, { x: "test", y: 1.23, q: ["nope", 5, "rawr"] })).toBeFalsy();
                });
            });
        });
        describe('objectUtilService key changing', function () {
            it('should make all keys lowercase', function () {
                var obj = {
                    key1: 'value1',
                    KEY2: 'value2',
                    keY3: 'value3'
                };
                var objProcessed = service.toLowerCaseKeys(obj);
                expect(objProcessed.key1).toBeDefined();
                expect(objProcessed.KEY2).toBeUndefined();
                expect(objProcessed.keY1).toBeUndefined();
                expect(objProcessed.key1).toBe('value1');
                expect(objProcessed.key2).toBe('value2');
                expect(objProcessed.key3).toBe('value3');
            });
            it('should not affect the original object for lowercase', function () {
                var obj = {
                    key1: 'value1',
                    KEY2: 'value2',
                    keY3: 'value3'
                };
                service.toLowerCaseKeys(obj);
                expect(obj.key1).toBeDefined();
                expect(obj.key2).toBeUndefined();
                expect(obj.key3).toBeUndefined();
                expect(obj.key1).toBe('value1');
                expect(obj.KEY2).toBe('value2');
                expect(obj.keY3).toBe('value3');
            });
            it('should make all keys capitalized', function () {
                var obj = {
                    key1: 'value1',
                    KEY2: 'value2',
                    keY3: 'value3'
                };
                var objProcessed = service.toCapitalizedCaseKeys(obj);
                expect(objProcessed.key1).toBeUndefined();
                expect(objProcessed.KEY2).toBeDefined();
                expect(objProcessed.keY1).toBeUndefined();
                expect(objProcessed.Key1).toBe('value1');
                expect(objProcessed.KEY2).toBe('value2');
                expect(objProcessed.KeY3).toBe('value3');
            });
            it('should make all keys capitalized based on property array', function () {
                var obj = {
                    key1: 'value1',
                    KEY2: 'value2',
                    keY3: 'value3'
                };
                var objProcessed = service.toCapitalizedCaseKeys(obj, ['key1']);
                expect(objProcessed.key1).toBeUndefined();
                expect(objProcessed.KEY2).toBeDefined();
                expect(objProcessed.keY3).toBeDefined();
                expect(objProcessed.Key1).toBe('value1');
                expect(objProcessed.KEY2).toBe('value2');
                expect(objProcessed.keY3).toBe('value3');
            });
            it('should handle edge case key types', function () {
                var obj = {
                    '123': 'value1',
                    '\'\\\/|': 'value2'
                };
                var objProcessed = service.toCapitalizedCaseKeys(obj);
                expect(objProcessed['123']).toBe('value1');
                expect(objProcessed['\'\\\/|']).toBe('value2');
            });
            it('should not affect the original object for lowercase', function () {
                var obj = {
                    key1: 'value1',
                    KEY2: 'value2',
                    keY3: 'value3'
                };
                service.toLowerCaseKeys(obj);
                service.toLowerCaseKeys(obj, ['key1', 'KEY2', 'keY3']);
                expect(obj.Key1).toBeUndefined();
                expect(obj.KeY3).toBeUndefined();
                expect(obj.key1).toBe('value1');
                expect(obj.KEY2).toBe('value2');
                expect(obj.keY3).toBe('value3');
            });
        });
    });
}());
/*
(function () {
    'use strict';

    describe('operatingSystemSnifferService', function () {

        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));

        var service,
            inStorage = {};

        beforeEach(angular.mock.module(function () {
        }));

        //$provide is a module-level object, and thus must get its own
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value('webStorage', hctraMocks.webStorage(inStorage));
        }));

        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('operatingSystemSnifferService');
        }));

        it('should recognized that this is a desktop', function () {
            expect(service.getOS()).toBeDefined();
            expect(service.getOS()).toEqual('desktop');
        });

        it('should return true if using desktop', function () {
            service.getOS();
            expect(service.isDesktopOs()).toBeTruthy();
        });
    });
}());
*/ 
/*
declare var hctraMocks: any;

(function () {
    "use strict";

    describe("PciInfoService", function () {

        beforeEach(angular.mock.module("HCTRAModule"));

        var service: HCTRA.Service.PciInfoService,
            $rootScope: angular.IRootScopeService,
            $q: angular.IQService;

        beforeEach(angular.mock.module(function ($provide: angular.auto.IProvideService) {
            $provide.value("vantivPaymentService", hctraMocks.vantivPaymentService());
        }));

        beforeEach(angular.mock.inject(function ($injector: angular.auto.IInjectorService) {
            service = $injector.get<HCTRA.Service.PciInfoService>("pciInfoService");
            
        }));

        beforeEach(angular.mock.inject(function (_$rootScope_: angular.IRootScopeService, _$q_: angular.IQService) {
            $rootScope = _$rootScope_;
            $q = _$q_;
        }));

        describe("non-array input", () => {

            it("should resolve a single object w/ values returned by vantivPay", function (done) {

                vantivPayValue({
                    lastFour: "1234",
                    paypageRegistrationId: "qwerty"
                });

                service.registerCard("4111111111111234").then((res: HCTRA.Model.VantivDto) => {

                    expect(res.lastFour).toBe("1234");
                    expect(res.paypageRegistrationId).toBe("qwerty");

                    expect(service.vantivPaymentService.vantivPay).toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });

            it("should resolve with last four of masked value and undefined paypageRegistrationId", function (done) {

                // we expect this to be ignored if input is masked or is 4 digits
                vantivPayValue({
                    lastFour: "5555",
                    paypageRegistrationId: "asdfghj"
                });

                service.registerCard("************-1234").then((res) => {

                    expect((<HCTRA.Model.VantivDto>res).lastFour).toBe("1234");
                    expect((<HCTRA.Model.VantivDto>res).paypageRegistrationId).toBe(null);

                    expect(service.vantivPaymentService.vantivPay).not.toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });

            it("should resolve with the four input digits and null paypageRegistrationId", function (done) {

                // we expect this to be ignored if input is masked or is 4 digits
                vantivPayValue({
                    lastFour: "5555",
                    paypageRegistrationId: "asdfghj"
                });

                service.registerCard("1234").then((res) => {

                    expect((<HCTRA.Model.VantivDto>res).lastFour).toBe("1234");
                    expect((<HCTRA.Model.VantivDto>res).paypageRegistrationId).toBe(null);

                    expect(service.vantivPaymentService.vantivPay).not.toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });
        });

        describe("single element array input", () => {

            it("should resolve single element array w/ values returned by vantivPay", function (done) {

                vantivPayValue({
                    lastFour: "3333",
                    paypageRegistrationId: "poiuy"
                });

                service.registerCard(["4111111111111234"]).then((res) => {

                    expect((<HCTRA.Model.VantivDto[]>res)[0].lastFour).toBe("3333");
                    expect((<HCTRA.Model.VantivDto[]>res)[0].paypageRegistrationId).toBe("poiuy");

                    expect(service.vantivPaymentService.vantivPay).toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });

            it("should resolve with single element array w/ last four of masked value and undefined paypageRegistrationId", function (done) {

                // we expect this to be ignored if input is masked or is 4 digits
                vantivPayValue({
                    lastFour: "5555",
                    paypageRegistrationId: "asdfghj"
                });

                service.registerCard(["************-1234"]).then((res) => {

                    expect((<HCTRA.Model.VantivDto[]>res)[0].lastFour).toBe("1234");
                    expect((<HCTRA.Model.VantivDto[]>res)[0].paypageRegistrationId).toBe(null);

                    expect(service.vantivPaymentService.vantivPay).not.toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });

            it("should resolve with the four input digits and null paypageRegistrationId", function (done) {

                // we expect this to be ignored if input is masked or is 4 digits
                vantivPayValue({
                    lastFour: "5555",
                    paypageRegistrationId: "asdfghj"
                });

                service.registerCard(["1234"]).then((res) => {

                    expect((<HCTRA.Model.VantivDto[]>res)[0].lastFour).toBe("1234");
                    expect((<HCTRA.Model.VantivDto[]>res)[0].paypageRegistrationId).toBe(null);

                    expect(service.vantivPaymentService.vantivPay).not.toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });
        });

        describe("multi element array input", () => {

            it("should resolve multi element array w/ values returned by vantivPay", function (done) {

                vantivPayValue({
                    lastFour: "3333",
                    paypageRegistrationId: "poiuy"
                });

                service.registerCard(["4111111111111234", "4111111111115678"]).then((res) => {

                    expect((<HCTRA.Model.VantivDto[]>res)[0].lastFour).toBe("3333");
                    expect((<HCTRA.Model.VantivDto[]>res)[0].paypageRegistrationId).toBe("poiuy");

                    expect((<HCTRA.Model.VantivDto[]>res)[1].lastFour).toBe("3333");
                    expect((<HCTRA.Model.VantivDto[]>res)[1].paypageRegistrationId).toBe("poiuy");

                    expect(service.vantivPaymentService.vantivPay).toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });

            it("should resolve with single element array w/ last four of masked value and undefined paypageRegistrationId", function (done) {

                // we expect this to be ignored if input is masked or is 4 digits
                vantivPayValue({
                    lastFour: "5555",
                    paypageRegistrationId: "asdfghj"
                });

                service.registerCard(["************-1234", "************-5678"]).then((res) => {

                    expect((<HCTRA.Model.VantivDto[]>res)[0].lastFour).toBe("1234");
                    expect((<HCTRA.Model.VantivDto[]>res)[0].paypageRegistrationId).toBe(null);

                    expect((<HCTRA.Model.VantivDto[]>res)[1].lastFour).toBe("5678");
                    expect((<HCTRA.Model.VantivDto[]>res)[1].paypageRegistrationId).toBe(null);

                    expect(service.vantivPaymentService.vantivPay).not.toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });

            it("should resolve with the four input digits and null paypageRegistrationId", function (done) {

                // we expect this to be ignored if input is masked or is 4 digits
                vantivPayValue({
                    lastFour: "5555",
                    paypageRegistrationId: "asdfghj"
                });

                service.registerCard(["1234", "5678"]).then((res) => {

                    expect((<HCTRA.Model.VantivDto[]>res)[0].lastFour).toBe("1234");
                    expect((<HCTRA.Model.VantivDto[]>res)[0].paypageRegistrationId).toBe(null);

                    expect((<HCTRA.Model.VantivDto[]>res)[1].lastFour).toBe("5678");
                    expect((<HCTRA.Model.VantivDto[]>res)[1].paypageRegistrationId).toBe(null);

                    expect(service.vantivPaymentService.vantivPay).not.toHaveBeenCalled();

                    done();
                });

                $rootScope.$apply();
            });
        });

        function vantivPayValue(vantivResponse: { lastFour: string, paypageRegistrationId: string}) {

            spyOn(service.vantivPaymentService, "vantivPay")
                .and
                .returnValue($q.resolve(vantivResponse));
        }
    });
} ());
 */ 
(function () {
    "use strict";
    // describe("ReadMoreOrLessService", () => {
    //     let service: HCTRA.Service.ReadMoreOrLessService;
    //     const mockState = hctraMocks.$state("myName");
    //     const mockLinkLookupService = hctraMocks.linkLookupService({ id: "byId", url: "byCmsPath" });
    //     const mockStateNames = hctraMocks.stateNames();
    //     beforeEach(angular.mock.module("HCTRAModule"));
    //     beforeEach(angular.mock.module(function ($provide) {
    //         $provide.value('$state', mockState);
    //         $provide.value('linkLookupService', mockLinkLookupService);
    //         $provide.value('stateNames', mockStateNames);
    //     }));
    //     describe("defaultToLess", () => {
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         it("should return true when titleName is 'Transtar Map'", () => {
    //             expect(service.defaultToLess('Transtar Map')).toBe(true);
    //         });
    //         [
    //             'Something',
    //             'Something Else',
    //             'Not Transtar map',
    //             undefined,
    //             null,
    //             ""
    //         ].forEach((titleName) => {
    //             it("should return false when titleName not 'Transtar Map'", () => {
    //                 expect(service.defaultToLess(titleName)).toBe(false);
    //             });
    //         });
    //     });
    //     describe("breakoutPageNeeded", () => {
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         [
    //             mockStateNames.closures,
    //             mockStateNames.newsFeed,
    //             mockStateNames.closuresArchiveChild,
    //             mockStateNames.newsArchiveChild
    //         ].forEach((stateName) => {
    //             it("should return true when state.current.name in closure or newsFeed or closuresArchiveChild or closuresArchiveChild", () => {
    //                 mockState.current.name = stateName;
    //                 expect(service.breakoutPageNeeded()).toBe(true);
    //             });
    //         });
    //         Object.keys(mockStateNames)
    //             .filter((key) => ['closures', 'newsFeed', 'closuresArchiveChild', 'newsArchiveChild'].indexOf(key) < 0)
    //             .map((key) => mockStateNames[key])
    //             .forEach((stateName) => {
    //                 it("should return false when state.current.name neither closure nor newsFeed nor closuresArchiveChild nor closuresArchiveChild", () => {
    //                     mockState.current.name = stateName;
    //                     expect(service.breakoutPageNeeded()).toBe(false);
    //                 });
    //             });
    //     });
    //     describe("displayBreakoutPageLink", () => {
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         [
    //             ["A", false, true],
    //             ["B", false, true],
    //             ["C", false, true]
    //         ].forEach((input) => {
    //             const longContent = input[0] as string;
    //             const isDefaultToLess = input[1] as boolean;
    //             const needsBreakoutPage = input[2] as boolean;
    //             it(`should return true when longContent non-empty string, defaultToLess false and needsBreakoutPage true`, function () {
    //                 expect(service.displayBreakoutPageLink(longContent, isDefaultToLess, needsBreakoutPage)).toBe(true);
    //             });
    //         });
    //         [
    //             [undefined, true, false],
    //             [null, true, true],
    //             ["", false, false],
    //             [undefined, false, true],
    //             ["E", true, false],
    //             ["C", true, true],
    //             ["D", false, false]
    //         ].forEach((input) => {
    //             const longContent = input[0] as string;
    //             const isDefaultToLess = input[1] as boolean;
    //             const needsBreakoutPage = input[2] as boolean;
    //             it(`should return false when longContent empty string\\null\\undefined or defaultToLess false or needsBreakoutPage false`, function () {
    //                 expect(service.displayBreakoutPageLink(longContent, isDefaultToLess, needsBreakoutPage)).toBe(false);
    //             });
    //         });
    //     });
    //     describe("isLongContent", () => {
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         [
    //             ["A", false, true],
    //             ["B", false, true],
    //             ["C", false, true]
    //         ].forEach((input) => {
    //             const longContent = input[0] as string;
    //             const defaultToLess = input[1] as boolean;
    //             const defaultToMore = input[2] as boolean;
    //             it(`should return true when longContent non-empty string, defaultToLess false and defaultToMore true`, function () {
    //                 expect(service.isLongContent(longContent, defaultToLess, defaultToMore)).toBe(true);
    //             });
    //         });
    //         [
    //             [undefined, true, false],
    //             [null, true, true],
    //             ["", false, false],
    //             [undefined, false, true],
    //             ["E", true, false],
    //             ["C", true, true],
    //             ["D", false, false]
    //         ].forEach((input) => {
    //             const longContent = input[0] as string;
    //             const defaultToLess = input[1] as boolean;
    //             const defaultToMore = input[2] as boolean;
    //             it(`should return false when longContent empty string\\null\\undefined or defaultToLess false or defaultToMore false`, function () {
    //                 expect(service.isLongContent(longContent, defaultToLess, defaultToMore)).toBe(false);
    //             });
    //         });
    //     });
    //     describe("getContent", () => {
    //         let isLongContentSpy;
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //             isLongContentSpy = spyOn(service as any, "isLongContent");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         [
    //             ["", ""],
    //             [null, null],
    //             [undefined, undefined],
    //             [undefined, null],
    //             [null, undefined],
    //             ["", undefined]
    //         ].forEach((input) => {
    //             const shortContent = input[0] as string;
    //             const longContent = input[1] as string;
    //             it(`should return empty string when shortContent "${shortContent}" and longContent "${longContent}"`, function () {
    //                 expect(service.getContent(shortContent, longContent, false, true)).toEqual("");
    //                 expect(isLongContentSpy).not.toHaveBeenCalled();
    //             });
    //         });
    //         [
    //             "",
    //             null,
    //             undefined
    //         ].forEach((shortContent) => {
    //             it(`should return longContent when shortContent "${shortContent}"`, function () {
    //                 expect(service.getContent(shortContent, "longContent", true, false)).toEqual("longContent");
    //                 expect(isLongContentSpy).not.toHaveBeenCalled();
    //             });
    //         });
    //         it(`should return longContent when shortContent non-empty string and isLongContent returns true`, function () {
    //             isLongContentSpy.and.returnValue(true);
    //             expect(service.getContent("shortContent", "longContent", true, false)).toEqual("longContent");
    //             expect(isLongContentSpy).toHaveBeenCalledWith("longContent", true, false);
    //         });
    //         it(`should return shortContent when shortContent non-empty string and isLongContent returns false`, function () {
    //             isLongContentSpy.and.returnValue(false);
    //             expect(service.getContent("shortContent", "longContent", true, false)).toEqual("shortContent");
    //             expect(isLongContentSpy).toHaveBeenCalledWith("longContent", true, false);
    //         });
    //     });
    //     describe("getExpanderText", () => {
    //         let isLongContentSpy;
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //             isLongContentSpy = spyOn(service as any, "isLongContent");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         [
    //             "",
    //             undefined,
    //             null
    //         ].forEach((shortContent) => {
    //             it(`should return "Read More" when shortContent "${shortContent}"`, function () {
    //                 expect(service.getExpanderText(shortContent, "longContent", false, true)).toEqual("Read More");
    //                 expect(isLongContentSpy).not.toHaveBeenCalled();
    //             });
    //         });
    //         it(`should return "Read More" when shortContent non-empty string and isLongContent returns false`, function () {
    //             isLongContentSpy.and.returnValue(false);
    //             expect(service.getExpanderText("shortContent", "longContent", true, false)).toEqual("Read More");
    //             expect(isLongContentSpy).toHaveBeenCalledWith("longContent", true, false);
    //         });
    //         it(`should return "Read Less" when shortContent non-empty string and isLongContent returns true`, function () {
    //             isLongContentSpy.and.returnValue(true);
    //             expect(service.getExpanderText("shortContent", "longContent", true, false)).toEqual("Read Less");
    //             expect(isLongContentSpy).toHaveBeenCalledWith("longContent", true, false);
    //         });
    //     });
    //     describe("displayReadMoreOrLessLink", () => {
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         [
    //             ["A", "B", false, false],
    //             ["B", "C", false, false]
    //         ].forEach((input) => {
    //             const shortContent = input[0] as string;
    //             const longContent = input[1] as string;
    //             const isDefaultToLess = input[2] as boolean;
    //             const displayBreakOutPage = input[3] as boolean;
    //             it(`should return true when shortContent and longContent non-empty strings and not same, defaultToLess false and displayBreakOutPageLink false`, function () {
    //                 expect(service.displayReadMoreOrLessLink(shortContent, longContent, isDefaultToLess, displayBreakOutPage)).toBe(true);
    //             });
    //         });
    //         [
    //             ["", "", true, true],
    //             [undefined, undefined, true, false],
    //             [null, null, false, true],
    //             ["", "", false, false],
    //             ["", "B", true, true],
    //             ["", "C", true, false],
    //             ["", "B", false, true],
    //             ["", "C", false, false],
    //             ["A", "", true, true],
    //             ["A", undefined, true, false],
    //             ["A", null, false, true],
    //             ["A", "", false, false],
    //             ["B", "B", true, true],
    //             ["C", "C", true, false],
    //             ["B", "B", false, true],
    //             ["C", "C", false, false]
    //         ].forEach((input) => {
    //             const shortContent = input[0] as string;
    //             const longContent = input[1] as string;
    //             const isDefaultToLess = input[2] as boolean;
    //             const displayBreakOutPage = input[3] as boolean;
    //             it(`should return false when shortContent or longContent null\\undefined\\empty strings or same or defaultToLess true or displayBreakOutPageLink true`, function () {
    //                 expect(service.displayReadMoreOrLessLink(shortContent, longContent, isDefaultToLess, displayBreakOutPage)).toBe(false);
    //             });
    //         });
    //     });
    //     describe("getArticleUrl", () => {
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         [
    //             mockStateNames.closuresArchiveChild,
    //             mockStateNames.newsArchiveChild
    //         ].forEach((stateName) => {
    //             it("should call and return value of linkLookupService.articleLookupById when state.current.name closuresArchiveChild or closuresArchiveChild", () => {
    //                 const linkLookUpServiceSpy = spyOn(mockLinkLookupService, 'articleLookupById').and.callThrough();
    //                 mockState.current.name = stateName;
    //                 expect(service.getArticleUrl('id', 'path')).toBe('byId');
    //                 expect(linkLookUpServiceSpy).toHaveBeenCalledWith('id');
    //             });
    //         });
    //         Object.keys(mockStateNames)
    //             .filter((key) => ['closuresArchiveChild', 'newsArchiveChild'].indexOf(key) < 0)
    //             .map((key) => mockStateNames[key])
    //             .forEach((stateName) => {
    //                 it("should call and retrun value of linkLookupService.articleLookup when state.current.name neither closuresArchiveChild nor closuresArchiveChild", () => {
    //                     const linkLookUpServiceSpy = spyOn(mockLinkLookupService, 'articleLookup').and.callThrough();
    //                     mockState.current.name = stateName;
    //                     expect(service.getArticleUrl('id', 'path')).toBe('byCmsPath');
    //                     expect(linkLookUpServiceSpy).toHaveBeenCalledWith('path');
    //                 });
    //             });
    //     });
    //     describe("getReadMoreOrLessInitialState", () => {
    //         let defaultToLessSpy;
    //         let needsBreakoutPageSpy;
    //         let displayBreakOutPageLinkSpy;
    //         let getContentSpy;
    //         let getExpanderTextSpy;
    //         let displayReadMoreOrLessLinkSpy;
    //         let getArticleUrlSpy;
    //         beforeEach(angular.mock.inject(($injector: angular.auto.IInjectorService) => {
    //             service = $injector.get<HCTRA.Service.ReadMoreOrLessService>("readMoreOrLessService");
    //             defaultToLessSpy = spyOn(service as any, "defaultToLess").and.returnValue("defaultToLess");
    //             needsBreakoutPageSpy = spyOn(service as any, "breakoutPageNeeded").and.returnValue("breakoutPageNeeded");
    //             displayBreakOutPageLinkSpy = spyOn(service as any, "displayBreakoutPageLink").and.returnValue(true);
    //             getContentSpy = spyOn(service as any, "getContent").and.returnValue("getContent");
    //             getExpanderTextSpy = spyOn(service as any, "getExpanderText").and.returnValue("getExpanderText");
    //             displayReadMoreOrLessLinkSpy = spyOn(service as any, "displayReadMoreOrLessLink").and.returnValue(true);
    //             getArticleUrlSpy = spyOn(service as any, "getArticleUrl").and.returnValue("getArticleUrl");
    //         }));
    //         it("canary", () => {
    //             expect(true).toBe(true);
    //         });
    //         it("should call functions with correct arguments and return readMoreOrLessInitialState", () => {
    //             expect(service.getReadMoreOrLessInitialState("shortContent", "longContent", true, "titleName", "itemId", "itemPath")).toEqual({
    //                 content: "getContent",
    //                 expanderText: "getExpanderText",
    //                 displayBreakoutPageLink: true,
    //                 displayReadMoreOrLessLink: true,
    //                 articleUrl: "getArticleUrl"
    //             });
    //             expect(defaultToLessSpy).toHaveBeenCalledWith("titleName");
    //             expect(needsBreakoutPageSpy).toHaveBeenCalledWith();
    //             expect(displayBreakOutPageLinkSpy).toHaveBeenCalledWith("longContent", "defaultToLess", "breakoutPageNeeded");
    //             expect(getContentSpy).toHaveBeenCalledWith("shortContent", "longContent", "defaultToLess", true);
    //             expect(getExpanderTextSpy).toHaveBeenCalledWith("shortContent", "longContent", "defaultToLess", true);
    //             expect(displayReadMoreOrLessLinkSpy).toHaveBeenCalledWith("shortContent", "longContent", "defaultToLess", true);
    //             expect(getArticleUrlSpy).toHaveBeenCalledWith("itemId", "itemPath");
    //         });
    //     });
    // });
})();
(function () {
    'use strict';
    describe('responsiveService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('responsiveService');
        }));
        it('should return true if on desktop', function () {
            expect(service.isDesktop).toBeTruthy();
        });
    });
}());
(function () {
    "use strict";
    describe("rssService", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var service, routes, documentLocationService, $rootScope, hrefUrl;
        beforeEach(function () {
            hrefUrl = {};
        });
        beforeEach(angular.mock.module(function ($provide) {
            $provide.constant("environmentConfig", hctraMocks.environmentConfig());
            $provide.value("documentLocationService", hctraMocks.documentLocationService(hrefUrl));
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("rssService");
        }));
        beforeEach(angular.mock.inject(function (_$rootScope_, _documentLocationService_, _routes_) {
            $rootScope = _$rootScope_;
            documentLocationService = _documentLocationService_;
            routes = _routes_;
            spyOn(documentLocationService, "goToHref").and.callFake(hctraMocks.documentLocationService(hrefUrl).goToHref);
        }));
        it("should call documentLocationService when id is found closures", function () {
            service.goToRssFeed(service.rssHomeClosuresKey);
            expect(documentLocationService.goToHref).toHaveBeenCalled();
            expect(hrefUrl.value).toBe(routes.rssFeed + "closures");
        });
        it("should call documentLocationService when id is found news", function () {
            service.goToRssFeed(service.rssLatestNewsKey);
            expect(documentLocationService.goToHref).toHaveBeenCalled();
            expect(hrefUrl.value).toBe(routes.rssFeed + "news");
        });
        it("should call documentLocationService when id is found custom", function () {
            service.goToRssFeed(service.rssMajorClosuresKey);
            expect(documentLocationService.goToHref).toHaveBeenCalled();
            expect(hrefUrl.value).toBe(routes.rssFeed + "customClosures");
        });
        it("should not call documentLocationService when id is not found", function () {
            service.goToRssFeed("");
            expect(documentLocationService.goToHref).not.toHaveBeenCalled();
            expect(hrefUrl.value).toBeUndefined();
        });
        it("should return a promise during rss link injection call", function () {
            var rssPromise = service.injectRssData();
            var rssArray;
            rssPromise.then(function (result) {
                rssArray = result;
            });
            $rootScope.$digest();
            expect(rssArray.length).toBe(4);
            for (var i = 0; i < rssArray.length; i++) {
                expect(rssArray[i]).toMatch(/^\/rss\/.*$/);
            }
        });
    });
}());
(function () {
    "use strict";
    describe("saveBillingService", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var service, inData = {
            value: "testData"
        }, genericRepo = hctraMocks.genericRepo(inData), modalService = hctraMocks.modalService(), state = hctraMocks.$state({}), responseErrorService = hctraMocks.responseErrorService(), obj;
        beforeEach(angular.mock.module(function () {
            obj = {
                billingType: "",
                billingInfo: {
                    cards: [{}, {}]
                }
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("genericRepo", genericRepo);
            $provide.value("responseErrorService", responseErrorService);
            $provide.value("modalService", modalService);
            $provide.value("$state", state);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("saveBillingService");
        }));
        describe("createSaveRequest", function () {
            it("should set first card in objectPassed.billingInfo.cards to primary when object passed has billingType Credit", function () {
                spyOn(service, "createCreditCardSaveRequest").and.returnValue("sampleCCRequest");
                obj.billingType = "CREDIT";
                service.createSaveRequest(obj);
                expect(obj.billingInfo.cards[0].primary).toBe(true);
            });
            it("should not set first card in objectPassed.billingInfo.cards to primary when object passed has billingType not Credit", function () {
                spyOn(service, "createCreditCardSaveRequest").and.returnValue("sampleCCRequest");
                obj.billingType = "";
                service.createSaveRequest(obj);
                expect(obj.billingInfo.cards[0].primary).toBeFalsy();
            });
            it("should return response from createCreditCardSaveRequest when object passed has billingType Credit", function () {
                spyOn(service, "createCreditCardSaveRequest").and.returnValue({
                    billingInfo: "",
                    cards: []
                });
                obj.billingType = "CREDIT";
                var originalBillingInfo = angular.copy(obj.billingInfo);
                var request = service.createSaveRequest(obj);
                expect(service.createCreditCardSaveRequest).toHaveBeenCalledTimes(1);
                expect(service.createCreditCardSaveRequest).toHaveBeenCalledWith(originalBillingInfo);
                expect(request).toEqual({
                    billingInfo: "",
                    cards: []
                });
            });
            it("should return response from createEftSaveRequest when object passed has billingType not equal to CREDIT", function () {
                spyOn(service, "createEftSaveRequest").and.returnValue({
                    billingInfo: "",
                    cards: null
                });
                obj.billingType = "EFT";
                var request = service.createSaveRequest(obj);
                expect(service.createEftSaveRequest).toHaveBeenCalledTimes(1);
                expect(service.createEftSaveRequest).toHaveBeenCalledWith(obj.billingInfo);
                expect(request).toEqual({
                    billingInfo: "",
                    cards: null
                });
            });
        });
        describe("createEftSaveRequest", function () {
            it("should return object with cards set to null and billingInfo with cards set to null, billingTypeCode E and billing typeDisplay EFT", function () {
                var expectedResult = {
                    cards: null,
                    billingInfo: {
                        existingField: 1,
                        cards: null,
                        billingTypeCode: "E",
                        billingTypeDisplay: "EFT"
                    }
                };
                expect(service.createEftSaveRequest({ existingField: 1 })).toEqual(expectedResult);
            });
        });
        describe("createCreditCardSaveRequest", function () {
            it("should return object with eft set to null cards to billingInfo.cards", function () {
                var answer = service.createCreditCardSaveRequest({ existingField: 1, cards: [{}] });
                expect(answer.cards).toBe(answer.billingInfo.cards);
                expect(answer.eft).toBe(null);
            });
            it("should return object with billingInfo properties card[0] set to primary, eft set to null, billingTypeCode set to C and billingTypeDisplay set to CREDIT", function () {
                var billingInfo = service.createCreditCardSaveRequest({ existingField: 1, cards: [{}] }).billingInfo;
                expect(billingInfo.eft).toBe(null);
                expect(billingInfo.billingTypeCode).toBe("C");
                expect(billingInfo.billingTypeDisplay).toBe("CREDIT");
                expect(billingInfo.existingField).toBe(1);
            });
            it("should return object with billingInfo cards zip copied to zipCode", function () {
                var billingInfo = service.createCreditCardSaveRequest({ existingField: 1, cards: [{ zip: 1 }, { zip: 2 }] }).billingInfo;
                expect(billingInfo.cards[0].zip).toBe(1);
                expect(billingInfo.cards[0].zipCode).toBe(1);
                expect(billingInfo.cards[1].zip).toBe(2);
                expect(billingInfo.cards[1].zipCode).toBe(2);
            });
            it("should return object with billingInfo cards country set to USA if not international", function () {
                var billingInfo = service.createCreditCardSaveRequest({
                    existingField: 1, cards: [
                        {
                            country: "a", international: false
                        }, {
                            country: "b", international: true
                        }
                    ]
                }).billingInfo;
                expect(billingInfo.cards[0].country).toBe("USA");
                expect(billingInfo.cards[1].country).toBe("b");
            });
            it("should return object with billingInfo cards cardExpiresDate even when incoming cardExpiresDate blank or null", function () {
                spyOn(service, "getDate").and.returnValues("1", "2");
                var billingInfo = service.createCreditCardSaveRequest({
                    existingField: 1, cards: [
                        {
                            cardExpiresDate: 1, selectedYear: "1992", expMonth: "1"
                        }, {
                            cardExpiresDate: "", selectedYear: "1993", expMonth: "2"
                        }, {
                            cardExpiresDate: "someDate", selectedYear: "1994", expMonth: "3"
                        }
                    ]
                }).billingInfo;
                expect(billingInfo.cards[0].cardExpiresDate).toBe("1");
                expect(billingInfo.cards[1].cardExpiresDate).toBe("2");
                expect(billingInfo.cards[2].cardExpiresDate).toBe("someDate");
                expect(service.getDate).toHaveBeenCalledTimes(2);
                expect(service.getDate).toHaveBeenCalledWith("1992", "1");
                expect(service.getDate).toHaveBeenCalledWith("1993", "2");
            });
        });
        describe("getDate", function () {
            [
                { year: 1992, month: 2, result: "1992-03-01T06:00:00.000Z" },
                { year: 1993, month: 4, result: "1993-05-01T05:00:00.000Z" },
                { year: 1994, month: 6, result: "1994-07-01T05:00:00.000Z" },
                { year: 1995, month: 7, result: "1995-08-01T05:00:00.000Z" },
                { year: 1996, month: 9, result: "1996-10-01T05:00:00.000Z" },
                { year: 1997, month: 11, result: "1997-12-01T06:00:00.000Z" }
            ].forEach(function (_a) {
                var year = _a.year, month = _a.month, result = _a.result;
                return it("should return " + result + " when called like getDate(" + year + ", " + month + ")", function () {
                    expect(service.getDate(year, month)).toEqual(result);
                });
            });
        });
        describe("saveCardOrEft", function () {
            it("should equal saveCreditCard and saveEft)", function () {
                expect(service.saveCardOrEft).toEqual(service.saveEFT);
                expect(service.saveCardOrEft).toEqual(service.saveCreditCard);
            });
            it("should call genericRepo.dataFactory.saveBillingInformation", function () {
                spyOn(genericRepo.dataFactory, "saveBillingInformation").and.callThrough();
                spyOn(service, "processSaveResponse");
                service.saveCardOrEft("request", "nextState");
                expect(genericRepo.dataFactory.saveBillingInformation).toHaveBeenCalledTimes(1);
                expect(genericRepo.dataFactory.saveBillingInformation).toHaveBeenCalledWith("request");
                expect(service.processSaveResponse).toHaveBeenCalledTimes(1);
                expect(service.processSaveResponse).toHaveBeenCalledWith(inData.value, "nextState");
            });
        });
        describe("processSaveResponse", function () {
            it("should display alert and show update successful modal then go to next state when response has no errors", function () {
                spyOn(service, "isErrorFree").and.returnValue(true);
                spyOn(responseErrorService, "displayAlertsFromResponse");
                spyOn(modalService, "showUpdateSuccessModal");
                spyOn(state, "go");
                service.processSaveResponse({ accountStatus: "response" }, "nextState");
                expect(responseErrorService.displayAlertsFromResponse).toHaveBeenCalledTimes(1);
                expect(responseErrorService.displayAlertsFromResponse).toHaveBeenCalledWith({ accountStatus: "response" }, true);
                expect(modalService.showUpdateSuccessModal).toHaveBeenCalledTimes(1);
                expect(modalService.showUpdateSuccessModal).toHaveBeenCalledWith("Billing Information Update", "billing information");
                expect(state.go).toHaveBeenCalledTimes(1);
                expect(state.go).toHaveBeenCalledWith("nextState", {}, { reload: true });
            });
        });
    });
}());
(function () {
    'use strict';
    describe('StorefrontEventService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var eventService, $window, $interval, $location, fakeJq, fakejQueryFunction, $state, stateNames, storefrontService, modalService, $rootScope, documentLocationService, $q, $timeout, errorDisplayService, genericRepo, maintenanceService, $transitions;
        var environmentConfig = {
            storefrontConfigs: {
                storefrontInactivityWarning: 999999,
                storefrontInactivityReset: 999999,
                storefrontInactivityIntervalDelay: 999999
            }
        };
        function returnResolved(value) {
            return $q.resolve(value);
        }
        function returnRejected(object) {
            return $q.reject(object);
        }
        beforeEach(angular.mock.inject(function ($injector) {
            try {
                $rootScope = $injector.get('$rootScope');
                var win = $injector.get('$window');
                var promise = win["Promise"];
                $window = jasmine.createSpy("$window", win);
                $window.open["listen"] = jasmine.createSpy("openListener", function () { });
                $window.console = jasmine.createSpyObj("fakeConsole", ["log"]);
                $window["MutationObserver"] = win["MutationObserver"];
                $window.URL = win.URL;
                stateNames = $injector.get("stateNames");
                $interval = jasmine.createSpy("$interval", $injector.get('$interval'));
                $timeout = jasmine.createSpy("$timeout", function () {
                    return true;
                });
                //$q = $injector.get("$q");
                $q = jasmine.createSpyObj("$q", ["resolve", "reject", "all", "when", "defer"]);
                $q.resolve.and.callFake(function (obj) {
                    return promise.resolve(obj);
                });
                $q.reject.and.callFake(function (obj) {
                    return promise.reject(obj);
                });
                $q.all.and.callFake(function (args) {
                    return promise.all(args);
                });
                $q.when.and.callFake(function (obj) {
                    return promise.resolve(obj);
                });
                $q.defer.and.callFake(function () {
                    var deferObj = {
                        resolve: null,
                        reject: null,
                        promise: null
                    };
                    deferObj.promise = new promise(function (res, rej) {
                        deferObj.resolve = res;
                        deferObj.reject = rej;
                    });
                    return deferObj;
                });
                documentLocationService = jasmine.createSpyObj("fakeDLS", ["goToHref"]);
                documentLocationService.goToHref["listen"] = jasmine.createSpy("gotohrefListener", function () { });
                $location = jasmine.createSpyObj("fakeLocation", ["url", "absUrl"]);
                $location.absUrl.and.returnValue("http://dev.hctra.pri");
                $state = jasmine.createSpyObj("$state", ["go"]);
                $state.current = {
                    name: stateNames.storefrontHome
                };
                $state.go.and.returnValue(returnResolved());
                fakeJq = jasmine.createSpyObj("fakeJq", ["on", "off", "removeAttr", "attr", "is", "trigger"]);
                fakeJq.on.and.returnValue(fakeJq);
                fakeJq.off.and.returnValue(fakeJq);
                fakeJq.removeAttr.and.returnValue(fakeJq);
                fakejQueryFunction = jasmine.createSpy("fakejQuery", function () { return fakeJq; });
                fakejQueryFunction.and.returnValue(fakeJq);
                storefrontService = jasmine.createSpyObj("storefrontService", [
                    "getCmsMediaItem", "isEnabled", "reset", "checkState", "pushLoggingInfo", "isWorkflowActive",
                    "currentWorkItem", "getWorkItemInitState", "registerEventHandlers",
                    "prefetchContent", "getCmsData", "initializing", "isCmsContent", "isInMaintenanceMode", "insertWorkItem", "skip",
                    'isQueued', 'getWorkItemById'
                ]);
                storefrontService.isInMaintenanceMode.and.callFake(function () {
                    return returnRejected();
                });
                storefrontService.initializing.and.returnValue(returnResolved());
                storefrontService.getCmsMediaItem.and.returnValue(returnResolved());
                storefrontService.getCmsData.and.returnValue(returnResolved());
                storefrontService.isEnabled.and.returnValue(true);
                storefrontService.reset.and.returnValue(returnResolved());
                storefrontService.pushLoggingInfo.and.returnValue(returnResolved());
                storefrontService.prefetchContent.and.returnValue(returnResolved());
                storefrontService.getStorefrontLogo = function () {
                    return {
                        "ItemId": "cccab286-133d-4118-bf4b-8b57d2434edf",
                        "ImageItem": {
                            "image": "-/media/30D08C39C5334DC78B66FC37CA8E4F84.ashx",
                            "alt": "HCTRA Logo"
                        }
                    };
                };
                storefrontService.workItems = [];
                spyOn($interval, "cancel");
                modalService = jasmine.createSpyObj("storefrontModalService", ["setGlobalModalSettings", "showExternalTask", "isExternalTaskModalOpen", "showInactivity", "showPdf", "showCmsContent"]);
                $transitions = jasmine.createSpyObj("$transitions", ["onStart", "onError", "onSuccess"]);
                eventService = newService();
                $rootScope.$apply();
            }
            catch (e) {
                fail(e);
            }
        }));
        function newService() {
            return new HCTRA.Storefront.Service.StorefrontEventService(fakejQueryFunction, $window, $interval, documentLocationService, $q, $location, $timeout, storefrontService, modalService, $state, stateNames, $rootScope, errorDisplayService, genericRepo, maintenanceService, environmentConfig, $transitions);
        }
        afterEach(function () {
            $rootScope.$apply();
        });
        it('registers all listeners', function () {
            //arrange
            var eventHandler = {};
            $window.open["listen"].and.returnValue(function () { });
            spyOn($rootScope, "$on");
            //act
            eventService.startListening(eventHandler);
            //assert
            expect($window.open["listen"]).toHaveBeenCalledWith(eventService.windowDotOpenInterceptor);
            expect($interval).toHaveBeenCalledWith(eventService.checkForUserTimeout, environmentConfig.storefrontConfigs.StorefrontInactivityIntervalDelay, 0, false);
            //            expect($rootScope.$on).toHaveBeenCalledTimes(3);
            //            var args = $rootScope.$on.calls.argsFor(0);
            //            expect(args[0]).toBe("$stateChangeStart");
            //            expect(args[1]).toBeDefined();
            //            args = $rootScope.$on.calls.argsFor(1);
            //            expect(args[0]).toBe("$stateChangeSuccess");
            //            expect(args[1]).toBeDefined();
            expect(fakeJq.on).toHaveBeenCalledWith(eventService.constructor.userInactivityEvents, eventService.updateActivity);
            //expect(fakeJq.on).toHaveBeenCalled(c.constructor.eventName("click"), "a[href]", c.nonUiRouterLinkClickIntercepter);
            expect(fakeJq.on).toHaveBeenCalledWith(eventService.constructor.eventName("scroll"), eventService.disableWindowScroll);
        });
        it('cancels all events when when stop listening', function () {
            //ararnge
            var eventHandler = {};
            var token = "thisIsAToken";
            $interval.and.returnValue(token);
            var dlsDestroy = jasmine.createSpy("dlsDestroy", function () { });
            documentLocationService.goToHref["listen"].and.returnValue(dlsDestroy);
            var winDotOpenDestroy = jasmine.createSpy("winDotOpenDestroy", function () { });
            $window.open["listen"].and.returnValue(winDotOpenDestroy);
            //var stateStartDestroy = jasmine.createSpy("stateStartDestroy", function () { });
            //var stateSuccessDestroy = jasmine.createSpy("stateSuccessDestroy", function () { });
            //            spyOn($rootScope, "$on").and.callFake(function (name) {
            //                if (name === "$stateChangeStart") {
            //                    return stateStartDestroy;
            //                } else if (name === "$stateChangeSuccess") {
            //                    return stateSuccessDestroy;
            //                }
            //                return function () { };
            //            });
            //act
            eventService.startListening(eventHandler);
            eventService.stopListening();
            //assert
            expect(dlsDestroy).toHaveBeenCalled();
            expect(winDotOpenDestroy).toHaveBeenCalled();
            expect(fakeJq.off).toHaveBeenCalledWith(eventService.constructor.eventNamespace);
            expect($interval.cancel).toHaveBeenCalledWith(token);
            //expect(stateStartDestroy).toHaveBeenCalled();
            //expect(stateSuccessDestroy).toHaveBeenCalled();
            expect(storefrontService.registerEventHandlers).toHaveBeenCalledWith(eventHandler);
        });
        it('does not redirect non cms content', function () {
            //arrange
            var href = "/SomeValidPath";
            var event = jasmine.createSpyObj("event", ["preventDefault", "stopPropagation", "stopImmediatePropagation"]);
            fakeJq.attr.and.callFake(function (attribute) {
                if (attribute === 'href')
                    return href;
                return null;
            });
            event.currentTarget = {
                baseURI: 'test'
            };
            //act
            eventService.nonUiRouterLinkClickIntercepter(event);
            //assert
            expect(fakejQueryFunction).toHaveBeenCalledWith(event.currentTarget);
            expect(event.preventDefault).not.toHaveBeenCalled();
            expect($state.go).not.toHaveBeenCalled();
            expect($location.url).not.toHaveBeenCalled();
        });
        it('redirects on cms content', function () {
            //arrange
            var href = "-/media/123.ashx";
            var event = jasmine.createSpyObj("event", ["preventDefault", "stopPropagation", "stopImmediatePropagation"]);
            event.currentTarget = {
                baseURI: 'test'
            };
            fakeJq.attr.and.callFake(function (attribute) {
                if (attribute === 'href')
                    return href;
                return null;
            });
            modalService.showPdf.and.callFake(function () {
                return returnRejected({ name: 'InvalidPDFException', message: "" });
            });
            //act
            eventService.nonUiRouterLinkClickIntercepter(event);
            //assert
            expect(fakejQueryFunction).toHaveBeenCalledWith(event.currentTarget);
            expect(event.preventDefault).toHaveBeenCalled();
            expect($state.go).not.toHaveBeenCalled();
            expect(modalService.showPdf).toHaveBeenCalled();
            //expect($location.url).toHaveBeenCalled();
        });
        it('intercepts open window calls and performs a location redirect', function () {
            //arrange
            var href = "/NewAccount";
            var event = jasmine.createSpyObj("event", ["preventDefault"]);
            var args = { href: href };
            //act
            eventService.windowDotOpenInterceptor(event, args);
            //assert
            expect(event.preventDefault).toHaveBeenCalled();
            expect($location.url).toHaveBeenCalledWith(href);
        });
        it('only checks for user timeout if storefront ui has been started by user', function () {
            //arrange
            $state.current.name = stateNames.storefrontHome;
            //act
            return eventService.checkForUserTimeout().catch(function () {
                //assert
                expect($state.go).not.toHaveBeenCalled();
                expect(storefrontService.reset).not.toHaveBeenCalled();
            });
        });
        it('gives an inactivity warning', function () {
            //arrange
            $state.current.name = stateNames.storefrontSelection;
            modalService.showInactivity.and.returnValue(returnResolved());
            environmentConfig.storefrontConfigs.StorefrontInactivityWarning = -1; //immediate
            environmentConfig.storefrontConfigs.StorefrontInactivityReset = 999999;
            //act
            eventService.checkForUserTimeout();
            //assert
            expect(storefrontService.reset).not.toHaveBeenCalled();
            expect(modalService.showInactivity).toHaveBeenCalled();
        });
        it('shows inactivity modal', function () {
            //arrange
            $state.current.name = stateNames.storefrontSelection;
            environmentConfig.storefrontConfigs.StorefrontInactivityWarning = -9999; //immediate
            environmentConfig.storefrontConfigs.StorefrontInactivityReset = -1; //also immediate
            modalService.showInactivity.and.returnValue(returnResolved());
            //act
            var promise = eventService.checkForUserTimeout();
            //assert
            expect(promise).toBeDefined();
            promise.then(function () {
                expect(modalService.showInactivity).toHaveBeenCalled();
            });
        });
        it('can handle service external task request', function () {
            //arrange
            var state = { name: "from" };
            modalService.isExternalTaskModalOpen.and.returnValue(false);
            modalService.showExternalTask.and.returnValue(returnResolved());
            var evt = jasmine.createSpyObj("angular event", ["preventDefault"]);
            evt.preventDefault.and.callFake(function () {
                evt.defaultPrevented = true;
            });
            storefrontService.checkState.and.returnValue(returnResolved({ isExternal: true }));
            eventService.registeredEventHandler = jasmine.createSpyObj("registeredEventHandler", ["onEndTransition", "onStartTransition"]);
            eventService.registeredEventHandler.onStartTransition.and.returnValue(returnResolved());
            //act
            return eventService.onStateChange({ from: function () { return state; }, to: function () { return { name: "to" }; }, router: {
                    stateService: {
                        target: function () { }
                    }
                }
            })
                .then(function () {
                expect(modalService.showExternalTask).toHaveBeenCalled();
            })
                .catch(function (e) { fail(e); });
            //            eventService.onStateChange(evt, { name: state, resolve: resolve }, {}, {}, {});
            //
            //            resolve
            //                .storefrontTransitionDelay()
            //                .then(function () {
            //                    expect(modalService.showExternalTask).toHaveBeenCalled();
            //                })
            //                .catch(function (e) { fail(e); });
        });
        it('does nothing when service requests an external task and modal is already open', function () {
            //arrange
            var state = { name: "from" };
            modalService.isExternalTaskModalOpen.and.returnValue(true);
            var evt = jasmine.createSpyObj("angular event", ["preventDefault"]);
            evt.preventDefault.and.callFake(function () {
                evt.defaultPrevented = true;
            });
            storefrontService.checkState.and.returnValue(returnResolved(true));
            eventService.registeredEventHandler = jasmine.createSpyObj("registeredEventHandler", ["onEndTransition", "onStartTransition"]);
            eventService.registeredEventHandler.onStartTransition.and.returnValue(returnResolved());
            //act
            return eventService.onStateChange({ from: function () { return state; }, to: function () { return { name: "to" }; } })
                .then(function () {
                expect(modalService.showExternalTask).not.toHaveBeenCalled();
                expect($state.go).not.toHaveBeenCalled();
            })
                .catch(function (e) { fail(e); });
        });
        describe('handleCheckStateError', function () {
            it('handles redirect that is not already queued', function () {
                var error = {
                    hasWorkItemRedirect: true,
                    workItemRedirect: 14 //missing info
                };
                storefrontService.isQueued.and.returnValue(false);
                storefrontService.skip.and.returnValue(returnResolved(''));
                return eventService
                    .handleCheckStateError(error)
                    .then(function () {
                    expect(storefrontService.insertWorkItem).toHaveBeenCalledWith(error.workItemRedirect);
                })
                    .catch(function () { fail('should not have been rejected.'); });
            });
            it('handles redirect that is already queued', function () {
                var error = {
                    hasWorkItemRedirect: true,
                    workItemRedirect: 14 //missing info
                };
                var workItem = {
                    isCompleted: true
                };
                storefrontService.isQueued.and.returnValue(true);
                storefrontService.skip.and.returnValue(returnResolved(''));
                storefrontService.getWorkItemById.and.returnValue(workItem);
                return eventService
                    .handleCheckStateError(error)
                    .then(function () {
                    expect(storefrontService.insertWorkItem).not.toHaveBeenCalledWith(error.workItemRedirect);
                    expect(workItem.isCompleted).toBeFalsy();
                })
                    .catch(function () { fail('should not have been rejected.'); });
            });
        });
        describe("cms modal functions", function () {
            beforeEach(function () {
                eventService.registeredEventHandler = jasmine.createSpyObj("registeredEventHandler", ["onEndTransition"]);
            });
            it('opens cms modal if state is from cms', function () {
                //arrange
                var toState = {};
                var fromState = { name: "from" };
                var transition = { from: function () { return fromState; }, to: function () { return toState; } };
                storefrontService.fullSiteMode = false;
                storefrontService.isCmsContent.and.returnValue(true);
                //act
                eventService.onStateChangeSuccess(transition);
                expect(modalService.showCmsContent).toHaveBeenCalledWith(toState, fromState.name);
            });
            it('does not open cms modal if state is not from cms', function () {
                //arrange
                var toState = {};
                var fromState = { name: "from" };
                var transition = { from: function () { return fromState; }, to: function () { return toState; } };
                storefrontService.fullSiteMode = false;
                storefrontService.isCmsContent.and.returnValue(false);
                //act
                eventService.onStateChangeSuccess(transition);
                expect(modalService.showCmsContent).not.toHaveBeenCalled();
            });
            it('does not open cms modal if state is from cms and is in full site mode', function () {
                //arrange
                var toState = {};
                var fromState = { name: "from" };
                var transition = { from: function () { return fromState; }, to: function () { return toState; } };
                storefrontService.fullSiteMode = true;
                storefrontService.isCmsContent.and.returnValue(true);
                //act
                eventService.onStateChangeSuccess(transition);
                expect(modalService.showCmsContent).not.toHaveBeenCalled();
            });
        });
        describe("link stripper", function () {
            var element = angular.element("<div />");
            beforeEach(function () {
                eventService.startListening();
                eventService.addMutationObserver(element[0]);
            });
            it("removes appropriate links - not fullsite mode", function () {
                storefrontService.fullSiteMode = false;
                var regularLink = angular.element("<a class='should-be-removed' href='/test'><span class='should-remain'>regularLink</span></a>");
                var hashLink = angular.element("<a class='should-remain' target='_parent' href='#test'>hashLink</a>");
                var ngClickLink = angular.element("<a class='should-remain' ng-click='someMethod()'>ngClickLink</a>");
                var pdfLink = angular.element("<a class='should-remain' href='/api/sessions/pdf/mypdf.pdf'>pdfLink</a>");
                var regularLinkInEchAftDisclaimer = angular
                    .element("<eft-ach-disclaimer class='should-remain'><a class='should-remain' href='/test'><span class='should-remain'>regularLink</span></a></eft-ach-disclaimer>");
                var regularLinkInEchAftDisclaimer2 = angular
                    .element("<eft-ach-disclaimer class='should-remain'><main><a class='should-remain' href='/test'><span class='should-remain'>regularLink</span></a></main></eft-ach-disclaimer>");
                element.append(regularLink);
                element.append(hashLink);
                element.append(ngClickLink);
                element.append(pdfLink);
                element.append(regularLinkInEchAftDisclaimer);
                element.append(regularLinkInEchAftDisclaimer2);
                expect(element.children().filter(".should-be-removed").length).toBe(1);
                expect(element.children().filter("[href='/test']").length).toBe(1);
                expect(element.children().filter("eft-ach-disclaimer").children().filter("[href='/test']").length).toBe(1);
                expect(element.children().filter("eft-ach-disclaimer").children().filter("main").children().filter("[href='/test']").length).toBe(1);
                expect(element.children().filter(".should-remain").length).toBe(5);
                expect(element.children().filter("eft-ach-disclaimer").children().filter(".should-remain").length).toBe(1);
                expect(element.children().filter("eft-ach-disclaimer").children().filter("main").children().filter(".should-remain").length).toBe(1);
                expect(element.children().filter("a").children().filter(".should-remain:contains('regularLink')").length).toBe(1);
                expect(element.children().filter("[target]").length).toBe(1);
                expect(element.children().filter(".should-remain:contains('hashLink')").length).toBe(1);
                expect(element.children().filter(".should-remain:contains('ngClickLink')").length).toBe(1);
                expect(element.children().filter(".should-remain:contains('pdfLink')").length).toBe(1);
            });
            it("removes appropriate links - fullsite mode", function () {
                storefrontService.fullSiteMode = true;
                var regularLink = angular.element("<a class='should-remain' href='/test'><span class='should-remain'>regularLink</span></a>");
                var hashLink = angular.element("<a class='should-remain' target='_parent' href='#test'>hashLink</a>");
                var ngClickLink = angular.element("<a class='should-remain' ng-click='someMethod()'>ngClickLink</a>");
                var pdfLink = angular.element("<a class='should-remain' href='/api/sessions/pdf/mypdf.pdf'>pdfLink</a>");
                var regularLinkInEchAftDisclaimer = angular
                    .element("<eft-ach-disclaimer><a class='should-remain' href='/test'><span class='should-remain'>regularLink</span></a></eft-ach-disclaimer>");
                var regularLinkInEchAftDisclaimer2 = angular
                    .element("<eft-ach-disclaimer><main><a class='should-remain' href='/test'><span class='should-remain'>regularLink</span></a></main></eft-ach-disclaimer>");
                element.append(regularLink);
                element.append(hashLink);
                element.append(ngClickLink);
                element.append(pdfLink);
                element.append(regularLinkInEchAftDisclaimer);
                element.append(regularLinkInEchAftDisclaimer2);
                expect(element.children().filter("[href='/test']").length).toBe(1);
                expect(element.children().filter("eft-ach-disclaimer").children().filter("[href='/test']").length).toBe(1);
                expect(element.children().filter("eft-ach-disclaimer").children().filter("main").children().filter("[href='/test']").length).toBe(1);
                expect(element.children().filter(".should-remain").length).toBe(4);
                expect(element.children().filter("eft-ach-disclaimer").children().filter(".should-remain").length).toBe(1);
                expect(element.children().filter("eft-ach-disclaimer").children().filter("main").children().filter(".should-remain").length).toBe(1);
                expect(element.children().filter("a").children().filter(".should-remain:contains('regularLink')").length).toBe(1);
                expect(element.children().filter("[target]").length).toBe(1);
                expect(element.children().filter(".should-remain:contains('hashLink')").length).toBe(1);
                expect(element.children().filter(".should-remain:contains('ngClickLink')").length).toBe(1);
                expect(element.children().filter(".should-remain:contains('pdfLink')").length).toBe(1);
            });
            afterEach(function () {
                eventService.stopListening();
                element.empty();
            });
        });
    });
}());
(function () {
    'use strict';
    describe('StorefrontModalService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        var storefrontService;
        var $state;
        var modalService;
        var stateNames;
        var $q;
        var $timeout;
        var materialDialogService;
        var cavveStates;
        var addMissingInformationService;
        var errorDisplayService;
        function returnResolved(obj) {
            return $q.resolve(obj);
        }
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            try {
                storefrontService = jasmine.createSpyObj("storefrontService", [
                    "getCmsItemById",
                    "isActiveSession",
                    "reset",
                    "startNewSession",
                    "hasIncompleteWorkItems",
                    "getWorkItemInitState",
                    "lockStateChanging",
                    "removeWorkItem"
                ]);
                materialDialogService = jasmine.createSpyObj('storefrontMaterialDialogWrapper', ['closeAll']);
                addMissingInformationService = jasmine.createSpyObj('addMissingInformationService', ['destroyMissingInformationFlags']);
                storefrontService.fullSiteMode = false;
                storefrontService.lockStateChanging.and.callFake(function (f) { return f(); });
                $state = jasmine.createSpyObj("$state", ["go"]);
                modalService = jasmine.createSpyObj("modalService", ["showModal", "onOpening", "resetSettings", "clearListeners", 'closeAll']);
                $timeout = jasmine.createSpy("$timeout", function () { });
                errorDisplayService = jasmine.createSpyObj('errorDisplayService', ['clearToasts']);
                $provide.factory("$q", ["replacementQService", function (replacementQService) {
                        return replacementQService;
                    }]);
                $provide.value("$timeout", $timeout);
                $provide.value("modalService", modalService);
                $provide.value("$state", $state);
                $provide.value("StorefrontService", storefrontService);
                $provide.value('storefrontMaterialDialogWrapper', materialDialogService);
                $provide.value('addMissingInformationService', addMissingInformationService);
                $provide.value('errorDisplayService', errorDisplayService);
            }
            catch (e) {
                fail(e);
            }
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            try {
                stateNames = $injector.get('stateNames');
                cavveStates = $injector.get('cavveStates');
                $q = $injector.get('$q');
                service = $injector.get("StorefrontModalService");
            }
            catch (e) {
                fail(e);
            }
        }));
        it('can instanciate a new service', function () {
            expect(service).toBeDefined();
        });
        it('closes all angular material dialogs', function () {
            service.closeAll();
            expect(materialDialogService.closeAll).toHaveBeenCalled();
        });
        it('can call survey from after exiting full site mode', function () {
            //arrange
            storefrontService.getCmsItemById.and.returnValue(returnResolved({
                Title: "title",
                Message: "Message",
                buttons: {
                    "EXIT": "exit",
                    "STAY": "stay"
                }
            }));
            storefrontService.fullSiteMode = true;
            storefrontService.isActiveSession.and.returnValue(true);
            modalService.showModal.and.returnValue(returnResolved("exit"));
            $state.go.and.returnValue(returnResolved());
            //act
            service.exit()
                .then(function () {
                //assert
                expect(storefrontService.fullSiteMode).toBe(false);
                expect($state.go).toHaveBeenCalledWith(stateNames.storefrontSurvey);
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('does not call survey if not in fullsite mode and session has not started yet', function () {
            //arrange
            storefrontService.getCmsItemById.and.returnValue(returnResolved({
                Title: "title",
                Message: "Message",
                buttons: {
                    "EXIT": "exit",
                    "STAY": "stay"
                }
            }));
            storefrontService.fullSiteMode = false;
            storefrontService.isActiveSession.and.returnValue(false);
            modalService.showModal.and.returnValue(returnResolved("exit"));
            //act
            service.exit()
                .then(function () {
                //assert
                expect(storefrontService.startNewSession).not.toHaveBeenCalled();
                expect(storefrontService.reset).toHaveBeenCalled();
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('opens custom modal when user opens a new account', function () {
            //arrage
            var workItem = {
                completionModal: 1
            };
            var postSignupSpy = spyOn(service, "postSignup").and.returnValue(returnResolved());
            storefrontService.getCmsItemById.and.returnValue(returnResolved({
                buttons: {
                    "NEXT": "next"
                }
            }));
            modalService.showModal.and.returnValue(returnResolved("finish"));
            var createModalSpy = spyOn(service, "create").and.callThrough();
            //act
            service
                .showCompletionMessage(workItem)
                .then(function () {
                //assert
                expect(createModalSpy).not.toHaveBeenCalledWith("WorkitemComplete");
                expect(postSignupSpy).toHaveBeenCalled();
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('restricted modal gets registered on setGlobalModalSettings', function () {
            //Act
            service.setGlobalModalSettings();
            //Assert
            expect(modalService.onOpening).toHaveBeenCalledTimes(2);
            expect(modalService.onOpening.calls.argsFor(1)[0]).toBe(service.blockModalsInRestrictedState);
        });
        it('restricted modal gets registered on restoreGlobalModalSettings', function () {
            //Act
            service.restoreGlobalModalSettings();
            //Assert
            expect(modalService.onOpening).toHaveBeenCalledTimes(1);
            expect(modalService.onOpening.calls.argsFor(0)[0]).toBe(service.blockModalsInRestrictedState);
        });
        it('preventDefault is called when in restrictedState and name is not in storefrontModalServiceModalNames', function () {
            //Arrange
            storefrontService.stateChangingRestricted = true;
            service.storefrontModalServiceModalNames = {};
            var mockEvent = { preventDefault: function () { return true; } };
            spyOn(mockEvent, 'preventDefault');
            //Act
            service.blockModalsInRestrictedState(mockEvent, "testName");
            //Assert
            expect(mockEvent.preventDefault).toHaveBeenCalledTimes(1);
        });
        it('preventDefault is not called when not in restrictedState', function () {
            //Arrange
            storefrontService.stateChangingRestricted = false;
            service.storefrontModalServiceModalNames = {};
            var mockEvent = { preventDefault: function () { return true; } };
            spyOn(mockEvent, 'preventDefault');
            //Act
            service.blockModalsInRestrictedState(mockEvent, "testName");
            //Assert
            expect(mockEvent.preventDefault).toHaveBeenCalledTimes(0);
        });
        it('preventDefault is not called when name is in storefrontModalServiceModalNames', function () {
            //Arrange
            storefrontService.stateChangingRestricted = true;
            service.storefrontModalServiceModalNames = { testName: "testName" };
            var mockEvent = { preventDefault: function () { return true; } };
            spyOn(mockEvent, 'preventDefault');
            //Act
            service.blockModalsInRestrictedState(mockEvent, "testName");
            //Assert
            expect(mockEvent.preventDefault).toHaveBeenCalledTimes(0);
        });
        it('opens postCAVVESignup if in CAVVE flow and removes Create Account work Item', function () {
            //arrage
            var workItem = {
                completionModal: 0
            };
            storefrontService.removeWorkItem.and.returnValue({});
            $state.current = {
                name: cavveStates.Receipt
            };
            storefrontService.getWorkItemInitState.and.returnValue("random state");
            var postCAVVESignup = spyOn(service, "postCAVVESignup").and.returnValue(returnResolved());
            var postSignup = spyOn(service, "postSignup").and.returnValue(returnResolved());
            storefrontService.getCmsItemById.and.returnValue(returnResolved({
                buttons: {
                    "NEXT": "next"
                }
            }));
            modalService.showModal.and.returnValue(returnResolved("finish"));
            var createModalSpy = spyOn(service, "create").and.callThrough();
            //act
            return service
                .showCompletionMessage(workItem)
                .then(function () {
                //assert
                expect(createModalSpy).not.toHaveBeenCalledWith("WorkitemComplete");
                expect(postCAVVESignup).toHaveBeenCalled();
                expect(postSignup).not.toHaveBeenCalled();
                expect(storefrontService.removeWorkItem).toHaveBeenCalledTimes(1);
                expect(storefrontService.removeWorkItem).toHaveBeenCalledWith(3);
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('opens postSignup if in CAVVE flow and does not remove Create Account work item', function () {
            //arrage
            var workItem = {
                completionModal: 0
            };
            storefrontService.removeWorkItem.and.returnValue(null);
            $state.current = {
                name: cavveStates.Receipt
            };
            storefrontService.getWorkItemInitState.and.returnValue("random state");
            var postCAVVESignup = spyOn(service, "postCAVVESignup").and.returnValue(returnResolved());
            var postSignup = spyOn(service, "postSignup").and.returnValue(returnResolved());
            storefrontService.getCmsItemById.and.returnValue(returnResolved({
                buttons: {
                    "NEXT": "next"
                }
            }));
            modalService.showModal.and.returnValue(returnResolved("finish"));
            var createModalSpy = spyOn(service, "create").and.callThrough();
            //act
            return service
                .showCompletionMessage(workItem)
                .then(function () {
                //assert
                expect(createModalSpy).not.toHaveBeenCalledWith("WorkitemComplete");
                expect(postCAVVESignup).not.toHaveBeenCalled();
                expect(postSignup).toHaveBeenCalled();
                expect(storefrontService.removeWorkItem).toHaveBeenCalledTimes(1);
                expect(storefrontService.removeWorkItem).toHaveBeenCalledWith(3);
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('destroys add missing information data on force go to survey', function () {
            $state.go.and.returnValue(returnResolved());
            return service.forceGoToSurvey()
                .then(function () {
                expect(addMissingInformationService.destroyMissingInformationFlags).toHaveBeenCalled();
            })
                .catch(function (e) {
                fail(e);
            });
        });
    });
}());
(function () {
    'use strict';
    describe('StorefrontService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service, storefrontEventHandlers, suspendedAccountService, storefrontUtilityService, routes, rootScope, cmsUtilService, stringUtilsService;
        var $q;
        var $window;
        var addmissingInfoService;
        var authService = {
            isAuthenticated: function () { },
            logout: function () { }
        };
        var genericRepo = {
            dataFactory: null
        };
        var webStorage;
        var storeLocation = "TNO";
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            $provide.factory("$q", ["$window", function ($window) {
                    var p = $window["Promise"];
                    p.when = function (v) {
                        if (v['then']) {
                            return v;
                        }
                        else {
                            return p.resolve(v);
                        }
                    };
                    return p;
                }]);
            $provide.factory("$timeout", ["$window", function ($window) {
                    return function () {
                        return $window["Promise"].resolve();
                    };
                }]);
            $provide.value('StorefrontCmsRequests', {
                'hctraLogo': {
                    Path: '/sitecore/media library/Images/HCTRA/Header Footer/HCTRA_Logo',
                    Fields: 'ItemID,Alt,Width,Height'
                },
                'states': {
                    ItemId: "449337DB-4759-48A7-8982-DC56F92C1F27",
                    Fields: 'ItemId,Name,Children'
                },
                'dbIds': {
                    ItemId: "449337DB-4759-48A7-8982-DC56F92C1F27",
                    Fields: ''
                },
                'tasks': {
                    ItemId: "449337DB-4759-48A7-8982-DC56F92C1F27",
                    Fields: ''
                }
            });
            suspendedAccountService = jasmine.createSpyObj("suspendedAccountService", ["isEmpty", "getSuspendedAccountTypeInformation"]);
            suspendedAccountService.getSuspendedAccountTypeInformation.and.callFake(function () {
                return $q.resolve({});
            });
            addmissingInfoService = jasmine.createSpyObj('addMissingInformationService', ['isMissingInfo', 'destroyMissingInformationFlags']);
            $provide.value("AuthService", authService);
            $provide.value("genericRepo", genericRepo);
            webStorage = jasmine.createSpyObj("fakeWebStorage", ["setKeyValue", "getValue", "removeEntry"]);
            $provide.value("webStorage", webStorage);
            storefrontUtilityService = {
                isRunningAsKiosk: true,
                storefrontLocation: 1,
                isSecureCardInputAvailable: true,
                machineName: "TestKiosk",
                webStoreData: null,
                lockStateChanging: function (action) { return action(); },
                stateChangingRestricted: false
            };
            $provide.value("StorefrontUtilityService", storefrontUtilityService);
            $provide.value("suspendedAccountService", suspendedAccountService);
            cmsUtilService = jasmine.createSpyObj('cmsUtilService', ['parseAllImageAttributes']);
            $provide.value('cmsUtilService', cmsUtilService);
            $provide.constant("environmentConfig", { billingInformation: { UseUpdatedPage: true }, isMergeMATandVioOn: false });
            $provide.value('addMissingInformationService', addmissingInfoService);
            stringUtilsService = jasmine.createSpyObj('stringUtilsService', ['getParameterObject']);
            $provide.value('stringUtilsService', stringUtilsService);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            $q = $injector.get("$q");
            routes = $injector.get("routes");
            rootScope = $injector.get("$rootScope");
            $window = $injector.get('$window');
            angular.extend(rootScope, {
                currentUser: {
                    acctActivity: "A",
                    newAccountStep: {
                        accountComplete: true
                    }
                }
            });
            var fakeDataFactory = jasmine.createSpyObj("fakeDataFactory", ["StartStorefrontDBSession", "EndStorefrontDBSession", "getCmsPageById"]);
            genericRepo.dataFactory = fakeDataFactory;
            fakeDataFactory.StartStorefrontDBSession.and.returnValue($q.resolve({
                dbResponse: 12,
                errors: []
            }));
            fakeDataFactory.EndStorefrontDBSession.and.returnValue($q.resolve({
                dbResponse: 12,
                errors: []
            }));
            fakeDataFactory.getCmsPageById.and.callFake(function (request) {
                var cmsItems = angular.toJson({
                    "Children": [
                        {
                            "storefrontDisplayName": "1",
                            "dbId": "MTOLL",
                            "uiOrder": 1,
                            "isSkippable": 1,
                            "requiresAuthentication": 0
                        },
                        {
                            "storefrontDisplayName": "2",
                            "dbId": "GINV",
                            "uiOrder": 2,
                            "isSkippable": 1,
                            "requiresAuthentication": 0
                        },
                        {
                            "storefrontDisplayName": "3",
                            "dbId": "OACC",
                            "uiOrder": 3,
                            "isSkippable": 1,
                            "requiresAuthentication": 0
                        },
                        {
                            "storefrontDisplayName": "4",
                            "dbId": "UBI",
                            "uiOrder": 4,
                            "isSkippable": 1,
                            "requiresAuthentication": 0
                        }
                    ]
                });
                switch (request.ItemId) {
                    case routes.storefrontWorkItemSelectionParentId:
                        return $q.resolve({
                            errors: [],
                            cmsResponse: cmsItems,
                            webVersion: "2.11.0.6619.19326",
                            alerts: null
                        });
                    case routes.storefrontDBIdsId:
                        return $q.resolve({
                            errors: [],
                            cmsResponse: "{ \"Children\": []}",
                            webVersion: "2.11.0.6619.19326",
                            alerts: null
                        });
                    default:
                        return $q.resolve({
                            errors: [],
                            cmsResponse: "{}",
                            webVersion: "2.11.0.6619.19326",
                            alerts: null
                        });
                }
            });
            storefrontEventHandlers = jasmine.createSpyObj("fakeEventHandler", ["onIncompleteWorkItem", "onCompletedWorkItem", "onStartTransition", "onEndTransition", "onResetting", "onResetComplete"]);
            storefrontEventHandlers.onCompletedWorkItem.and.returnValue($q.resolve());
            storefrontEventHandlers.onResetting.and.returnValue($q.resolve());
            service = $injector.get('StorefrontService');
            service.sessionId = 11;
            service.registerEventHandlers(storefrontEventHandlers);
            rootScope.$apply();
        }));
        function getWorkItem(id) {
            for (var index = 0; index < service.workItems.length; index++) {
                if (service.workItems[index].id === id) {
                    return service.workItems[index];
                }
            }
            return null;
        }
        afterEach(function () {
            rootScope.$apply();
        });
        describe('isQueued', function () {
            it('says workitem is queued', function () {
                return service.serviceInitialized.then(function () {
                    var w1 = getWorkItem(1);
                    w1.isSelected = true;
                    var isQueued = service.isQueued(w1.id);
                    expect(isQueued).toBeTruthy();
                });
            });
            it('says workitem is not queued', function () {
                return service.serviceInitialized.then(function () {
                    var w1 = getWorkItem(1);
                    w1.isSelected = false;
                    var isQueued = service.isQueued(w1.id);
                    expect(isQueued).toBeFalsy();
                });
            });
        });
        it('should reset internal state when reset is called', function () {
            spyOn(authService, "isAuthenticated").and.returnValue(false);
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w2 = getWorkItem(2);
                w1.isSelected = true;
                w2.isSelected = true;
                return service.next()
                    .then(function () {
                    expect(service.isWorkflowActive()).toBeTruthy();
                    return service.next();
                })
                    .then(function () {
                    expect(w1.isCompleted).toBeTruthy();
                    return service.reset();
                })
                    .then(function () {
                    expect(w1.isSelected).toBeFalsy();
                    expect(w1.isUnavailable).toBeFalsy();
                    expect(w1.isCompleted).toBeFalsy();
                    expect(service.isWorkflowActive()).toBeFalsy();
                    expect(webStorage.setKeyValue).toHaveBeenCalled();
                    expect(addmissingInfoService.destroyMissingInformationFlags).toHaveBeenCalled();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('mark work item as completed when completed', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                expect(service.isEnabled()).toBeTruthy();
                return service.next()
                    .then(function () {
                    expect(w1.isCompleted).toBeFalsy();
                    return service.next();
                })
                    .then(function () {
                    expect(w1.isCompleted).toBeTruthy();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should skip completed items on next()', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w2 = getWorkItem(2);
                w1.isSelected = true;
                w1.isCompleted = true;
                w2.isSelected = true;
                return service.next()
                    .then(function () {
                    expect(service.currentWorkItem().id).toBe(w2.id);
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should respond with incomplete workitem event if remaining workitems', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w2 = getWorkItem(2);
                w1.isSelected = true;
                w2.isSelected = true;
                storefrontEventHandlers.onIncompleteWorkItem.and.returnValue($q.resolve(null));
                storefrontEventHandlers.onCompletedWorkItem.and.returnValue($q.resolve(null));
                return service.next()
                    .then(function (item) {
                    expect(item.id).toBe(w1.id);
                    return service.next();
                })
                    .then(function (item) {
                    expect(item.id).toBe(w2.id);
                    w1.isCompleted = false;
                    return service.next();
                })
                    .then(function () {
                    expect(storefrontEventHandlers.onIncompleteWorkItem).toHaveBeenCalled();
                })
                    .catch(function (e) {
                    fail(e);
                });
            });
        });
        it('responds to an incompleted work item', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w2 = getWorkItem(2);
                w1.isSelected = true;
                w2.isSelected = true;
                (storefrontEventHandlers.onIncompleteWorkItem.and.returnValue($q.resolve()));
                return service.next()
                    .then(function (item) {
                    expect(item.id).toBe(w1.id);
                    return service.next();
                })
                    .then(function (item) {
                    expect(item.id).toBe(w2.id);
                    w1.isCompleted = false;
                    return service.next();
                })
                    .then(function () {
                    expect(storefrontEventHandlers.onIncompleteWorkItem).toHaveBeenCalled();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        describe('skip', function () {
            it('can skip skippable workitems', function () {
                return service.serviceInitialized.then(function () {
                    var w1 = getWorkItem(1);
                    var w2 = getWorkItem(2);
                    w1.isSelected = true;
                    w1.isSkippable = true;
                    w2.isSelected = true;
                    return service.next()
                        .then(function (item) {
                        expect(item.id).toBe(w1.id);
                        expect(item.isCompleted).toBeFalsy();
                        return service.skip();
                    })
                        .then(function (stateName) {
                        expect(stateName).toBe(w2.states[0]);
                        expect(w1.isCompleted).toBeFalsy();
                    })
                        .catch(function (e) { fail(e); });
                });
            });
            it('responds with incomplete workitem event when skipping past last workitem', function () {
                return service.serviceInitialized.then(function () {
                    var w1 = getWorkItem(1);
                    w1.isSelected = true;
                    w1.isSkippable = true;
                    storefrontEventHandlers.onIncompleteWorkItem.and.returnValue($q.resolve(null));
                    return service.next()
                        .then(function (item) {
                        expect(item.id).toBe(w1.id);
                        expect(item.isCompleted).toBeFalsy();
                        return service.skip();
                    })
                        .catch(function (evt) {
                        fail("show not have failed (1): " + evt);
                    })
                        .then(function () {
                        expect(storefrontEventHandlers.onIncompleteWorkItem).toHaveBeenCalled();
                    })
                        .catch(function (evt) {
                        fail("show not have failed (2): " + evt);
                    });
                });
            });
            it('cannot skip non skippable workitems', function () {
                return service.serviceInitialized.then(function () {
                    var w1 = getWorkItem(1);
                    var w2 = getWorkItem(2);
                    w1.isSelected = true;
                    w1.isSkippable = false;
                    w2.isSelected = true;
                    return service.next()
                        .then(function (item) {
                        expect(item.id).toBe(w1.id);
                        expect(item.isCompleted).toBeFalsy();
                        return service.skip();
                    })
                        .then(function () { fail("Should have rejected a non skippable work item."); })
                        .catch(function (item) {
                        expect(item.id).toBe(w1.id);
                        expect(w1.isCompleted).toBeFalsy();
                        expect(w2.isCompleted).toBeFalsy();
                    });
                });
            });
            it('cannot skip to the current workitem', function () {
                return service.serviceInitialized.then(function () {
                    var w1 = getWorkItem(1);
                    var w2 = getWorkItem(2);
                    w1.isSelected = true;
                    w1.isSkippable = true;
                    w2.isSelected = true;
                    return service.next()
                        .then(function (item) {
                        expect(item.id).toBe(w1.id);
                        expect(service.currentWorkItem()).toBe(item);
                        //skip back to w1
                        return service.skip(item.id);
                    })
                        .then(function () { fail("Should have rejected skipping to current item"); })
                        .catch(function (item) {
                        expect(item.id).toBe(w1.id);
                        expect(w1.isCompleted).toBeFalsy();
                        expect(w2.isCompleted).toBeFalsy();
                    });
                });
            });
        });
        it('should logout user when reset', function () {
            spyOn(authService, "isAuthenticated").and.returnValue(true);
            spyOn(authService, "logout").and.returnValue($q.resolve());
            return service.serviceInitialized.then(function () {
                return service.reset()
                    .then(function () {
                    expect(storefrontEventHandlers.onResetting).toHaveBeenCalled();
                    expect(service.isWorkflowActive()).toBeFalsy();
                    expect(authService.logout).toHaveBeenCalled();
                    expect(storefrontEventHandlers.onResetComplete).toHaveBeenCalled();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should clear named caches', function () {
            return $window.caches
                .open('test') //open and creates a cache
                .then(function () { return service.clearNamedCaches(); }) //should delete this cache now
                .then(function () { return $window.caches.has('test'); }) //check if cache is there
                .then(function (isCachePreset) { expect(isCachePreset).toBeFalsy(); }); //assert
        });
        it('should not return a work item when starting if no items are selected', function () {
            return service.serviceInitialized.then(function () {
                return service.next()
                    .then(function (item) {
                    expect(item).toBeNull();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should return the only selected item when starting', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                return service.next()
                    .then(function (firstItem) {
                    expect(firstItem).toBeDefined();
                    expect(firstItem).toBe(w1);
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should return null when there are no more selected work items left', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                storefrontEventHandlers.onCompletedWorkItem.and.returnValue($q.resolve(null));
                return service.next()
                    .then(function (item) {
                    expect(item).not.toBeNull();
                    return service.next();
                })
                    .then(function (nextItem) {
                    expect(nextItem).toBeNull();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should call next() when the work item is no longer selected', function () {
            var nextSpy = spyOn(service, "next").and.callThrough();
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                storefrontEventHandlers.onCompletedWorkItem.and.callFake(function (previousItem, item) {
                    item.isSelected = false;
                    return $q.resolve(null);
                });
                return service.next()
                    .then(function () {
                    expect(nextSpy).toHaveBeenCalledTimes(2);
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should not alter state transitions if TO state is within current state', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                return service.startWorkItems()
                    .then(function () {
                    return service.checkState({ name: w1.states[1] });
                })
                    .then(function (result) {
                    expect(service.isWorkflowActive()).toBeTruthy();
                    expect(result.isExternal).toBeFalsy();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should alter state transition to next work item', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w2 = getWorkItem(2);
                w1.isSelected = true;
                w2.isSelected = true;
                storefrontEventHandlers.onCompletedWorkItem.and.returnValue($q.resolve(null));
                return service.startWorkItems()
                    .then(function () {
                    return service.next(true);
                })
                    .then(function (item) {
                    expect(item).toBeDefined();
                    expect(item.id).toBe(w2.id);
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should not alter state transition if state is external work item, but flag it as external', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                return service.startWorkItems()
                    .then(function () {
                    return service.checkState({ name: "externalStateName" });
                })
                    .then(function (externalState) {
                    expect(service.isWorkflowActive()).toBeTruthy();
                    expect(externalState).toBeTruthy();
                })
                    .catch(function (e) {
                    fail(e);
                });
            });
        });
        it('should not alter state transition if state is external work item, but flag it as external and current state requires authentication and is authenticated', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                w1.requiresAuthentication = true;
                spyOn(authService, "isAuthenticated").and.returnValue(true);
                return service.startWorkItems()
                    .then(function () {
                    return service.checkState("externalStateName");
                })
                    .then(function (externalState) {
                    expect(service.isWorkflowActive()).toBeTruthy();
                    expect(externalState).toBeTruthy();
                })
                    .catch(function (e) {
                    fail(e);
                });
            });
        });
        it('should redirect to login if workitem requires authentication', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                spyOn(authService, "isAuthenticated").and.returnValue(false);
                w1.isSelected = true;
                w1.requiresAuthentication = true;
                return service.startWorkItems()
                    .then(function (startStateName) {
                    return service.checkState({ name: startStateName });
                })
                    .catch(function (error) {
                    expect(error).toEqual({
                        hasWorkItemRedirect: true,
                        restrictedAbort: false,
                        workItemRedirect: HCTRA.Model.SelectedOptions.LOGIN
                    });
                });
            });
        });
        it('should redirect to login if next workitem requires authentication', function () {
            spyOn(authService, "isAuthenticated").and.returnValue(false);
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w2 = getWorkItem(2);
                w1.isSelected = true;
                w1.requiresAuthentication = false;
                w2.isSelected = true;
                w2.requiresAuthentication = true;
                return service.startWorkItems()
                    .then(function (state) {
                    return service.checkState({ name: state });
                })
                    .catch(function (e) { fail(e); })
                    .then(function (result) {
                    expect(result.isExternal).toBeFalsy();
                    return service.completeWorkItem();
                })
                    .catch(function (e) { fail(e); })
                    .then(function (state) {
                    return service.checkState({ name: state });
                })
                    .then(function (e) {
                    fail(e);
                })
                    .catch(function (error) {
                    expect(error).toEqual({
                        hasWorkItemRedirect: true,
                        restrictedAbort: false,
                        workItemRedirect: HCTRA.Model.SelectedOptions.LOGIN
                    });
                });
            });
        });
        it('should skip login if workitem requires authentication and user is already logged in', function () {
            spyOn(authService, "isAuthenticated").and.returnValue(true);
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                w1.isSelected = true;
                w1.requiresAuthentication = true;
                return service.startWorkItems()
                    .then(function (startStateName) {
                    return service.checkState({ name: startStateName });
                })
                    .then(function (result) {
                    expect(result.isExternal).toBeFalsy();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should skip login if next workitem requires authentication but user is already in', function () {
            spyOn(authService, "isAuthenticated").and.returnValue(true);
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w2 = getWorkItem(2);
                w1.isSelected = true;
                w1.requiresAuthentication = true;
                w2.isSelected = true;
                w2.requiresAuthentication = true;
                storefrontEventHandlers.onCompletedWorkItem.and.returnValue($q.resolve());
                return service.startWorkItems()
                    .then(function (stateName) {
                    return service.checkState({ name: stateName });
                })
                    .then(function (result) {
                    expect(result.isExternal).toBeFalsy();
                    return service.completeWorkItem();
                })
                    .then(function (stateName) {
                    return service.checkState({ name: stateName });
                })
                    .then(function (result) {
                    expect(result.isExternal).toBeFalsy();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should save to web storage when next is called', function () {
            return service.serviceInitialized.then(function () {
                var w1 = getWorkItem(1);
                var w3 = getWorkItem(3);
                w1.isSelected = true;
                w3.isSelected = true;
                return service.next()
                    .then(function (firstItem) {
                    expect(firstItem).toBeDefined();
                    expect(webStorage.setKeyValue).toHaveBeenCalled();
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('should restore from web storage when service is created', function () {
            expect(service).toBeDefined();
            return service.serviceInitialized.then(function () {
                return service.onInitialized
                    .then(function () {
                    expect(webStorage.getValue).toHaveBeenCalled();
                });
            });
        });
        it('restores from webStorage', function () {
            return service.serviceInitialized.then(function () {
                //arrange 
                var data = {
                    sessionId: 3141,
                    currentItemId: 2,
                    selectedItemIds: [1, 2],
                    completedItemIds: [1],
                    fullSiteMode: false
                };
                webStorage.getValue.and.returnValue(data);
                //act
                service.restoreFromStorage();
                //assert
                expect(service.sessionId).toBe(3141);
                expect(service.currentWorkItem()).toBeDefined();
                expect(service.currentWorkItem().id).toBe(2);
                expect(getWorkItem(1).isSelected).toBeTruthy();
                expect(getWorkItem(2).isSelected).toBeTruthy();
                expect(service.workItems.filter(function (x) { return x.isSelected; }).length).toBe(2);
            });
        });
        it('can start new database session (kiosk mode)', function () {
            return service.serviceInitialized.then(function () {
                //arrange
                var w1 = getWorkItem(1);
                var w3 = getWorkItem(3);
                w1.isSelected = true;
                w3.isSelected = true;
                //act
                return service.startNewSession()
                    .then(function () {
                    //assert
                    expect(genericRepo.dataFactory.StartStorefrontDBSession).toHaveBeenCalled();
                    var args = genericRepo.dataFactory.StartStorefrontDBSession.calls.argsFor(0);
                    expect(args[0]).toBeDefined();
                    expect(args[0].location).toBe(storeLocation);
                    expect(args[0].selectedOptions).toBeDefined();
                    var options = service.workItems.filter(function (i) { return i.isSelected && !i.isShadowItem; })
                        .map(function (i) { return HCTRA.Model.SelectedOptions[i.id]; }).join(',');
                    expect(args[0].selectedOptions).toBe(options);
                });
            });
        });
        it('can start new database session (desktop mode)', function () {
            return service.serviceInitialized.then(function () {
                //arrange
                service['isFullSiteMode'] = true;
                //act
                return service.startNewSession()
                    .then(function () {
                    //assert
                    expect(genericRepo.dataFactory.StartStorefrontDBSession).toHaveBeenCalled();
                    var args = genericRepo.dataFactory.StartStorefrontDBSession.calls.argsFor(0);
                    expect(args[0]).toBeDefined();
                    expect(args[0].location).toBe(storeLocation);
                    expect(args[0].selectedOptions).toBe('WEBST');
                });
            });
        });
        it('can determine if states are cms content or not', function () {
            return service.serviceInitialized.then(function () {
                var cmsState1 = {
                    controller: "GenericNonSectionalCmsController"
                };
                var cmsState2 = {
                    controller: "GenericSectionalCmsController"
                };
                var regularState = {
                    controller: "anythingelse"
                };
                expect(service.isCmsContent(cmsState1)).toBeTruthy();
                expect(service.isCmsContent(cmsState2)).toBeTruthy();
                expect(service.isCmsContent(regularState)).toBeFalsy();
            });
        });
        it('can handle a simulated MAT hand off', function () {
            return service.serviceInitialized.then(function () {
                //arrange
                service.internalWorkItems = [
                    { "DisplayName": "Missed a toll", "completionModal": 0, "dbId": "MTOLL", "uiOrder": 1, "isSkippable": false, "requiresAuthentication": false, "id": 1, "states": ["MissedATollParent.MissedATollLanding", "MissedATollParent.MissedATollBillingInfo", "MissedATollParent.MissedATollViolationInformation", "MissedATollParent.MissedATollConfirmPayment", "MissedATollParent.MissedATollReceipt", "MissedATollParent"], "unavailableWhenSelected": [], "isShadowItem": false }
                ];
                service.addShadowItems(service.internalWorkItems);
                service.internalWorkItems = service.internalWorkItems.sort(function (w1, w2) {
                    return w1.uiOrder - w2.uiOrder;
                });
                var w1 = getWorkItem(1); //MAT
                w1.isSelected = true;
                //act
                return service.startWorkItems()
                    //assert
                    .then(function (initState) {
                    expect(initState).toBe(w1.states[0]);
                    return service.checkState({ name: initState });
                })
                    .then(function (result) {
                    expect(service.isWorkflowActive()).toBeTruthy();
                    expect(result.isExternal).toBeFalsy();
                    return service.completeWorkItem();
                })
                    .then(function (nextState) {
                    expect(nextState).toBeFalsy();
                    expect(storefrontEventHandlers.onCompletedWorkItem).toHaveBeenCalledWith(w1, null);
                })
                    .catch(function (e) { fail(e); });
            });
        });
        it('will unselect work item when calling removeWorkItem and return work item', function () {
            //assemble
            var mockWorkItem = { "DisplayName": "Missed a toll", "completionModal": 0, "dbId": "MTOLL", "uiOrder": 1, "isSkippable": false, "isSelected": true, "requiresAuthentication": false, "id": 1, "states": ["MissedATollParent.MissedATollLanding", "MissedATollParent.MissedATollBillingInfo", "MissedATollParent.MissedATollViolationInformation", "MissedATollParent.MissedATollConfirmPayment", "MissedATollParent.MissedATollReceipt", "MissedATollParent"], "unavailableWhenSelected": [], "isShadowItem": false };
            service.internalWorkItems = [
                mockWorkItem
            ];
            //act
            var result = service.removeWorkItem(1);
            //assert
            expect(result).toBe(mockWorkItem);
            expect(mockWorkItem.isSelected).toBeFalsy();
        });
        it('return undefined if there is no work item to remove', function () {
            //assemble
            var mockWorkItem = { "DisplayName": "Missed a toll", "completionModal": 0, "dbId": "MTOLL", "uiOrder": 1, "isSkippable": false, "isSelected": true, "requiresAuthentication": false, "id": 1, "states": ["MissedATollParent.MissedATollLanding", "MissedATollParent.MissedATollBillingInfo", "MissedATollParent.MissedATollViolationInformation", "MissedATollParent.MissedATollConfirmPayment", "MissedATollParent.MissedATollReceipt", "MissedATollParent"], "unavailableWhenSelected": [], "isShadowItem": false };
            service.internalWorkItems = [
                mockWorkItem
            ];
            //act
            var result = service.removeWorkItem(0);
            //assert
            expect(result).not.toBeDefined();
            expect(mockWorkItem.isSelected).toBeTruthy();
        });
        it('defines all workitem states', function () {
            return service.serviceInitialized
                .then(function () {
                for (var _i = 0, _a = service.workItems.filter(function (x) { return !x.isShadowItem; }); _i < _a.length; _i++) {
                    var item = _a[_i];
                    expect(item.states).toBeDefined();
                    expect(item.states.length > 0).toBeTruthy();
                }
            });
        });
    });
}());
((function () {
    'use strict';
    describe('StorefrontUtilityService', function () {
        beforeEach(angular.mock.module('HCTRAModule'));
        var userAgent1 = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; HCTRA.Storefront TNO) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36";
        var userAgent2 = "Mozilla/5.0 (Windows NT 6.1; Win64; x64;) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36";
        var userAgent3 = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; HCTRA.Storefront TNO UaMachineName) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36";
        var userAgent4 = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; HCTRA.Storefront TNO -kapi) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36";
        var service;
        var $q;
        describe("Storefront User agent - no machine name no flag", function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.constant("environmentConfig", { storefrontConfigs: { DefaultMachineName: "-default" } });
                $provide.value("$window", {
                    navigator: {
                        userAgent: userAgent1
                    },
                    external: {
                        getKioProperty: function (arg) {
                            return arg === "Kiosk" && "MachineNameClassic";
                        }
                    }
                });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('StorefrontUtilityService');
                $q = $injector.get('$q');
            }));
            it('should set to in storefront mode with proper user agent string', function () {
                expect(service.isRunningAsKiosk).toBeTruthy();
                expect(service.storefrontLocation).toBe(1);
                expect(service.machineName).toBe("-default");
            });
        });
        describe("Storefront User agent - no machine name with flag", function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.constant("environmentConfig", { storefrontConfigs: { DefaultMachineName: "-default" } });
                $provide.value("$window", {
                    navigator: {
                        userAgent: userAgent4
                    },
                    external: {
                        getKioProperty: function (arg) {
                            return arg === "Kiosk" && "MachineNameClassic";
                        }
                    }
                });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('StorefrontUtilityService');
            }));
            it('should set to in storefront mode with proper user agent string', function () {
                expect(service.isRunningAsKiosk).toBeTruthy();
                expect(service.storefrontLocation).toBe(1);
                expect(service.machineName).toBe("MachineNameClassic");
            });
        });
        describe("Storefront User agent - no machine name2 no flag", function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.constant("environmentConfig", { storefrontConfigs: { DefaultMachineName: "-default" } });
                $provide.value("$window", {
                    navigator: {
                        userAgent: userAgent1
                    },
                    KioApp: {
                        DoUrlSubstitution: function (arg) {
                            return arg === "$$KIO_COMPUTERNAME$$" && "MachineName";
                        }
                    }
                });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('StorefrontUtilityService');
            }));
            it('should set to in storefront mode with proper user agent string', function () {
                expect(service.isRunningAsKiosk).toBeTruthy();
                expect(service.storefrontLocation).toBe(1);
                expect(service.machineName).toBe("-default");
            });
        });
        describe("Storefront User agent - no machine name2 with flag", function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.constant("environmentConfig", { storefrontConfigs: { DefaultMachineName: "-default" } });
                $provide.value("$window", {
                    navigator: {
                        userAgent: userAgent4
                    },
                    KioApp: {
                        DoUrlSubstitution: function (arg) {
                            return arg === "$$KIO_COMPUTERNAME$$" && "MachineName";
                        }
                    }
                });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('StorefrontUtilityService');
            }));
            it('should set to in storefront mode with proper user agent string', function () {
                expect(service.isRunningAsKiosk).toBeTruthy();
                expect(service.storefrontLocation).toBe(1);
                expect(service.machineName).toBe("MachineName");
            });
        });
        describe("Storefront User agent - with machine name", function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.constant("environmentConfig", { storefrontConfigs: { DefaultMachineName: "-default" } });
                $provide.value("$window", {
                    navigator: {
                        userAgent: userAgent3
                    }
                });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('StorefrontUtilityService');
            }));
            it('should set to in storefront mode with proper user agent string', function () {
                expect(service.isRunningAsKiosk).toBeTruthy();
                expect(service.storefrontLocation).toBe(1);
                expect(service.machineName).toBe("UaMachineName");
            });
        });
        describe("Non-storefront User agent", function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.value("$window", {
                    navigator: {
                        userAgent: userAgent2
                    }
                });
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('StorefrontUtilityService');
            }));
            it('should not be in storefront mode', function () {
                expect(service.isRunningAsKiosk).toBeFalsy();
                expect(service.storefrontLocation).toBeUndefined();
            });
        });
        describe("locking tests", function () {
            beforeEach(angular.mock.module(function ($provide) {
                $provide.factory("$q", [
                    "$window", function ($window) {
                        return $window["Promise"];
                    }
                ]);
            }));
            beforeEach(angular.mock.inject(function ($injector) {
                service = $injector.get('StorefrontUtilityService');
                $q = $injector.get('$q');
            }));
            it('can lock state changing', function () {
                expect(service.stateChangingRestricted).toBeFalsy();
                return service.lockStateChanging(function () {
                    expect(service.stateChangingRestricted).toBeTruthy();
                    return $q.resolve();
                }).finally(function () {
                    expect(service.stateChangingRestricted).toBeFalsy();
                });
            });
        });
    });
})());
/*
(function() {
    "use strict";

    describe("ToggleButtonsService", function () {

        beforeEach(angular.mock.module("HCTRAModule"));

        var service: HCTRA.Service.ToggleButtonsService,
            my$q: ng.IQService,
            my$rootScope: ng.IRootScopeService;

        beforeEach(angular.mock.inject(function ($injector: angular.auto.IInjectorService) {
            service = $injector.get<HCTRA.Service.ToggleButtonsService>("toggleButtonsService");
            service.resetLock();
            spyOn(service, 'disableButtons');
            spyOn(service, 'enableButtons');
        }));

        beforeEach(angular.mock.inject(function (_$rootScope_, _$q_) {
            my$rootScope = _$rootScope_;
            my$q = _$q_;
        }));

        it("should enable buttons globally when not locked", function () {

            service.enableButtonsGlobal();
            expect((<any>service).enableButtons).toHaveBeenCalled();
        });

        it("should disable buttons globally when not locked", function () {

            service.disableButtonsGlobal();
            expect((<any>service).disableButtons).toHaveBeenCalled();
        });

        it("should not enable buttons globally when locked", function (done) {

            // won't resolve until following lines have already executed
            var resolvedPromise = my$q.resolve().then(() => { done() });
            service.disableUntilResolved(resolvedPromise);

            service.enableButtonsGlobal();
            expect((<any>service).enableButtons).not.toHaveBeenCalled();

            my$rootScope.$apply();
        });

        it("should not disable buttons globally when locked", function (done) {

            // won't resolve until following lines have already executed
            var resolvedPromise = my$q.resolve().then(() => { done() });
            service.disableUntilResolved(resolvedPromise); // will call disableButtons once
            expect((<any>service).disableButtons).toHaveBeenCalledTimes(1);

            service.disableButtonsGlobal(); // should not call disableButtons a second time
            expect((<any>service).disableButtons).toHaveBeenCalledTimes(1);

            my$rootScope.$apply();

        });
    });
}());
*/ 
(function () {
    'use strict';
    describe('validationService', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var service;
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        //beforeEach(angular.mock.module(function ($provide) {
        //}));
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get('validationService');
        }));
        it('should allow for 2 different validators to exists at a time.', function () {
            //arrange
            var form1 = {
                field1: { $valid: true },
                field2: { $valid: 'iShouldnotBeHere' }
            };
            var form2 = {
                field2: { $valid: false },
                field1: { $valid: 'iShouldnotBeHere' }
            };
            //act
            var validator1 = service(form1);
            var validator2 = service(form2);
            var isField1Valid = validator1.isValid('field1');
            var isField2Valid = validator2.isValid('field2');
            //assert
            expect(isField1Valid).toEqual(form1.field1.$valid);
            expect(isField2Valid).toEqual(form2.field2.$valid);
        });
    });
}());
(function () {
    'use strict';
    // describe("vantivPaymentService", function () {
    //     var service;
    //     var $http, q, rootScope, dataFactory;
    //     var config = {
    //         applicationId: "app",
    //         applicationName: "appName",
    //         applicationVersion: "v0.0.0",
    //         authorization: "authorization",
    //         acceptorId: "acceptorId",
    //         accountId: "accountId",
    //         accountToken: "TOKEN",
    //         requestId: "3141",
    //         laneId: 9999,
    //         url: "http://www.test.test/",
    //         vaultId: "vaultId"
    //     };
    //     beforeEach(angular.mock.module('HCTRAModule'));
    //     beforeEach(angular.mock.module(function ($provide) {
    //         $http = jasmine.createSpyObj("$http", ["post"]);
    //         dataFactory = jasmine.createSpyObj("dataFactory", ["TriPosLog"]);
    //         $provide.value("$http", $http);
    //         $provide.value("errorDisplayService", {});
    //         $provide.value("genericRepo",
    //             {
    //                 dataFactory: dataFactory
    //             });
    //         $provide.value("responseErrorService", {});
    //         $provide.constant("environmentConfig", {});
    //         $provide.value("siteVerbiage", {});
    //         $provide.value("creditCardTypes", {});
    //         $provide.value('StorefrontUtilityService', { machineName: 'machineName' });
    //     }));
    //     beforeEach(angular.mock.inject(function ($injector, $q, $rootScope) {
    //         q = $q;
    //         service = $injector.get('vantivPaymentService');
    //         rootScope = $rootScope;
    //     }));
    //     it("should get configuration then call vantiv", function () {
    //         //arrange
    //         var response = {};
    //         var postResult = {
    //             data: response,
    //             config: {},
    //             status: 200 
    //         };
    //         var configCopy = angular.extend({}, config);
    //         $http.post.and.returnValue(q.resolve(postResult));
    //         //assert
    //         expect(configCopy.url).toBeDefined();
    //         expect(configCopy.laneId).toBeDefined();
    //         expect(configCopy.vaultId).toBeDefined();
    //         expect(configCopy.applicationId).toBeDefined();
    //         expect(configCopy.applicationName).toBeDefined();
    //         expect(configCopy.applicationVersion).toBeDefined();
    //         expect(configCopy.authorization).toBeDefined();
    //         expect(configCopy.acceptorId).toBeDefined();
    //         expect(configCopy.accountId).toBeDefined();
    //         expect(configCopy.accountToken).toBeDefined();
    //         expect(configCopy.requestId).toBeDefined();
    //         service
    //             .getTokenizedCreditCardData(configCopy, false, "")
    //             .then(function(result) {
    //                 expect($http.post).toHaveBeenCalled();
    //                 var args = $http.post.calls.argsFor(0);
    //                 expect(args[0]).toBe(config.url + "token/omni");
    //                 expect(args[1].laneId).toBe(config.laneId);
    //                 expect(args[1].vaultId).toBe(config.vaultId);
    //                 var headers = args[2].headers;
    //                 expect(headers["tp-application-id"]).toBe(config.applicationId);
    //                 expect(headers["tp-application-name"]).toBe(config.applicationName);
    //                 expect(headers["tp-application-version"]).toBe(config.applicationVersion);
    //                 expect(headers["tp-authorization"]).toBe(config.authorization);
    //                 expect(headers["tp-express-acceptor-id"]).toBe(config.acceptorId);
    //                 expect(headers["tp-express-account-id"]).toBe(config.accountId);
    //                 expect(headers["tp-express-account-token"]).toBe(config.accountToken);
    //                 expect(headers["tp-request-id"]).toBe(config.requestId);
    //                 expect(result).toBe(response);
    //                 expect(result.cancelledByUser).toBeFalsy();
    //                 expect(dataFactory.TriPosLog).toHaveBeenCalled();
    //                 expect(configCopy.url).toBeUndefined();
    //                 expect(configCopy.laneId).toBeUndefined();
    //                 expect(configCopy.vaultId).toBeUndefined();
    //                 expect(configCopy.applicationId).toBeUndefined();
    //                 expect(configCopy.applicationName).toBeUndefined();
    //                 expect(configCopy.applicationVersion).toBeUndefined();
    //                 expect(configCopy.authorization).toBeUndefined();
    //                 expect(configCopy.acceptorId).toBeUndefined();
    //                 expect(configCopy.accountId).toBeUndefined();
    //                 expect(configCopy.accountToken).toBeUndefined();
    //                 expect(configCopy.requestId).toBeDefined();
    //             })
    //             .catch(function() {
    //                 fail('should have not rejected');
    //             });
    //         rootScope.$apply();
    //     });
    //     it("should handle cancelled events from vantiv", function () {
    //         //arrange
    //         var response = {
    //             _hasErrors: true,
    //             _errors: [{ exceptionMessage: "sometext and cancelled response" }]
    //         };
    //         var postResult = {
    //             data: response,
    //             config: {},
    //             status: 200 
    //         };
    //         $http.post.and.returnValue(q.resolve(postResult));
    //         var configCopy = angular.extend({}, config);
    //         //assert
    //         service
    //             .getTokenizedCreditCardData(configCopy, false, "")
    //             .then(function (result) {
    //                 expect(result.cancelledByUser).toBeTruthy();
    //                 expect(dataFactory.TriPosLog).toHaveBeenCalled();
    //             }).catch(function () {
    //                 fail('should not have rejected');
    //             });
    //         rootScope.$apply();
    //     });
    //     it("should reject on an error from vantiv", function () {
    //         //arrange
    //         var response = {
    //             _hasErrors: true,
    //             _errors: [{ exceptionMessage: "any error" }]
    //         };
    //         var postResult = {
    //             data: response,
    //             config: {},
    //             status: 200 
    //         };
    //         var configCopy = angular.extend({}, config);
    //         $http.post.and.returnValue(q.resolve(postResult));
    //         //assert
    //         service
    //             .getTokenizedCreditCardData(configCopy, false, "")
    //             .then(function () {
    //                 fail('should not have resolved');
    //             }).catch(function (val) {
    //                 expect(val).toBeDefined();
    //                 expect(dataFactory.TriPosLog).toHaveBeenCalled();
    //             });
    //         rootScope.$apply();
    //     });
    // });
})();
(function () {
    "use strict";
    describe("ViolationsCalcService", function () {
        beforeEach(angular.mock.module("HCTRAModule"));
        var service, hctra = "harrisData", mctra = "montData", fbctra = "fortData";
        var data = {};
        beforeEach(function () {
            data[hctra] = [];
            data[mctra] = [];
            data[fbctra] = [];
        });
        beforeEach(angular.mock.inject(function ($injector) {
            service = $injector.get("violationsCalcService");
        }));
        it("should correctly calculate for two invoices", function () {
            // first invoice in payment (only relevant info included)
            data[hctra].push({
                payNow: 3,
                invoiceDue: 80,
                pastPayments: 5
            });
            // second invoice in payment (only relevant info included)
            data[mctra].push({
                payNow: 5,
                invoiceDue: 60,
                pastPayments: 1
            });
            var summary = service.calculateAllInvoicesSummary(data, 200, 10);
            expect(summary.amountBeingPaidNow).toBe(8); // amount being paid across all invoices
            expect(summary.originalAmountOwedForAll.invoices).toBe(200);
            expect(summary.originalAmountOwedForAll.selectedInvoices).toBe(140);
            expect(summary.originalAmountOwedForAll.unselectedInvoices).toBe(60);
            expect(summary.amountOwed.beforePaymentForAll.invoices).toBe(190);
            expect(summary.amountOwed.beforePaymentForAll.selectedInvoices).toBe(134);
            expect(summary.amountOwed.beforePaymentForAll.unselectedInvoices).toBe(56);
            expect(summary.amountPreviouslyPaidForAll.invoices).toBe(10);
            expect(summary.amountPreviouslyPaidForAll.selectedInvoices).toBe(6);
            expect(summary.amountPreviouslyPaidForAll.unselectedInvoices).toBe(4);
            expect(summary.amountOwed.afterPaymentForAll.invoices).toBe(182);
            expect(summary.amountOwed.afterPaymentForAll.selectedInvoices).toBe(126);
            expect(summary.amountOwed.afterPaymentForAll.unselectedInvoices).toBe(56);
        });
    });
}());
(function () {
    "use strict";
    describe("SetupOnlineAccessConfirmationController", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope;
        var loginRoutes;
        var setUrl;
        var inStorage;
        beforeEach(angular.mock.module(function () {
            setUrl = {
                value: ""
            };
            inStorage = {
                value: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$location", hctraMocks.$location(setUrl));
            $provide.value("webStorage", hctraMocks.webStorage(inStorage));
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile, _loginRoutes_) {
            scope = $rootScope.$new();
            var rootScope = $rootScope;
            loginRoutes = _loginRoutes_;
            $controller("SetupOnlineAccessConfirmationController", { $scope: scope, $rootScope: rootScope });
            var templateHtml = $templateCache.get("app/templates/setupOnlineAccess/setupOnlineAccessConfirmation.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("should have a redirect to login", function () {
            scope.goToLogin();
            expect(setUrl.value).toBe(loginRoutes.Login);
        });
    });
}());
(function () {
    "use strict";
    describe("SetupOnlineAccessIdentificationController", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, stateNames, setUrl, displayMessage, inState, inStorage, inObject;
        beforeEach(angular.mock.module(function () {
            setUrl = {
                value: ""
            };
            displayMessage = {
                value: ""
            };
            inState = {
                value: ""
            };
            inStorage = {};
            inObject = {
                value: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$location", hctraMocks.$location());
            $provide.value("$state", hctraMocks.$state(inState));
            $provide.value("stateNames", hctraMocks.stateNames);
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("hctraSessionLogin", hctraMocks.hctraSessionLogin());
            $provide.value("routes", hctraMocks.routes());
            $provide.value("$window", hctraMocks.$window(setUrl));
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayMessage));
            $provide.value("validationService", hctraMocks.validationService());
            $provide.value("webStorage", hctraMocks.webStorage(inStorage));
            $provide.value("linkLookupService", hctraMocks.linkLookupService(inObject));
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile, _stateNames_) {
            scope = $rootScope.$new();
            var rootScope = $rootScope;
            stateNames = _stateNames_;
            scope.setupOnlineAccessIdentificationForm = {};
            $controller("SetupOnlineAccessIdentificationController", { $scope: scope, $rootScope: rootScope });
            var templateHtml = $templateCache.get("app/templates/setupOnlineAccess/setupOnlineAccessIdentification.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        it("should have a defined scope and model object", function () {
            expect(scope).toBeDefined();
            expect(scope.setupOnlineAccessIdentificationDetails).toBeDefined();
        });
        it("should be valid at first", function () {
            expect(scope.setupOnlineAccessIdentificationForm.$valid).toBeTruthy();
        });
        it("should empty out alternate fields when submit", function () {
            scope.setupOnlineAccessIdentificationDetails.accountInfo = "account";
            scope.setupOnlineAccessIdentificationDetails.personalInfo = "driversLicense";
            scope.setupOnlineAccessIdentificationDetails.tagNumber = "test";
            scope.setupOnlineAccessIdentificationDetails.taxIdNumber = "test";
            scope.submitInfo(true);
            expect(scope.setupOnlineAccessIdentificationDetails.tagNumber).toBe("");
            expect(scope.setupOnlineAccessIdentificationDetails.taxIdNumber).toBe("");
            scope.setupOnlineAccessIdentificationDetails.accountInfo = "tag";
            scope.setupOnlineAccessIdentificationDetails.personalInfo = "taxId";
            scope.setupOnlineAccessIdentificationDetails.accountNumber = "test";
            scope.setupOnlineAccessIdentificationDetails.driversLicense = "test";
            scope.submitInfo(true);
            expect(scope.setupOnlineAccessIdentificationDetails.accountNumber).toBe("");
            expect(scope.setupOnlineAccessIdentificationDetails.driversLicense).toBe("");
        });
        it("should redirect and save info upon valid submit", function () {
            scope.submitInfo(true);
            expect(inState.value).toBe(stateNames.setupOnlineAccessLoginInfo);
            expect(inStorage.setupAcctId).toBe("12345");
            expect(inStorage.setupDbSessionId).toBe("test session id");
            expect(inStorage.setupLastLoginIp).toBe("test login ip");
        });
    });
}());
(function () {
    "use strict";
    describe("SetupOnlineAccessLoginInfoController", function () {
        beforeEach(angular.mock.module("HCTRATemplates"));
        beforeEach(angular.mock.module("HCTRAModule"));
        var scope, stateNames, displayMessage, inState, inStorage;
        beforeEach(angular.mock.module(function () {
            displayMessage = {
                value: ""
            };
            inState = {
                value: ""
            };
            inStorage = {
                value: ""
            };
        }));
        beforeEach(angular.mock.module(function ($provide) {
            $provide.value("$state", hctraMocks.$state(inState));
            $provide.value("genericRepo", hctraMocks.genericRepo());
            $provide.value("responseErrorService", hctraMocks.responseErrorService(displayMessage));
            $provide.value("validationService", hctraMocks.validationService());
            $provide.value("webStorage", hctraMocks.webStorage(inStorage));
        }));
        beforeEach(angular.mock.inject(function ($rootScope, $controller, $templateCache, $compile, _stateNames_) {
            scope = $rootScope.$new();
            var rootScope = $rootScope;
            stateNames = _stateNames_;
            scope.setupOnlineAccessLoginInfoForm = {};
            $controller("SetupOnlineAccessLoginInfoController", { $scope: scope, $rootScope: rootScope });
            $templateCache.put("/app/directives/newPasswordTemplate.html", $templateCache.get("app/directives/newPasswordTemplate.html"));
            $templateCache.put("/app/directives/newEmailTemplate.html", $templateCache.get("app/directives/newEmailTemplate.html"));
            $templateCache.put("/app/directives/newAlternateEmailTemplate.html", $templateCache.get("app/directives/newAlternateEmailTemplate.html"));
            $templateCache.put("/app/directives/newSecurityQuestionTemplate.html", $templateCache.get("app/directives/newSecurityQuestionTemplate.html"));
            var templateHtml = $templateCache.get("app/templates/setupOnlineAccess/setupOnlineAccessLoginInfo.html");
            var formElem = angular.element(templateHtml);
            $compile(formElem)(scope);
            scope.$digest();
        }));
        it("should have a defined scope", function () {
            expect(scope).toBeDefined();
        });
        it("should be invalid at first", function () {
            expect(scope.setupOnlineAccessLoginInfoForm.$valid).toBeFalsy();
        });
        it("should have a model object", function () {
            expect(typeof (scope.setupOnlineAccessLoginInfoDetails)).toBe(typeof ({}));
        });
        it("should have prepopulate model object with account data", function () {
            expect(scope.setupOnlineAccessLoginInfoDetails.acctId).toBe("true");
            expect(scope.setupOnlineAccessLoginInfoDetails.dbSessionId).toBe("true");
            expect(scope.setupOnlineAccessLoginInfoDetails.lastLoginIp).toBe("true");
        });
        it("should do nothing upon invalid submit", function () {
            scope.submitInfo(false);
            expect(inState.value).toBe("");
        });
        it("should redirect upon valid submit", function () {
            scope.submitInfo(true);
            expect(inState.value).toBe(stateNames.setupOnlineAccessConfirmation);
        });
    });
}());
// (function () {
//     'use strict';
//     //describe() begins a unit testing fixture
//     describe('SiteMapController', function () {
//         //module() is registered on window and is a shortcut to angular.mock.module()
//         //use it to mock the main app module
//         //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
//         // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
//         // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
//         beforeEach(angular.mock.module('HCTRAModule'));
//         var $controller,
//             SiteMapController,
//             scope,
//             authObj = {
//                 isAuthenticated: false
//             },
//             linkLookupServiceObject = {
//                 "/sitecore/content/HCTRA/EZTagAccount/t1": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/EZTagAccount/t1",
//                     templateName: "Page",
//                     title: "What is this life?"
//                 },
//                 "/sitecore/content/HCTRA/TollInvoices/t2": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/TollInvoices/t2",
//                     templateName: "Page",
//                     title: "It is inexplicable"
//                 },
//                 "/sitecore/content/HCTRA/AboutHCTRA/t3": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/AboutHCTRA/t3",
//                     templateName: "Page",
//                     title: "Knowing is not knowledge"
//                 },
//                 "/sitecore/content/HCTRA/TravelTools/t4": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/TravelTools/t4",
//                     templateName: "Page",
//                     title: "Although we could"
//                 },
//                 "/sitecore/content/HCTRA/HelpAndSupport/t5": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/HelpAndSupport/t5",
//                     templateName: "Page",
//                     title: "Perference is no"
//                 },
//                 "/sitecore/content/HCTRA/EZTagAccount/t6": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/EZTagAccount/t6",
//                     templateName: "Closure",
//                     title: "About Us"
//                 },
//                 "/sitecore/content/HCTRA/TollInvoices/t7": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/TollInvoices/t7",
//                     templateName: "FAQ",
//                     title: "Unexpected happenings"
//                 },
//                 "/sitecore/content/HCTRA/AboutHCTRA/t8": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: false,
//                     itemPath: "/sitecore/content/HCTRA/AboutHCTRA/t8",
//                     templateName: "JobOpening",
//                     title: "Are upon us"
//                 },
//                 "/sitecore/content/HCTRA/TravelTools/t9": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/TravelTools/t9",
//                     templateName: "MajorProject",
//                     title: "simultaneous confusion"
//                 },
//                 "/sitecore/content/HCTRA/HelpAndSupport/t10": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/HelpAndSupport/t10",
//                     templateName: "Template",
//                     title: "About Us"
//                 },
//                 "/sitecore/content/HCTRA/HelpAndSupport/t11": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/HelpAndSupport/t11",
//                     templateName: "News",
//                     title: "Page"
//                 },
//                 "/sitecore/content/HCTRA/TravelTools/t12": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/TravelTools/t9",
//                     templateName: "MajorProject",
//                     title: "absolutely not"
//                 },
//                 "/sitecore/content/HCTRA/HelpAndSupport/t13": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/HelpAndSupport/t5",
//                     templateName: "Page",
//                     title: "Unlikely"
//                 },
//                 "/sitecore/content/HCTRA/AboutHCTRA/t14": {
//                     friendlyURL: "/AboutUs",
//                     includeInSearch: true,
//                     itemPath: "/sitecore/content/HCTRA/AboutHCTRA/t8",
//                     templateName: "JobOpening",
//                     title: "Unless death"
//                 }
//             };
//         //$provide is a module-level object, and thus must get its own 
//         //injection through the module() function
//         beforeEach(angular.mock.module(function ($provide) {
//             $provide.value('linkLookupService', hctraMocks.linkLookupService(linkLookupServiceObject));
//             $provide.value('AuthService', hctraMocks.AuthService(authObj));
//         }));
//         //inject() is a window-registered global for angular.mock.inject
//         //it injects the root scope and controller-grabbing services into your test
//         //the injector unwraps the underscores
//         beforeEach(angular.mock.inject(function (_$rootScope_, _$controller_) {
//             //create new, empty ng scope, controller, service objects
//             scope = _$rootScope_.$new();
//             $controller = _$controller_;
//             //create the controller
//             SiteMapController = $controller('SiteMapController', { $scope: scope });
//         }));
//         it('sitemap should sort and correctly when not logged in', function () {
//             scope.$digest();
//             var index = 0;
//             var titleArray = [
//                 { title: "EZ Tag Account", array: [{ title: "What is this life?", url: "/AboutUs" }] },
//                 { title: "About HCTRA", array: [{ title: "absolutely not", url: "/AboutUs" }] },
//                 { title: "Travel Tools", array: [{ title: "Although we could", url: "/AboutUs" }] },
//                 { title: "Help & Support", array: [{ title: "Perference is no", url: "/AboutUs" }] },
//                 { title: "Violations & Missed Tolls", array: [{ title: "It is inexplicable", url: "/AboutUs" }] },
//                 { title: "Job Openings", array: [{ title: "Unless death", url: "/AboutUs" }] },
//                 { title: "FAQ Articles", array: [{ title: "Unexpected happenings", url: "/AboutUs" }] }
//             ];
//             for (var key in scope.vm.sitemap) {
//                 // eslint-disable-next-line no-prototype-builtins
//                 if (!scope.vm.sitemap.hasOwnProperty(key)) { continue; }
//                 expect(scope.vm.sitemap[key].title).toBe(titleArray[index].title);
//                 //console.log("actual: "+scope.vm.sitemap[key].array[0].title+" expected: "+titleArray[index].array[0].title)
//                 expect(angular.equals(scope.vm.sitemap[key].array[0], titleArray[index].array[0])).toBeTruthy();
//                 index++;
//             }
//             expect(angular.equals(scope.vm.sitemap.aboutHctraSection.array[2], { title: "simultaneous confusion", url: "/AboutUs" })).toBeTruthy();
//             expect(angular.equals(scope.vm.sitemap.helpAndSupportSection.array[1], { title: "Unlikely", url: "/AboutUs" })).toBeTruthy();
//             expect(angular.equals(scope.vm.sitemap.aboutHctraSection.array[1], { title: "Knowing is not knowledge", url: "/AboutUs" })).toBeTruthy();
//         });
//         it('sitemap should sort and correctly when logged in', function () {
//             authObj.isAuthenticated = true;
//             scope.$digest();
//             var index = 0;
//             var titleArray = [
//                 { title: "EZ Tag Account", array: [{ title: "What is this life?", url: "/AboutUs" }] },
//                 { title: "About HCTRA", array: [{ title: "absolutely not", url: "/AboutUs" }] },
//                 { title: "Travel Tools", array: [{ title: "Although we could", url: "/AboutUs" }] },
//                 { title: "Help & Support", array: [{ title: "Perference is no", url: "/AboutUs" }] },
//                 { title: "Violations & Missed Tolls", array: [{ title: "It is inexplicable", url: "/AboutUs" }] },
//                 { title: "Job Openings", array: [{ title: "Are upon us", url: "/AboutUs" }] },
//                 { title: "FAQ Articles", array: [{ title: "Unexpected happenings", url: "/AboutUs" }] }
//             ];
//             for (var key in scope.vm.sitemap) {
//                 // eslint-disable-next-line no-prototype-builtins
//                 if (!scope.vm.sitemap.hasOwnProperty(key)) { continue; }
//                 expect(scope.vm.sitemap[key].title).toBe(titleArray[index].title);
//                 //console.log("actual: " + scope.vm.sitemap[key].array[0].title + " expected: " + titleArray[index].array[0].title)
//                 expect(angular.equals(scope.vm.sitemap[key].array[0], titleArray[index].array[0])).toBeTruthy();
//                 index++;
//             }
//             expect(angular.equals(scope.vm.sitemap.aboutHctraSection.array[2], { title: "simultaneous confusion", url: "/AboutUs" })).toBeTruthy();
//             expect(angular.equals(scope.vm.sitemap.helpAndSupportSection.array[1], { title: "Unlikely", url: "/AboutUs" })).toBeTruthy();
//             expect(angular.equals(scope.vm.sitemap.jobSection.array[1], { title: "Unless death", url: "/AboutUs" })).toBeTruthy();
//             expect(angular.equals(scope.vm.sitemap.aboutHctraSection.array[1], { title: "Knowing is not knowledge", url: "/AboutUs" })).toBeTruthy();
//         });
//         it('sitemap should sort correctly when some members are missing', function () {
//             authObj.isAuthenticated = true;
//             linkLookupServiceObject["/sitecore/content/HCTRA/TollInvoices/t2"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/AboutHCTRA/t3"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/TravelTools/t4"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/HelpAndSupport/t5"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/EZTagAccount/t6"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/AboutHCTRA/t8"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/TollInvoices/t7"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/TravelTools/t9"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/HelpAndSupport/t10"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/TravelTools/t12"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/HelpAndSupport/t13"] = null;
//             linkLookupServiceObject["/sitecore/content/HCTRA/AboutHCTRA/t14"] = null;
//             scope.$digest();
//             expect(scope.vm.sitemap.aboutHctraSection).toBeUndefined();
//             expect(scope.vm.sitemap.travelToolsSection).toBeUndefined();
//             expect(scope.vm.sitemap.helpAndSupportSection).toBeUndefined();
//             expect(scope.vm.sitemap.tollInvoicesSection).toBeUndefined();
//             expect(scope.vm.sitemap.projectsSection).toBeUndefined();
//             expect(scope.vm.sitemap.jobSection).toBeUndefined();
//             expect(scope.vm.sitemap.faqSection).toBeUndefined();
//             expect(angular.equals(scope.vm.sitemap.ezTagSection.array[0], { title: "What is this life?", url: "/AboutUs" })).toBeTruthy();
//         });
//         it('sitemap should not have sitemap link', function () {
//             linkLookupServiceObject['/sitecore/content/HCTRA/Common/Site Map'] =
//             {
//                 friendlyURL: "/SiteMap",
//                 includeInSearch: true,
//                 itemId: "8BE16CF8-82D9-4283-BD03-814A6522199B",
//                 templateName: "Page",
//                 title: "Can I eat?"
//             };
//             authObj.isAuthenticated = true;
//             SiteMapController = $controller('SiteMapController', { $scope: scope });
//             scope.$digest();
//             for (var key in scope.vm.sitemap) {
//                 // eslint-disable-next-line no-prototype-builtins
//                 if (!scope.vm.sitemap.hasOwnProperty(key)) { continue; }
//                 if (scope.vm.sitemap[key].array.length > 0) {
//                     scope.vm.sitemap[key].array.forEach(function (element) {
//                         expect(element.url).not.toEqual("/SiteMap");
//                     });
//                 }
//             }
//         });
//     });
// }());
(function () {
    'use strict';
    describe('StoreFrontController', function () {
        //module() is registered on window and is a shortcut to angular.mock.module()
        //use it to mock the main app module
        //Note: DO NOT include the real app.js file on the testRunner HTML file. This will 
        // cause a cascade of dependencies that you will have a hard time catching-up to. testApp.js 
        // contains a simple module definition that isolates out the complexities. Unit test piece-by-piece
        beforeEach(angular.mock.module('HCTRAModule'));
        var $scope, $window, $controller, $state, stateNames, loginStates, storefrontService, modalService, $rootScope, $q, eventService;
        var errorDisplayService;
        var Promise;
        var environmentConfig = {
            storefrontConfigs: {
                storefrontInactivityWarning: 999999,
                storefrontInactivityReset: 999999,
                storefrontInactivityIntervalDelay: 999999
            }
        };
        function returnResolved(value) {
            return new Promise(function (resolve) { return resolve(value); });
        }
        function returnRejected(object) {
            return new Promise(function (resolve, reject) { return reject(object); });
        }
        //$provide is a module-level object, and thus must get its own 
        //injection through the module() function
        beforeEach(angular.mock.module(function ($provide) {
            errorDisplayService = jasmine.createSpyObj("errorDisplayService", ["clearToasts"]);
            $provide.constant('environmentConfig', environmentConfig);
            $provide.value('errorDisplayService', errorDisplayService);
        }));
        beforeEach(angular.mock.inject(function ($injector) {
            try {
                $rootScope = $injector.get('$rootScope');
                eventService = jasmine.createSpyObj("eventService", ["startListening", "stopListening", "resetState"]);
                var win = $injector.get('$window');
                Promise = win.Promise;
                $scope = $rootScope.$new();
                $controller = $injector.get('$controller');
                stateNames = $injector.get("stateNames");
                loginStates = $injector.get("loginStates");
                $window = jasmine.createSpyObj("$window", ["open"]);
                $window.open["listen"] = jasmine.createSpy("openListener", function () { });
                $window.console = jasmine.createSpyObj("fakeConsole", ["log"]);
                $window.location = {
                    reload: jasmine.createSpy("window.location.reload", function () { })
                };
                $state = jasmine.createSpyObj("$state", ["go", "get"]);
                $state.current = {
                    name: stateNames.storefrontHome
                };
                $state.go.and.returnValue(returnResolved());
                $state.get.and.callFake(function (state) {
                    if (state === stateNames.storefrontHome) {
                        return {
                            cms: {
                                landingPageId: ''
                            }
                        };
                    }
                    return null;
                });
                storefrontService = jasmine.createSpyObj("storefrontService", [
                    "getCmsMediaItem", "isEnabled", "reset", "checkState", "pushLoggingInfo", "isWorkflowActive",
                    "currentWorkItem", "getWorkItemInitState", "fullSiteMode", "registerEventHandlers",
                    "prefetchContent", "getCmsData", "clearSession"
                ]);
                storefrontService.onInitialized = returnResolved();
                storefrontService.isShellAccountInitialized = true;
                storefrontService.getCmsMediaItem.and.returnValue(returnResolved());
                storefrontService.getCmsData.and.returnValue(returnResolved());
                storefrontService.isEnabled.and.returnValue(true);
                storefrontService.reset.and.returnValue(returnResolved());
                storefrontService.pushLoggingInfo.and.returnValue(returnResolved());
                storefrontService.prefetchContent.and.returnValue(returnResolved());
                storefrontService.getStorefrontLogo = function () {
                    return {
                        "ItemId": "cccab286-133d-4118-bf4b-8b57d2434edf",
                        "ImageItem": {
                            "image": "-/media/30D08C39C5334DC78B66FC37CA8E4F84.ashx",
                            "alt": "HCTRA Logo"
                        }
                    };
                };
                storefrontService.workItems = [];
                modalService = jasmine.createSpyObj("storefrontModalService", ["setGlobalModalSettings", "showExternalTask", "isExternalTaskModalOpen", "showInactivity", "showPdf", "failedToInitMessage", "showCompletionMessage", "closeAll"]);
                modalService.failedToInitMessage.and.callFake(function () {
                    fail();
                    return returnResolved();
                });
                $q = jasmine.createSpyObj("$q", ["resolve", "reject", "when"]);
                $q.resolve.and.callFake(function (obj) {
                    return returnResolved(obj);
                });
                $q.reject.and.callFake(function (obj) {
                    return returnRejected(obj);
                });
                $q.when.and.callFake(function (obj) {
                    if ('then' in obj && 'catch' in obj && 'finally' in obj) {
                        return obj;
                    }
                    return returnResolved(obj);
                });
            }
            catch (e) {
                fail(e);
            }
        }));
        var newController = function (s) {
            return $controller("StorefrontController", {
                $scope: s || $scope,
                $window: $window,
                $state: $state,
                StorefrontService: storefrontService,
                router: [],
                StorefrontModalService: modalService,
                $q: $q,
                StorefrontEventService: eventService
            });
        };
        it('can build lookup from routing table', function () {
            //arrange
            var routes = [
                //2 happy paths different names
                {
                    name: 'a',
                    config: {
                        templateUrl: "a"
                    }
                },
                {
                    name: 'b',
                    config: {
                        templateUrl: "b"
                    }
                },
                //2 with view names and different names
                {
                    name: 'c',
                    config: {
                        views: {
                            "": {
                                templateUrl: "c"
                            },
                            "other": {
                                templateUrl: "cother"
                            }
                        }
                    }
                },
                {
                    name: 'd',
                    config: {
                        views: {
                            "": {
                                templateUrl: "d"
                            },
                            "other": {
                                templateUrl: "dother"
                            }
                        }
                    }
                },
                // templateurl is a function
                {
                    name: 'e',
                    config: {
                        templateUrl: function () { return "e"; }
                    }
                },
                // view.templateurl is a function
                {
                    name: 'f',
                    config: {
                        views: {
                            "": {
                                templateUrl: function () { return "f"; }
                            },
                            "other": {
                                templateUrl: function () { return "fother"; }
                            }
                        }
                    }
                }
            ];
            //act
            newController().onInitialized
                .then(function (c) {
                var lookupTable = c.buildRouteLookup(routes);
                //assert
                expect(lookupTable['a']).toBe('a');
                expect(lookupTable['b']).toBe('b');
                expect(angular.isArray(lookupTable['c'])).toBeTruthy();
                expect(lookupTable['c'].length === 2).toBeTruthy();
                expect(lookupTable['c'].indexOf('c') >= 0).toBeTruthy();
                expect(lookupTable['c'].indexOf('cother') >= 0).toBeTruthy();
                expect(angular.isArray(lookupTable['d'])).toBeTruthy();
                expect(lookupTable['d'].length === 2).toBeTruthy();
                expect(lookupTable['d'].indexOf('d') >= 0).toBeTruthy();
                expect(lookupTable['d'].indexOf('dother') >= 0).toBeTruthy();
                expect(lookupTable['e']).not.toBeDefined();
                expect(angular.isArray(lookupTable['f'])).toBeTruthy();
                expect(lookupTable['f'].length === 0).toBeTruthy();
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('can prefetch content', function () {
            //arrange
            var lookup = {
                "a": "a",
                "b": "b",
                "c": [],
                "d": ["d", "dother"]
            };
            lookup[stateNames.storefrontSelection] = "f";
            lookup[stateNames.storefrontSurvey] = "g";
            lookup[loginStates.Login] = "h";
            lookup[loginStates.AddMissingInformation] = "i";
            newController().onInitialized
                .then(function (c) {
                spyOn(c, "buildRouteLookup").and.callFake(function () {
                    return lookup;
                });
                storefrontService.workItems = [
                    {
                        selectedIcon: { image: 'image1url' },
                        unselectedIcon: { image: 'image2url' },
                        states: ['a', 'b', 'd']
                    }
                ];
                //act
                return c.prefetchAllContent();
            })
                .then(function () {
                //assert
                expect(storefrontService.prefetchContent).toHaveBeenCalled();
                //since prefetch is called initially when controller is instanciated, we'll need the args for the second call to prefetch
                var urls = storefrontService.prefetchContent.calls.argsFor(1)[0];
                expect(urls.length).toBe(10);
                expect(urls).toContain('image1url');
                expect(urls).toContain('image2url');
                expect(urls).toContain('a');
                expect(urls).toContain('b');
                expect(urls).toContain('d');
                expect(urls).toContain('dother');
                expect(urls).toContain('f');
                expect(urls).toContain('g');
                expect(urls).toContain('h');
                expect(urls).toContain('i');
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('can call completion modal and no next workitem', function () {
            //arrange
            storefrontService.fullSiteMode = false;
            var w1 = {};
            modalService.showCompletionMessage.and.returnValue(returnResolved());
            //act
            newController().onInitialized
                .then(function (c) {
                return c.onCompletedWorkItem(w1, null);
            })
                .then(function () {
                //assert
                expect(modalService.showCompletionMessage).toHaveBeenCalledWith(w1);
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('handles on reset', function () {
            var c = newController();
            return c
                .onResetting()
                .then(function () {
                expect(modalService.closeAll).toHaveBeenCalledWith(true);
                expect(modalService.setGlobalModalSettings).toHaveBeenCalled();
                expect(eventService.resetState).toHaveBeenCalled();
                return c.onResetComplete();
            })
                .then(function () {
                expect($state.go).toHaveBeenCalledWith(stateNames.storefrontHome);
                expect(errorDisplayService.clearToasts).toHaveBeenCalled();
            })
                .catch(function (e) {
                fail(e);
            });
        });
        it('handles hard reset', function () {
            $window.location.origin = "TEST";
            var c = newController();
            $window.location.href = "CHANGE";
            return c
                .onResetting()
                .then(function () {
                expect(modalService.closeAll).toHaveBeenCalledWith(true);
                expect(modalService.setGlobalModalSettings).toHaveBeenCalled();
                expect(eventService.resetState).toHaveBeenCalled();
                $state.go.calls.reset();
                return c.onResetComplete(true);
            })
                .then(function () {
                expect($state.go).not.toHaveBeenCalled();
                expect($window.location.href).toBe("TEST/Storefront");
            })
                .catch(function (e) {
                fail(e);
            });
        });
    });
}());
(function () {
    'use strict';
    describe('StoreFrontSurveyController', function () {
        var scope, storefrontService, $state, stateNames, $rootScope, $controller, Promise, $window;
        function createController(s) {
            return $controller("StorefrontSurveyController", {
                $scope: s || scope,
                $state: $state,
                StorefrontService: storefrontService,
                stateNames: stateNames
            });
        }
        function returnResolved(obj) {
            return Promise.resolve(obj);
        }
        beforeEach(angular.mock.module('HCTRAModule'));
        beforeEach(angular.mock.inject(function ($injector) {
            $window = $injector.get("$window");
            Promise = $window["Promise"];
            $rootScope = $injector.get('$rootScope');
            scope = $rootScope.$new();
            $controller = $injector.get("$controller");
            $state = jasmine.createSpyObj("$state", ["go"]);
            $state.current = {
                cms: {
                    surveyThankYouModalId: "id1",
                    surveyId: "id2"
                }
            };
            storefrontService = jasmine.createSpyObj("storefrontService", ["isEnabled", "fullSiteMode", "getCmsItemById"]);
            storefrontService.getCmsItemById.and.callFake(function (id) {
                if (id === "id1") {
                    return returnResolved({
                        Title: "title",
                        buttons: {}
                    });
                }
                else if (id === "id2") {
                    return returnResolved({
                        badRatingIconSelected: {
                            image: {}
                        },
                        neutralRatingIconSelected: {
                            image: {}
                        },
                        goodRatingIconSelected: {
                            image: {}
                        },
                        badRatingIconUnselected: {
                            image: {}
                        },
                        neutralRatingIconUnselected: {
                            image: {}
                        },
                        goodRatingIconUnselected: {
                            image: {}
                        }
                    });
                }
                return Promise.reject();
            });
        }));
        it('can create survey controller', function () {
            //arrange
            //act
            var controller = createController();
            //assert
            expect(controller).toBeDefined();
        });
        //        it('can decorate window.open as well as $window.open',function() {
        //            //arrange
        //
        //            //act
        //
        //            //assert
        //            expect($window).toBeDefined();
        //            expect($window.open).toBeDefined();
        //            expect($window.open['listen']).toBeDefined();
        //
        //            expect(window).toBeDefined();
        //            expect(window.open).toBeDefined();
        //            expect(window.open['listen']).toBeDefined();
        //        });
    });
})();
// (function () {
//     'use strict';
//     angular.module('HCTRAModule').constant('routes', urls());
//     angular.module('HCTRAModule').constant('stateNames', states());
//     // Define the route state names
//     function states() {
//         return {
//             personalAccount: 'NewAccount.CreateAccount.PersonalAccount',
//             personalInformation: 'NewAccount.CreateAccountDetails.PersonalInformation',
//             vehicleInformation: 'NewAccount.AddEZTAG.VehicleInformation',
//             choosePaymentMethod: 'NewAccount.PaymentMaster.ChooseMethod',
//             enterBankAccount: 'NewAccount.PaymentMaster.BankAccount',
//             creditCardEntry: 'NewAccount.PaymentMaster.CreditCard',
//             addMissingInformation: 'AddMissingInformation',
//             createAccountReceipt: 'NewAccount.CreateAccountReceipt'
//         };
//     }
//     // Define the route page urls
//     function urls() {
//         return {
//             accountActivity: '/AccountActivity',
//             accountSummary: '/AccountSummary',
//             creditCardEntry: '/CreditCardEntry',
//             forgotPasswordAccount: '/ForgotPasswordAccount',
//             forgotPasswordEmail: '/ForgotPasswordEmail',
//             forgotPasswordEmailSent: '/ForgotPasswordEmailSent',
//             forgotPasswordValidateAccount: '/ForgotPasswordValidateAccount',
//             forgotPasswordReset: '/ForgotPasswordReset',
//             login: '/Login',
//             newAccount: '/NewAccount',
//             createAccount: '/CreateAccount',
//             personalAccount: '/PersonalAccount',
//             createAccountDetails: '/CreateAccountDetails',
//             personalInformation: '/PersonalInformation',
//             addEZTAG: '/AddEZTAG',
//             vehicleInformation: '/VehicleInformation',
//             addAdditionalVehicle: '/AddAdditionalVehicle',
//             paymentMaster: '/PaymentMaster',
//             choosePaymentMethod: '/ChoosePaymentMethod',
//             enterBankAccount: '/EnterBankAccount',
//             addMissingInformation: '/AddMissingInformation'
//         };
//     }
// })();
//# sourceMappingURL=appBundle.testing.js.map